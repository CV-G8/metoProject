(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WeatherDV = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _polyfill = _interopRequireDefault(require("h_3"));

/**
 * 相机工具，转换cesium和threejs相机，仅做参数映射，不考虑两个引擎的差异。也即是以cesium相机为主，换到threejs相机只是为了语法上的需要
 */
var CameraUtils = /*#__PURE__*/function () {
  function CameraUtils() {
    (0, _classCallCheck2["default"])(this, CameraUtils);
  }

  (0, _createClass2["default"])(CameraUtils, null, [{
    key: "getMirrorCamera",
    value:
    /**
     * 
     * @param {THREE.PerspectiveCamera|Cesium.Camera} camera
     * @param {THREE.Matrix4} mirrorMatrixWorld 
     * @param {THREE.PerspectiveCamera} [mirrorCamera] 
     */
    function getMirrorCamera(camera, mirrorMatrixWorld, mirrorCamera, up) {
      if (camera instanceof Cesium.Camera) {
        camera = this.toPerspectiveCamera3js(camera);
      }

      var _THREE = THREE,
          Vector3 = _THREE.Vector3,
          Matrix4 = _THREE.Matrix4,
          PerspectiveCamera = _THREE.PerspectiveCamera;
      var mirrorWorldPosition = new Vector3();
      var cameraWorldPosition = new Vector3();
      var rotationMatrix = new Matrix4();
      var normal = new Vector3();
      var view = new Vector3();
      var lookAtPosition = new Vector3();
      var target = new Vector3();
      var scope = {
        matrixWorld: mirrorMatrixWorld
      };
      mirrorCamera = mirrorCamera || new PerspectiveCamera(); // mirrorCamera.copy(camera);

      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix);
      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away
      // if (view.dot(normal) > 0) return;

      view.reflect(normal).negate();
      view.add(mirrorWorldPosition);
      rotationMatrix.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, 1);
      lookAtPosition.applyMatrix4(rotationMatrix);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(mirrorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(mirrorWorldPosition);
      mirrorCamera.position.copy(view);
      mirrorCamera.up.set(0, 1, 0);
      mirrorCamera.up.applyMatrix4(rotationMatrix);
      mirrorCamera.up.reflect(normal);
      mirrorCamera.lookAt(target);
      mirrorCamera.updateMatrixWorld();
      mirrorCamera.far = camera.far;
      mirrorCamera.near = camera.near;
      mirrorCamera.fov = camera.fov;
      mirrorCamera.focus = camera.focus;
      mirrorCamera.updateProjectionMatrix();
      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);
      return mirrorCamera;
    }
    /**
     * 
     * @param {THREE.Camera} camera3js 
     * @return {Cesium.Camera}
     */

  }, {
    key: "getCameraFromCache",
    value: function getCameraFromCache(camera3js) {
      return cameraMap.get(camera3js);
    }
    /**
     * 
     * @param {THREE.Camera} camera3js 
     * @return {THREE.Frustum}
     */

  }, {
    key: "getFrustum3js",
    value: function getFrustum3js(camera3js) {
      if (!camera3js.isCamera) camera3js = cameraMap.get(camera3js);
      return frustumMap.get(camera3js);
    }
    /**
     * cesium相机转threejs相机
     * @param {Cesium.Camera} camera  
     * @param {THREE.PerspectiveCamera} [camera3js] 
     * @param {{
     *  matrix:Cesium.Matrix4,
     *  inverseMatrix:Cesium.Matrix4
     * }} [referenceFrame] 
     * @returns {THREE.PerspectiveCamera} camera3js
     */

  }, {
    key: "toPerspectiveCamera3js",
    value: function toPerspectiveCamera3js(camera, camera3js, referenceFrame) {
      referenceFrame = referenceFrame || camera._referenceFrame;
      var frustum = camera.frustum;

      if (!camera3js) {
        if (cameraMap.has(camera)) {
          camera3js = cameraMap.get(camera);
        } else {
          camera3js = new THREE.PerspectiveCamera();
          cameraMap.set(camera, camera3js);
        }
      }

      camera3js.aspect = frustum.aspectRatio;
      camera3js.near = frustum.near;
      camera3js.far = frustum.far;
      camera3js.fov = Cesium.Math.toDegrees(frustum.fovy);
      camera3js.updateProjectionMatrix(); // var cvm =  camera.viewMatrix;
      // var civm = camera.inverseViewMatrix;
      // camera3js.matrixWorld.set(
      //   civm[0], civm[4], civm[8 ], civm[12],
      //   civm[1], civm[5], civm[9 ], civm[13],
      //   civm[2], civm[6], civm[10], civm[14],
      //   civm[3], civm[7], civm[11], civm[15]
      // );
      // camera3js.matrixWorldInverse.set(
      //   cvm[0], cvm[4], cvm[8 ], cvm[12],
      //   cvm[1], cvm[5], cvm[9 ], cvm[13],
      //   cvm[2], cvm[6], cvm[10], cvm[14],
      //   cvm[3], cvm[7], cvm[11], cvm[15]
      // );

      convertMatrixFromCameraCesium(camera, camera3js, referenceFrame);
      return camera3js;
    }
    /**
     * cesium相机转threejs相机
     * @param {Cesium.Camera} camera  
     * @param {THREE.OrthographicCamera} [camera3js] 
     * @param {{
        *  matrix:Cesium.Matrix4,
        *  inverseMatrix:Cesium.Matrix4
        * }} [referenceFrame] 
        * @returns {THREE.OrthographicCamera} camera3js
        */

  }, {
    key: "toOrthographicCamera3js",
    value: function toOrthographicCamera3js(camera, camera3js, referenceFrame) {
      referenceFrame = referenceFrame || camera._referenceFrame;
      var frustum = camera.frustum;

      if (!camera3js) {
        if (cameraMap.has(camera)) {
          camera3js = cameraMap.get(camera);
        } else {
          camera3js = new THREE.OrthographicCamera();
          cameraMap.set(camera, camera3js);
        }
      }

      var w = camera.frustum.width,
          h = w / frustum.aspectRatio;
      camera3js.right = w / 2;
      camera3js.left = -w / 2;
      camera3js.top = h / 2;
      camera3js.bottom = -h / 2;
      camera3js.near = frustum.near;
      camera3js.far = frustum.far; // let w = camera3js.right - camera3js.left,
      // h = camera3js.top - camera3js.bottom;
      // frustum.aspectRatio = w / h;
      // frustum.near = camera3js.near;
      // frustum.far = camera3js.far;
      // frustum.width = w;

      camera3js.updateProjectionMatrix(); // var cvm =  camera.viewMatrix;
      // var civm = camera.inverseViewMatrix;
      // camera3js.matrixWorld.set(
      //   civm[0], civm[4], civm[8 ], civm[12],
      //   civm[1], civm[5], civm[9 ], civm[13],
      //   civm[2], civm[6], civm[10], civm[14],
      //   civm[3], civm[7], civm[11], civm[15]
      // );
      // camera3js.matrixWorldInverse.set(
      //   cvm[0], cvm[4], cvm[8 ], cvm[12],
      //   cvm[1], cvm[5], cvm[9 ], cvm[13],
      //   cvm[2], cvm[6], cvm[10], cvm[14],
      //   cvm[3], cvm[7], cvm[11], cvm[15]
      // );

      convertMatrixFromCameraCesium(camera, camera3js, referenceFrame);
      return camera3js;
    }
    /**
     * threejs's PerspectiveCamera=>cesium's camera
     * @param {THREE.PerspectiveCamera} camera3js 
      * @param {Cesium.Scene} scene
     * @param {{
     *  matrix:Cesium.Matrix4,
     *  inverseMatrix:Cesium.Matrix4
     * }} [referenceFrame] 
      * @param {Cesium.Camera} [camera]
     * @returns {Cesium.Camera} camera  
     */

  }, {
    key: "fromPerspectiveCamera3js",
    value: function fromPerspectiveCamera3js(camera3js, scene, referenceFrame, camera) {
      var _Cesium = Cesium;
      updateFrustum3js(camera3js);
      referenceFrame = referenceFrame || camera3js._referenceFrame;

      if (!camera) {
        if (cameraMap.has(camera3js)) {
          camera = cameraMap.get(camera3js);
        } else {
          camera = new _Cesium.Camera(scene);
          camera.frustum.xOffset = 0;
          camera.frustum.yOffset = 0;
          cameraMap.set(camera3js, camera);
        }
      } //frustum


      var frustum = camera.frustum;

      var fovy = _Cesium.Math.toRadians(camera3js.fov);

      frustum.aspectRatio = camera3js.aspect;
      frustum.near = camera3js.near;
      frustum.far = camera3js.far;
      frustum.fov = Math.atan(Math.tan(fovy * 0.5) * frustum.aspectRatio) * 2.0; //viewMatrix,inverseViewMatrix,position,direction

      convertMatrixFromCamera3js(camera3js, camera, referenceFrame);
      return camera;
    }
    /**
     * threejs's PerspectiveCamera=>cesium's camera
     * @param {THREE.OrthographicCamera} camera3js 
     * @param {Cesium.Scene} scene
     * @param {{
        *  matrix:Cesium.Matrix4,
        *  inverseMatrix:Cesium.Matrix4
        * }} [referenceFrame] 
      * @param {Cesium.Camera} [camera]
        * @returns {Cesium.Camera} camera  
        */

  }, {
    key: "fromOrthographicCamera3js",
    value: function fromOrthographicCamera3js(camera3js, scene, referenceFrame, camera) {
      var _Cesium2 = Cesium,
          Camera = _Cesium2.Camera,
          OrthographicFrustum = _Cesium2.OrthographicFrustum;
      updateFrustum3js(camera3js);
      referenceFrame = referenceFrame || camera3js._referenceFrame;

      if (!camera) {
        if (cameraMap.has(camera3js)) {
          camera = cameraMap.get(camera3js);
        } else {
          camera = new Camera(scene);
          camera.frustum = new OrthographicFrustum();
          cameraMap.set(camera3js, camera);
        }
      } //frustum

      /**
       * @type {Cesium.OrthographicFrustum}
       * @private
       */


      var frustum = camera.frustum;
      var w = camera3js.right - camera3js.left,
          h = camera3js.top - camera3js.bottom;
      frustum.aspectRatio = w / h;
      frustum.near = camera3js.near || 1e-16;
      frustum.far = camera3js.far;
      frustum.width = w; //viewMatrix,inverseViewMatrix,position,direction

      convertMatrixFromCamera3js(camera3js, camera, referenceFrame);
      return camera;
    }
  }]);
  return CameraUtils;
}();

var cvm, civm, _cacheCameraTarget, _cacheCameraRotationMatrix, _cacheCameraRotationMatrix4;

var cameraMap = new WeakMap(),
    frustumMap = new WeakMap();

var _cacheCameraPosition, _cacheCameraDirection;

var _cacheDirInverse = {
  x: 0,
  y: 1,
  z: 0
};

var _cacheCameraProjScreenMatrix, _cacheCameraViewMatrix, _cacheCameraInverseViewMatrix;

function _getCacheCamera3jsProjScreenMatrix(camera) {
  if (!_cacheCameraProjScreenMatrix) _cacheCameraProjScreenMatrix = new THREE.Matrix4();

  _cacheCameraProjScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

  return _cacheCameraProjScreenMatrix;
}
/**
 * 
 * @param {THREE.PerspectiveCamera|THREE.OrthographicCamera} camera3js 
 * @param {Cesium.Camera} camera 
 * @param {*} referenceFrame 
 * @private
 */


function convertMatrixFromCamera3js(camera3js, camera, referenceFrame) {
  var _Cesium3 = Cesium,
      Matrix4 = _Cesium3.Matrix4,
      Cartesian3 = _Cesium3.Cartesian3,
      Matrix3 = _Cesium3.Matrix3;
  (0, _polyfill["default"])(); //viewMatrix&inverseViewMatrix

  var matrixWorld = camera3js.matrixWorld.elements,
      matrixWorldInverse = camera3js.matrixWorldInverse.elements; //  setMatrix

  if (!_cacheCameraViewMatrix) {
    _cacheCameraViewMatrix = new Matrix4();
    _cacheCameraInverseViewMatrix = new Matrix4();
    _cacheCameraPosition = new Cartesian3();
    _cacheCameraDirection = new Cartesian3();
  }

  if (referenceFrame && referenceFrame.matrix) {
    camera3js.modelMatrix = Matrix4.multiply(referenceFrame.matrix, matrixWorld, camera3js.modelMatrix || new Matrix4());
    Matrix4.clone(camera3js.modelMatrix, _cacheCameraInverseViewMatrix);
    Matrix4.inverse(camera3js.modelMatrix, _cacheCameraViewMatrix);
  } else {
    Matrix4.clone(matrixWorldInverse, _cacheCameraViewMatrix);
    Matrix4.clone(matrixWorld, _cacheCameraInverseViewMatrix);
  } //position and direction
  // Matrix4.getTranslation(_cacheCameraInverseViewMatrix, camera.position);
  // var rotMat = new Matrix3();
  // Matrix4.getMatrix3(_cacheCameraInverseViewMatrix, rotMat);
  // Matrix3.getColumn(rotMat, 0, camera.direction);
  // Matrix3.getColumn(rotMat, 2, camera.up);
  // Cartesian3.cross(camera.direction, camera.up, camera.right);
  // camera._adjustOrthographicFrustum(true);


  Matrix4.getTranslation(_cacheCameraInverseViewMatrix, _cacheCameraPosition);

  if (camera3js.isOrthographicCamera || !Cartesian3.equals(Cartesian3.ZERO, _cacheCameraPosition)) {
    Matrix4.multiplyByPoint(_cacheCameraInverseViewMatrix, _cacheDirInverse, _cacheCameraDirection);
    Cartesian3.subtract(_cacheCameraDirection, _cacheCameraPosition, _cacheCameraDirection);

    _cacheCameraPosition.clone(camera.position);

    _cacheCameraDirection.clone(camera.direction);
  } // Cartesian3.cross(camera.direction, camera.up, camera.right);


  Matrix4.clone(_cacheCameraViewMatrix, camera.viewMatrix);
  Matrix4.clone(_cacheCameraInverseViewMatrix, camera.inverseViewMatrix); //custom projectionMatrix

  if (!Matrix4.equals(camera.frustum.projectionMatrix, camera3js.projectionMatrix.elements)) {
    var customCamera = camera.customCamera || {};
    customCamera.projectionMatrix = Matrix4.clone(camera3js.projectionMatrix.elements, customCamera.projectionMatrix);
    camera.customCamera = customCamera;
  } else {
    camera.customCamera = undefined;
  }
}
/**
 * 
 * @param {*} camera 
 * @param {THREE.Camera} camera3js 
 * @param {*} referenceFrame
 * @private 
 */


function convertMatrixFromCameraCesium(camera, camera3js, referenceFrame) {
  var Matrix4 = Cesium.Matrix4;
  var matrixWorld = camera3js.matrixWorld;
  var inverseViewMatrix = camera.inverseViewMatrix;
  (0, _polyfill["default"])();

  if (Matrix4.equals(inverseViewMatrix, camera3js.modelMatrix)) {
    return;
  }

  if (referenceFrame) {
    if (!referenceFrame.inverseMatrix) {
      var inverseMatrix = new Matrix4();
      referenceFrame.inverseMatrix = Matrix4.inverse(referenceFrame.matrix, inverseMatrix);
    }

    matrixWorld.multiplyMatrices(referenceFrame.inverseMatrix, inverseViewMatrix);
  } else {
    matrixWorld.copy(inverseViewMatrix);
  }

  matrixWorld.decompose(camera3js.position, camera3js.quaternion, camera3js.scale);
  camera3js.updateMatrixWorld();
  camera3js.modelMatrix = Matrix4.clone(inverseViewMatrix, camera3js.modelMatrix); //custom projectionMatrix

  if (camera.customCamera) {
    var customCamera = camera.customCamera;

    if (customCamera.projectionMatrix) {
      camera3js.projectionMatrix.copy(customCamera.projectionMatrix);
      camera3js.projectionMatrixInverse.invert(camera3js.projectionMatrix);
    }
  } //update frustum 


  updateFrustum3js(camera3js);
}

function updateFrustum3js(camera3js) {
  var frustum3js = frustumMap.get(camera3js);

  if (!frustum3js) {
    frustum3js = new THREE.Frustum();
    frustumMap.set(camera3js, frustum3js);
  }

  var projScreenMatrix = _getCacheCamera3jsProjScreenMatrix(camera3js);

  frustum3js.setFromProjectionMatrix(projScreenMatrix);
}

var _default = CameraUtils;
exports["default"] = _default;

},{"h_3":7,"e_1":235,"s_2":236,"M_0":241}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

// import { CSG } from '../util/CSG.js' 
// import { simplify_three } from './MeshEditor/ThirdParty/modify.js';
// import subdivUVNormalized from './TexturePacker.js';

/**
 * 
 * @param {Cesium.Cartesian3} pa 
 * @param {Cesium.Cartesian3} pb 
 * @param {Cesium.Cartesian3} pc 
 * @returns {number}
 */
function computeArea(pa, pb, pc) {
  if (!pa || !pb || !pc) {
    console.warn(pa, pb, pc);
    return 0;
  }

  var Cartesian3 = Cesium.Cartesian3;
  var a = Cartesian3.distance(pa, pb);
  var b = Cartesian3.distance(pb, pc);
  var c = Cartesian3.distance(pa, pc);
  var p = (a + b + c) / 2,
      S = Math.sqrt(p * (p - a) * (p - b) * (p - c));
  return S;
}
/**
*
*@constructor 
*/


function GeometryUtils() {}

function getAttrs(geo) {
  var attrNames = [];

  for (var name in geo.attributes) {
    if (geo.attributes.hasOwnProperty(name) && geo.attributes[name]) {
      attrNames.push(name);
    }
  }

  return attrNames;
}

var Matrix3, Matrix4, Cartesian3, Cartesian2, BoundingSphere, GeometryAttribute, ComponentDatatype;
var scratchPosition; //= new Cesium.Cartesian3();

var scratchMatrix4; //= new Cesium.Matrix4();

var scratchRotation; //= new Cesium.Matrix3();

var scratchOffset; //= new Cesium.Cartesian3();

var _scratchCB, _scratchAB;

var constantsHasInit = false;

function initConstants$GeometryUtils() {
  if (constantsHasInit) return;
  constantsHasInit = true;
  var _Cesium = Cesium;
  Matrix3 = _Cesium.Matrix3;
  Matrix4 = _Cesium.Matrix4;
  Cartesian3 = _Cesium.Cartesian3;
  Cartesian2 = _Cesium.Cartesian2;
  BoundingSphere = _Cesium.BoundingSphere;
  GeometryAttribute = _Cesium.GeometryAttribute;
  ComponentDatatype = _Cesium.ComponentDatatype;
  scratchPosition = new Cartesian3();
  scratchMatrix4 = new Matrix4();
  scratchRotation = new Matrix3();
  scratchOffset = new Cartesian3();
  _scratchCB = new Cartesian3();
  _scratchAB = new Cartesian3();
}
/**
 * 
 * @param {THREE.BufferGeometry} bufferGeometry3js 
 * @param {number}materialIndexOrGroupIndex
 * @param {boolean}[groupOptimized]
 * @returns {THREE.BufferGeometry}
 */


function extractGeometry(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized) {
  var geometry = bufferGeometry3js;
  var srcAttributes = geometry.attributes;
  var newGeometry = new THREE.BufferGeometry();
  var indices = genGeometryIndices(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized);

  for (var name in srcAttributes) {
    var attribute = srcAttributes[name];
    var itemSize = attribute.itemSize;
    var srcArray = attribute.array;
    var normalized = attribute.normalized;
    var dstArray = new srcArray.constructor(indices.length * itemSize);
    var idx = 0;

    for (var i = 0; i < indices.length; i++) {
      var ptr = indices[i] * itemSize;

      for (var j = 0; j < itemSize; j++) {
        dstArray[idx++] = srcArray[ptr + j];
      }
    }

    var newAttribute = new THREE.BufferAttribute(dstArray, itemSize, normalized);
    newGeometry.setAttribute(name, newAttribute);
  }

  indices = null;
  return newGeometry;
}

GeometryUtils.extractGeometry = extractGeometry;
/**
 * 
 * @param {THREE.BufferGeometry} bufferGeometry3js 
 * @param {number}materialIndexOrGroupIndex
 * @param {boolean}[groupOptimized]
 * @returns {number[]}
 */

function genGeometryIndices(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized) {
  var geometry = bufferGeometry3js;
  var position = geometry.attributes.position;
  var groups = geometry.groups;
  var drawRange = geometry.drawRange;
  var index = geometry.index,
      indices = [],
      vertCount = position.count;

  if (index) {
    // indexed buffer geometry
    if (groups && groups.length > 0) {
      for (var i = 0, il = groups.length; i < il; i++) {
        var group = groups[i];

        if (!groupOptimized) {
          if (i != materialIndexOrGroupIndex) continue;
        } else if (group.materialIndex != materialIndexOrGroupIndex) continue;

        var start = Math.max(group.start, drawRange.start);
        var end = Math.min(index.count, group.start + group.count, drawRange.start + drawRange.count);

        for (var j = start, jl = end; j < jl; j += 3) {
          var a = index.getX(j);
          var b = index.getX(j + 1);
          var c = index.getX(j + 2);
          indices.push(a, b, c);
        }
      }
    } else {
      var _start = Math.max(0, drawRange.start);

      var _end = Math.min(index.count, drawRange.start + drawRange.count);

      for (var _i = _start, _il = _end; _i < _il; _i += 3) {
        var _a = index.getX(_i);

        var _b = index.getX(_i + 1);

        var _c = index.getX(_i + 2);

        indices.push(_a, _b, _c);
      }
    }
  } else {
    // non-indexed buffer geometry
    if (groups && groups.length > 0) {
      for (var _i2 = 0, _il2 = groups.length; _i2 < _il2; _i2++) {
        var _group = groups[_i2];

        if (!groupOptimized) {
          if (_i2 != materialIndexOrGroupIndex) continue;
        } else if (_group.materialIndex != materialIndexOrGroupIndex) continue;

        var _start2 = Math.max(_group.start, drawRange.start);

        var _end2 = Math.min(position.count, _group.start + _group.count, drawRange.start + drawRange.count);

        for (var _j = _start2, _jl = _end2; _j < _jl; _j += 3) {
          var _a2 = _j;

          var _b2 = _j + 1;

          var _c2 = _j + 2;

          indices.push(_a2, _b2, _c2);
        }
      }
    } else {
      var _start3 = Math.max(0, drawRange.start);

      var _end3 = Math.min(position.count, drawRange.start + drawRange.count);

      for (var _i3 = _start3, _il3 = _end3; _i3 < _il3; _i3 += 3) {
        var _a3 = _i3;

        var _b3 = _i3 + 1;

        var _c3 = _i3 + 2;

        indices.push(_a3, _b3, _c3);
      }
    }
  }

  if (vertCount > 65535) indices = new Uint32Array(indices);else if (vertCount > 255) indices = new Uint16Array(indices);else indices = new Uint8Array(indices);
  return indices;
}

GeometryUtils.genGeometryIndices = genGeometryIndices;
/**
 * 
 * @param {THREE.BufferGeometry} bufferGeometry3js 
 * @param {number}materialIndexOrGroupIndex
 * @param {boolean}[groupOptimized]
 * @param {Cesium.BoundingSphere}[boundingSphere]
 * @returns {{boundingSphere:Cesium.BoundingSphere,indices:number[]}}
 */

function computeBoundingSphereAndIndices(bufferGeometry3js, materialIndexOrGroupIndex, groupOptimized, boundingSphere) {
  initConstants$GeometryUtils();
  var geometry = bufferGeometry3js;
  var position = geometry.attributes.position;
  var positions = position.array;
  var PositionTypeCtor = positions.constructor;
  var groups = geometry.groups;
  var drawRange = geometry.drawRange;
  var index = geometry.index,
      indices = [],
      vertCount = position.count;

  if (!groups || groups.length <= 1 || typeof materialIndexOrGroupIndex != 'number') {
    if (!geometry.boundingSphere) geometry.computeBoundingSphere();
    boundingSphere = BoundingSphere.clone(geometry.boundingSphere, boundingSphere);
    indices = index && index.array;
  } else {
    indices = [];

    if (index) {
      // indexed buffer geometry
      for (var i = 0, il = groups.length; i < il; i++) {
        var group = groups[i];

        if (!groupOptimized) {
          if (i != materialIndexOrGroupIndex) continue;
        } else if (group.materialIndex != materialIndexOrGroupIndex) continue;

        var start = Math.max(group.start, drawRange.start);
        var end = Math.min(index.count, group.start + group.count, drawRange.start + drawRange.count);

        for (var j = start, jl = end; j < jl; j++) {
          indices.push(index.getX(j));
        }
      }

      var points = [];

      for (var _i4 = 0; _i4 < indices.length; _i4++) {
        var index = indices[_i4];
        var p = Cartesian3.unpack(position.array, index * 3);
        points.push(p);
      }

      boundingSphere = BoundingSphere.fromPoints(points, boundingSphere);
    } else {
      // non-indexed buffer geometry 
      var boundingSpheres = [];

      for (var _i5 = 0, _il4 = groups.length; _i5 < _il4; _i5++) {
        var _group2 = groups[_i5];

        if (!groupOptimized) {
          if (_i5 != materialIndexOrGroupIndex) continue;
        } else if (_group2.materialIndex != materialIndexOrGroupIndex) continue;

        var _start4 = Math.max(_group2.start, drawRange.start);

        var _end4 = Math.min(position.count, _group2.start + _group2.count, drawRange.start + drawRange.count);

        var byteOffset = _start4 * position.itemSize * PositionTypeCtor.BYTES_PER_ELEMENT;
        var arrayLength = (_end4 - _start4) * position.itemSize;
        var vertices = new PositionTypeCtor(positions.buffer, byteOffset, arrayLength);
        var groupBoundingSphere = BoundingSphere.fromVertices(vertices);
        boundingSpheres.push(groupBoundingSphere);

        for (var _j2 = _start4, _jl2 = _end4; _j2 < _jl2; _j2++) {
          indices.push(_j2);
        }
      }

      if (boundingSpheres.length > 0) {
        if (boundingSpheres.length == 1) boundingSphere = BoundingSphere.clone(boundingSpheres[0], boundingSphere);else {
          boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres, boundingSphere);
        }
      }
    }
  }

  if (indices && !indices.buffer) {
    if (vertCount > 65535) indices = new Uint32Array(indices);else if (vertCount > 255) indices = new Uint16Array(indices);else indices = new Uint8Array(indices);
  }

  return {
    indices: indices,
    boundingSphere: boundingSphere
  };
}

GeometryUtils.computeBoundingSphereAndIndices = computeBoundingSphereAndIndices;
/**
*点绕x轴旋转，修改顶点坐标
*@param {Cesium.Cartesian3}point
*@param {Number}angle 弧度
*/

GeometryUtils.pointRotateX = function (point, angle) {
  initConstants$GeometryUtils(); // const { Matrix3, Matrix4, Cartesian3 } = Cesium;

  Matrix3.fromRotationX(angle, scratchRotation);
  Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);
  Matrix4.multiplyByPoint(scratchMatrix4, point, point);
};
/**
*点绕y轴旋转，修改顶点坐标
*@param {Cesium.Cartesian3}point
*@param {Number}angle 弧度
*/


GeometryUtils.pointRotateY = function (point, angle) {
  initConstants$GeometryUtils();
  Matrix3.fromRotationY(angle, scratchRotation);
  Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);
  Matrix4.multiplyByPoint(scratchMatrix4, point, point);
};
/**
*点绕z轴旋转，修改顶点坐标
*@param {Cesium.Cartesian3}point
*@param {Number}angle 弧度
*/


GeometryUtils.pointRotateZ = function (point, angle) {
  initConstants$GeometryUtils();
  Matrix3.fromRotationZ(angle, scratchRotation);
  Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);
  Matrix4.multiplyByPoint(scratchMatrix4, point, point);
};
/**
*绕x轴旋转，修改顶点坐标
*@param {Cesium.Geometry}geometry
*@param {Number}angle 弧度
*/


GeometryUtils.rotateX = function (geometry, angle) {
  initConstants$GeometryUtils();
  var positions = geometry.attributes.position.values;
  Matrix3.fromRotationX(angle, scratchRotation);
  Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);

  for (var i = 0; i < positions.length; i += 3) {
    scratchPosition.x = positions[i];
    scratchPosition.y = positions[i + 1];
    scratchPosition.z = positions[i + 2];
    Matrix4.multiplyByPoint(scratchMatrix4, scratchPosition, scratchPosition);
    positions[i] = scratchPosition.x;
    positions[i + 1] = scratchPosition.y;
    positions[i + 2] = scratchPosition.z;
  }
};
/**
*绕y轴旋转，修改顶点坐标
*@param {Cesium.Geometry}geometry
*@param {Number}angle 弧度
*/


GeometryUtils.rotateY = function (geometry, angle) {
  initConstants$GeometryUtils();
  var positions = geometry.attributes.position.values;
  Matrix3.fromRotationY(angle, scratchRotation);
  Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);

  for (var i = 0; i < positions.length; i += 3) {
    scratchPosition.x = positions[i];
    scratchPosition.y = positions[i + 1];
    scratchPosition.z = positions[i + 2];
    Matrix4.multiplyByPoint(scratchMatrix4, scratchPosition, scratchPosition);
    positions[i] = scratchPosition.x;
    positions[i + 1] = scratchPosition.y;
    positions[i + 2] = scratchPosition.z;
  }
};
/**
*绕z轴旋转，修改顶点坐标
*@param {Cesium.Geometry}geometry
*@param {Number}angle 弧度
*/


GeometryUtils.rotateZ = function (geometry, angle) {
  initConstants$GeometryUtils();
  var positions = geometry.attributes.position.values;
  Matrix3.fromRotationZ(angle, scratchRotation);
  Matrix4.fromRotationTranslation(scratchRotation, Cartesian3.ZERO, scratchMatrix4);

  for (var i = 0; i < positions.length; i += 3) {
    scratchPosition.x = positions[i];
    scratchPosition.y = positions[i + 1];
    scratchPosition.z = positions[i + 2];
    Matrix4.multiplyByPoint(scratchMatrix4, scratchPosition, scratchPosition);
    positions[i] = scratchPosition.x;
    positions[i + 1] = scratchPosition.y;
    positions[i + 2] = scratchPosition.z;
  }
};
/**
 * 
 * @param {number[]} positions 
 * @param {number} index 
 * @returns {boolean}
 */


GeometryUtils.isValidVertex = function (positions, index) {
  index = index * 3;
  return !isNaN(positions[index]) //x
  && !isNaN(positions[index + 1]) //y
  && !isNaN(positions[index + 2]); //z
};
/**
 * 
 * @param {number[]} positions 
 * @param {number} a 
 * @param {number} b 
 * @param {number} c
 * @returns {boolean}
 */


GeometryUtils.isValidTriangle = function (positions, a, b, c) {
  var result = this.isValidVertex(positions, a) && this.isValidVertex(positions, b) && this.isValidVertex(positions, c);
  a = Cartesian3.unpack(positions, a * 3);
  b = Cartesian3.unpack(positions, b * 3);
  c = Cartesian3.unpack(positions, c * 3);
  var ba = Cartesian3.subtract(b, a, new Cartesian3());
  var ca = Cartesian3.subtract(c, a, new Cartesian3());
  var n = Cartesian3.cross(ba, ca, new Cartesian3());

  if (Cartesian3.equals(n, Cartesian3.ZERO)) {
    debugger;
    result = false;
  }

  return result;
};
/**
 * 删除位置坐标有NaN的顶点，返回新的几何体
 * @param {THREE.BufferGeometry} geometry 
 * @returns {THREE.BufferGeometry} newGeometry
 */


GeometryUtils.removeInvalidVertices = function (geometry) {
  if (!geometry.isBufferGeometry) {
    console.warn('unsupport geometry type');
    return geometry;
  }

  var newGeometry = geometry.clone(),
      srcAttributes = geometry.attributes,
      dstAttributes = newGeometry.attributes;
  var attrNames = [];

  for (var name in dstAttributes) {
    if (dstAttributes.hasOwnProperty(name) && dstAttributes[name]) {
      var att = dstAttributes[name];
      var srcType = att.array.constructor;
      att.array = [];
      att.array._srcType = srcType;
      attrNames.push(name);
    }
  }

  function addVertex(index) {
    attrNames.forEach(function (name) {
      var src = srcAttributes[name],
          dst = dstAttributes[name];
      var itemSize = src.itemSize,
          start = itemSize * index;

      for (var i = 0; i < itemSize; i++) {
        dst.array.push(src.array[start + i]);
      }
    });
  }

  function addTriangle(a, b, c) {
    addVertex(a);
    addVertex(b);
    addVertex(c);
  }

  var positions = geometry.attributes.position,
      vertexCount = positions.count;
  positions = positions.array || positions.values;

  if (geometry.index) {
    var indices = geometry.index.array;

    for (var i = 0; i < indices.length; i += 3) {
      var a = indices[i],
          b = indices[i + 1],
          c = indices[i + 2];

      if (this.isValidTriangle(positions, a, b, c)) {
        addTriangle(a, b, c);
      }
    }
  } else {
    for (var _i6 = 0; _i6 < vertexCount; _i6 += 3) {
      var _a4 = _i6,
          _b4 = _i6 + 1,
          _c4 = _i6 + 2;

      if (this.isValidTriangle(positions, _a4, _b4, _c4)) {
        addTriangle(_a4, _b4, _c4);
      }
    }
  }

  for (var _name in dstAttributes) {
    if (dstAttributes.hasOwnProperty(_name) && dstAttributes[_name]) {
      var _att = dstAttributes[_name];
      var _srcType = _att.array._srcType;
      _att.array = new _srcType(_att.array);
      _att.count = _att.array.length / _att.itemSize;
      delete _att.array._srcType;
    }
  }

  return newGeometry;
};
/**
 * 将几何体强制使用索引，以期减少几何内存占用，如果几何体的groups.length大于1，则返回undefined
 * @param {THREE.BufferGeometry} geometry 
 * @param {boolean}[removeUv2=false]
 * @param {boolean}[removeUv3=true]
 * @returns {undefined|THREE.BufferGeometry} newGeometry
 */


GeometryUtils.forceIndices = function (geometry, removeUv2, removeUv3) {
  if (typeof THREE == 'undefined') {
    throw new Error('强制索引功能依赖threejs，但是上下文未找到THREE模块 ');
  }

  if (geometry.index) {
    console.warn('该几何已有索引');
    return;
  }

  if (geometry.groups && geometry.groups.length > 1) {
    console.warn('该几何无法强制使用索引');
    return;
  }

  if (typeof removeUv3 == 'undefined') removeUv3 = true;
  var indices = [],
      map = new Map();
  var srcAttributes = geometry.attributes;
  var positions = srcAttributes.position;
  var srcCount = positions.count;
  positions = positions.array;
  var newGeometry = geometry.clone(),
      dstAttributes = newGeometry.attributes,
      attrNames = [];

  for (var name in dstAttributes) {
    if (removeUv3 && name == 'uv3' || removeUv2 && name == 'uv2') {
      delete dstAttributes[name];
      continue;
    }

    if (dstAttributes.hasOwnProperty(name) && dstAttributes[name]) {
      var att = dstAttributes[name];
      var srcType = att.array.constructor;
      att.array = [];
      att.array._srcType = srcType;
      attrNames.push(name);
    }
  }

  var newIndex = 0;

  function addVertex(index) {
    var code = [positions[index * 3], positions[index * 3 + 1], positions[index * 3 + 2]].join(',');

    if (dstAttributes.uv) {
      var uv = srcAttributes.uv.array;
      code += ',' + [uv[index * 2], uv[index * 2 + 1]].join(',');
    }

    if (dstAttributes.uv2) {
      var uv2 = srcAttributes.uv2.array;
      code += ',' + [uv2[index * 2], uv2[index * 2 + 1]].join(',');
    }

    if (!map.has(code)) {
      attrNames.forEach(function (name) {
        var src = srcAttributes[name],
            dst = dstAttributes[name];
        var itemSize = src.itemSize,
            start = itemSize * index;

        for (var i = 0; i < itemSize; i++) {
          dst.array.push(src.array[start + i]);
        }
      });
      map.set(code, newIndex);
      newIndex++;
    }

    return map.get(code);
  }

  for (var i = 0; i < srcCount; i++) {
    var idx = addVertex(i);
    indices.push(idx);
  }

  if (newIndex > 65535) {
    indices = new Uint32Array(indices);
  } else if (newIndex > 255) {
    indices = new Uint16Array(indices);
  } else {
    indices = new Uint8Array(indices);
  }

  map.clear();
  newGeometry.groups = [{
    start: 0,
    count: Infinity,
    materialIndex: 0
  }];
  newGeometry.index = new THREE.BufferAttribute(indices, 1, false);

  for (var _name2 in dstAttributes) {
    if (dstAttributes.hasOwnProperty(_name2) && dstAttributes[_name2]) {
      var _att2 = dstAttributes[_name2];
      var _srcType2 = _att2.array._srcType;
      _att2.array = new _srcType2(_att2.array);
      _att2.count = _att2.array.length / _att2.itemSize;
      delete _att2.array._srcType;
    }
  }

  return newGeometry;
};

function minmax(arr, offset, stride) {
  offset = offset || 0;
  stride = stride || 1;
  var min = Number.MAX_VALUE,
      max = -Number.MAX_VALUE;

  for (var i = offset; i < arr.length; i += stride) {
    var v = arr[i];
    if (isNaN(v) || v == Infinity || v == -Infinity) continue;
    min = Math.min(min, v);
    max = Math.max(max, v);
  }

  return {
    min: min,
    max: max
  };
}
/**
 * 
 * @param {THREE.BufferGeometry} geometry 
 * @returns {THREE.BufferGeometry}geometry
 */


GeometryUtils.clampToIndices = function (geometry) {
  if (geometry.index) {
    // geometry = geometry.clone();
    var index = geometry.index.array;

    var _minmax = minmax(index),
        max = _minmax.max;

    var atts = geometry.attributes;

    for (var key in atts) {
      if (atts.hasOwnProperty(key)) {
        var _atts$key = atts[key],
            array = _atts$key.array,
            itemSize = _atts$key.itemSize,
            count = _atts$key.count;
        if (count == max + 1) continue;
        var end = itemSize * (max + 1) * array.constructor.BYTES_PER_ELEMENT;
        var buffer = array.buffer.slice(0, end);
        array = new array.constructor(buffer);
        atts[key].array = array;
      }
    }
  }

  return geometry;
};
/**
 * 
 * @param {Cesium.Geometry|THREE.BufferGeometry} geometry 
 * @returns {boolean}
 */


GeometryUtils.computeSurfaceArea = function (geometry) {
  if (!(geometry instanceof Cesium.Geometry) && !geometry.isBufferGeometry) {
    console.warn('unsupport geometry type');
    return -1;
  }

  var positions = geometry.attributes.position;
  var indices = geometry.indices || geometry.index;
  if (indices) indices = indices.array || indices;
  positions = positions.array || positions.values;
  positions = Cartesian3.unpackArray(positions);
  var area = 0;

  if (indices) {
    for (var i = 0; i < indices.length; i += 3) {
      var a = indices[i],
          b = indices[i + 1],
          c = indices[i + 2];
      area += computeArea(positions[a], positions[b], positions[c]);
    }
  } else {
    for (var _i7 = 0; _i7 < positions.length; _i7 += 3) {
      var _a5 = positions[_i7],
          _b5 = positions[_i7 + 1],
          _c5 = positions[_i7 + 2];
      area += computeArea(_a5, _b5, _c5);
    }
  }

  return area;
};
/**
 * 
 * @param {THREE.BufferGeometry} a 
 * @param {THREE.BufferGeometry} b 
 * @returns {boolean}
 */


GeometryUtils.geometryEquals = function (a, b) {
  a = a.attributes.position.array;
  b = b.attributes.position.array;
  var eq = a.length == b.length;

  if (eq) {
    var l = a.length;

    for (var i = 0; i < l; i++) {
      if (a[i] != b[i]) {
        eq = false;
        break;
      }
    }
  }

  return eq;
};
/**
 * 
 * @param {THREE.Geometry} geometry 
 * @param {number} simplifyFactor 
 * @param {{
        agressiveness: number,
        update: number,
        recompute: boolean
 * }}[options]
 */


GeometryUtils.simplify = function (geometry, simplifyFactor, options) {
  if (typeof THREE == 'undefined') {
    throw new Error('模型简化功能依赖threejs，但是上下文未找到THREE模块 ');
  }

  if (!simplifyFactor) {
    throw new Error('缺少参数simplifyFactor');
  }

  var srcCount = geometry.attributes.position.count;
  var target_count = simplifyFactor * srcCount;
  geometry = simplify_three(geometry, target_count, options);
  var dstCount = geometry.attributes.position.count;
  var delt = dstCount - srcCount;

  if (delt < 0) {
    var positions = geometry.attributes.position.array;
    var isValid = true;

    for (var i = 0; i < dstCount; i++) {
      if (!this.isValidVertex(positions, i)) {
        isValid = false;
        break;
      }
    }

    if (!isValid) {
      geometry = GeometryUtils.removeInvalidVertices(geometry);
    }
  }

  return geometry;
}; // GeometryUtils.subdivUVNormalized = subdivUVNormalized;


var triangulate = function () {
  //src:http://turfjs.org/docs/#tin
  var Triangle = function () {
    function Triangle(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      var A = b.x - a.x;
      var B = b.y - a.y;
      var C = c.x - a.x;
      var D = c.y - a.y;
      var E = A * (a.x + b.x) + B * (a.y + b.y);
      var F = C * (a.x + c.x) + D * (a.y + c.y);
      var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
      var dx;
      var dy; // If the points of the triangle are collinear, then just find the
      // extremes and use the midpoint as the center of the circumcircle.

      this.x = (D * E - B * F) / G;
      this.y = (A * F - C * E) / G;
      dx = this.x - a.x;
      dy = this.y - a.y;
      this.r = dx * dx + dy * dy;
    }

    return Triangle;
  }();

  function byX(a, b) {
    return b.x - a.x;
  }

  function dedup(edges) {
    var j = edges.length;
    var a;
    var b;
    var i;
    var m;
    var n;

    outer: while (j) {
      b = edges[--j];
      a = edges[--j];
      i = j;

      while (i) {
        n = edges[--i];
        m = edges[--i];

        if (a === m && b === n || a === n && b === m) {
          edges.splice(j, 2);
          edges.splice(i, 2);
          j -= 2;
          continue outer;
        }
      }
    }
  }
  /**
   * 
   * @param {(Cesium.Cartesian2|THREE.Vector2)[]} vertices 
   */


  function triangulate(vertices) {
    // Bail if there aren't enough vertices to form any triangles.
    if (vertices.length < 3) {
      return [];
    } // Ensure the vertex array is in order of descending X coordinate
    // (which is needed to ensure a subquadratic runtime), and then find
    // the bounding box around the points.


    vertices.sort(byX);
    var i = vertices.length - 1;
    var xmin = vertices[i].x;
    var xmax = vertices[0].x;
    var ymin = vertices[i].y;
    var ymax = ymin;
    var epsilon = 1e-12;
    var a;
    var b;
    var c;
    var A;
    var B;
    var G;

    while (i--) {
      if (vertices[i].y < ymin) {
        ymin = vertices[i].y;
      }

      if (vertices[i].y > ymax) {
        ymax = vertices[i].y;
      }
    } // Find a supertriangle, which is a triangle that surrounds all the
    // vertices. This is used like something of a sentinel value to remove
    // cases in the main algorithm, and is removed before we return any
    // results.
    // Once found, put it in the "open" list. (The "open" list is for
    // triangles who may still need to be considered; the "closed" list is
    // for triangles which do not.)


    var dx = xmax - xmin;
    var dy = ymax - ymin;
    var dmax = dx > dy ? dx : dy;
    var xmid = (xmax + xmin) * 0.5;
    var ymid = (ymax + ymin) * 0.5;
    var open = [new Triangle({
      __sentinel: true,
      x: xmid - 20 * dmax,
      y: ymid - dmax
    }, {
      __sentinel: true,
      x: xmid,
      y: ymid + 20 * dmax
    }, {
      __sentinel: true,
      x: xmid + 20 * dmax,
      y: ymid - dmax
    })];
    var closed = [];
    var edges = [];
    var j; // Incrementally add each vertex to the mesh.

    i = vertices.length;

    while (i--) {
      // For each open triangle, check to see if the current point is
      // inside it's circumcircle. If it is, remove the triangle and add
      // it's edges to an edge list.
      edges.length = 0;
      j = open.length;

      while (j--) {
        // If this point is to the right of this triangle's circumcircle,
        // then this triangle should never get checked again. Remove it
        // from the open list, add it to the closed list, and skip.
        dx = vertices[i].x - open[j].x;

        if (dx > 0 && dx * dx > open[j].r) {
          closed.push(open[j]);
          open.splice(j, 1);
          continue;
        } // If not, skip this triangle.


        dy = vertices[i].y - open[j].y;

        if (dx * dx + dy * dy > open[j].r) {
          continue;
        } // Remove the triangle and add it's edges to the edge list.


        edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
        open.splice(j, 1);
      } // Remove any doubled edges.


      dedup(edges); // Add a new triangle for each edge.

      j = edges.length;

      while (j) {
        b = edges[--j];
        a = edges[--j];
        c = vertices[i]; // Avoid adding colinear triangles (which have error-prone
        // circumcircles)

        A = b.x - a.x;
        B = b.y - a.y;
        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));

        if (Math.abs(G) > epsilon) {
          open.push(new Triangle(a, b, c));
        }
      }
    } // Copy any remaining open triangles to the closed list, and then
    // remove any triangles that share a vertex with the supertriangle.


    Array.prototype.push.apply(closed, open);
    i = closed.length;

    while (i--) {
      if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
        closed.splice(i, 1);
      }
    }

    return closed;
  }

  return triangulate;
}();

GeometryUtils.triangulate = triangulate;
/**
 * 
 * @param {Cesium.Cartesian3} p1 
 * @param {Cesium.Cartesian3} p2 
 * @param {Cesium.Cartesian3} p3 
 * @param {Cesium.Cartesian3} [result] 
 */

function computeNormal(pA, pB, pC, result, normalized) {
  initConstants$GeometryUtils();

  if (!result) {
    result = new Cartesian3();
  }

  Cartesian3.subtract(pC, pB, _scratchCB);
  Cartesian3.subtract(pA, pB, _scratchAB);
  Cartesian3.cross(_scratchCB, _scratchAB, result);
  var magnitude = Cartesian3.magnitude(result);
  if (magnitude != 0 && normalized != false) Cartesian3.normalize(result, result);
  return result;
}

GeometryUtils.computeNormal = computeNormal;
/**
*
*@param {Cesium.Geometry}geometry
*/

GeometryUtils.computeVertexNormals = function (geometry) {
  initConstants$GeometryUtils(); // const _Cesium = Cesium;

  var indices = geometry.indices;
  var attributes = geometry.attributes;

  if (attributes.position) {
    var positions = attributes.position.values;
    var il = indices ? indices.length : positions.length / 3;

    if (attributes.normal === undefined) {
      attributes.normal = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        values: new Float32Array(positions.length)
      });
    } else {
      // reset existing normals to zero
      var array = attributes.normal.values;

      if (!indices) {
        for (var i = 0; i < il; i++) {
          array[i] = 0;
        }
      } else {
        var pi;

        for (var i = 0; i < il; i++) {
          pi = indices[i];
          array[pi * 3] = 0;
          array[pi * 3 + 1] = 0;
          array[pi * 3 + 2] = 0;
        }
      }
    }

    var normals = attributes.normal.values;
    var vA, vB, vC;
    var pA = new Cartesian3(),
        pB = new Cartesian3(),
        pC = new Cartesian3();
    var cb = new Cartesian3(),
        ab = new Cartesian3();

    for (var i = 0; i < il; i += 3) {
      vA = indices ? indices[i + 0] * 3 : i * 3;
      vB = indices ? indices[i + 1] * 3 : (i + 1) * 3;
      vC = indices ? indices[i + 2] * 3 : (i + 2) * 3;
      Cartesian3.fromArray(positions, vA, pA);
      Cartesian3.fromArray(positions, vB, pB);
      Cartesian3.fromArray(positions, vC, pC);
      Cartesian3.subtract(pC, pB, cb);
      Cartesian3.subtract(pA, pB, ab);
      Cartesian3.cross(cb, ab, cb);
      normals[vA] += cb.x;
      normals[vA + 1] += cb.y;
      normals[vA + 2] += cb.z;
      normals[vB] += cb.x;
      normals[vB + 1] += cb.y;
      normals[vB + 2] += cb.z;
      normals[vC] += cb.x;
      normals[vC + 1] += cb.y;
      normals[vC + 2] += cb.z;
    }

    normalizeNormals(geometry);
    attributes.normal.needsUpdate = true;
  }

  return geometry;
};

function normalizeNormals(geometry) {
  var normals = geometry.attributes.normal.values;
  var x, y, z, n;

  for (var i = 0; i < normals.length; i += 3) {
    x = normals[i];
    y = normals[i + 1];
    z = normals[i + 2];
    n = 1.0 / Math.sqrt(x * x + y * y + z * z);
    normals[i] = x * n;
    normals[i + 1] = y * n;
    normals[i + 2] = z * n;
  }
}
/**
*合并两个或两个以上图形类型（primitiveType），属性数量、名称以及属性值的类型（GeometryAttribute的componentDatatype、componentsPerAttribute等）都一致的几何体
*@param {Array<Cesium.Geometry>}geometries 
*@return {Cesium.Geometry}
*/


GeometryUtils.mergeGeometries = function (geometries) {
  if (!geometries || !geometries.length) {
    throw new Error("缺少geometries参数");
  }

  if (geometries.length == 1) {
    return geometries[0];
  }

  var geometriesAttrs = [];
  var lengthChanged = false;
  var primitiveTypeChanged = false;
  var primitiveType = geometries[0].primitiveType;

  for (var i = 0; i < geometries.length; i++) {
    geometriesAttrs[i] = getAttrs(geometries[i]);

    if (i > 0) {
      if (primitiveType != geometries[i].primitiveType) {
        primitiveTypeChanged = true;
        break;
      }

      var lastGeoAttrs = geometriesAttrs[i - 1];
      lengthChanged = lastGeoAttrs.length != geometriesAttrs[i].length;

      if (!lengthChanged) {
        for (var j = 0; j < lastGeoAttrs.length; j++) {
          if (lastGeoAttrs[j] != geometriesAttrs[i][j]) {
            lengthChanged = true;
            break;
          }
        }
      }
    }

    primitiveType = geometries[i].primitiveType;

    if (lengthChanged || primitiveTypeChanged) {
      break;
    }
  }

  if (primitiveTypeChanged) {
    throw new Error("待合并的几何体中primitiveType属性不完全一致");
  }

  if (lengthChanged) {
    throw new Error("待合并的几何体中属性数量和和名称不完全一致");
  }

  return mergeGeometries(geometries);
};

function mergeGeometries(geometries) {
  if (geometries.length == 1) return geometries[0];
  var attrNames = [];
  var valueArrs = [];
  var valueTypes = [];
  var valueConstructors = [];
  var valueComponents = [];
  var valueNormalizes = [];
  var valueOffsets = [];
  var indices = [];
  var primitiveType;
  var indexOffst = 0;
  var componentCounts = [];
  var geometry = geometries[0];
  primitiveType = geometry.primitiveType;

  for (var _attrName in geometry.attributes) {
    if (geometry.attributes.hasOwnProperty(_attrName) && geometry.attributes[_attrName]) {
      var attr = geometry.attributes[_attrName];
      attrNames.push(_attrName); // valueArrs.push([]);

      valueComponents.push(attr.componentsPerAttribute);
      valueTypes.push(attr.componentDatatype);
      valueConstructors.push(attr.values.constructor);
      valueNormalizes.push(attr.normalize);
      componentCounts.push(0);
      valueOffsets.push(0);
    }
  }

  for (var i = 0; i < geometries.length; i++) {
    var _geometry = geometries[i];

    for (var j = 0; j < attrNames.length; j++) {
      var _attrName2 = attrNames[j];
      componentCounts[j] += _geometry.attributes[_attrName2].values.length;
    }
  }

  for (var _j3 = 0; _j3 < attrNames.length; _j3++) {
    valueArrs.push(new valueConstructors[_j3](componentCounts[_j3]));
  }

  if (!geometries[0].indices) {
    indices = null;
  }

  for (var _i8 = 0; _i8 < geometries.length; _i8++) {
    var _geometry2 = geometries[_i8];

    for (var ai = 0; ai < attrNames.length; ai++) {
      var attrName = attrNames[ai];
      var valueArr = valueArrs[ai];
      var attrValues = _geometry2.attributes[attrName].values;
      valueArr.set(attrValues, valueOffsets[ai]);
      valueOffsets[ai] += attrValues.length;
    }

    if (_geometry2.indices) {
      for (var _j4 = 0; _j4 < _geometry2.indices.length; _j4++) {
        var index = _geometry2.indices[_j4];
        indices.push(index + indexOffst);
      }

      indexOffst += _geometry2.attributes.position.values.length / 3;
    }
  }

  var attributes = {};

  for (var _i9 = 0; _i9 < attrNames.length; _i9++) {
    var _attrName3 = attrNames[_i9];
    attributes[_attrName3] = {
      values: valueArrs[_i9],
      componentsPerAttribute: valueComponents[_i9],
      componentDatatype: valueTypes[_i9],
      normalize: valueNormalizes[_i9]
    };
  }

  if (indices) {
    var vertexCount = valueArrs[0] / valueComponents[0];

    if (vertexCount < 65535) {
      indices = new Uint16Array(indices);
    } else {
      indices = new Uint32Array(indices);
    }
  }

  geometry = new Cesium.Geometry({
    attributes: attributes,
    indices: indices,
    primitiveType: primitiveType
  });
  return geometry;
}
/**
 * 
 * @param {Cesium.Geometry[]} geometries 
 * @returns {Cesium.Geometry}
 */


GeometryUtils.mergeGroupedGeometries = function (geometries) {
  var _Cesium = Cesium;
  var attributes = GeometryUtils.cloneGeometryAttributes(geometries[0].attributes);

  var _loop = function _loop(name) {
    if (attributes.hasOwnProperty(name)) {
      var attribute = attributes[name];
      var componentsPerAttribute = attribute.componentsPerAttribute;
      var componentDatatype = attribute.componentDatatype;
      var values = [];
      geometries.forEach(function (geometry) {
        var srcAttribute = geometry.attributes[name];
        var srcValues = srcAttribute.values;

        for (var i = 0; i < geometry.indices.length; i++) {
          var vi = geometry.indices[i];

          for (var j = 0; j < componentsPerAttribute; j++) {
            values.push(srcValues[vi * componentsPerAttribute + j]);
          }
        }
      });
      attributes[name].values = _Cesium.ComponentDatatype.createTypedArray(componentDatatype, values);
    }
  };

  for (var name in attributes) {
    _loop(name);
  }

  return new _Cesium.Geometry({
    attributes: attributes,
    primitiveType: geometries[0].primitiveType
  });
};
/**
 * 
 * @param {THREE.BufferGeometry[]} geometries 
 * @returns {THREE.BufferGeometry}
 */


function mergeGeometries3js(geometries) {
  var _THREE = THREE;
  var newGeometry = geometries[0].clone();
  var newAttributes = newGeometry.attributes;

  for (var name in newAttributes) {
    var newAttribute = newAttributes[name];
    var count = 0,
        aLength = 0;

    for (var i = 0; i < geometries.length; i++) {
      var geom = geometries[i];
      var att = geom.attributes[name];
      count += att.count;
      aLength += att.array.length;
    }

    newAttribute.count = count;
    newAttribute.array = new newAttribute.array.constructor(aLength);
    var array = newAttribute.array,
        offset = 0;

    for (var _i10 = 0; _i10 < geometries.length; _i10++) {
      var _geom = geometries[_i10];
      var _att3 = _geom.attributes[name],
          currArr = _att3.array;
      array.set(currArr, offset);
      offset += currArr.length;
    }
  } //


  var indexList = [],
      newIndexLen = 0;

  for (var _i11 = 0; _i11 < geometries.length; _i11++) {
    var _geom2 = geometries[_i11];
    var indices = genGeometryIndices(_geom2, 0, true);
    indexList.push(indices);
    newIndexLen += indices.length;
  }

  var newIndices,
      vertCount = newAttributes.position.count,
      newIndexCtor;

  if (vertCount > 65535) {
    newIndices = new Uint32Array(newIndexLen);
    newIndexCtor = _THREE.Uint32BufferAttribute;
  } else if (vertCount > 255) {
    newIndices = new Uint16Array(newIndexLen);
    newIndexCtor = _THREE.Uint16BufferAttribute;
  } else {
    newIndices = new Uint8Array(newIndexLen);
    newIndexCtor = _THREE.Uint8BufferAttribute;
  }

  var offset = 0,
      ptr = 0,
      removeIndex = true,
      prevIndex = -1;

  for (var _i12 = 0; _i12 < indexList.length; _i12++) {
    var index = indexList[_i12];

    for (var j = 0; j < index.length; j++) {
      var currIdx = index[j] + offset;
      newIndices[ptr++] = currIdx;

      if (currIdx - prevIndex != 1) {
        removeIndex = false;
      }

      prevIndex = currIdx;
    }

    offset += geometries[_i12].attributes.position.count;
  }

  if (removeIndex) {
    newGeometry.index = null;
  } else {
    newGeometry.setIndex(new newIndexCtor(newIndices, 1, false));
  }

  newGeometry.computeBoundingSphere();
  newGeometry.computeBoundingBox();
  return newGeometry;
}

GeometryUtils.mergeGeometries3js = mergeGeometries3js;
/**
*
*@param {Cesium.Geometry}geometry
*@param {Cesium.Cartesian3}offset
*/

GeometryUtils.translate = function (geometry, offset) {
  initConstants$GeometryUtils();

  if (Array.isArray(offset)) {
    scratchOffset.x = offset[0];
    scratchOffset.y = offset[1];
    scratchOffset.z = offset[2];
  } else {
    Cartesian3.clone(offset, scratchOffset);
  }

  for (var i = 0; i < geometry.attributes.position.values.length; i += 3) {
    geometry.attributes.position.values[i] += scratchOffset.x;
    geometry.attributes.position.values[i + 1] += scratchOffset.y;
    geometry.attributes.position.values[i + 2] += scratchOffset.z;
  } //if (geometry.attributes.normal) {
  //    Cesium.GeometryPipeline.computeNormal(geometry);
  //}

};
/**
*
*@param {TypeArray} array
*@return {Cesium.ComponentDatatype}  
*/


GeometryUtils.getAttributeComponentType = function (array) {
  var ComponentDatatype = Cesium.ComponentDatatype;
  var attributeComponentType = ComponentDatatype.SHORT;

  if (array instanceof Int8Array) {
    attributeComponentType = ComponentDatatype.BYTE;
  } else if (array instanceof Uint8Array || array instanceof Uint8ClampedArray) {
    attributeComponentType = ComponentDatatype.UNSIGNED_BYTE;
  } else if (array instanceof Int16Array) {
    attributeComponentType = ComponentDatatype.SHORT;
  } else if (array instanceof Uint16Array) {
    attributeComponentType = ComponentDatatype.UNSIGNED_SHORT;
  } else if (array instanceof Int32Array) {
    attributeComponentType = ComponentDatatype.INT;
  } else if (array instanceof Uint32Array) {
    attributeComponentType = ComponentDatatype.UNSIGNED_INT;
  } else if (array instanceof Float32Array) {
    attributeComponentType = ComponentDatatype.FLOAT;
  } else if (array instanceof Float64Array) {
    attributeComponentType = ComponentDatatype.DOUBLE;
  }

  return attributeComponentType;
};
/**
 * 
 * @param {{[key:string]:Cesium.GeometryAttribute}} srcAttributes 
 * @returns {{[key:string]:Cesium.GeometryAttribute}} newAttributes
 */


GeometryUtils.cloneGeometryAttributes = function (srcAttributes) {
  var attributes = {};

  for (var name in srcAttributes) {
    if (srcAttributes.hasOwnProperty(name) && srcAttributes[name]) {
      var srcAttribute = srcAttributes[name];
      attributes[name] = {
        componentDatatype: srcAttribute.componentDatatype,
        componentsPerAttribute: srcAttribute.componentsPerAttribute,
        normalize: srcAttribute.normalize,
        values: []
      };
    }
  }

  return attributes;
};
/**
 * 
 * @param {Cesium.Geometry} geometry 
 * @returns {Cesium.Geometry}
 */


GeometryUtils.cloneGeometry = function (geometry) {
  var attributes = this.cloneGeometryAttributes(geometry.attributes);

  for (var key in attributes) {
    if (attributes.hasOwnProperty(key)) {
      var attribute = attributes[key];
      var values = geometry.attributes[key].values;
      attribute.values = new values.constructor(values);
    }
  }

  var indices = geometry.indices ? new geometry.indices.constructor(geometry.indices) : undefined;
  var newGeometry = new Cesium.Geometry({
    attributes: attributes,
    indices: indices,
    primitiveType: geometry.primitiveType,
    boundingSphere: geometry.boundingSphere ? geometry.boundingSphere.clone() : undefined
  });
  return newGeometry;
};
/**
*
*@param {Object}geometry
*@return {Boolean}
*/


GeometryUtils.isGeometry3js = function (geometry) {
  return typeof THREE !== 'undefined' && geometry.isBufferGeometry || geometry.attributes && geometry.attributes.position && geometry.index || geometry.vertices && geometry.faces;
};
/**
 *
 * @param {THREE.BufferGeometry}geometry 
 * @param {THREE.Mesh} object
 * @private
 */


GeometryUtils.parseBufferGeometry3js = function (geometry, object) {
  // var start = new Date();
  var _Cesium2 = Cesium,
      GeometryAttribute = _Cesium2.GeometryAttribute,
      PrimitiveType = _Cesium2.PrimitiveType,
      Geometry = _Cesium2.Geometry;
  var attributes = {};

  if (!geometry.attributes.normal) {
    geometry.computeVertexNormals();
  }

  for (var attrName in geometry.attributes) {
    if (geometry.attributes.hasOwnProperty(attrName)) {
      var attr = geometry.getAttribute(attrName);

      if (attr && attr.array.length > 0) {
        attributes[attrName] = new GeometryAttribute({
          componentDatatype: GeometryUtils.getAttributeComponentType(attr.array),
          componentsPerAttribute: attr.itemSize,
          values: attr.array,
          normalize: attr.normalized
        });
      }
    }
  }

  var indices;
  var primitiveType = 4;

  if (typeof geometry.GeometryMode != 'undefined') {
    primitiveType = geometry.GeometryMode;
  }

  if (!geometry.index) {
    var ptCount = attributes.position.values.length / 3;

    if (geometry.groups && geometry.groups.length) {
      indices = [];
      geometry.groups.forEach(function (group) {
        if (group.start + group.count > ptCount) {
          console.warn('group.count>ptCount');
        }

        for (var i = 0; i < group.count && i + group.start < ptCount; i++) {
          indices.push(i + group.start);
        }
      });
    } else if (object.isLine) {
      if (object.isLineSegments) {
        primitiveType = 1;
      } else if (object.isLineLoop) {
        primitiveType = 2;
      } else {
        primitiveType = 3;
      }
    } else if (object.isPoints) {
      primitiveType = 0;
    }

    if (indices) {
      if (ptCount > 65535) {
        indices = new Uint32Array(indices);
      } else {
        indices = new Uint16Array(indices);
      }
    }
  } else {
    indices = geometry.index.array;
  }

  var cesGeometry = new Geometry({
    attributes: attributes,
    indices: indices,
    primitiveType: primitiveType
  });

  if (geometry.boundingSphere) {
    cesGeometry.boundingSphere = BoundingSphere.clone(geometry.boundingSphere);
  }

  return cesGeometry;
};
/**
*
*@param {THREE.Geometry}geometry3js
*@return {Cesium.Geometry} 
*/


GeometryUtils.fromGeometry3js = function (geometry3js, object, useCesiumNormal) {
  if (geometry3js.attributes && (geometry3js.index || geometry3js.groups.length)) {} else {
    if (!geometry3js.isBufferGeometry) {
      geometry3js = new THREE.BufferGeometry().fromGeometry(geometry3js);
    }

    if (!geometry3js.attributes.normal && !useCesiumNormal && geometry3js.computeVertexNormals) {
      geometry3js.computeVertexNormals();
    }
  }

  var _Cesium = Cesium;
  var geometry = GeometryUtils.parseBufferGeometry3js(geometry3js, object);

  if (useCesiumNormal && !geometry.attributes.normal && geometry.primitiveType == 4) {
    _Cesium.GeometryPipeline.computeNormal(geometry);
  }

  return geometry;
};
/**
 * 
 * @param {Cesium.Geometry} geometry 
 * @param {THREE.BufferGeometry} [result]
 * @returns {THREE.BufferGeometry} result
 */


GeometryUtils.toBufferGeometry3js = function (geometry, result) {
  var _THREE2 = THREE,
      BufferGeometry = _THREE2.BufferGeometry,
      BufferAttribute = _THREE2.BufferAttribute,
      Sphere = _THREE2.Sphere;
  if (!result) result = new BufferGeometry();
  var attributes = geometry.attributes;

  for (var name in attributes) {
    if (attributes.hasOwnProperty(name) && attributes[name]) {
      var attribute = attributes[name];
      var array = attribute.values;

      if (array instanceof Float64Array) {
        array = new Float32Array(array);
      }

      var attribute3js = new BufferAttribute(array, attribute.componentsPerAttribute, attribute.normalize);
      result.setAttribute(name, attribute3js);
    }
  }

  if (attributes.st) {
    result.attributes.uv = result.attributes.st;
    result.deleteAttribute('st');
  }

  if (geometry.indices) {
    var _attribute3js = new BufferAttribute(geometry.indices, 1, false);

    result.setIndex(_attribute3js);
  }

  if (geometry.boundingSphere) {
    var bs = geometry.boundingSphere;
    if (!result.boundingSphere) result.boundingSphere = new Sphere();
    result.boundingSphere.center.copy(bs.center);
    result.boundingSphere.radius = bs.radius;
  }

  return result;
};
/**
*
*@param {Cesium.Geometry}geometry
*@return {THREE.Geometry} 
*/


GeometryUtils.toGeometry3js = function (geometry) {
  if (typeof THREE === 'undefined') {
    throw new Error("THREE 未加载");
  }

  var _THREE3 = THREE,
      Geometry = _THREE3.Geometry,
      Vector3 = _THREE3.Vector3,
      Face3 = _THREE3.Face3;
  var positions = geometry.attributes.position.values;
  var positionIdx = 0;
  var geometry3js = new Geometry();

  for (var i = 0; i < positions.length; i += 3) {
    positionIdx = i * 3;
    geometry3js.vertices.push(new Vector3(positions[positionIdx], positions[positionIdx + 2], positions[positionIdx + 1]));
  }

  for (var i = 0; i < geometry.indices.length; i += 3) {
    var idx1 = geometry.indices[i];
    var idx2 = geometry.indices[i + 1];
    var idx3 = geometry.indices[i + 2];
    geometry3js.faces.push(new Face3(idx1, idx2, idx3));
  }

  return geometry3js;
};
/**
*@param {Cesium.Geometry|THREE.Geometry}geometry
*@param {Cesium.Cartesian3}[offset]
*@return {CSG}
*/


GeometryUtils.toCSG = function (geometry, offset) {
  if (!(typeof THREE === 'undefined')) {
    if (geometry.isBufferGeometry) {
      return GeometryUtils._toCSG3js(geometry, offset);
    }
  }

  var _Cesium = Cesium;

  if (!offset) {
    offset = {
      x: 0,
      y: 0,
      z: 0
    };
  }

  if (!geometry.attributes.normal) {
    geometry = _Cesium.GeometryPipeline.computeNormal(geometry);
  }

  if (geometry.primitiveType !== 4) {
    throw new Error("暂不支持此类几何体");
  }

  if (!CSG) {
    throw new Error('CSG 库未加载。请从 https://github.com/evanw/csg.js 获取');
  }

  var faceCount = geometry.indices.length / 3;
  var polygons = [],
      vertices = [];
  var positions = geometry.attributes.position.values;
  var normals = geometry.attributes.normal.values;
  var normalIdx = 0,
      positionIdx = 0;

  for (var i = 0; i < geometry.indices.length; i += 3) {
    vertices = [];
    var idx1 = geometry.indices[i];
    var idx2 = geometry.indices[i + 1];
    var idx3 = geometry.indices[i + 2];
    positionIdx = idx1 * 3;
    normalIdx = idx1 * 3;
    vertices.push(new CSG.Vertex([positions[positionIdx++] + offset.x, positions[positionIdx++] + offset.y, positions[positionIdx++] + offset.z], [normals[normalIdx++], normals[normalIdx++], normals[normalIdx++]]));
    positionIdx = idx2 * 3;
    normalIdx = idx2 * 3;
    vertices.push(new CSG.Vertex([positions[positionIdx++] + offset.x, positions[positionIdx++] + offset.y, positions[positionIdx++] + offset.z], [normals[normalIdx++], normals[normalIdx++], normals[normalIdx++]]));
    positionIdx = idx3 * 3;
    normalIdx = idx3 * 3;
    vertices.push(new CSG.Vertex([positions[positionIdx++] + offset.x, positions[positionIdx++] + offset.y, positions[positionIdx++] + offset.z], [normals[normalIdx++], normals[normalIdx++], normals[normalIdx++]]));
    polygons.push(new CSG.Polygon(vertices));
  }

  return CSG.fromPolygons(polygons);
};
/**
*@param {CSG}csg_model
*@param {Boolean}[toGeometry3js=false]
*@return {Cesium.Geometry|THREE.Geometry}
*/


GeometryUtils.fromCSG = function (csg_model, toGeometry3js) {
  if (!(typeof THREE === 'undefined') && toGeometry3js) {
    return GeometryUtils._fromCSG3js(csg_model);
  }

  var i,
      j,
      vertices,
      polygons = csg_model.toPolygons();

  if (!CSG) {
    throw new Error('CSG 库未加载。请从 https://github.com/evanw/csg.js 获取');
  }

  var _Cesium3 = Cesium,
      GeometryAttribute = _Cesium3.GeometryAttribute,
      PrimitiveType = _Cesium3.PrimitiveType,
      Geometry = _Cesium3.Geometry;
  var positions = [];
  var normals = [];
  var indices = [];

  for (i = 0; i < polygons.length; i++) {
    // Vertices
    vertices = [];

    for (j = 0; j < polygons[i].vertices.length; j++) {
      vertices.push(getGeometryVertice(positions, normals, polygons[i].vertices[j].pos, polygons[i].plane.normal));
    }

    if (vertices[0] === vertices[vertices.length - 1]) {
      vertices.pop();
    }

    for (var j = 2; j < vertices.length; j++) {
      indices.push(vertices[0], vertices[j - 1], vertices[j]);
    }
  }

  positions = new Float32Array(positions);
  normals = new Float32Array(normals);
  indices = new Int32Array(indices);
  var attributes = {};
  attributes.position = new GeometryAttribute({
    componentDatatype: ComponentDatatype.FLOAT,
    componentsPerAttribute: 3,
    values: positions
  });
  attributes.normal = new GeometryAttribute({
    componentDatatype: ComponentDatatype.FLOAT,
    componentsPerAttribute: 3,
    values: normals
  });
  var cesGeometry = new Geometry({
    attributes: attributes,
    indices: indices,
    primitiveType: 4
  });
  return cesGeometry;
};

GeometryUtils._toCSG3js = function (three_model, offset, rotation) {
  if (typeof THREE === 'undefined') {
    throw new Error("THREE 未加载");
  }

  var i, geometry, polygons, vertices, rotation_matrix;

  if (!CSG) {
    throw 'CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js';
  }

  var _THREE4 = THREE,
      Mesh = _THREE4.Mesh,
      Geometry = _THREE4.Geometry,
      Euler = _THREE4.Euler,
      Vector3 = _THREE4.Vector3,
      Matrix4 = _THREE4.Matrix4,
      Face3 = _THREE4.Face3,
      Face4 = _THREE4.Face4;
  var _CSG$Vertex = CSG.Vertex,
      Vertex = _CSG$Vertex.Vertex,
      Polygon = _CSG$Vertex.Polygon;

  if (three_model instanceof Mesh) {
    geometry = three_model.geometry;
    offset = offset || three_model.position;
    rotation = rotation || three_model.rotation;
  } else if (three_model instanceof Geometry) {
    geometry = three_model;
    offset = offset || new Vector3(0, 0, 0);
    rotation = rotation || new Euler(0, 0, 0);
  } else if (three_model.isBufferGeometry) {
    geometry = new Geometry().fromBufferGeometry(three_model);
    offset = offset || new Vector3(0, 0, 0);
    rotation = rotation || new Euler(0, 0, 0);
  } else {
    throw 'Model type not supported.';
  }

  rotation_matrix = new Matrix4().makeRotationFromEuler(rotation);
  var polygons = [];
  var faces = geometry.faces,
      srcVertices = geometry.vertices;

  for (i = 0; i < faces.length; i++) {
    var face = faces[i];
    var a = face.a,
        b = face.b,
        c = face.c,
        d = face.d,
        normal = face.normal;
    var normalArr = [normal.x, normal.y, normal.z];

    if (face instanceof Face3) {
      vertices = [];
      vertices.push(new Vertex(srcVertices[a].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      vertices.push(new Vertex(srcVertices[b].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      vertices.push(new Vertex(srcVertices[c].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      polygons.push(new Polygon(vertices));
    } else if (face instanceof Face4) {
      vertices = [];
      vertices.push(new Vertex(srcVertices[a].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      vertices.push(new Vertex(srcVertices[b].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      vertices.push(new Vertex(srcVertices[d].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      polygons.push(new Polygon(vertices));
      vertices = [];
      vertices.push(new Vertex(srcVertices[b].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      vertices.push(new Vertex(srcVertices[c].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      vertices.push(new Vertex(srcVertices[d].clone().add(offset).applyMatrix4(rotation_matrix), normalArr));
      polygons.push(new Polygon(vertices));
    } else {
      throw 'Model contains unsupported face.';
    }
  }

  return CSG.fromPolygons(polygons);
};

GeometryUtils._fromCSG3js = function (csg_model) {
  if (typeof THREE === 'undefined') {
    throw new Error("THREE 未加载");
  }

  var i,
      j,
      vertices,
      face,
      three_geometry = new THREE.Geometry(),
      polygons = csg_model.toPolygons();

  if (!CSG) {
    throw 'CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js';
  }

  var _THREE5 = THREE,
      Vector3 = _THREE5.Vector3,
      Vector2 = _THREE5.Vector2,
      Face3 = _THREE5.Face3;

  for (i = 0; i < polygons.length; i++) {
    // Vertices
    vertices = [];

    for (j = 0; j < polygons[i].vertices.length; j++) {
      vertices.push(GeometryUtils._getGeometryVertice3js(three_geometry, polygons[i].vertices[j].pos));
    }

    if (vertices[0] === vertices[vertices.length - 1]) {
      vertices.pop();
    }

    for (var j = 2; j < vertices.length; j++) {
      face = new Face3(vertices[0], vertices[j - 1], vertices[j], new Vector3().copy(polygons[i].plane.normal));
      three_geometry.faces.push(face);
      three_geometry.faceVertexUvs[0].push(new Vector2());
    }
  }

  three_geometry.computeBoundingBox();
  return three_geometry;
};

GeometryUtils._getGeometryVertice3js = function (geometry, vertice_position) {
  var i;

  for (i = 0; i < geometry.vertices.length; i++) {
    if (geometry.vertices[i].x === vertice_position.x && geometry.vertices[i].y === vertice_position.y && geometry.vertices[i].z === vertice_position.z) {
      // Vertice already exists
      return i;
    }
  }

  ;
  geometry.vertices.push(new THREE.Vector3(vertice_position.x, vertice_position.y, vertice_position.z));
  return geometry.vertices.length - 1;
};
/**
*@param {Array<Number>}positions
*@param {Array<Number>}normals
*@param {Cesium.CSG.Vector}vertice_position
*@param {Cesium.CSG.Vector}plane_normal
*@return {Number}
*@private
*/


function getGeometryVertice(positions, normals, vertice_position, plane_normal) {
  var i,
      idx = 0;

  for (i = 0; i < positions.length; i += 3) {
    if (positions[i] === vertice_position.x && positions[i + 1] === vertice_position.y && positions[i + 2] === vertice_position.z) {
      // Vertice already exists
      return idx;
    }

    idx++;
  }

  ;
  positions.push(vertice_position.x, vertice_position.y, vertice_position.z);
  normals.push(plane_normal.x, plane_normal.y, plane_normal.z);
  return idx;
}
/**
 * 
 * @param {THREE.Vec2[]} contour 
 * @param {THREE.Vec2[][]} holes 
 * @param {THREE.Vec2[]} outVertices 
 * @param {number[]} outIndices 
 */


function triangulateShape(contour, holes, outVertices, outIndices) {
  var ShapeUtils = THREE.ShapeUtils;
  var indices = outIndices,
      vertices = outVertices;
  var i, l, shapeHole;
  var indexOffset = vertices.length; //var points = shape.extractPoints(curveSegments);

  var shapeVertices = contour.slice();
  var shapeHoles = holes.map(function (hole) {
    return hole.slice();
  }); // check direction of vertices

  if (ShapeUtils.isClockWise(shapeVertices) === false) {
    shapeVertices = shapeVertices.reverse();
  }

  for (i = 0, l = shapeHoles.length; i < l; i++) {
    shapeHole = shapeHoles[i];

    if (ShapeUtils.isClockWise(shapeHole) === true) {
      shapeHoles[i] = shapeHole.reverse();
    }
  }

  var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

  for (i = 0, l = shapeHoles.length; i < l; i++) {
    shapeHole = shapeHoles[i];
    shapeVertices = shapeVertices.concat(shapeHole);
  } // vertices, normals, uvs


  for (i = 0, l = shapeVertices.length; i < l; i++) {
    var vertex = shapeVertices[i];
    vertices.push(vertex); //.x, vertex.y, 0);
    //normals.push(0, 0, 1);
    //uvs.push(vertex.x, vertex.y); // world uvs
  } // incides


  for (i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    var a = face[0] + indexOffset;
    var b = face[1] + indexOffset;
    var c = face[2] + indexOffset;
    indices.push(a, b, c); //groupCount += 3;
  }
}

GeometryUtils.triangulateShape = triangulateShape;
/**
 * 
 * @param {THREE.BufferGeometry} geometry 
 * @returns {number[]}
 */

function genGeometryIndicesAll(geometry) {
  var index = geometry.index;
  var groups = geometry.groups;
  var indices;

  if (index) {
    indices = index.array;
  } else {
    if (groups && groups.length > 1) {
      indices = [];

      for (var i = 0; i < groups.length; i++) {
        var tempIndices = genGeometryIndices(geometry, i, false);

        for (var j = 0; j < tempIndices.length; j++) {
          indices.push(tempIndices[j]);
        }
      }
    } else {
      indices = genGeometryIndices(geometry, 0, true);
    }
  }

  return indices;
}

GeometryUtils.genGeometryIndicesAll = genGeometryIndicesAll;
/**
 * 
 * @param {THREE.BufferGeometry} geometry3js 
 * @param {object}[options]
 * @param {object}[options.angleEpsilon=1] in degrees
 * @param {object}[options.removeCoplanar=true] 
 * @return {THREE.BufferGeometry} 
 */

function toOutlineGeometry3js(geometry3js) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _THREE = THREE;
  var Vector3 = _THREE.Vector3,
      BufferGeometry = _THREE.BufferGeometry,
      BufferAttribute = _THREE.BufferAttribute,
      MathUtils = _THREE.MathUtils;
  var angleEpsilon = options.angleEpsilon == undefined ? 1 : options.angleEpsilon;
  angleEpsilon = MathUtils.DEG2RAD * angleEpsilon;
  var removeCoplanar = options.removeCoplanar == undefined ? true : options.removeCoplanar;
  var geometry = geometry3js;
  var position = geometry.getAttribute('position');
  var indices = genGeometryIndicesAll(geometry);
  var A = new Vector3();
  var B = new Vector3();
  var C = new Vector3();
  var newVertices = [],
      newVertexMap = new Map();
  var edges = [],
      edgeMap = new Map();
  /**
   * 
   * @param {THREE.Vector3} v 
   */

  function addVertex(v) {
    var key = [v.x, v.y, v.z].join(',');
    var index = newVertexMap.get(key);

    if (index == undefined) {
      index = newVertices.length;
      newVertexMap.set(key, index);
      newVertices.push(v.clone());
    }

    return index;
  }

  function pushEdge(edge, triangle) {
    var edgeCopy = edge.slice();
    edgeCopy.sort(function (a, b) {
      return a - b;
    });
    var key = edgeCopy.join(',');
    var edgeUnique = edgeMap.get(key);

    if (!edgeUnique) {
      edgeUnique = {
        edge: edgeCopy,
        triangles: []
      };
      edges.push(edgeUnique);
      edgeMap.set(key, edgeUnique);
    }

    edgeUnique.triangles.push(triangle);
  }
  /**
   *  
   * @param {THREE.Vector3} a 
   * @param {THREE.Vector3} b 
   * @param {THREE.Vector3} c 
   */


  function pushTriangle(a, b, c) {
    a = addVertex(a);
    b = addVertex(b);
    c = addVertex(c);
    var triangle = {
      a: a,
      b: b,
      c: c
    };
    pushEdge([a, b], triangle);
    pushEdge([b, c], triangle);
    pushEdge([c, a], triangle);
  }

  function getVertex(V, v) {
    V.fromBufferAttribute(position, v);
  }

  for (var i = 0; i < indices.length; i += 3) {
    var a = indices[i],
        b = indices[i + 1],
        c = indices[i + 2];
    getVertex(A, a);
    getVertex(B, b);
    getVertex(C, c);
    pushTriangle(A, B, C);
  }

  var polygon = [];
  var N = new Vector3();

  for (var _i13 = 0; _i13 < edges.length; _i13++) {
    var edgeUnique = edges[_i13];
    var triangles = edgeUnique.triangles;

    if (triangles.length > 1) {
      var isCoplanar = true;

      if (removeCoplanar) {
        triangles.forEach(function (triangle) {
          if (triangle.normal) return;
          var a = triangle.a,
              b = triangle.b,
              c = triangle.c;
          a = newVertices[a];
          b = newVertices[b];
          c = newVertices[c];
          computeNormal(a, b, c, N, false);
          triangle.normal = N.clone();
        });
        var N0 = triangles[0].normal;

        for (var j = 1; j < triangles.length; j++) {
          var triangle = triangles[j];
          var angle = N0.angleTo(triangle.normal);

          if (angle > angleEpsilon) {
            isCoplanar = false;
            break;
          }
        }
      }

      if (isCoplanar) {
        continue;
      }
    }

    polygon.push(edgeUnique.edge[0], edgeUnique.edge[1]);
  }

  position = [];
  polygon.forEach(function (id) {
    var v = newVertices[id];
    position.push(v.x, v.y, v.z);
  });
  var geometry = new BufferGeometry();
  position = new BufferAttribute(new Float32Array(position), 3, false);
  geometry.setAttribute('position', position);
  edges.length = 0;
  edgeMap.clear();
  newVertices.length = 0;
  newVertexMap.clear();
  polygon.length = 0;
  return geometry;
}

GeometryUtils.toOutlineGeometry3js = toOutlineGeometry3js;
var _default = GeometryUtils;
exports["default"] = _default;

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * @constructor
 */
function IEffect() {
  /**
   * @type {(THREE.Mesh|THREE.Points|THREE.Line)[]}
   */
  this.selected = [];
}

;
Object.assign(IEffect.prototype, {
  isIEffect: true,
  preUpdate: function preUpdate(scene, camera3js, frameState, currentWebglRenderState) {
    console.warn('IEffect.preRender not implemeted');
  },
  postUpdate: function postUpdate(scene, camera3js, frameState, currentWebglRenderState) {
    console.warn('IEffect.postRender not implemeted');
  }
});
var _default = IEffect;
exports["default"] = _default;

},{}],4:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _MeshVisualizer = _interopRequireDefault(require("._7"));

var IRenderable = /*#__PURE__*/function () {
  function IRenderable() {
    (0, _classCallCheck2["default"])(this, IRenderable);
    this.isIRenderable = true;
    /**
     * @type {MeshVisualizer}
     */

    this.visualizer = null;
  }
  /**
   * 
   * @param {MeshVisualizer} visualizer 
   */


  (0, _createClass2["default"])(IRenderable, [{
    key: "onRemoved",
    value: function onRemoved(visualizer) {}
    /**
    * 
    * @param {MeshVisualizer} visualizer 
    */

  }, {
    key: "onAdded",
    value: function onAdded(visualizer) {}
    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @param {(Object3D|THREE.Object3D)[]} renderList 
     */

  }, {
    key: "render",
    value: function render(frameState, renderList) {
      throw new Error('IRenderable.render not implemented.');
    }
  }]);
  return IRenderable;
}();

exports["default"] = IRenderable;

},{"._7":5,"e_1":235,"s_2":236,"M_0":241}],5:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _RendererUtils = _interopRequireDefault(require("o_9"));

var _WebGLRenderer = _interopRequireDefault(require("m_10"));

var _TextureUtils = _interopRequireDefault(require("M_11"));

var _CameraUtils = _interopRequireDefault(require("e_12"));

var _WebGLRenderItem = _interopRequireDefault(require("s_13"));

var _WebGLRenderStates = _interopRequireDefault(require("h_14"));

var _WebGLRenderState = _interopRequireDefault(require("-_15"));

var _WebGLRenderItems = _interopRequireDefault(require("3_16"));

var _WebGLGeometries = _interopRequireDefault(require("D_17"));

var _WebGLLights = _interopRequireDefault(require("._18"));

var _IEffect = _interopRequireDefault(require("C_19"));

var _IRenderable = _interopRequireDefault(require("o_20"));

var _polyfill = _interopRequireDefault(require("h_3"));

//Cesium classes
var Matrix4;
var Matrix3;
var Matrix2;
var defaultValue;
var defined;
var Texture;
var PixelFormat;
var PixelDatatype;
var Cartesian3;
var Color;
var Ray;
var Transforms;
var Event;
var CubeMap;
var PrimitiveType;
var Intersect, BoundingSphere;
var Renderbuffer, Framebuffer, RenderbufferFormat; //

var world2localMatrix;
var surfacePointLocal;
var rayDir;
var pos;
var rayOriginLocal;
var scratchRay;
var constantsHasInit$2 = false;

var _projScreenMatrix, _vector3;

function initConstants$2() {
  if (constantsHasInit$2) return;
  constantsHasInit$2 = true;
  var _Cesium = Cesium;
  Matrix4 = _Cesium.Matrix4;
  Matrix3 = _Cesium.Matrix3;
  Matrix2 = _Cesium.Matrix2;
  defaultValue = _Cesium.defaultValue;
  defined = _Cesium.defined;
  Texture = _Cesium.Texture;
  PixelFormat = _Cesium.PixelFormat;
  PixelDatatype = _Cesium.PixelDatatype;
  Cartesian3 = _Cesium.Cartesian3;
  Color = _Cesium.Color;
  Ray = _Cesium.Ray;
  Transforms = _Cesium.Transforms;
  Event = _Cesium.Event;
  PrimitiveType = _Cesium.PrimitiveType;
  CubeMap = Cesium.CubeMap;
  Renderbuffer = _Cesium.Renderbuffer;
  Framebuffer = _Cesium.Framebuffer;
  RenderbufferFormat = _Cesium.RenderbufferFormat;
  Intersect = _Cesium.Intersect;
  BoundingSphere = _Cesium.BoundingSphere;
  (0, _polyfill["default"])();
  world2localMatrix = new Matrix4();
  surfacePointLocal = new Cartesian3();
  rayDir = new Cartesian3();
  pos = new Cartesian3();
  rayOriginLocal = new Cartesian3();
  scratchRay = new Ray();
  _projScreenMatrix = new Matrix4();
  _vector3 = new Cartesian3();
}

function endFrame(object) {
  var material = object.material;
  object.needsUpdate = false;
  object.modelMatrixNeedsUpdate = false;

  if (object.instances) {
    object.instances.forEach(function (instance) {
      instance.modelMatrixNeedsUpdate = false;
    });
  }

  if (material.needsUpdate == true) material.needsUpdate = false;
}
/**
*
*
*@param {Object}options
*@param {Cesium.Matrix4}[options.modelMatrix=Cesium.Matrix4.IDENTITY]
*@param {Cesium.Cartesian3}[options.position=Cesium.Cartesian3.ZERO] eastNorthUpToFixedFrame
*@param {Boolean}[options.show=true]
* 
*@constructor 
*@extends Cesium.Primitive
*/


function MeshVisualizer(options) {
  initConstants$2();
  options = options || {};

  if (!options.modelMatrix && options.position) {
    options.modelMatrix = Transforms.eastNorthUpToFixedFrame(options.position);
  }

  var scope = this; // Object3D.call(scope, options);

  scope._modelMatrix = options.modelMatrix ? options.modelMatrix : Matrix4.IDENTITY.clone();
  scope._children = [];
  scope.isMeshVisualizer = true;
  scope._actualModelMatrix = Matrix4.clone(scope._modelMatrix);
  scope._actualModelMatrixYup = new Matrix4();
  scope._actualModelMatrixXup = new Matrix4();
  scope._actualModelMatrixInverse = new Matrix4();
  scope._actualModelMatrixYupInverse = new Matrix4();
  scope._actualModelMatrixXupInverse = new Matrix4();
  scope._modelMatrixNeedsUpdate = true;
  scope._ready = true;
  scope._isWireframe = false;
  scope._debug = false;
  scope._show = defaultValue(options.show, true);
  scope._center = Matrix4.getTranslation(scope._modelMatrix, new Cartesian3());
  scope._textureCache = {}; // scope._uniformMaps = new WeakMap();
  //for picking and postprocessing

  scope._pickIds = [];
  scope.beforeUpdate = new Event();
  scope.afterUpdate = new Event();
  scope.beforeDestroy = new Event();
  scope._scene = options.scene;
  scope.optimizeCommandInit = defaultValue(options.optimizeCommandInit, false);
  scope.optimizeInitCount = defaultValue(options.optimizeInitCount, 10); //   

  var _THREE = THREE;
  scope._defaultAmbientLight = new _THREE.AmbientLight('white', 1.);
  var sunLight = new _THREE.DirectionalLight(Color.WHITE.clone(), 2);
  sunLight.castShadow = true;
  sunLight.name = 'sunLight';
  scope._sunLight = sunLight;
  this.sunLightShadowRange = options.sunLightShadowRange || 500;
  this.sunLightShadowFar = options.sunLightShadowFar || 10000;
  this.sunLightShadowSize = options.sunLightShadowSize || 2048;
  scope._sunPositionLC = new Cartesian3();
  scope._sunTargetPositionLC = new Cartesian3();
  scope._sunTargetPositionWC = new Cartesian3();
  scope._sunDirectionLC = new Cartesian3();
  scope.useSunLight = defaultValue(options.useSunLight, false); // scope.occlusionCulling = new OcclusionCulling()
  //for threejs 

  scope.renderer = new _WebGLRenderer["default"](scope);
  scope._lights = new _WebGLLights["default"]();
  scope.maxChangingCount = 10;
  scope.useEncodedPosition = defaultValue(options.useEncodedPosition, false);
  scope.defaultTexture = null;
  scope.defaultCubeMap = null;
  scope.defaultShadowMap = null;
  scope._environment = null;
  scope._environmentChanged = false;
  scope.environment = options.environment;
  scope._backgroundMesh = null;
  scope._background = null;
  scope._backgroundSize = 1;
  scope.backgroundIsSkybox = false;
  scope.backgroundVisibleDistance = 1e4;
  /**
   * @type {IEffect[]}
   */

  scope.effects = [];
  /**
   * @type {THREE.PointLight[]}
   */

  scope.fixedLights = [];
  /**
   * @type {THREE.PointLight[]}
   */

  scope.partialLights = [];
  scope._fixedWebGLLights = new _WebGLLights["default"]();
  scope._partialWebGLLights = new _WebGLLights["default"]();
  scope._minRange = defaultValue(options.minRange, 8);
  scope.isMoonVisible = defaultValue(options.isMoonVisible, true);
  scope.isSunVisible = defaultValue(options.isSunVisible, true);
  scope.initBackground();
  scope.updateModelMatrix();
} //MeshVisualizer方法


MeshVisualizer.prototype = {
  //公开接口

  /**
   * 
   * @param {Cesium.FrameState|Cesium.Scene} frameState 
   * @public
   */
  init: function init(frameState) {
    var _this = this;

    frameState = frameState.frameState || frameState;
    this.renderer.init(frameState);

    if (!this._scene) {
      this._scene = frameState.camera._scene;
    }

    if (!this._onCameraChanged) {
      var timer = null;

      this._onCameraChanged = function () {
        _this._cameraChanged = true;
        if (timer) timer = clearTimeout(timer);
        timer = setTimeout(function () {
          _this._cameraChanged = false;
        }, 2000);
      };

      frameState.camera.changed.addEventListener(this._onCameraChanged);
    }

    if (!this.frameState) this._frameState = frameState;

    if (!this.defaultTextureImage) {
      var cv = document.createElement("canvas");
      this.defaultTextureImage = cv;
      cv.width = 2;
      cv.height = 2;
      var ctx = cv.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, 2, 2);
    }

    if (!this.defaultCubeMap) {
      var defaultTextureImage = this.defaultTextureImage;

      if (!defaultTextureImage) {
        defaultTextureImage = document.createElement("canvas");
        defaultTextureImage.width = 2;
        defaultTextureImage.height = 2;
        this.defaultTextureImage = defaultTextureImage;
      }

      this.defaultCubeMap = new CubeMap({
        context: frameState.context,
        source: {
          positiveX: defaultTextureImage,
          negativeX: defaultTextureImage,
          positiveY: defaultTextureImage,
          negativeY: defaultTextureImage,
          positiveZ: defaultTextureImage,
          negativeZ: defaultTextureImage
        }
      });
    }

    if (!this.defaultTexture) {
      this.defaultTexture = new Texture({
        context: frameState.context,
        source: this.defaultTextureImage
      });
    }

    if (this.defaultShadowMap == null) {
      var cv = document.createElement('canvas');
      cv.width = 256;
      cv.height = 256;
      this.defaultShadowMap = new Texture({
        context: frameState.context,
        source: cv
      });
    }

    if (!this.defaultFramebuffer) {
      var width = 256,
          height = 256,
          context = frameState.context;
      var colorTexture = new Texture({
        context: context,
        width: width,
        height: height
      });
      var depthRenderbuffer = new Renderbuffer({
        context: context,
        width: width,
        height: height,
        format: 33189
      });
      this.defaultFramebuffer = new Framebuffer({
        context: context,
        colorTextures: [colorTexture],
        depthRenderbuffer: depthRenderbuffer
      });
    }

    this.initBackground();
    this.updateEnvironment();
  },
  initBackground: function initBackground() {
    if (typeof THREE != 'undefined' && !this._backgroundMesh) {
      var _THREE = THREE;
      var renderer = this.renderer;
      var defaultTextureImage = this.defaultTextureImage;

      if (!defaultTextureImage) {
        defaultTextureImage = document.createElement("canvas");
        defaultTextureImage.width = 2;
        defaultTextureImage.height = 2;
        this.defaultTextureImage = defaultTextureImage;
      }

      var backgroundMesh = new _THREE.Mesh(new _THREE.BoxBufferGeometry(2, 2, 2), new _THREE.ShaderMaterial({
        name: 'BackgroundCubeMaterial',
        uniforms: _THREE.UniformsUtils.clone(_THREE.ShaderLib.cube.uniforms),
        vertexShader: _THREE.ShaderLib.cube.vertexShader,
        fragmentShader: _THREE.ShaderLib.cube.fragmentShader,
        side: 1,
        depthTest: false,
        depthWrite: false,
        fog: false
      }));
      backgroundMesh.geometry.deleteAttribute('normal');
      backgroundMesh.geometry.deleteAttribute('uv');
      backgroundMesh.pass = 0;
      backgroundMesh.frustumCulled = false;
      Object.defineProperty(backgroundMesh.material, 'envMap', {
        get: function get() {
          return this.uniforms.envMap.value;
        },
        set: function set(background) {
          if (background) {
            background = renderer._cubemaps.get(background);
            this.uniforms.envMap.value = background;
            this.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
          }
        }
      });
      backgroundMesh.material.uniforms.flipEnvMap.value = 1;
      var background = this.background || new _THREE.CubeTexture([this.defaultTextureImage, this.defaultTextureImage, this.defaultTextureImage, this.defaultTextureImage, this.defaultTextureImage, this.defaultTextureImage]);
      backgroundMesh.material.uniforms.envMap.value = background;
      backgroundMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      backgroundMesh.scale.setScalar(this._backgroundSize);
      backgroundMesh.visible = !!this.background;
      this._backgroundMesh = backgroundMesh;
      this._background = null;
    }
  },
  updateEnvironment: function updateEnvironment(frameState) {
    var _this2 = this;

    frameState = frameState || this._frameState;

    if (!frameState) {
      console.warn('frameState  is required,this function will be called in the next frame');
      return;
    }

    ;

    if (this._environmentChanged && this._environment && this._environment.isTexture) {
      var uuid = this._environment.uuid;
      var envMap = this._textureCache[uuid];

      if (!envMap) {
        var texUniform = _TextureUtils["default"].fromTexure3js(this._environment); //, texUniform);


        var createNew = false;

        if (this._environment.isCubeTexture) {
          envMap = _TextureUtils["default"].createCubeTexture(texUniform, frameState.context);
          createNew = true;
        } else if (!texUniform.isEmptyTextureUniform) {
          texUniform.target = 3553;
          envMap = _TextureUtils["default"].createTexture(texUniform, frameState.context);
          createNew = true;
        }

        if (createNew) {
          texUniform.onDispose(function () {
            if (!envMap.isDestroyed()) envMap.destroy();
            delete _this2._textureCache[uuid];
          });
          envMap.__createByVisualizer = true;
          this._textureCache[uuid] = envMap;
        }
      }
    }
  },

  /**
  * 
  *@param {IRenderable|THREE.Object3D}object
  */
  add: function add(object) {
    object.visualizer = this;

    this._children.push(object);

    if (object.isIRenderable) {
      object.onAdded(this);
    }
  },

  /**
   * 移除mesh，释放由MeshVisualizer创建的内部资源
   * @param {THREE.Object3D|IRenderable}object
   * @param {boolean}dispose
   * @public
   */
  remove: function remove(object, dispose) {
    var _this3 = this;

    var _Cesium2 = Cesium,
        Pass = _Cesium2.Pass,
        destroyObject = _Cesium2.destroyObject;

    for (var i = 0; i < this._children.length; i++) {
      if (this._children[i] == object) {
        this._children.splice(i, 1);
      }
    } //release drawCommands & pickIds


    traverseObject3D(object, function (object) {
      if (object.isObject3D) {
        var geometry = object.geometry,
            material = object.material;

        if (material && geometry) {
          if (dispose) {
            var materials = Array.isArray(material) ? material : [material];
            materials.forEach(function (material) {
              return material.dispose();
            });
            geometry.dispose();
            object.dispatchEvent({
              type: 'dispose'
            }, object);
          } else {
            _this3.renderer._cesiumVertextArrays["delete"](geometry);
          }
        }
      } else {
        if (dispose && object.isRuntimeMesh) {
          object.destroy && object.destroy();
        }

        if (object.renderItems) {
          var renderItems = Array.isArray(object.renderItems) ? object.renderItems : [object.renderItems];
          renderItems.forEach(function (renderItem) {
            if (renderItem.destroy) renderItem.destroy();
            renderItem.material = null;
          });
          delete object.renderItems;
        }
      }

      if (object.pickId || object.pickObject) {
        var pickId = object.pickId || object.pickObject.pickId;

        if (pickId) {
          var _i = _this3._pickIds.indexOf(pickId);

          if (_i >= 0) {
            _this3._pickIds.splice(_i, 1);
          }

          delete object.pickId;
          pickId.destroy && pickId.destroy();
        }

        if (object.pickObject) {
          delete object.pickObject.pickId;
          delete object.pickObject;
        }
      }
    }); //remove drawCommands 

    var cesiumScene = this._scene;
    var frustumCommandsList = cesiumScene._view.frustumCommandsList;
    var passes = [0, 7, 8, 4];
    frustumCommandsList.forEach(function (frustumCommands) {
      passes.forEach(function (pass) {
        var commandList = frustumCommands.commands[pass];
        var newCommandList = [];
        commandList.forEach(function (command) {
          if (command.isDestroyed && command.isDestroyed()) {
            return;
          }

          if (!command.vertexArray.isDestroyed()) newCommandList.push(command);
        });
        commandList.length = 0;
        newCommandList.forEach(function (command) {
          commandList.push(command);
        });
      });
    }); //Destroy released shaders and textures

    cesiumScene._shaderFrameCount = 199;

    if (object.isIRenderable) {
      object.onRemoved(this);
    }
  },

  /**
  *
  *拾取点，用局部坐标系表达。内部使用Cesium.Scene.pickPosition和MeshVisualizer.worldCoordinatesToLocal实现。
  * @param {Cesium.Cartesian2}windowPosition
  * @param {Cesium.Cartesian3}[result]
  * @return {Cesium.Cartesian3}
  * @public
  */
  pickPosition: function pickPosition(windowPosition, result) {
    if (!this._scene) {
      return undefined;
    }

    surfacePointLocal = this._scene.pickPosition(windowPosition, surfacePointLocal);

    if (!surfacePointLocal) {
      return undefined;
    }

    this.worldCoordinatesToLocal(surfacePointLocal, surfacePointLocal);
    Cartesian3.clone(surfacePointLocal, result);
    return result;
  },

  /**
  *
  *创建一条射线，用局部坐标系表达
  * @param {Cesium.Cartesian2}windowPosition
  * @param {Cesium.Ray}[result]
  * @param {Cesium.Cartesian3}[up]
  * @return {Cesium.Ray}
  * @public
  */
  getPickRay: function getPickRay(windowPosition, result, up) {
    if (!this._scene) {
      return undefined;
    }

    var _Cesium3 = Cesium,
        Cartesian3 = _Cesium3.Cartesian3,
        Ray = _Cesium3.Ray;

    if (!result) {
      result = Ray();
    }

    this._scene.camera.getPickRay(windowPosition, scratchRay); //ray用于计算小球发射点位置，这里射线的起始点是世界坐标，不能像Threejs那样直接拿来计算，需要转成局部坐标


    surfacePointLocal = this._scene.pickPosition(windowPosition, surfacePointLocal); //射线和局部场景的交点

    if (!surfacePointLocal) {
      return undefined;
    }

    Cartesian3.clone(scratchRay.direction, rayDir); //世界坐标转局部坐标

    this.worldCoordinatesToLocal(scratchRay.origin, rayOriginLocal, up);
    this.worldCoordinatesToLocal(surfacePointLocal, surfacePointLocal, up);
    Cartesian3.add(rayOriginLocal, rayDir, pos); //计算发射方向

    Cartesian3.subtract(surfacePointLocal, pos, rayDir);
    Cartesian3.clone(surfacePointLocal, result.origin);
    Cartesian3.clone(rayDir, result.direction);
    return result;
  },

  /**
  *世界坐标到局部坐标
  * @param {Cesium.Cartesian3}worldCoordinates
  * @param {Cesium.Cartesian3}[result]
  * @param {Cesium.Cartesian3}[up]
  * @return {Cesium.Cartesian3}
  * @public
  */
  worldCoordinatesToLocal: function worldCoordinatesToLocal(worldCoordinates, result, up) {
    if (!result) {
      result = new Cartesian3();
    }

    var modelMatrix = this._actualModelMatrix;

    if (up) {
      if (up.y) {
        //y up
        modelMatrix = this._actualModelMatrixYup;
      } else if (up.x) {
        modelMatrix = this._actualModelMatrixXup;
      }
    }

    Matrix4.inverseTransformation(modelMatrix, world2localMatrix);
    Matrix4.multiplyByPoint(world2localMatrix, worldCoordinates, result);
    return result;
  },

  /**
   *局部坐标到世界坐标
  * @param {Cesium.Cartesian3}localCoordinates
  * @param {Cesium.Cartesian3}[result]
  * @param {Cesium.Cartesian3}[up]
  * @return {Cesium.Cartesian3}
  * @public
  */
  localToWorldCoordinates: function localToWorldCoordinates(localCoordinates, result, up) {
    if (!result) {
      result = new Cartesian3();
    }

    var modelMatrix = this._actualModelMatrix;

    if (up) {
      if (up.y) {
        //y up
        modelMatrix = this._actualModelMatrixYup;
      } else if (up.x) {
        modelMatrix = this._actualModelMatrixXup;
      }
    }

    Matrix4.multiplyByPoint(modelMatrix, localCoordinates, result);
    return result;
  },
  //私有方法

  /**
   * 
   * @private
   */
  computeModelMatrix: function computeModelMatrix(object) {
    var needsUpdate = object.modelMatrixNeedsUpdate;

    if (needsUpdate) {
      var matrixWorld = object.matrixWorld.elements;
      var modelMatrix = object.modelMatrix;
      var scope = this;

      if (object.up.y) {
        //y up
        Matrix4.multiply(scope._actualModelMatrixYup, matrixWorld, modelMatrix);
      } else if (object.up.x) {
        Matrix4.multiply(scope._actualModelMatrixXup, matrixWorld, modelMatrix);
      } else {
        //z up
        Matrix4.multiply(scope._actualModelMatrix, matrixWorld, modelMatrix);
      }

      if (object.forward && object.forward.z) {
        // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.
        Matrix4.multiplyTransformation(modelMatrix, Cesium.Axis.Z_UP_TO_X_UP, modelMatrix);
      }
    }
  },

  /**
   * @private
   */
  updateModelMatrix: function updateModelMatrix() {
    var scope = this;
    var actualModelMatrix = scope._actualModelMatrix;
    var actualModelMatrixYup = scope._actualModelMatrixYup;
    var actualModelMatrixXup = scope._actualModelMatrixXup; //z up
    // Matrix4.multiply(scope.modelMatrix, scope.matrixWorld, actualModelMatrix);

    Matrix4.clone(scope.modelMatrix, actualModelMatrix); //y up

    _RendererUtils["default"].yUp2Zup(actualModelMatrix, actualModelMatrixYup); //x up


    Matrix4.multiplyTransformation(actualModelMatrix, Cesium.Axis.X_UP_TO_Z_UP, actualModelMatrixXup); //z up

    Matrix4.inverse(actualModelMatrix, scope._actualModelMatrixInverse); //y up

    Matrix4.inverse(actualModelMatrixYup, scope._actualModelMatrixYupInverse); //x up

    Matrix4.inverse(actualModelMatrixXup, scope._actualModelMatrixXupInverse);
    Matrix4.getTranslation(actualModelMatrix, scope._center);
  },
  //实现Cesium Primitive接口 

  /**
   * 
   * @param {THREE.Object3D} object 
   * @param {Cesium.FrameState} frameState 
   * @param {boolean} cameraChanged 
   * @private
   */
  computeObjectVisibility: function computeObjectVisibility(object, frameState, cameraChanged) {
    var _Intersect = Intersect,
        INSIDE = 1,
        OUTSIDE = -1,
        INTERSECTING = 0;

    if (object.frustumCulled == false) {
      if (object.isCustomInstancedMesh) {
        var availableInstances = object._availableInstances || [];
        object._availableInstances = availableInstances;
        availableInstances.length = 0;
        object.instances.forEach(function (instance) {
          availableInstances.push(instance);
        });
      }

      object.mvis_visibility = INTERSECTING;
      return;
    } else if (object.isInstancedMesh || !object.geometry) {
      debugger;
      return;
    }

    var modelMatrixNeedsUpdate = object.modelMatrixNeedsUpdate;
    if (!modelMatrixNeedsUpdate && !cameraChanged) return;
    var camera = frameState.camera,
        cullingVolume = frameState.cullingVolume;

    var geometry = _WebGLGeometries["default"].get(object.geometry);

    var boundingSphere = geometry.boundingSphere;
    var boundingVolume = geometry.boundingVolume;

    if (object.isCustomInstancedMesh) {
      var instances = object.instances;

      var _availableInstances = object._availableInstances || [];

      object._availableInstances = _availableInstances;
      _availableInstances.length = 0;
      instances.forEach(function (instance) {
        if (!instance.show) return;
        var insBs = instance.boundingSphere;
        insBs.radius = boundingSphere.radius * instance.scale;
        var modelMatrixNeedsUpdate = instance.modelMatrixNeedsUpdate;

        if (modelMatrixNeedsUpdate) {
          Matrix4.getTranslation(instance.modelMatrix, insBs.center);
        }

        instance.mvis_distanceToCamera = camera.distanceToBoundingSphere(insBs);
        instance.mvis_visibility = INSIDE;

        if (object.maxVisibleDistance && instance.mvis_distanceToCamera > object.maxVisibleDistance) {
          instance.mvis_visibility = OUTSIDE;
          return;
        }

        instance.mvis_visibility = cullingVolume.computeVisibility(insBs);

        if (instance.mvis_visibility != OUTSIDE) {
          _availableInstances.push(instance);
        }
      });
    } else {
      if (modelMatrixNeedsUpdate) {
        var modelMatrix = object.modelMatrix;
        Matrix4.multiplyByPoint(modelMatrix, boundingSphere.center, boundingVolume.center);
        boundingVolume.radius = boundingSphere.radius * Matrix4.getMaximumScale(object.modelMatrix);
      }

      object.mvis_distanceToCamera = camera.distanceToBoundingSphere(boundingVolume);
      object.mvis_visibility = INSIDE;

      var range = _RendererUtils["default"].computeRange(object.mvis_distanceToCamera, boundingVolume.radius, frameState);

      if (range < this.minRange) {
        object.mvis_visibility = OUTSIDE;
      } else if (object.maxVisibleDistance && object.mvis_distanceToCamera > object.maxVisibleDistance) {
        object.mvis_visibility = OUTSIDE;
      }

      if (object.mvis_visibility != OUTSIDE) {
        object.mvis_visibility = cullingVolume.computeVisibility(boundingVolume);
      }
    }
  },

  /**
   * 
   * @param {WebGLRenderItem} renderItem 
   * @param {Cesium.FrameState} frameState  
   * @private
   */
  isRenderItemVisible: function isRenderItemVisible(renderItem, frameState) {
    if (!renderItem.frustumCulled) return true;
    var boundingVolume = renderItem.boundingVolume;
    var distanceToCamera = // renderItem.z;
    frameState.camera.distanceToBoundingSphere(boundingVolume);

    var range = _RendererUtils["default"].computeRange(distanceToCamera, boundingVolume.radius, frameState);

    renderItem.distanceToCamera = distanceToCamera;

    if (range < this.minRange) {
      return false;
    }

    if (renderItem.object.mvis_visibility == 0) {
      var visibility = frameState.cullingVolume.computeVisibility(boundingVolume);

      if (visibility == -1) {
        return false;
      }
    }

    return true;
  },

  /**
   * 
   * @param {THREE.Light} light 
   * @param {Cesium.FrameState} frameState 
   * @private
   */
  isLightVisible: function isLightVisible(light, frameState) {
    var bs = light.boundingSphere;

    if (light.modelMatrixNeedsUpdate || !bs) {
      if (!bs) {
        bs = new BoundingSphere();
        light.boundingSphere = bs;
      }

      Matrix4.getTranslation(light.modelMatrix, bs.center);
      bs.radius = light.distance;
    }

    if (this._cameraChanged || light.modelMatrixNeedsUpdate) {
      light._exVisible = frameState.cullingVolume.computeVisibility(bs) != -1;
    }

    return light._exVisible;
  },

  /**
   * 
   * @param {THREE.Light} light 
   * @param {Cesium.FrameState} frameState 
   * @private
   */
  updateExtensionLight: function updateExtensionLight(light, frameState) {
    if (light.matrixAutoUpdate) {
      light.updateMatrixWorld();
    }

    if (light.modelMatrixNeedsUpdate || !light.boundingSphere) {
      this.computeModelMatrix(light);
    }

    this.isLightVisible(light, frameState);
    light.modelMatrixNeedsUpdate = false;
  },

  /**
   * 
   * @param {THREE.Object3D} object  
   * @param {Cesium.FrameState} frameState 
   * @param {THREE.PerspectiveCamera} camera3jsLocal 
   * @param {WebGLRenderState} currentWebglRenderState
   * @param {THREE.Frustum}[frustum3js]
   * @private
   */
  projectObject: function projectObject(object, frameState, camera3jsLocal, currentWebglRenderState, frustum3js) {
    if (!object.isObject3D) return;
    if (!object.show && !object.visible) return;

    if (object.isGroup || object.isScene) {
      var children = object.children;

      for (var i = 0; i < children.length; i++) {
        this.projectObject(children[i], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
      }
    } else {
      if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera3jsLocal);
      } else if (object.isLight) {
        //light
        if (object.isPointLight) {
          this.updateExtensionLight(object, frameState);
        } else {
          this.computeModelMatrix(object);
        }

        currentWebglRenderState.pushLight(object);

        if (object.target) {
          //更新灯光锁定目标的模型矩阵，来实现改变光照方向
          if (object.target.matrixAutoUpdate) {
            object.target.updateMatrixWorld();
          }

          this.computeModelMatrix(object.target);
        }

        if (object.castShadow) {
          currentWebglRenderState.pushShadow(object);
        }
      } else if (object.isMesh || object.isLine || object.isPoints || object.Sprite) {
        if (!object.isCustomInstancedMesh) this.computeModelMatrix(object); //计算mesh和实例的可见性 

        this.computeObjectVisibility(object, frameState, this._cameraChanged, frustum3js);
        var visible = object.mvis_visibility != -1; // if (visible && frustum3js && object.isRuntimeMesh != true) {
        //     var geometry = WebGLGeometries.get(object.geometry);
        //     var bs = geometry.boundingSphere;
        //     if (!frustum3js.intersectsSphere(bs)) {
        //         visible = false
        //     }
        // }

        if (!visible || frameState.passes.pick && (object.allowPick == false || object.material.allowPick == false)) {
          object.modelMatrixNeedsUpdate = false;
        } else {
          currentWebglRenderState.pushRenderable(object);
        }
      }

      var _children = object.children;

      for (var _i2 = 0; _i2 < _children.length; _i2++) {
        this.projectObject(_children[_i2], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
      }
    }
  },

  /**
   * 
   * @param {Cesium.FrameState} frameState 
   * @param {THREE.PerspectiveCamera} camera3jsLocal 
   * @param {WebGLRenderState} currentRenderState 
   * @private
   */
  updateBackground: function updateBackground(frameState, camera3jsLocal, currentRenderState) {
    var backgroundMesh = this._backgroundMesh;

    if (backgroundMesh && backgroundMesh.visible) {
      if (this.backgroundIsSkybox) {
        backgroundMesh.scale.setScalar(1);
        backgroundMesh.updateMatrixWorld();
        backgroundMesh.matrixWorld.copyPosition(camera3jsLocal.matrixWorld);
        var distance = Cartesian3.distance(frameState.camera.positionWC, this._center);

        if (distance > this.backgroundVisibleDistance) {
          backgroundMesh.material.uniforms.opacity.value = 1.0 - (distance - this.backgroundVisibleDistance) / this.backgroundVisibleDistance;
        } else {
          backgroundMesh.material.uniforms.opacity.value = 1;
        }
      } else {
        backgroundMesh.updateMatrixWorld();
      }

      this.computeModelMatrix(backgroundMesh);

      this.renderer._webglRenderItems.getAndUpdate(backgroundMesh, frameState, false, currentRenderState, camera3jsLocal);
    }
  },

  /**
   * 
   * @param {Cesium.FrameState} frameState 
   * @private
   */
  updateSunLight: function updateSunLight(frameState) {
    if (!this._sunLight) return;
    var scope = this;
    var scene = scope._scene;
    var sunLightCesium = scene.light;
    var sunLight = scope._sunLight;
    var sunLightShadow = sunLight.shadow;
    var shadowCamera = sunLightShadow.camera;
    var shadowState = frameState.shadowState;
    var uniformState = frameState.context.uniformState;
    var sunPositionWC = uniformState._sunPositionWC,
        sunDirectionWC = uniformState._sunDirectionWC,
        sunPositionLC = scope._sunPositionLC,
        sunTargetPositionLC = scope._sunTargetPositionLC,
        sunTargetPositionWC = scope._sunTargetPositionWC,
        sunDirectionLC = scope._sunDirectionLC;
    this.worldCoordinatesToLocal(sunPositionWC, sunPositionLC, {
      y: 1
    });
    Cartesian3.subtract(sunPositionWC, sunDirectionWC, sunTargetPositionWC);
    this.worldCoordinatesToLocal(sunTargetPositionWC, sunTargetPositionLC, {
      y: 1
    });
    Cartesian3.subtract(sunPositionLC, sunTargetPositionLC, sunDirectionLC);
    if (!sunLight) return;
    var sunLightTarget = sunLight.target;
    Color.clone(sunLight.color, sunLightCesium.color);
    sunLight.intensity = sunLightCesium.intensity; //position,direction

    var sunLightShadowFar = this.sunLightShadowFar;
    var sunLightShadowRange = this.sunLightShadowRange;
    var sunLightShadowSize = this.sunLightShadowSize;
    sunLight.position.copy(sunPositionLC).normalize().multiplyScalar(sunLightShadowFar); //shadowState.farPlane)

    sunLight.updateMatrixWorld();
    sunLightTarget.updateMatrixWorld();
    this.computeModelMatrix(sunLight);
    this.computeModelMatrix(sunLightTarget); //shadow,camera

    if (sunLightShadowSize != sunLightShadow.mapSize.x) {
      sunLightShadow.mapSize.set(sunLightShadowSize, sunLightShadowSize);
      sunLightShadow.__mapVersion = 0;
    }

    shadowCamera.left = -sunLightShadowRange;
    shadowCamera.right = sunLightShadowRange;
    shadowCamera.top = sunLightShadowRange;
    shadowCamera.bottom = -sunLightShadowRange;
    shadowCamera.far = sunLightShadowFar * 2; // shadowState.farPlane ;

    shadowCamera.near = 0.1; //shadowState.nearPlane;

    shadowCamera.updateProjectionMatrix();
  },

  /**
   * 
   * @param {THREE.Scene|MeshVisualizer} scene  
   * @param {Cesium.FrameState} frameState 
   * @param {THREE.Camera} camera3jsLocal 
   * @param {WebGLRenderState} currentWebglRenderState
   * @param {THREE.Frustum}[frustum3js]
   * @private
   */
  projectObjects: function projectObjects(scene, frameState, camera3jsLocal, currentWebglRenderState, frustum3js) {
    var _this4 = this;

    var dynamicRenderables = currentWebglRenderState.dynamicRenderables; //level1

    scene.children.forEach(function (object) {
      //IRenderable
      if (typeof object.render == 'function') {
        object.render(frameState, dynamicRenderables, _this4.renderer, camera3jsLocal, currentWebglRenderState);
      }

      if (!object.visible && !object.show) return;

      if (object.isObject3D) {
        if (object.matrixAutoUpdate || object.modelMatrixNeedsUpdate) {
          object.updateMatrixWorld();

          _this4.computeModelMatrix(object);
        }
      }
    }); // this.updateBackground(frameState, camera3jsLocal);
    //

    if (scene.isMeshVisualizer) {
      var _children2 = scene.children;

      for (var i = 0; i < _children2.length; i++) {
        this.projectObject(_children2[i], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
      }
    } else {
      this.projectObject(scene, frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
    }

    if (this.useSunLight && this._sunLight) {
      var sunLight = this._sunLight;
      var children = sunLight.children;

      for (var _i3 = 0; _i3 < children.length; _i3++) {
        this.projectObject(children[_i3], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
      }

      this.projectObject(sunLight.shadow.camera, frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
    }

    for (var _i4 = 0; _i4 < dynamicRenderables.length; _i4++) {
      this.projectObject(dynamicRenderables[_i4], frameState, camera3jsLocal, currentWebglRenderState, frustum3js);
    }
  },

  /**
   *  
   * @param {Cesium.FrameState} frameState 
   * @param {WebGLRenderState} currentRenderState 
   * @param {THREE.Camera}[camera3js]
   * @param {THREE.Frustum}[frustum3js]
   * @private 
   */
  createOrUpdateCommands: function createOrUpdateCommands(frameState, currentRenderState, camera3js, frustum3js) {
    var wireframeChanged = false;
    var sysWireframe = frameState.camera._scene._globe._surface.tileProvider._debug.wireframe;
    if (sysWireframe != this._sysWireframe) wireframeChanged = true;
    this._sysWireframe = sysWireframe;
    var camera = frameState.camera,
        frustum = camera.frustum,
        cameraChanged = this._cameraChanged;
    Matrix4.multiply(frustum.projectionMatrix, camera.viewMatrix, _projScreenMatrix);
    var webGLRenderList = currentRenderState.renderList,
        renderables = currentRenderState.renderables;
    /**
     * @type {WebGLRenderItems}
     */

    var webglRenderItems = this.renderer._webglRenderItems;
    var optimizeInitCount = this.optimizeInitCount,
        optimizeCommandInit = this.optimizeCommandInit;
    var loadingCommands = [];

    for (var i = 0, l = renderables.length; i < l; i++) {
      var object = renderables[i]; //

      if (optimizeCommandInit && loadingCommands.length >= optimizeInitCount) continue; //three.js's object

      var renderItems = webglRenderItems.getAndUpdate(object, frameState, sysWireframe, currentRenderState, camera3js);
      var modelMatrixNeedsUpdate = object.modelMatrixNeedsUpdate || this.modelMatrixNeedsUpdate;
      var visibilityNeedsUpdate = modelMatrixNeedsUpdate || cameraChanged;

      if (renderItems.length == 1) {
        renderItems[0].visible = true;
        visibilityNeedsUpdate = false;
      }

      for (var j = 0, lj = renderItems.length; j < lj; j++) {
        var renderItem = renderItems[j];
        var boundingVolume = renderItem.boundingVolume;
        Matrix4.multiplyByPoint(_projScreenMatrix, boundingVolume.center, _vector3);
        renderItem.z = _vector3.z;
        if (renderItem.material.visible == false) continue;

        if (visibilityNeedsUpdate || renderItem.visible == undefined) {
          renderItem.visible = this.isRenderItemVisible(renderItem, frameState, frustum3js);
        }

        if (renderItem.visible == false) {
          continue;
        } // if (frustum3js) {
        //     if (!frustum3js.intersectsSphere(renderItem.boundingSphere)) {
        //         continue;
        //     }
        // }
        //


        if (!renderItem.loaded) {
          if (optimizeCommandInit && loadingCommands.length >= optimizeInitCount) return;
          loadingCommands.push(renderItem);
          renderItem.loaded = true;
        } //


        if (object == this._backgroundMesh) continue;
        webGLRenderList.push(renderItem);
      }
    }

    webGLRenderList.sort();
  },
  //for shadowMap

  /**
   * 
   * @param {*} scene 
   * @param {*} frameState 
   * @param {*} camera3js  
   * @returns {WebGLRenderState}
   * @private
   */
  getAndUpdateRenderState: function getAndUpdateRenderState(scene, frameState, camera3js, frustum3js) {
    var webglRenderStates = this.renderer._webglRenderStates;
    var currentRenderState = webglRenderStates.get(scene, frameState.camera);
    currentRenderState.init();
    this.updateSunLight(frameState);
    this.updateBackground(frameState, camera3js, currentRenderState);
    this.projectObjects(scene, frameState, camera3js, currentRenderState, frustum3js); // this.createOrUpdateCommands(frameState,  currentRenderState);

    return currentRenderState;
  },

  /**
  *Cesium Primitive接口方法，渲染程序入口，必须实现才能最终渲染到cesium场景
  * @param {Cesium.FrameState}frameState
  * @param {Object3D}[scene]  
  * @param {Cesium.DrawCommand[]}[renderList]
  */
  update: function update(frameState, scene, renderList) {
    var _this5 = this;

    if (frameState.mode !== Cesium.SceneMode.SCENE3D) return;
    this.init(frameState);

    if (!this._ready || !scene && !this.show) {
      //如果未准备好则不加入渲染队列
      return;
    }

    scene = scene || this;
    if (!scene.geometry && scene.children.length == 0) return;
    var isRenderToRenderTarget = !!renderList;
    var currentCamera = frameState.camera;
    this.updateSunLight(frameState);

    if (!isRenderToRenderTarget && frameState.passes.render) {
      this.mainCamera = currentCamera;
      this.beforeUpdate.raiseEvent(frameState);
    }
    /**
     * @type {WebGLRenderer}
     * @private
     */


    var renderer = this.renderer;
    var webgglShadowMap = renderer.shadowMap;
    /**
     * @type {WebGLRenderStates}
     */

    var webglRenderStates = renderer._webglRenderStates;
    var currentWebglRenderState = webglRenderStates.get(scene, currentCamera);
    var currentWebglRenderList = currentWebglRenderState.renderList;
    var backgroundMesh = this._backgroundMesh;
    var commandList = isRenderToRenderTarget ? renderList : frameState.commandList; //

    if (frameState.passes.offscreen || frameState.passes.depth || frameState.passes.pick) {
      if (this.mainCamera) webglRenderStates.get(scene, this.mainCamera).getDrawCommands(commandList, frameState);else currentWebglRenderList.getDrawCommands(commandList, frameState);
      return;
    }

    ;
    currentWebglRenderState.lights = this._lights;
    currentWebglRenderState.init();
    renderer._webglRenderItems.changingState.maxChangingCount = this.maxChangingCount;

    if (this._modelMatrixNeedsUpdate) {
      if (this._backgroundMesh) {
        this._backgroundMesh.modelMatrixNeedsUpdate = true;
      }

      this.updateModelMatrix();
    } //


    var camera3js;
    var referenceFrame = currentCamera._referenceFrame || {
      matrix: this._actualModelMatrixYup,
      inverseMatrix: this._actualModelMatrixYupInverse
    };
    var _localClippingEnabled = false,
        _clippingEnabled = false;
    var clipping = renderer._clipping;

    if (currentCamera.isOrthographicCamera) {
      camera3js = _CameraUtils["default"].toOrthographicCamera3js(currentCamera, null, referenceFrame);
    } else {
      camera3js = _CameraUtils["default"].toPerspectiveCamera3js(currentCamera, null, referenceFrame);
    }

    if (!currentCamera._referenceFrame) camera3js._referenceFrame = referenceFrame;
    _localClippingEnabled = renderer.localClippingEnabled;
    _clippingEnabled = clipping.init(renderer.clippingPlanes, _localClippingEnabled, camera3js);
    currentWebglRenderState.clippingEnabled = _clippingEnabled;
    currentWebglRenderState.localClippingEnabled = _localClippingEnabled; //

    if (!isRenderToRenderTarget && frameState.passes.render) {
      scene.children.forEach(function (object) {
        //IRenderable
        if (object.isIRenderable && object.onBeforeRender) {
          object.onBeforeRender(frameState, _this5.renderer, camera3js, currentWebglRenderState);
        }
      });
    } //


    var frustum3js = isRenderToRenderTarget ? _CameraUtils["default"].getFrustum3js(camera3js) : null;
    this.projectObjects(scene, frameState, camera3js, currentWebglRenderState, frustum3js);
    var dynamicRenderables = currentWebglRenderState.dynamicRenderables;
    var renderables = currentWebglRenderState.renderables;
    var shadowsArray = currentWebglRenderState.shadowsArray;
    var lightsArray = currentWebglRenderState.lightsArray; //onBeforeRender  

    if (_clippingEnabled === true) clipping.beginShadows();
    var camera3js2 = null,
        oldReferenceFrame = currentCamera._referenceFrame;
    if (currentCamera.isOrthographicCamera) camera3js2 = _CameraUtils["default"].toOrthographicCamera3js(currentCamera, null, referenceFrame);else camera3js2 = _CameraUtils["default"].toPerspectiveCamera3js(currentCamera, null, referenceFrame);

    for (var i = 0; i < renderables.length; i++) {
      var _object = renderables[i];

      if (!_object.visible || !_object.onBeforeRender || _object.onBeforeRender == THREE.Object3D.prototype.onBeforeRender) {
        continue;
      }

      var referenceFrame = oldReferenceFrame || {
        matrix: this._actualModelMatrixYup,
        inverseMatrix: this._actualModelMatrixYupInverse
      };
      camera3js2._referenceFrame = referenceFrame;

      _object.onBeforeRender(renderer, scene, camera3js2, this._scene);

      camera3js2._referenceFrame = oldReferenceFrame;
    }

    if (this.useSunLight && this._sunLight) {
      if (this._sunLight.castShadow && !frameState.shadowState.shadowsEnabled) {
        currentWebglRenderState.pushShadow(this._sunLight);
      }
    } //shadowMap 


    if (!webgglShadowMap.enabled) {
      shadowsArray.length = 0;
    }

    if (webgglShadowMap.autoUpdate) {
      webgglShadowMap.render(shadowsArray, scene, frameState, this);
    } //
    //更新灯光  


    if (lightsArray.length == 0) currentWebglRenderState.pushLight(this._defaultAmbientLight);

    if (this.useSunLight && this._sunLight) {
      currentWebglRenderState.pushLight(this._sunLight);
    }

    currentWebglRenderState.setupLights(currentCamera); //light extension:point lights 

    this.fixedLights.forEach(function (light) {
      _this5.updateExtensionLight(light, frameState);
    });
    this.partialLights.forEach(function (light) {
      _this5.updateExtensionLight(light, frameState);
    });

    this._fixedWebGLLights.setup(this.fixedLights, null, currentCamera, frameState);

    this._partialWebGLLights.setup(this.partialLights, null, currentCamera, frameState); //


    if (_clippingEnabled === true) clipping.endShadows(); //

    this.createOrUpdateCommands(frameState, currentWebglRenderState, camera3js, frustum3js); //background

    var backgroundRenderItems;

    if (backgroundMesh) {
      this.updateBackground(frameState, camera3js, currentWebglRenderState);
      backgroundRenderItems = backgroundMesh.renderItems;

      if (!this.backgroundIsSkybox && backgroundRenderItems) {
        currentWebglRenderList.push(backgroundRenderItems[0]);
      }
    }

    currentWebglRenderList.getDrawCommands(commandList, frameState); //effect passes

    for (var _i5 = 0; _i5 < this.effects.length; _i5++) {
      var effect = this.effects[_i5];
      if (!effect.enabled || !effect.preUpdate && !effect.preUpdate) continue;
      if (!effect.name) effect.name = 'effect-' + Cesium.createGuid();
      effect.preUpdate(scene, camera3js, frameState, currentWebglRenderState); //render effect

      var effectSelected = effect.selected ? effect.selected : renderables;

      for (var j = 0; j < effectSelected.length; j++) {
        var _object2 = effectSelected[j];
        if (_object2.isRuntimeMesh) continue;
        var renderItems = _object2.renderItems;

        var geometry = _WebGLGeometries["default"].get(_object2.geometry);

        var objectMaterial = _object2.material;
        var isMultiMaterial = Array.isArray(objectMaterial);

        for (var k = 0; k < renderItems.length; k++) {
          var renderItem = renderItems[k];
          var materialIndex = renderItem.materialIndex;
          var material = isMultiMaterial ? objectMaterial[materialIndex] : objectMaterial;
          if (_object2.onBeforeRender) _object2.onBeforeRender(renderer, scene, camera3js, geometry, material);

          var drawCommand = renderer._webglRenderItems.getAndUpdateDerived(_object2, geometry, material, renderItem, effect.name, frameState, currentWebglRenderState, camera3js);

          if (!drawCommand) continue;
          if (_object2.onAfterRender) _object2.onAfterRender(renderer, scene, camera3js, geometry, material);
          commandList.push(drawCommand);
        }
      }

      if (effect.postUpdate) effect.postUpdate(scene, camera3js, frameState, currentWebglRenderState);
    } // 


    var environmentState = this._scene._environmentState;
    var backgroundIsSkybox = this.backgroundIsSkybox && backgroundMesh && backgroundMesh.visible && backgroundMesh.renderItems; //BeforeFinalRender

    if (isRenderToRenderTarget) {
      if (environmentState.isMoonVisible && this.isMoonVisible) commandList.unshift(environmentState.moonCommand);
      if (environmentState.isSunVisible && this.isSunVisible) commandList.unshift(environmentState.sunDrawCommand);

      if (backgroundIsSkybox) {
        var skyboxCommand = backgroundRenderItems[0].drawCommand;
        commandList.unshift(skyboxCommand);
      }

      if (this.mainCamera != currentCamera) currentWebglRenderState.init();
    } else {
      for (var _i6 = 0; _i6 < renderables.length; _i6++) {
        var object = renderables[_i6];

        if (object.onBeforeFinalRender) {
          object.onBeforeFinalRender(renderer, scene, camera3js2, this._scene);
        }

        endFrame(renderables[_i6]);
      }

      for (var _i7 = 0; _i7 < lightsArray.length; _i7++) {
        lightsArray[_i7].modelMatrixNeedsUpdate = false;
      }

      if (environmentState.skyAtmosphereCommand && backgroundIsSkybox) {
        var skyboxCommand = backgroundRenderItems[0].drawCommand;
        environmentState.isSkyAtmosphereVisible = true;
        if (backgroundMesh.material.uniforms.opacity.value > 0.5) environmentState.skyAtmosphereCommand = skyboxCommand;
      }

      this.afterUpdate.raiseEvent(frameState); //清空渲染对象数组和光影数组

      renderables.length = 0;
      dynamicRenderables.length = 0;
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }

    this._modelMatrixNeedsUpdate = false;
    this.frameNumber = frameState.frameNumber;
    this._environmentChanged = false;
  },

  /**
  *释放资源
  */
  destroy: function destroy() {
    var _this6 = this;

    this.beforeDestroy.raiseEvent(this);
    this._ready = false;
    MeshVisualizer.traverseObject3D(this, function (object) {
      _this6.remove(object);

      object.dispose && object.dispose();
      object.destroy && object.destroy();
    }, false);
    this.renderer.dispose();

    for (var i in this._textureCache) {
      if (this._textureCache.hasOwnProperty(i)) {
        delete this._textureCache[i];
      }
    }

    this._textureCache = {};

    if (this._pickIds) {
      for (i = 0; i < this._pickIds.length; ++i) {
        this._pickIds[i].destroy && this._pickIds[i].destroy();
      }
    }

    this._pickIds.splice(0);
  },
  traverse: function traverse(callback) {
    traverseObject3D(this, callback);
  }
};
/**
*
*遍历节点
*@param {Object3D}root
*@param {MeshVisualizer~TraverseCallback}traverseFunc 访问每个节点时回调该函数，进行相关操作。回调函数包含一个参数，traverseArgs，其中封装了一个属性cancelCurrent，可以通过改变此属性达到终止遍历当前节点的子节点
*@param {Boolean}visibleOnly visibleOnly为true时仅遍历可见的节点，如果父级节点不可见则不再访问其子节点
*@private
*/

MeshVisualizer.traverse = function (node, traverseFunc, visibleOnly, scratchTraverseArgs) {
  if (!node) {
    return;
  }

  if (!scratchTraverseArgs) {
    scratchTraverseArgs = {
      cancelCurrent: false,
      cancelAll: false
    };
  }

  scratchTraverseArgs.cancelCurrent = false;

  if (visibleOnly && !node.show && !node.visible) {
    return;
  } // if (node.isMeshVisModel && !node.visible) return;


  if (!(node instanceof MeshVisualizer) && (node.geometry && node.material || node.isLight || node.isGroup || node.isObject3D || node.isScene)) {
    traverseFunc(node, scratchTraverseArgs);
  } // if (node.isMeshVisModel && node.root) node = node.root;


  var children = node.children;

  if (children) {
    for (var i = 0; i < children.length; i++) {
      if (scratchTraverseArgs.cancelCurrent) {
        continue;
      }

      if (scratchTraverseArgs.cancelAll) {
        break;
      }

      MeshVisualizer.traverse(node.children[i], traverseFunc, visibleOnly, scratchTraverseArgs);
    }
  } else if (node.scene) {
    MeshVisualizer.traverse(node.scene, traverseFunc, visibleOnly, scratchTraverseArgs);
  }
};

function traverseObject3D(node, callback, parent) {
  if (node.length) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      traverseObject3D(child, callback, node);
    }
  } else {
    callback(node, parent);
    var children = node.children;
    if (!children) return;
    var l = children.length;

    for (var _i8 = 0; _i8 < l; _i8++) {
      var _child = children[_i8];
      traverseObject3D(_child, callback, node);
    }
  }
}

MeshVisualizer.prototype.traverseObject3D = traverseObject3D;
/**
*
*@MeshVisualizer~TraverseCallback
*@param {Mesh|LOD|MeshVisualizer|Object}node
*@param {Object}traverseArgs
*@param {Boolean}traverseArgs.cancelCurrent 为true时终止遍历当前节点的子节点
*@param {Boolean}traverseArgs.cancelAll 为true时终止遍历，退出遍历循环
*/
//MeshVisualizer属性

Object.defineProperties(MeshVisualizer.prototype, {
  children: {
    get: function get() {
      return this._children;
    }
  },

  /**
  * @readonly
  * @type {Cesium.Matrix4}
  */
  modelMatrix: {
    get: function get() {
      return this._modelMatrix;
    },
    set: function set(val) {
      if (val) {
        this._modelMatrix = val; // this._matrixWorld.elements = this._modelMatrix
      }
    }
  },
  sunPositionLC: {
    get: function get() {
      return this._sunPositionLC;
    }
  },
  sunDirectionLC: {
    get: function get() {
      return this._sunDirectionLC;
    }
  },
  background: {
    get: function get() {
      return this._background;
    },
    set: function set(background) {
      if (background && background.isColor) return;
      this._background = background;
      var backgroundMesh = this._backgroundMesh;

      if (backgroundMesh) {
        if (background) {
          var material = backgroundMesh.material;

          if (material.envMap != background) {
            material.needsUpdate = true;
          }

          material.envMap = background;
          backgroundMesh.visible = true;
        } else {
          backgroundMesh.visible = false;
        }
      }
    }
  },
  backgroundSize: {
    get: function get() {
      return this._backgroundSize;
    },
    set: function set(backgroundSize) {
      backgroundSize = backgroundSize || 1;
      this._backgroundSize = backgroundSize;
      var backgroundMesh = this._backgroundMesh;

      if (backgroundMesh) {
        backgroundMesh.scale.setScalar(backgroundSize);
      }
    }
  },
  backgroundMesh: {
    get: function get() {
      return this._backgroundMesh;
    }
  },

  /**
   * @type {THREE.CubeTexture}
   * @memberof MeshVisualizer.prototype
   */
  environment: {
    get: function get() {
      return this._environment;
    },
    set: function set(val) {
      var scope = this;
      var environment = scope._environment;

      if (val && val.isTexture) {
        scope._environment = val;
        scope._environmentChanged = true;
      } else if (environment) {
        var uuid = environment.uuid;
        var envMap = scope._textureCache[uuid];

        if (envMap && envMap._createByMeshVisualizer) {
          envMap.destroy();
          delete scope._textureCache[uuid];
        }

        scope._environment = val;
        scope._environmentChanged = true;
      }
    }
  },
  pickIds: {
    get: function get() {
      return this._pickIds;
    }
  },

  /**
   * @type {Cesium.Scene}
   */
  scene: {
    set: function set(val) {
      this._scene = val;
    },
    get: function get() {
      return this._scene;
    }
  },

  /**
   * @type {Cesium.FrameState}
   */
  frameState: {
    get: function get() {
      if (!this._scene) {
        return undefined;
      }

      return this._frameState;
    }
  },

  /**
   * @type {Boolean}
   */
  show: {
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
    }
  },

  /**
   * @type {Boolean}
   */
  ready: {
    get: function get() {
      return this._ready;
    }
  },
  minRange: {
    get: function get() {
      return this._minRange;
    },
    set: function set(val) {
      var scope = this;

      if (scope._minRange != val) {
        scope._minRange = val;
        scope._cameraChanged = true;
        requestAnimationFrame(function () {
          scope._cameraChanged = false;
        });
      }
    }
  }
});
var _default = MeshVisualizer;
exports["default"] = _default;

},{"e_12":1,"C_19":3,"o_20":4,"o_9":6,"h_3":7,"M_11":17,"D_17":22,"._18":23,"s_13":29,"3_16":30,"-_15":32,"h_14":33,"m_10":35,"M_0":241}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var yUpToZUp, scratchTranslation, scratchQuaternion, scratchScale, scratchTranslationQuaternionRotationScale, clearCommandScratch;
/**
*
*@constructor
*@memberof Cesium
*/

function RendererUtils() {}
/**
 *  
 *  
 * @param {number} distanceToCamera  
 * @param {number} radius  
 * @param {Cesium.FrameState} frameState  
 * @param {number} [progressiveResolutionHeightFraction]  
 * @returns {Number} range:in pixels
 */


RendererUtils.computeRange = function (distanceToCamera, radius, frameState, progressiveResolutionHeightFraction) {
  var _Cesium = Cesium;

  var heightFraction = _Cesium.defaultValue(progressiveResolutionHeightFraction, 1.0);

  var camera = frameState.camera;
  var context = frameState.context;
  var height = context.drawingBufferHeight * heightFraction;
  var distance = Math.max(distanceToCamera, _Cesium.Math.EPSILON7);
  var sseDenominator = camera.frustum.sseDenominator;
  var geometricError = radius;
  var range = geometricError * height / (distance * sseDenominator);
  range /= frameState.pixelRatio;
  return range;
};

var scratchO;
/**
 * @article https://www.iquilezles.org/www/articles/sphereproj/sphereproj.htm
 * @code http://www.shadertoy.com/view/XdBGzd?
 * @param {Cesium.BoundingSphere} sph sphere in world space
 * @param {Cesium.Matrix4} cam camera matrix (world to camera)
 * @param {float} fl projection (focal length) 
 */

RendererUtils.projectSphere = function (sph, cam, fl) {
  var _Cesium = Cesium;
  if (!scratchO) scratchO = new _Cesium.Cartesian4(); // transform to camera space
  // vec3  o = (cam*vec4(sph.xyz,1.0)).xyz; 

  var o = _Cesium.Matrix4.multiplyByPoint(cam, sph.center, scratchO);

  var r2 = sph.radius * sph.radius;
  var z2 = o.z * o.z;

  var l2 = _Cesium.Cartesian3.dot(o, o);

  return -Math.PI * fl * fl * r2 * Math.sqrt(Math.abs((l2 - r2) / (r2 - z2))) / (r2 - z2);
};
/**
*使用帧缓冲技术，执行渲染命令，渲染到纹理  
*@param {Cesium.DrawCommand|Array<Cesium.DrawCommand>}drawCommand 渲染命令（集合）
*@param {Cesium.FrameState}frameState 帧状态对象，可以从Cesium.Scene中获取
*@param {Cesium.Texture}outpuTexture 将渲染到的目标纹理对象
*@param {Cesium.Texture}[outputDepthTexture] 可选，输出的深度纹理
*/


RendererUtils.renderToTexture = function (drawCommand, frameState, outputTexture, outputDepthTexture) {
  var _Cesium2 = Cesium,
      Framebuffer = _Cesium2.Framebuffer,
      Texture = _Cesium2.Texture,
      PixelFormat = _Cesium2.PixelFormat,
      PixelDatatype = _Cesium2.PixelDatatype,
      ClearCommand = _Cesium2.ClearCommand,
      Color = _Cesium2.Color;
  var drawCommands = Array.isArray(drawCommand) ? drawCommand : [drawCommand];
  var context = frameState.context;
  var framebuffer = null,
      destroy = false;

  if (outputTexture instanceof Framebuffer) {
    framebuffer = outputTexture;
  }

  if (!framebuffer) {
    if (!outputDepthTexture || outputDepthTexture.width != outputTexture.width || outputDepthTexture.height != outputTexture.height) {
      outputDepthTexture = new Texture({
        context: context,
        width: outputTexture.width,
        height: outputTexture.height,
        pixelFormat: 6402,
        pixelDatatype: 5123
      });
    }

    framebuffer = new Framebuffer({
      context: context,
      colorTextures: [outputTexture],
      destroyAttachments: false,
      depthTexture: outputDepthTexture
    });
    destroy = true;
  }

  if (!clearCommandScratch) {
    clearCommandScratch = new ClearCommand({
      color: new Color(0.0, 0.0, 0.0, 0.0)
    });
  }

  var clearCommand = clearCommandScratch;
  clearCommand.framebuffer = framebuffer;
  clearCommand.renderState = frameState.renderState;
  clearCommand.execute(context);
  drawCommands.forEach(function (drawCommand) {
    drawCommand.framebuffer = framebuffer;
    drawCommand.execute(context);
  });

  if (destroy) {
    framebuffer.destroy();
  }
};
/**
*使用帧缓冲技术，执行渲染命令，渲染到纹理并读取像素值，可以用于实现并行计算  
*@param {Cesium.DrawCommand|Array<Cesium.DrawCommand>}drawCommand 渲染命令（集合）
*@param {Cesium.FrameState}frameState 帧状态对象，可以从Cesium.Scene中获取
*@param {Cesium.Texture}outpuTexture 将渲染到的目标纹理对象
*@param {Object}[options] 
*@param {Array.<Number>}outputPixels 
*@return {Array.<Number>}outputPixels  输出的像素
*/


RendererUtils.renderToPixels = function (drawCommand, frameState, outputTexture, options, pixels) {
  var _Cesium3 = Cesium,
      Framebuffer = _Cesium3.Framebuffer,
      Texture = _Cesium3.Texture,
      PixelFormat = _Cesium3.PixelFormat,
      PixelDatatype = _Cesium3.PixelDatatype,
      ClearCommand = _Cesium3.ClearCommand,
      Color = _Cesium3.Color;
  var drawCommands = Array.isArray(drawCommand) ? drawCommand : [drawCommand];
  var context = frameState.context;
  var framebuffer = null,
      destroy = false;

  if (outputTexture instanceof Framebuffer) {
    framebuffer = outputTexture;
  }

  if (!framebuffer) {
    var outputDepthTexture = new Texture({
      context: context,
      width: outputTexture.width,
      height: outputTexture.height,
      pixelFormat: 6402,
      pixelDatatype: 5123
    });
    framebuffer = new Framebuffer({
      context: context,
      colorTextures: [outputTexture],
      depthTexture: context.depthTexture ? outputDepthTexture : undefined,
      destroyAttachments: false
    });
    destroy = true;
  }

  if (!clearCommandScratch) {
    clearCommandScratch = new ClearCommand({
      color: new Color(0.0, 0.0, 0.0, 0.0)
    });
  }

  var clearCommand = clearCommandScratch;
  clearCommand.framebuffer = framebuffer;
  clearCommand.renderState = frameState.renderState;
  clearCommand.execute(context);
  drawCommands.forEach(function (drawCommand) {
    drawCommand.framebuffer = framebuffer;
    drawCommand.execute(context);
  });
  options = options ? options : {};
  pixels = RendererUtils.readPixels(frameState, Object.assign(options, {
    framebuffer: framebuffer
  }), pixels);
  delete options.framebuffer;

  if (destroy) {
    framebuffer.destroy();
  }

  return pixels;
};

var scratchBackBufferArray;
/**
 * Validates a framebuffer.
 * Available in debug builds only.
 * @private
 */

function validateFramebuffer(context) {
  //>>includeStart('debug', pragmas.debug);
  if (context.validateFramebuffer) {
    var gl = context._gl;
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    if (status !== gl.FRAMEBUFFER_COMPLETE) {
      var message;

      switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          message = 'Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.';
          break;

        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          message = 'Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.';
          break;

        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          message = 'Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.';
          break;

        case gl.FRAMEBUFFER_UNSUPPORTED:
          message = 'Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.';
          break;
      }

      throw new DeveloperError(message);
    }
  } //>>includeEnd('debug');

}

function bindFramebuffer(context, framebuffer) {
  var _Cesium = Cesium;

  if (framebuffer !== context._currentFramebuffer) {
    // this check must use typeof, not defined, because defined doesn't work with undeclared variables.
    if (typeof WebGLRenderingContext !== 'undefined') {
      scratchBackBufferArray = [1029];
    }

    context._currentFramebuffer = framebuffer;
    var buffers = scratchBackBufferArray;

    if (_Cesium.defined(framebuffer)) {
      framebuffer._bind();

      validateFramebuffer(context); // TODO: Need a way for a command to give what draw buffers are active.

      buffers = framebuffer._getActiveColorAttachments();
    } else {
      var gl = context._gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    if (context.drawBuffers) {
      context.glDrawBuffers(buffers);
    }
  }
} //var pixels;


var scratchPixelFormat;
var scratchPixelDatatype;
/**
 * @param {Cesium.FrameState}frameState
 * @param {Object}[readState]
 * @param {number}readState.x
 * @param {number}readState.y
 * @param {number}readState.width
 * @param {number}readState.height
 * @param {Cesium.PixelDatatype}readState.pixelDatatype
 * @param {Cesium.PixelFormat}readState.pixelFormat
 * @param {Cesium.Framebuffer}[readState.framebuffer]
 * @param {ArrayBufferView}pixels
 * @return {ArrayBufferView}
 */

RendererUtils.readPixels = function (frameState, readState, pixels) {
  var _Cesium4 = Cesium,
      DeveloperError = _Cesium4.DeveloperError,
      Framebuffer = _Cesium4.Framebuffer,
      Texture = _Cesium4.Texture,
      PixelFormat = _Cesium4.PixelFormat,
      PixelDatatype = _Cesium4.PixelDatatype,
      ClearCommand = _Cesium4.ClearCommand,
      Color = _Cesium4.Color;
  var gl = frameState.context._gl;
  readState = readState || {};
  var x = Math.max(readState.x || 0, 0);
  var y = Math.max(readState.y || 0, 0);
  var width = readState.width || gl.drawingBufferWidth;
  var height = readState.height || gl.drawingBufferHeight;
  var pixelDatatype = readState.pixelDatatype || 5121;
  var pixelFormat = readState.pixelFormat || 6408;
  var framebuffer = readState.framebuffer || frameState.frameNumber;

  if (width <= 0) {
    throw new DeveloperError('readState.width must be greater than zero.');
  }

  if (height <= 0) {
    throw new DeveloperError('readState.height must be greater than zero.');
  }

  bindFramebuffer(this, framebuffer);
  var size = 4;

  if (pixelFormat == 6407) {
    size = 3;
  } else if (pixelFormat == 6406) {
    size = 1;
  }

  if (!pixels) {
    //|| pixels.length !== size * width * height
    //|| scratchPixelFormat != pixelFormat || scratchPixelDatatype != pixelDatatype) {
    if (pixelDatatype == 5126) {
      pixelDatatype = gl.FLOAT;
      pixels = new Float32Array(size * width * height);
    } else if (pixelDatatype == 5121) {
      pixels = new Uint8Array(size * width * height);
    } else {
      pixels = new Uint16Array(size * width * height);
    }
  }

  gl.readPixels(x, y, width, height, pixelFormat, pixelDatatype, pixels);
  scratchPixelFormat = pixelFormat;
  scratchPixelDatatype = pixelDatatype;
  return pixels;
};

var zUpToYUp;
/**
*
*@param {Cesium.Matrix4}srcMatrix
*@param {Cesium.Matrix4}dstMatrix
*@return {Cesium.Matrix4}
*/

RendererUtils.yUp2Zup = function (srcMatrix, dstMatrix) {
  var _Cesium = Cesium;
  var Matrix4 = _Cesium.Matrix4,
      Matrix3 = _Cesium.Matrix3;

  if (!yUpToZUp) {
    yUpToZUp = Matrix4.fromRotationTranslation(Matrix3.fromRotationX(_Cesium.Math.PI_OVER_TWO));
    zUpToYUp = Matrix4.inverse(yUpToZUp, new Matrix4());
  }

  return Matrix4.multiplyTransformation(srcMatrix, yUpToZUp, dstMatrix);
};
/**
*
*@param {Cesium.Matrix4}srcMatrix
*@param {Cesium.Matrix4}dstMatrix
*@return {Cesium.Matrix4}
*/


RendererUtils.zUp2YUp = function (srcMatrix, dstMatrix) {
  var _Cesium = Cesium;
  var Matrix4 = _Cesium.Matrix4,
      Matrix3 = _Cesium.Matrix3;

  if (!yUpToZUp) {
    yUpToZUp = Matrix4.fromRotationTranslation(Matrix3.fromRotationX(_Cesium.Math.PI_OVER_TWO));
    zUpToYUp = Matrix4.inverse(yUpToZUp, new Matrix4());
  }

  return Matrix4.multiplyTransformation(srcMatrix, zUpToYUp, dstMatrix);
};
/**
*平移、旋转或缩放，返回计算之后的模型转换矩阵
*@param {Cesium.Matrix4}srcModelMatrix
*@param {Cesium.Cartesian3}[translation=undefined]
*@param {Object}[rotation=undefined] 旋转参数
*@param {Cesium.Cartesian3}[rotation.axis] 旋转轴
*@param {Number}[rotation.angle] 旋转角度
*@param {Cesium.Cartesian3}[scale] 缩放
*@param {Cesium.Matrix4}[outModelMatrix] 计算结果矩阵，和返回值一样，但是传递此参数时则返回值不是新创建的Cesium.Matrix4实例
*@return {Cesium.Matrix4}
*/


RendererUtils.computeModelMatrix = function (srcModelMatrix, translation, rotation, scale, outModelMatrix) {
  if (arguments.length == 0) {
    return srcModelMatrix;
  }

  var _Cesium = Cesium;
  var Matrix4 = _Cesium.Matrix4,
      Cartesian3 = _Cesium.Cartesian3,
      Quaternion = _Cesium.Quaternion;
  if (!scratchTranslation) scratchTranslation = new Cartesian3();
  if (!scratchQuaternion) scratchQuaternion = new Quaternion();
  if (!scratchScale) scratchScale = new Cartesian3();
  if (!scratchTranslationQuaternionRotationScale) scratchTranslationQuaternionRotationScale = new Matrix4();

  if (!outModelMatrix) {
    outModelMatrix = new Matrix4();
  }

  Matrix4.clone(srcModelMatrix, outModelMatrix);

  if (!translation) {
    scratchTranslation.x = 0;
    scratchTranslation.y = 0;
    scratchTranslation.z = 0;
  }

  scratchTranslation.x = translation.x;
  scratchTranslation.y = translation.y;
  scratchTranslation.z = translation.z;

  if (!scale) {
    scratchScale.x = 1;
    scratchScale.y = 1;
    scratchScale.z = 1;
  }

  scratchScale.x = scale.x;
  scratchScale.y = scale.y;
  scratchScale.z = scale.z;

  if (rotation instanceof Quaternion) {
    Quaternion.clone(rotation, scratchQuaternion);
  } else {
    var axis = rotation.axis;
    var angle = rotation.angle;
    Quaternion.fromAxisAngle(new Cartesian3(axis.x, axis.y, axis.z), //axis.y=1 y是旋转轴
    _Cesium.Math.toRadians(angle), scratchQuaternion);
  } //translate,rotate,scale


  Matrix4.fromTranslationQuaternionRotationScale(scratchTranslation, scratchQuaternion, scratchScale, scratchTranslationQuaternionRotationScale);
  Matrix4.multiplyTransformation(outModelMatrix, scratchTranslationQuaternionRotationScale, outModelMatrix);
  return outModelMatrix;
};

var _default = RendererUtils;
exports["default"] = _default;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = polyfill;
var _polyfilled = false;
/**
 * 处理cesium和threejs的部分差异，增加一些辅助属性。
 * @returns 
 * @private
 */

function polyfill() {
  if (_polyfilled) return;
  _polyfilled = true;
  var _Cesium = Cesium,
      Matrix4 = _Cesium.Matrix4,
      Matrix3 = _Cesium.Matrix3,
      Matrix2 = _Cesium.Matrix2,
      Cartesian3 = _Cesium.Cartesian3,
      Cartesian2 = _Cesium.Cartesian2,
      Quaternion = _Cesium.Quaternion,
      OrthographicFrustum = _Cesium.OrthographicFrustum,
      Camera = _Cesium.Camera,
      ShaderProgram = _Cesium.ShaderProgram,
      defined = _Cesium.defined,
      createUniform = _Cesium.createUniform;

  Cartesian3.prototype.set = function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  };

  Cartesian3.prototype.copy = function (src) {
    this.x = src.x;
    this.y = src.y;
    this.z = src.z;
    return this;
  };

  Cartesian2.prototype.set = function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  };

  Cartesian2.prototype.copy = function (src) {
    this.x = src.x;
    this.y = src.y;
    return this;
  };

  Quaternion.prototype.set = function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };

  Quaternion.prototype.copy = function (src) {
    this.x = src.x;
    this.y = src.y;
    this.z = src.z;
    this.w = src.w;
    return this;
  };

  if (!OrthographicFrustum.prototype.isOrthographicFrustum) {
    OrthographicFrustum.prototype.isOrthographicFrustum = true;
    Object.defineProperties(Camera.prototype, {
      isOrthographicCamera: {
        get: function get() {
          return this.frustum && this.frustum.isOrthographicFrustum == true;
        }
      }
    });
  } // 修改Cesium.ShaderProgram.prototype._setUniforms：使cesium支持元素为自定义类型的uniform数组


  ShaderProgram.prototype._setUniforms = function (uniformMap, uniformState, validate) {
    var len;
    var i;

    if (defined(uniformMap)) {
      if (!this._makeSupportStructureUniformsDone) {
        modifyUniforms(this);
        this._makeSupportStructureUniformsDone = true;
      }

      var manualUniforms = this._manualUniforms;
      len = manualUniforms.length;

      for (i = 0; i < len; ++i) {
        var mu = manualUniforms[i]; //>>includeStart('debug', pragmas.debug);

        if (!uniformMap[mu.name]) {
          console.error('uniform ' + mu.name + " is undefined");
          debugger;
        } //>>includeEnd('debug');


        mu.value = uniformMap[mu.name]();
      }
    }

    var automaticUniforms = this._automaticUniforms;
    len = automaticUniforms.length;

    for (i = 0; i < len; ++i) {
      var au = automaticUniforms[i];
      au.uniform.value = au.automaticUniform.getValue(uniformState);
    } ///////////////////////////////////////////////////////////////////
    // It appears that assigning the uniform values above and then setting them here
    // (which makes the GL calls) is faster than removing this loop and making
    // the GL calls above.  I suspect this is because each GL call pollutes the
    // L2 cache making our JavaScript and the browser/driver ping-pong cache lines.


    var uniforms = this._uniforms;
    len = uniforms.length;

    for (i = 0; i < len; ++i) {
      uniforms[i].set();
    }

    if (validate) {
      var gl = this._gl;
      var program = this._program;
      gl.validateProgram(program); //>>includeStart('debug', pragmas.debug);
      // if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
      //     throw new _Cesium.DeveloperError(
      //         "Program validation failed.  Program info log: " +
      //         gl.getProgramInfoLog(program)
      //     );
      // }
      //>>includeEnd('debug');
    }
  };

  function modifyUniforms(shaderProgram) {
    var sp = shaderProgram,
        gl = sp._gl;
    var uniformsByName = sp._uniformsByName; //先获取所有已经定义的uniform，触发内部逻辑，才能取到program

    var program = sp._program;
    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var i = 0; i < numUniforms; i++) {
      var info = gl.getActiveUniform(program, i);
      var uniformName = info.name;
      var indexOfBracket = uniformName.indexOf("[");

      if (indexOfBracket >= 0) {
        var uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];

        if (defined(uniformArray)) {
          continue;
        }

        if (!uniformsByName[info.name]) {
          var loc = gl.getUniformLocation(program, info.name);
          var uniform = createUniform(gl, info, info.name, loc);
          sp._uniformsByName[info.name] = uniform;

          sp._uniforms.push(uniform);

          sp._manualUniforms.push(uniform);
        }
      }
    }
  } //给Cesium的矩阵加上elements，使其能参与threejs的矩阵运算


  if (!Matrix4.prototype.__patched__) {
    Matrix4.prototype.__patched__ = true;
    Object.defineProperties(Matrix4.prototype, {
      elements: {
        get: function get() {
          return this;
        }
      }
    });
    Object.defineProperties(Matrix3.prototype, {
      elements: {
        get: function get() {
          return this;
        }
      }
    });
    Object.defineProperties(Matrix2.prototype, {
      elements: {
        get: function get() {
          return this;
        }
      }
    });
  }

  if (typeof THREE != 'undefined' && !THREE.Material.prototype.__patched__) {
    var _THREE = THREE,
        Material = _THREE.Material,
        Color = _THREE.Color,
        Object3D = _THREE.Object3D;
    Material.prototype.__patched__ = true; //给threejs 的Material加上一些辅助属性

    Object.defineProperties(Material.prototype, {
      renderStateNeedsUpdate: {
        set: function set() {
          this.renderStateVersion++;
        }
      },
      renderStateVersion: {
        get: function get() {
          if (this._renderStateVersion == undefined) this._renderStateVersion = 0;
          return this._renderStateVersion;
        },
        set: function set(val) {
          this._renderStateVersion = val;
        }
      },
      autoRefresh: {
        get: function get() {
          if (this._autoRefresh == undefined) this._autoRefresh = true;
          return this._autoRefresh;
        },
        set: function set(val) {
          this._autoRefresh = val;
        }
      },
      translucent: {
        get: function get() {
          if (this._translucent == undefined) this._translucent = false;
          return this._translucent;
        },
        set: function set(val) {
          if (this._translucent != val) {
            this._translucent = val;
            this.needsUpdate = true;
          }
        }
      }
    }); //给threejs的Color加上red,green,blue,alpha，使其能参与Cesium Color的运算

    Object.defineProperties(Color.prototype, {
      red: {
        get: function get() {
          return this.r;
        },
        set: function set(val) {
          this.r = val;
        }
      },
      green: {
        get: function get() {
          return this.g;
        },
        set: function set(val) {
          this.g = val;
        }
      },
      blue: {
        get: function get() {
          return this.b;
        },
        set: function set(val) {
          this.b = val;
        }
      },
      alpha: {
        get: function get() {
          return 1;
        },
        set: function set(val) {}
      }
    }); //给Object3D加上一些辅助属性(如modelMatrix等)

    var emptyInstances = [],
        emptyInstancedAttributes = [];
    Object.defineProperties(Object3D.prototype, {
      modelMatrixNeedsUpdate: {
        get: function get() {
          if (this._modelMatrixNeedsUpdate == undefined) this._modelMatrixNeedsUpdate = true;
          return this._modelMatrixNeedsUpdate;
        },
        set: function set(val) {
          this._modelMatrixNeedsUpdate = val;
        }
      },
      modelMatrix: {
        get: function get() {
          if (this._modelMatrix == undefined) this._modelMatrix = Matrix4.IDENTITY.clone();
          return this._modelMatrix;
        },
        set: function set(val) {
          this._modelMatrix = val;
        }
      },
      maxVisibleDistance: {
        get: function get() {
          if (!this._maxVisibleDistance) this._maxVisibleDistance = Infinity;
          return this._maxVisibleDistance;
        },
        set: function set(val) {
          if (this._maxVisibleDistance != val) {
            this._maxVisibleDistance = val;
            var len = this.children;

            for (var i = 0; i < len; i++) {
              var child = this.children[i];
              if (child._maxVisibleDistance == Infinity) child.maxVisibleDistance = val;
            }
          }
        }
      },
      instances: {
        get: function get() {
          if (!this._instances) this._instances = emptyInstances;
          return this._instances;
        },
        set: function set(val) {
          if (this._instances != val) {
            this._instances = val;
            var len = this.children.length;

            for (var i = 0; i < len; i++) {
              var child = this.children[i];
              if (child._instances == emptyInstances) child.instances = val;
            }

            if (val && val.length > 0) {
              this._isCustomInstancedMesh = true;
            } else {
              this._isCustomInstancedMesh = false;
            }
          }
        }
      },
      instancedAttributes: {
        get: function get() {
          if (!this._instancedAttributes) this._instancedAttributes = emptyInstancedAttributes;
          return this._instancedAttributes;
        },
        set: function set(val) {
          if (this._instancedAttributes != val) {
            this._instancedAttributes = val;
            var len = this.children;

            for (var i = 0; i < len; i++) {
              var child = this.children[i];
              if (child._instancedAttributes == emptyInstancedAttributes) child.instancedAttributes = val;
            }
          }
        }
      },
      isCustomInstancedMesh: {
        get: function get() {
          if (this._isCustomInstancedMesh == undefined) this._isCustomInstancedMesh = false;
          return this._isCustomInstancedMesh;
        }
      }
    }); //修改updateMatrixWorld方法，通知对象更新modelMatrix

    Object3D.prototype._updateMatrixWorld = Object3D.prototype.updateMatrixWorld;

    Object3D.prototype.updateMatrixWorld = function (force) {
      if (this.matrixAutoUpdate) this.updateMatrix();

      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }

        this.matrixWorldNeedsUpdate = false;
        force = true; //

        this.modelMatrixNeedsUpdate = true;
      } // update children


      var children = this.children;

      for (var i = 0; i < children.length; i++) {
        children[i].updateMatrixWorld(force);
      }
    };
  }
}

},{}],8:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = CesiumCommands;

var _WebGLGeometries = _interopRequireDefault(require("e_23"));

var _GeometryUtils = _interopRequireDefault(require("s_24"));

var _WebGLRenderItem = _interopRequireDefault(require("h_25"));

var _WebGLLights = _interopRequireDefault(require("-_26"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

/**
 * 绘图命令工具，用于生成、更新、销毁Cesium.DrawCommand 
 * @param {WebGLRenderer} renderer  
 */
function CesiumCommands(renderer) {
  var visualizer = renderer._visualizer;
  var webglUniforms = renderer._uniforms;
  var cesiumRenderStates = renderer._cesiumRenderStates;
  var cesiumShaderPrograms = renderer._cesiumShaderPrograms;
  var cesiumVertextArrays = renderer._cesiumVertextArrays;
  /**
   *  
   * @param {THREE.Mesh} mesh3js 
   * @param {WebGLLights}lights
   * @param {number}[materialIndexOrGroupIndex] 
   * @param {ArrayBufferView}indices
   * @param {boolean}[groupOptimized]
   * @returns {WebGLRenderItem}
  */

  this.create = function (mesh3js, lights, shadows, materialIndexOrGroupIndex, indices, groupOptimized) {
    var frameState = visualizer.frameState,
        context = frameState.context; // const webglUniforms = renderer._uniforms;
    // const cesiumRenderStates = renderer._cesiumRenderStates

    var geometry = _WebGLGeometries["default"].get(mesh3js.geometry);

    var groups = geometry.groups;
    var material3js = mesh3js.material;
    var pickIdStr = 'czm_pickColor';
    var primitiveType;
    var _Cesium = Cesium,
        defined = _Cesium.defined,
        Matrix4 = _Cesium.Matrix4,
        PrimitiveType = _Cesium.PrimitiveType,
        DrawCommand = _Cesium.DrawCommand,
        Pass = _Cesium.Pass; //primitiveType

    if (mesh3js.isMesh) {
      if (material3js.wireframe) {
        primitiveType = 1;
      } else {
        primitiveType = 4;
      }
    } else if (mesh3js.isLine) {
      if (mesh3js.isLineSegments) {
        primitiveType = 1;
      } else if (mesh3js.isLineLoop) {
        primitiveType = 2;
      } else {
        primitiveType = 3;
      }
    } else if (mesh3js.isPoints) {
      primitiveType = 0;
    } else {
      primitiveType = 4;
    } //


    var instances = mesh3js.instances;
    var availableInstances = mesh3js._availableInstances;
    var drawCommand = new DrawCommand({
      modelMatrix: instances && instances.length > 0 ? undefined : Matrix4.clone(visualizer.modelMatrix),
      owner: mesh3js,
      castShadows: true,
      pickId: pickIdStr,
      receiveShadows: true,
      primitiveType: primitiveType,
      cull: false,
      instanceCount: instances && instances.length > 0 ? availableInstances.length : undefined
    }); //vertexArray

    var vertexArray = cesiumVertextArrays.create(geometry, mesh3js, materialIndexOrGroupIndex, indices, groupOptimized);
    var attributeLocations = vertexArray._attributeLocations;

    if (vertexArray.instanceCount) {
      drawCommand.instanceCount = vertexArray.instanceCount;
    }

    drawCommand.vertexArray = vertexArray; //shaderProgram

    var materialIndex = materialIndexOrGroupIndex,
        groupIndex = null;

    if (Array.isArray(material3js)) {
      //group
      if (!groupOptimized) {
        groupIndex = materialIndexOrGroupIndex;
        materialIndex = groups[groupIndex].materialIndex;
      }

      material3js = material3js[materialIndex];
    }

    drawCommand.shaderProgram = cesiumShaderPrograms.get(material3js, attributeLocations, mesh3js, lights, shadows); //pass

    var pass = mesh3js.pass;

    if (typeof pass != 'number' || pass < 0 || pass > 8) {
      pass = material3js.translucent ? 8 : 4;
    } // drawCommand.pass = material3js.translucent ?  8 : pass//|| 4


    drawCommand.pass = material3js.translucent ? 8 : material3js.stencilWrite ? 5 : 4;
    drawCommand._v_pass = material3js.translucent || material3js.transparent ? 8 : pass; //4

    if (!defined(material3js.allowPick)) {
      material3js.allowPick = true;
    }

    drawCommand.renderState = cesiumRenderStates.create(material3js, mesh3js);
    drawCommand._renderStateOptions = material3js._renderStateOptions;
    drawCommand.uniformMap = webglUniforms.getUniformMap(material3js, mesh3js, frameState, lights, shadows);

    if (mesh3js.uniformMapLoadedCallback) {
      mesh3js.uniformMapLoadedCallback(drawCommand.uniformMap, frameState, mesh3js);
    }

    return new _WebGLRenderItem["default"](drawCommand, material3js, materialIndex, mesh3js, geometry, visualizer, groupIndex);
  };
  /**
   * 
   * @param {THREE.Mesh} mesh3js 
   * @param {WebGLLights}[lights]
   * @param {THREE.Light[]}[shadows]
   * @returns {WebGLRenderItem[]}
   */


  this.createArray = function (mesh3js, lights, shadows) {
    var renderItems = [];

    var geometry = _WebGLGeometries["default"].get(mesh3js.geometry, mesh3js.material);

    var groupsOptimized = geometry.groupsOptimized; //合并材质相同的组，drawCommand数量与material的相同

    for (var i = 0; i < groupsOptimized.length; i++) {
      var newGroup = groupsOptimized[i];
      var materialIndex = newGroup.materialIndex;
      var groupOptimized = true; // const groupIndex = newGroup.groupIndex;
      // const material = mesh3js.material[materialIndex];
      // if (material.transparent && !material.translucent) {
      //     groupOptimized = false;
      //     materialIndex=groupIndex;
      // }

      var boundingSphereAndIndices = _GeometryUtils["default"].computeBoundingSphereAndIndices(geometry, materialIndex, groupOptimized);

      var boundingSphere = boundingSphereAndIndices.boundingSphere,
          indices = boundingSphereAndIndices.indices;
      var renderItem = this.create(mesh3js, lights, shadows, materialIndex, indices, groupOptimized);
      renderItem.boundingSphere = boundingSphere;
      renderItems.push(renderItem);
    } // //不合并，drawCommand数量与group的相同
    // var geometry = mesh3js.geometry;
    // var groups = geometry.groups;
    // groups.forEach((group) => {
    //     var renderItem = this.create(mesh3js, frameSate, visualizer, group);
    //     renderItems.push(renderItem);
    // }); 


    return renderItems;
  };
  /**
   * 
   * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} mesh  
   * @param {THREE.BufferGeometry}geometry
   */


  this.update = function (mesh, geometry) {
    var _Cesium2 = Cesium,
        BoundingSphere = _Cesium2.BoundingSphere,
        Matrix4 = _Cesium2.Matrix4;
    geometry = geometry || mesh.geometry;
    var renderItems = Array.isArray(mesh.renderItems) ? mesh.renderItems : [mesh.renderItems];
    var hasGroup = Array.isArray(mesh.material);
    renderItems.forEach(function (renderItem) {
      var drawCommand = renderItem.drawCommand;
      var material = renderItem.material || mesh.material;

      if (mesh.isInstancedMesh) {
        drawCommand.instanceCount = mesh.count;
      }

      if (mesh.instances && mesh.instances.length) {
        //boundingVolume
        if (mesh.frustumCulled != false && !drawCommand.boundingVolume) {
          var bs = BoundingSphere.clone(mesh._boundingSphere);
          drawCommand.boundingVolume = bs;
        } //instanceCount


        drawCommand.instanceCount = mesh._availableInstances.length;
      } else if (mesh.frustumCulled != false || material.translucent || material.transparent) {
        //boundingVolume
        var bs = hasGroup && drawCommand.__boundingSphere ? drawCommand.__boundingSphere : geometry.boundingSphere;

        if (!bs) {
          if (geometry.computeBoundingSphere) {
            geometry.computeBoundingSphere();
            bs = geometry.boundingSphere;
          } else {
            var positionAttr = geometry.attributes.position;
            bs = BoundingSphere.fromVertices(positionAttr.values || positionAttr.array);
            geometry.boundingSphere = bs;
          }
        }

        if (!drawCommand.boundingVolume) {
          drawCommand.boundingVolume = BoundingSphere.clone(bs);
        }

        if (visualizer._modelMatrixNeedsUpdate || mesh.modelMatrixNeedsUpdate || !drawCommand.boundingVolume._multiplyByModelMatrix) {
          Matrix4.multiplyByPoint(mesh.modelMatrix, bs.center, drawCommand.boundingVolume.center);
          drawCommand.boundingVolume.radius = bs.radius * Matrix4.getMaximumScale(mesh.modelMatrix);
          drawCommand.boundingVolume._multiplyByModelMatrix = true;
        }

        var instanceCount = geometry.maxInstancedCount || geometry.instanceCount;

        if (instanceCount) {
          drawCommand.instanceCount = instanceCount;
        }
      } //modelMatrix 


      drawCommand.modelMatrix = mesh.modelMatrix;
    });

    if (hasGroup) {
      renderItems.forEach(function (renderItem) {
        var material = renderItem.material;

        visualizer.renderer._uniforms.refresh(material, mesh);
      });
    }
  };
}

},{"s_24":2,"e_23":22,"-_26":23,"h_25":29,"3_27":35,"M_0":241}],9:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = CesiumRenderStates;

var _ConstantMap = _interopRequireDefault(require("._29"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

/**
 * 渲染状态工具，使用内置的材质或者threejs材质，生成Cesium的RenderState
 * @param {WebGLRenderer} renderer 
 */
function CesiumRenderStates(renderer) {
  var _Cesium = Cesium,
      RenderState = _Cesium.RenderState;

  var _renderStateCache = new Map();
  /**
   * 
   * @param {THREE.Material} material 
   * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object 
   * @param {boolean} fromCache 
   * @return {Cesium.RenderState}
   */


  this.create = function (material, object, fromCache) {
    var rs;

    if (fromCache) {
      rs = _renderStateCache.get(material);

      if (!rs) {
        rs = getRenderState(material, object);

        _renderStateCache.set(material, rs);

        material.material3js.addEventListener('dispose', function () {
          _renderStateCache["delete"](material, rs);
        });
      }
    } else {
      rs = getRenderState(material, object);
    }

    return rs;
  }; // this.update = function (object) {
  //     return getRenderState(material, object);
  // }


  function enableOrDisable(gl, glEnum, enable) {
    if (enable) {
      gl.enable(glEnum);
    } else {
      gl.disable(glEnum);
    }
  }

  function applyBlendingColor(gl, color) {
    gl.blendColor(color.red, color.green, color.blue, color.alpha);
  }
  /**
   * 
   * @param {WebGL2RenderingContext} gl 
   * @param {*} renderState 
   * @param {*} passState 
   */


  function applyBlending(gl, renderState, passState) {
    var blending = renderState.blending;
    var enabled = Cesium.defined(passState.blendingEnabled) ? passState.blendingEnabled : blending.enabled;
    enableOrDisable(gl, gl.BLEND, enabled);

    if (enabled) {
      // applyBlendingColor(gl, blending.color);
      // gl.blendEquationSeparate(blending.equationRgb, blending.equationAlpha);
      // gl.blendFuncSeparate(
      //     blending.functionSourceRgb,
      //     blending.functionDestinationRgb,
      //     blending.functionSourceAlpha,
      //     blending.functionDestinationAlpha
      // );
      //    gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA ); 
      // gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      // gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
      gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }
  }

  var scratchViewport;

  function applyViewport(gl, renderState, passState) {
    var viewport = Cesium.defaultValue(renderState.viewport, passState.viewport);

    if (!Cesium.defined(viewport)) {
      if (!scratchViewport) scratchViewport = new Cesium.BoundingRectangle();
      viewport = scratchViewport;
      viewport.width = passState.context.drawingBufferWidth;
      viewport.height = passState.context.drawingBufferHeight;
    }

    passState.context.uniformState.viewport = viewport;
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
  } // Cesium.RenderState.__apply = Cesium.RenderState.apply;
  // Cesium.RenderState.apply = function (gl, renderState, passState) {
  //     Cesium.RenderState.__apply(gl, renderState, passState);
  //     applyBlending(gl, renderState, passState);
  //     applyViewport(gl, renderState, passState);
  // }
  // Cesium.RenderState.__partialApply = Cesium.RenderState.partialApply
  // Cesium.RenderState.partialApply = function (
  //     gl,
  //     previousRenderState,
  //     renderState,
  //     previousPassState,
  //     passState,
  //     clear
  // ) {
  //     Cesium.RenderState.__partialApply(gl,
  //         previousRenderState,
  //         renderState,
  //         previousPassState,
  //         passState,
  //         clear);
  //     applyBlending(gl, renderState, passState);
  //     applyViewport(gl, renderState, passState);
  // }

  /**
   * 
   * @param {THREE.Material} material3js 
   * @param {boolean} frontFaceCW 
   * @return {Cesium.RenderState}
   * @private
   */


  function getRenderStateOptions(material3js, frontFaceCW) {
    var capabilities = renderer._capabilities,
        extensions = renderer._extensions;
    var equationToGL = _ConstantMap["default"].equationMap;
    var _Cesium2 = Cesium,
        WebGLConstants = _Cesium2.WebGLConstants,
        StencilFunction = _Cesium2.StencilFunction,
        StencilOperation = _Cesium2.StencilOperation,
        StencilConstants = _Cesium2.StencilConstants,
        defined = _Cesium2.defined,
        defaultValue = _Cesium2.defaultValue,
        CullFace = _Cesium2.CullFace,
        BlendingState = _Cesium2.BlendingState;
    var _THREE = THREE,
        MinEquation = 103,
        MaxEquation = 104,
        DoubleSide = 2,
        BackSide = 1,
        NoBlending = 0,
        MultiplyBlending = 4,
        NormalBlending = 1,
        CustomBlending = 5,
        AdditiveBlending = 2,
        SubtractiveBlending = 3;
    var factorToGL = _ConstantMap["default"].factorMap;
    var depthFuncMap = _ConstantMap["default"].depthFuncMap; // const gl = WebGLConstants;
    //const { MIN, MAX, ZERO, ONE, ONE_MINUS_SRC_ALPHA, SRC_ALPHA, SRC_COLOR, DST_ALPHA, DST_COLOR, ONE_MINUS_SRC_COLOR } = gl;
    //

    var material = material3js;
    var flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;

    if (capabilities.isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      var extension = extensions.get('EXT_blend_minmax');

      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }

    if (!defined(material.side)) {
      material.side = 2;
    } // if (flipSided&&frontFaceCW) debugger
    // if (material.polygonOffset) debugger


    if (material.onCreateRenderState) {
      var rs = material.onCreateRenderState();
      if (rs) return rs;
    }

    return {
      frontFace: frontFaceCW && flipSided ? 2304 : 2305,
      cull: {
        enabled: material.side != DoubleSide,
        // defaultValue(cull.enabled, false),
        face: material.side == BackSide ? 1028 : 1029 // 1029|1028|1032 //defaultValue(cull.face, 1029),

      },
      lineWidth: 1,
      polygonOffset: {
        enabled: material.polygonOffset,
        factor: material.polygonOffsetFactor,
        units: material.polygonOffsetUnits
      },
      depthRange: material.depthRange || {
        near: 0,
        far: 1
      },
      depthTest: {
        enabled: material.depthTest,
        func: defaultValue(depthFuncMap[material.depthFunc], 515)
      },
      colorMask: {
        red: material.colorWrite,
        green: material.colorWrite,
        blue: material.colorWrite,
        alpha: material.colorWrite
      },
      depthMask: defaultValue(material.depthWrite, true),
      blending: function () {
        if (material.blending == NoBlending) {
          return BlendingState.DISABLED;
        }

        var blendEquation = material.blendEquation;
        var blendEquationAlpha = material.blendEquationAlpha || material.blendEquation;

        if (material.blending !== CustomBlending) {
          if (material.premultipliedAlpha) {
            // return Cesium.BlendingState.ALPHA_BLEND;
            switch (material.blending) {
              case NormalBlending:
                return {
                  enabled: true,
                  equationRgb: equationToGL[blendEquation],
                  equationAlpha: equationToGL[blendEquationAlpha],
                  functionSourceRgb: 1,
                  functionSourceAlpha: 1,
                  functionDestinationRgb: 771,
                  functionDestinationAlpha: 771
                }; // gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

                break;

              case AdditiveBlending:
                return {
                  enabled: true,
                  equationRgb: equationToGL[blendEquation],
                  equationAlpha: equationToGL[blendEquationAlpha],
                  functionDestinationAlpha: 1,
                  functionDestinationRgb: 1,
                  functionSourceAlpha: 1,
                  functionSourceRgb: 770
                }; // gl.blendFunc( gl.ONE, gl.ONE );

                break;

              case SubtractiveBlending:
                return {
                  enabled: true,
                  equationRgb: equationToGL[blendEquation],
                  equationAlpha: equationToGL[blendEquationAlpha],
                  functionSourceRgb: 0,
                  functionSourceAlpha: 769,
                  functionDestinationRgb: 0,
                  functionDestinationAlpha: 771
                }; // gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

                break;

              case MultiplyBlending:
                return {
                  enabled: true,
                  equationRgb: equationToGL[blendEquation],
                  equationAlpha: equationToGL[blendEquationAlpha],
                  functionSourceRgb: 0,
                  functionSourceAlpha: 0,
                  functionDestinationRgb: 768,
                  functionDestinationAlpha: 770
                }; // gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

                break;

              default:
                console.error('RenderSateUtils: Invalid blending: ', material.blending);
                break;
            }
          } else {
            switch (material.blending) {
              case NormalBlending:
                return {
                  enabled: true,
                  // color: new Color(1,1,1,1.),
                  equationRgb: equationToGL[blendEquation],
                  equationAlpha: equationToGL[blendEquationAlpha],
                  functionSourceRgb: 770,
                  functionSourceAlpha: 1,
                  functionDestinationRgb: 771,
                  functionDestinationAlpha: 771
                }; // gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

                break;

              case AdditiveBlending:
                return BlendingState.ADDITIVE_BLEND;
                break;
              // case 3:
              //     return Cesium.BlendingState.PRE_MULTIPLIED_ALPHA_BLEND; 
              // 	// gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
              // 	break;
              // case 4:
              //     return Cesium.BlendingState.PRE_MULTIPLIED_ALPHA_BLEND; 
              //     return;
              // 	// gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
              // 	break;

              default:
                console.error('RenderSateUtils: Invalid blending: ', material.blending);
                break;
            }
          } // ADDITIVE_BLEND
          // ALPHA_BLEND
          // DISABLED: {enabled: false}
          // PRE_MULTIPLIED_ALPHA_BLEND: 

        } else {
          return {
            enabled: material.blending == NoBlending,
            // color: //Color
            equationRgb: equationToGL[blendEquation],
            equationAlpha: equationToGL[blendEquationAlpha],
            functionSourceRgb: factorToGL[material.blendSrc],
            functionSourceAlpha: factorToGL[material.blendSrcAlpha],
            functionDestinationRgb: factorToGL[material.blendDst],
            functionDestinationAlpha: factorToGL[material.blendDstAlpha]
          };
        }
      }(),
      stencilMask: material.stencilWrite ? material.stencilWriteMask : //如果材质设定了开启模板测试，则使用threejs材质设置的模版测试参数
      StencilConstants.CESIUM_3D_TILE_MASK,
      //否则使用3dtiles模板测试参数
      stencilTest: material.stencilWrite ? {
        //如果材质设定了开启模板测试，则使用threejs材质设置的模版测试参数
        enabled: material.stencilWrite,
        frontFunction: material.stencilFunc,
        backFunction: material.stencilFunc,
        reference: defaultValue(material.stencilRef, 0),
        mask: defaultValue(material.stencilFuncMask, ~0),
        frontOperation: {
          fail: material.stencilFail,
          zFail: material.stencilZFail,
          zPass: material.stencilZPass
        },
        backOperation: {
          fail: material.stencilFail,
          zFail: material.stencilZFail,
          zPass: material.stencilZPass
        }
      } : {
        //否则使用3dtiles模板测试参数
        backFunction: 519,
        backOperation: {
          fail: 7680,
          zFail: 7680,
          zPass: 7681
        },
        enabled: true,
        frontFunction: 519,
        frontOperation: {
          fail: 7680,
          zFail: 7680,
          zPass: 7681
        },
        mask: 128,
        reference: 128
      }
    };
  }
  /**
  *
  *@param {MeshMaterial}material
  *@param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite}object 
  *@return {Cesium.RenderState}frameState
  *@private
  */


  function getRenderState(material, object) {
    var frontFaceCW = object.matrixWorld.determinant() < 0; // determinant(mesh.matrixWorld.elements) < 0 //(mesh.isMesh && object.matrixWorld.determinant() < 0);

    var renderStateOpts = getRenderStateOptions(material, frontFaceCW);
    material._renderStateOptions = renderStateOpts;
    var renderState = RenderState.fromCache(renderStateOpts); // var renderState = new RenderState(renderStateOpts);

    return renderState;
  }
}

},{"._29":12,"3_27":35,"M_0":241}],10:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = CesiumShaderPrograms;

var _ShaderUtils = _interopRequireDefault(require("m_32"));

var _MeshVisualizer = _interopRequireDefault(require("M_33"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

var _WebGLProgram = require("s_35");

var _WebGLPrograms = _interopRequireDefault(require("h_36"));

var _WebGLLights = _interopRequireDefault(require("-_26"));

var _extension_lights_parsGlsl = _interopRequireDefault(require("3_38"));

var _extention_lights_fragment_beginGlsl = _interopRequireDefault(require("D_39"));

var emptyLights = {
  directional: [],
  point: [],
  spot: [],
  rectArea: [],
  hemi: [],
  directionalShadowMap: [],
  pointShadowMap: [],
  spotShadowMap: []
};
/**
 * 
 * @param {WebGLRenderer} renderer 
 */

function CesiumShaderPrograms(renderer) {
  var visualizer = renderer._visualizer;
  var webglUniforms = renderer._uniforms;
  var properties = renderer._properties;
  var _Cesium = Cesium,
      ShaderSource = _Cesium.ShaderSource,
      ShaderProgram = _Cesium.ShaderProgram;
  /**
   *  
   * @param {{fragmentShader:string,vertexShader:string}} shader 
   */

  function appendExtensionLights(shader) {
    //
    var fixedWebGLLights = visualizer._fixedWebGLLights;
    var partialWebGLLights = visualizer._partialWebGLLights;
    var NUM_STATIC_POINT_LIGHTS = fixedWebGLLights.state.point.length;
    var NUM_PAITIAL_POINT_LIGHTS = partialWebGLLights.state.point.length;

    if (NUM_STATIC_POINT_LIGHTS > 0 || NUM_PAITIAL_POINT_LIGHTS > 0) {
      var fs = shader.fragmentShader;
      fs = _ShaderUtils["default"].insertAfter(fs, /uniform vec3 lightProbe\[ 9 \];/g, _extension_lights_parsGlsl["default"].replace(/NUM_STATIC_POINT_LIGHTS/g, NUM_STATIC_POINT_LIGHTS).replace(/NUM_PAITIAL_POINT_LIGHTS/g, NUM_PAITIAL_POINT_LIGHTS));
      fs = _ShaderUtils["default"].insertAfter(fs, /IncidentLight directLight;/g, _extention_lights_fragment_beginGlsl["default"].replace(/NUM_STATIC_POINT_LIGHTS/g, NUM_STATIC_POINT_LIGHTS).replace(/NUM_PAITIAL_POINT_LIGHTS/g, NUM_PAITIAL_POINT_LIGHTS));
      shader.fragmentShader = fs;
    }
  }
  /**
   *  
   * @param {THREE.Mesh|THREE.Line|THREE.LineLoop|THREE.LineSegments|THREE.Points|THREE.Sprite} object   
   * @param {WebGLLights} [lights]
   * @param {THREE.Light[]} [shadows]
   */


  function compileShader3js(material3js, object, lights, shadows) {
    //three version >= 0.119.1
    var scene = visualizer;
    shadows = shadows || null;
    /**
     * @type {WebGLPrograms}
     * @private
     */

    var programs = renderer._programs;
    var parameters = programs.getParameters(material3js, material3js.lightMap ? emptyLights : lights.state, shadows, scene, object);
    var uniforms = programs.getUniforms(material3js);
    parameters.uniforms = uniforms;

    if (typeof material3js.onBeforeCompile == 'function') {
      material3js.onBeforeCompile(parameters, renderer);
    }

    if (material3js.isNodeMaterial) {
      uniforms = parameters.uniforms;
      parameters = programs.getParameters(material3js, material3js.lightMap ? emptyLights : lights.state, shadows, scene, object);
      parameters.uniforms = uniforms; //

      var materialProperties = properties.get(material3js);
      materialProperties.needsLights = material3js.lights;
      materialProperties.clipping = material3js.clipping;
    }

    var cacheKey = programs.getProgramCacheKey(parameters);

    var program = renderer._programs.acquireProgram(parameters, cacheKey);

    program.uniforms = parameters.uniforms;
    return program;
  }
  /**
   * 
   * @param {THREE.Material} material 
   * @param {{[key:string]:number}} attributeLocations 
   * @param {THREE.Mesh|THREE.Line|THREE.LineLoop|THREE.LineSegments|THREE.Points|THREE.Sprite} object  
   * @returns {Cesium.ShaderProgram}
   * @private
   */


  this.get = function (material3js, attributeLocations, object, lights, shadows) {
    var context = visualizer.frameState.context;
    var instances = object.instances;
    var shader; // var lights = visualizer._lights.state;

    var scene = visualizer; // var shadows = visualizer._shadowsArray;

    shader = compileShader3js(material3js, object, lights, shadows);

    _ShaderUtils["default"].processInstanceShader(object, shader); //TODO:
    //  ShaderUtils.processOcclusionCulling(object, shader);


    var pickIdStr = 'czm_pickColor';
    var pickColorQualifier = instances && instances.length ? 'varying' : material3js.pickColorQualifier || 'uniform';
    var pickColorDefinition = pickColorQualifier + ' vec4 ' + pickIdStr + ';\n';
    var logDepthExtension = '#ifdef GL_EXT_frag_depth \n' + '#extension GL_EXT_frag_depth : enable \n' + '#endif \n\n';
    shader.vertexShader = '\n\
                #define CESIUM_MESH_VISUALIZER\n\
                uniform vec3 u_cameraPositionLC;\n\
                uniform mat4 matrixWorld;\n\
                uniform mat3 normalMatrixWorld;\n\
                uniform mat4 viewMatrixThree;\n\
                uniform mat4 modelViewMatrixInverse;\n\
                uniform mat4 _CesiumModel2ThreeModel;\n\
                uniform mat3 _CesiumNormal2ThreeNormal;\n\
                uniform mat4 _ThreeModel2CesiumModel;\n\
                uniform mat3 _ThreeNormal2CesiumNormal;\n\
                ' + shader.vertexShader;
    var fs = '\n\
                #define CESIUM_MESH_VISUALIZER\n\
                uniform mat4 matrixWorld;\n\
                uniform mat3 normalMatrixWorld;\n\
                uniform mat4 viewMatrixThree;\n\
                uniform mat4 modelViewMatrixInverse;\n\
                uniform mat4 _CesiumModel2ThreeModel;\n\
                uniform mat3 _CesiumNormal2ThreeNormal;\n\
                uniform mat4 _ThreeModel2CesiumModel;\n\
                uniform mat3 _ThreeNormal2CesiumNormal;\n' + shader.fragmentShader;
    shader.fragmentShader = fs;

    if (visualizer.useEncodedPosition) {
      _ShaderUtils["default"].modifyEncodedPosition(object, shader);
    }

    _ShaderUtils["default"].modifyShadowWorldPosition(object, shader);

    _ShaderUtils["default"].modifyEnvMapQueryVec(object, shader);

    appendExtensionLights(shader);
    shader.fragmentShader = (0, _WebGLProgram.unrollLoops)(shader.fragmentShader); //

    if (material3js.onAfterCompile) {
      material3js.onAfterCompile(shader, renderer);
    } //


    if (material3js.pickColorQualifier == 'varying') {
      //&& !material3js.isShaderMaterial) {
      if (shader.vertexShader.indexOf(pickIdStr) == -1) {
        var pickColorName = material3js.pickColorName || 'pickColor';
        shader.vertexShader = _ShaderUtils["default"].insertBeforeMain(shader.vertexShader, 'attribute vec4 ' + pickColorName + ';\n' + 'varying vec4 ' + pickIdStr + ';\n');
        shader.vertexShader = _ShaderUtils["default"].insertAfterMain(shader.vertexShader, pickIdStr + '=' + pickColorName + ';\n');
      }
    } //


    webglUniforms.set(material3js, shader.uniforms, object, lights, shadows); //

    var vs = new ShaderSource({
      sources: [shader.vertexShader]
    });
    var fs = new ShaderSource({
      sources: [pickColorDefinition + shader.fragmentShader, logDepthExtension]
    });
    var translucent = material3js.translucent || material3js.transparent;

    if (!translucent && context.fragmentDepth) {
      fs.defines.push('WRITE_DEPTH');
    }

    var shaderProgram = ShaderProgram.fromCache({
      context: context,
      fragmentShaderSource: fs,
      vertexShaderSource: vs,
      attributeLocations: attributeLocations
    });
    return shaderProgram;
  };
}

},{"M_33":5,"m_32":14,"3_38":15,"D_39":16,"-_26":23,"s_35":26,"h_36":27,"3_27":35,"M_0":241}],11:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _GeometryUtils = _interopRequireDefault(require("s_24"));

var _WebGLGeometries = _interopRequireDefault(require("e_23"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

function WebGLAttributeCache() {
  var _vaAttributes = new WeakMap();

  this.get = function (geometryAttribute) {
    return _vaAttributes.get(geometryAttribute);
  };

  this.set = function (geometryAttribute, vaAttribute, geometry) {
    function onGeometryDispose() {
      // _vaAttributes.delete(vaAttribute);
      _vaAttributes["delete"](geometryAttribute);

      geometry.removeEventListener('dispose', onGeometryDispose);
    }

    geometry.addEventListener('dispose', onGeometryDispose);

    _vaAttributes.set(geometryAttribute, vaAttribute); // _vaAttributes.set(vaAttribute, geometryAttribute);

  };

  this["delete"] = function (attribute) {
    // var cacheVal = _vaAttributes.get(attribute);
    // _vaAttributes.delete(cacheVal);
    _vaAttributes["delete"](attribute);
  };
}
/**
 * 顶点数组工具，使用threejs BufferGeometry和Cesium Geometry，生成、更新DrawCommand的vertexArray
 * @param {WebGLRenderer} renderer 
 */


function CesiumVertextArrays(renderer) {
  var _Cesium = Cesium,
      Matrix4 = _Cesium.Matrix4,
      defined = _Cesium.defined,
      GeometryPipeline = _Cesium.GeometryPipeline,
      BufferUsage = _Cesium.BufferUsage,
      VertexArray = _Cesium.VertexArray,
      defaultValue = _Cesium.defaultValue,
      Cartesian3 = _Cesium.Cartesian3,
      Cartesian2 = _Cesium.Cartesian2,
      Cartesian4 = _Cesium.Cartesian4,
      Color = _Cesium.Color,
      Buffer = _Cesium.Buffer,
      ComponentDatatype = _Cesium.ComponentDatatype,
      IndexDatatype = _Cesium.IndexDatatype,
      BoundingSphere = _Cesium.BoundingSphere;
  var visualizer = renderer._visualizer;

  var _webglAttributeCache = new WebGLAttributeCache();

  var scratchMatrix = new Matrix4();

  function getVertexBufferTypedArray(mesh, creating) {
    var instances = creating ? mesh._instances : mesh._availableInstances;
    var instancesLength = instances.length;
    var collectionCenter = mesh._center;
    var vertexSizeInFloats = 12;
    var bufferData = mesh._vertexBufferTypedArray;

    if (!defined(bufferData) || instancesLength * vertexSizeInFloats > bufferData.length) {
      bufferData = new Float32Array(instancesLength * vertexSizeInFloats);
    } // Hold onto the buffer data so we don't have to allocate new memory every frame.


    mesh._vertexBufferTypedArray = bufferData;

    for (var i = 0; i < instancesLength; ++i) {
      var modelMatrix = instances[i].modelMatrix; // Instance matrix is relative to center

      var instanceMatrix = Matrix4.clone(modelMatrix, scratchMatrix);
      instanceMatrix[12] -= collectionCenter.x;
      instanceMatrix[13] -= collectionCenter.y;
      instanceMatrix[14] -= collectionCenter.z;
      var offset = i * vertexSizeInFloats; // First three rows of the model matrix

      bufferData[offset + 0] = instanceMatrix[0];
      bufferData[offset + 1] = instanceMatrix[4];
      bufferData[offset + 2] = instanceMatrix[8];
      bufferData[offset + 3] = instanceMatrix[12];
      bufferData[offset + 4] = instanceMatrix[1];
      bufferData[offset + 5] = instanceMatrix[5];
      bufferData[offset + 6] = instanceMatrix[9];
      bufferData[offset + 7] = instanceMatrix[13];
      bufferData[offset + 8] = instanceMatrix[2];
      bufferData[offset + 9] = instanceMatrix[6];
      bufferData[offset + 10] = instanceMatrix[10];
      bufferData[offset + 11] = instanceMatrix[14];
    }

    return bufferData;
  }

  function getPickIdBufferTypedArray(mesh, context, creating) {
    var i;
    var instances = creating ? mesh._instances : mesh._availableInstances;
    var instancesLength = instances.length;
    var pickIdBuffer = mesh._pickIdBufferTypedArray;

    if (!pickIdBuffer || instancesLength * 4 > pickIdBuffer.length) {
      pickIdBuffer = new Uint8Array(instancesLength * 4);
    }

    mesh._pickIdBufferTypedArray = pickIdBuffer;

    for (i = 0; i < instancesLength; ++i) {
      var instance = instances[i];
      var pickId = mesh._pickIds[instance.instanceId];

      if (!pickId) {
        pickId = context.createPickId(instance);
        mesh._pickIds[instance.instanceId] = pickId;
      }

      var pickColor = pickId.color;
      var offset = i * 4;
      pickIdBuffer[offset] = Color.floatToByte(pickColor.red);
      pickIdBuffer[offset + 1] = Color.floatToByte(pickColor.green);
      pickIdBuffer[offset + 2] = Color.floatToByte(pickColor.blue);
      pickIdBuffer[offset + 3] = Color.floatToByte(pickColor.alpha);
    }

    return pickIdBuffer;
  }

  function getInstancedAttribTypedArray(mesh, instancedAttribute, creating) {
    var i; // var instances = mesh._availableInstances;

    var instances = creating ? mesh._instances : mesh._availableInstances;
    var instancesLength = instances.length;
    var name = instancedAttribute.name;
    var componentsPerAttribute;
    var isColorValue = instancedAttribute["default"] instanceof Color;

    if (typeof instancedAttribute["default"] == 'number') {
      componentsPerAttribute = 1;
    } else if (instancedAttribute["default"] instanceof Cartesian2) {
      componentsPerAttribute = 2;
    } else if (instancedAttribute["default"] instanceof Cartesian3) {
      componentsPerAttribute = 3;
    } else if (instancedAttribute["default"] instanceof Cartesian4) {
      componentsPerAttribute = 4;
    } else if (isColorValue) {
      componentsPerAttribute = 4;
    }

    var bufferData = mesh['_' + name + 'BufferTypedArray'];

    if (!bufferData || instancesLength * componentsPerAttribute > bufferData.length) {
      if (isColorValue) {
        bufferData = new Uint8Array(instancesLength * componentsPerAttribute);
      } else {
        bufferData = new Float32Array(instancesLength * componentsPerAttribute);
      }
    }

    mesh['_' + name + 'BufferTypedArray'] = bufferData;

    if (isColorValue) {
      for (i = 0; i < instancesLength; ++i) {
        var instance = instances[i];
        var val = instance[name];
        var offset = i * componentsPerAttribute;
        bufferData[offset] = Color.floatToByte(val.red);
        bufferData[offset + 1] = Color.floatToByte(val.green);
        bufferData[offset + 2] = Color.floatToByte(val.blue);
        bufferData[offset + 3] = Color.floatToByte(val.alpha);
      }
    } else if (typeof instancedAttribute["default"] == 'number') {
      for (i = 0; i < instancesLength; ++i) {
        var instance = instances[i];
        var val = instance[name];
        bufferData[i] = val;
      }
    } else if (instancedAttribute["default"] instanceof Cartesian2) {
      for (i = 0; i < instancesLength; ++i) {
        var instance = instances[i];
        var val = instance[name];
        var offset = i * componentsPerAttribute;
        bufferData[offset] = val.x;
        bufferData[offset + 1] = val.y;
      }
    } else if (instancedAttribute["default"] instanceof Cartesian3) {
      for (i = 0; i < instancesLength; ++i) {
        var instance = instances[i];
        var val = instance[name];
        var offset = i * componentsPerAttribute;
        bufferData[offset] = val.x;
        bufferData[offset + 1] = val.y;
        bufferData[offset + 2] = val.z;
      }
    } else if (instancedAttribute["default"] instanceof Cartesian4) {
      for (i = 0; i < instancesLength; ++i) {
        var instance = instances[i];
        var val = instance[name];
        var offset = i * componentsPerAttribute;
        bufferData[offset] = val.x;
        bufferData[offset + 1] = val.y;
        bufferData[offset + 2] = val.z;
        bufferData[offset + 3] = val.w;
      }
    }

    return bufferData;
  }

  function createMeshInstancedAttributes(mesh, context, vertexArrayAttributes, attributeLocations, maxAttribLocation) {
    var instancedAttributes = mesh.instancedAttributes;
    instancedAttributes.forEach(function (instancedAttribute) {
      var name = instancedAttribute.name;
      attributeLocations[name] = ++maxAttribLocation;
      var buffer = Buffer.createVertexBuffer({
        context: context,
        typedArray: getInstancedAttribTypedArray(mesh, instancedAttribute, true),
        usage: 35044
      });
      instancedAttribute._buffer = buffer;
      var attribute = {
        index: attributeLocations[instancedAttribute.name],
        vertexBuffer: buffer,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype.FLOAT,
        normalize: false,
        offsetInBytes: 0,
        strideInBytes: 0,
        instanceDivisor: 1
      };

      if (typeof instancedAttribute["default"] == 'number') {
        attribute.componentsPerAttribute = 1;
      } else if (instancedAttribute["default"] instanceof Cartesian2) {
        attribute.componentsPerAttribute = 2;
      } else if (instancedAttribute["default"] instanceof Cartesian3) {
        attribute.componentsPerAttribute = 3;
      } else if (instancedAttribute["default"] instanceof Cartesian4) {
        attribute.componentsPerAttribute = 4;
      } else if (instancedAttribute["default"] instanceof Color) {
        attribute.componentDatatype = ComponentDatatype.UNSIGNED_BYTE;
        attribute.normalize = true;
        attribute.componentsPerAttribute = 4;
      }

      vertexArrayAttributes.push(attribute);
    });
    return maxAttribLocation;
  }

  function createInstanceMvMatrixVertexBuffer(mesh, context) {
    var pickIdBuffer = getPickIdBufferTypedArray(mesh, context, true);
    mesh._pickIdBuffer = Buffer.createVertexBuffer({
      context: context,
      typedArray: pickIdBuffer,
      usage: 35044
    });
    var vertexBufferTypedArray = getVertexBufferTypedArray(mesh, true);
    mesh._vertexBuffer = Buffer.createVertexBuffer({
      context: context,
      typedArray: vertexBufferTypedArray,
      usage: 35044
    });
  }

  function copyFromBufferView(vertexBuffer, arrayView, offsetInBytes) {
    offsetInBytes = offsetInBytes || 0;
    var gl = vertexBuffer._gl;
    var target = vertexBuffer._bufferTarget;
    gl.bindBuffer(target, vertexBuffer._buffer);
    gl.bufferData(target, arrayView, gl.DYNAMIC_DRAW);
    gl.bindBuffer(target, null);
  }

  function updateInstanceVertexBuffer(mesh, context) {
    var vertexBufferTypedArray = getVertexBufferTypedArray(mesh);
    copyFromBufferView(mesh._vertexBuffer, vertexBufferTypedArray);
    var pickIdBufferTypedArray = getPickIdBufferTypedArray(mesh, context);
    copyFromBufferView(mesh._pickIdBuffer, pickIdBufferTypedArray);
    var instancedAttributes = mesh.instancedAttributes;
    instancedAttributes.forEach(function (instancedAttribute) {
      var bufferTypedArray = getInstancedAttribTypedArray(mesh, instancedAttribute);
      copyFromBufferView(instancedAttribute._buffer, bufferTypedArray);
    });
  }

  function createPickIds(mesh, context) {
    // PERFORMANCE_IDEA: we could skip the pick buffer completely by allocating
    // a continuous range of pickIds and then converting the base pickId + batchId
    // to RGBA in the shader.  The only consider is precision issues, which might
    // not be an issue in WebGL 2.
    var instances = mesh._instances;
    var instancesLength = instances.length;
    var pickIds = new Array(instancesLength);

    for (var i = 0; i < instancesLength; ++i) {
      pickIds[i] = context.createPickId(instances[i]);
    }

    return pickIds;
  } //创建实例化mesh所有实例的整体外包围球，并计算中心，因为cesium的实例化渲染传递矩阵是需要这个中心加入运算


  function createInstanceBoundingSphere(mesh) {
    var instancesLength = mesh._instances.length;
    var points = new Array(instancesLength);

    for (var i = 0; i < instancesLength; ++i) {
      points[i] = Matrix4.getTranslation(mesh._instances[i].modelMatrix, new Cartesian3());
    }

    mesh._boundingSphere = BoundingSphere.fromPoints(points);
    Cartesian3.clone(mesh._boundingSphere.center, mesh._center);
  }
  /**
   * 转换Three.js BufferGeometry的InterleavedBufferAttribute
   * @param {string} name
   * @param {THREE.InterleavedBufferAttribute|THREE.InstancedInterleavedBuffer} attribute 
   * @param {{[key:string]:number}}attributeLocations
   * @param {Cesium.Context}
   * @private
   */


  function createInterleavedAttribute3js(name, attribute, attributeLocations, context) {
    var data = attribute.data;
    var stride = data.stride;
    var offset = attribute.offset;
    var array = data.array;
    var bytesPerElement = array.constructor.BYTES_PER_ELEMENT;
    var vertexBuffer = Buffer.createVertexBuffer({
      context: context,
      typedArray: array,
      usage: data.usage
    });
    var vaAttribute = {
      index: attributeLocations[name],
      vertexBuffer: vertexBuffer,
      componentDatatype: _GeometryUtils["default"].getAttributeComponentType(array),
      componentsPerAttribute: attribute.itemSize,
      normalize: attribute.normalized,
      offsetInBytes: offset * bytesPerElement,
      strideInBytes: stride * bytesPerElement
    };

    if (data && data.isInstancedInterleavedBuffer) {
      vaAttribute.instanceDivisor = data.meshPerAttribute || 1;
    }

    return vaAttribute;
  }
  /**
   * 
   * @param {string} name 
   * @param {THREE.BufferAttribute|THREE.InstancedBufferAttribute} attribute 
   * @param {{[key:string]:number}} attributeLocations 
   * @param {Cesium.Context} context 
   * @param {Cesium.BufferUsage}bufferUsage
   * @param {{start:number,count:number}}[group]
   * @returns {Cesium.VertexArrayAttribute}
   * @private
   */


  function createAttribute3js(name, attribute, attributeLocations, context, bufferUsage, group) {
    try {
      var array = attribute.array;

      if (array instanceof Uint32Array) {
        array = new Float32Array(array);
        console.warn('Mesh3D.CesiumVertextArrays：暂不支持Uint32Array类型顶点数组，已经强制替换为Float32Array（这会增加内存开销）');
      }

      var vertexBuffer = Buffer.createVertexBuffer({
        context: context,
        typedArray: array,
        usage: attribute.usage || bufferUsage
      });
      var vaAttribute = {
        index: attributeLocations[name],
        vertexBuffer: vertexBuffer,
        componentDatatype: _GeometryUtils["default"].getAttributeComponentType(array),
        componentsPerAttribute: attribute.itemSize,
        normalize: attribute.normalized
      };

      if (attribute.isInstancedBufferAttribute) {
        vaAttribute.offsetInBytes = 0;
        vaAttribute.strideInBytes = 0;
        vaAttribute.instanceDivisor = attribute.meshPerAttribute || 1;
      }

      return vaAttribute;
    } catch (err) {
      debugger;
      throw err;
    }
  }
  /**
   * 
   * 
   * @param {object} options
   * @param {THREE.BufferGeometry} options.geometry 
   * @param {Cesium.Context} options.context 
   * @param {Cesium.BufferUsage} [options.bufferUsage]
   * @param {{start:number,count:number}}[options.group]
   * @param {ArrayBufferView}[options.indices]
   * @returns {Cesium.Buffer}
   * @private 
   */


  function createIndexBuffer3js(options) {
    // var mesh = options.mesh;
    // var geometry = mesh.geometry;
    var geometry = options.geometry;
    var groups = geometry.groups;
    var bufferUsage = defaultValue(options.bufferUsage, 35048);
    var context = options.context;
    var group = options.group;
    var groupOptimized = options.groupOptimized; //索引buffer

    var indices = options.indices,
        indexBuffer,
        index = geometry.index;

    if (!indices) {
      if (typeof group != 'undefined' && groups.length > 1) {
        //处理threejs用gl.drawArrays绘制的部分，转成用drawElements绘制
        indices = _GeometryUtils["default"].genGeometryIndices(geometry, group, groupOptimized);
      } else if (index) {
        indices = index.array;
      }
    }

    if (indices && indices.length > 0) {
      var indexDatatype = 5123;
      if (indices instanceof Uint8Array) indexDatatype = 5121;else if (indices instanceof Uint32Array) indexDatatype = 5125;
      indexBuffer = Buffer.createIndexBuffer({
        context: context,
        typedArray: indices,
        usage: bufferUsage,
        indexDatatype: indexDatatype
      });
    }

    return indexBuffer;
  }
  /**
   * 
   * 
   * @param {object} options
   * @param {THREE.BufferGeometry} options.geometry 
   * @param {Cesium.Context} options.context 
   * @param {{[key:string]:number}} options.attributeLocations 
   * @param {Cesium.VertexArrayAttribute[]}[options.vertexArrayAttributes]
   * @param {{start:number,count:number}}[options.group]
   * @param {ArrayBufferView}[options.indices]
   * @param {boolean}[options.useEncodedPosition=false]
   * @private
   */


  function fromBufferGeometry3js(options) {
    var geometry = options.geometry; // const position = geometry.attributes.position;

    var groups = geometry.groups; // const drawRange = geometry.drawRange;

    var context = options.context;
    var attributeLocations = options.attributeLocations;
    var group = options.group;
    var groupOptimized = options.groupOptimized;
    var bufferUsage = defaultValue(options.bufferUsage, 35048);
    var vaAttributes = [].concat(options.vertexArrayAttributes || []);
    var attributes3js = geometry.attributes;

    if (options.useEncodedPosition) {
      //positionHigh+positionLow
      attributes3js = Object.assign({}, geometry.attributes);
      var position = attributes3js.position,
          positions = position.array;
      var positionHigh = attributes3js.positionHigh = Object.assign({}, position);
      var positionLow = attributes3js.positionLow = Object.assign({}, position);
      positionHigh.array = new Float32Array(positions.length);
      positionLow.array = new Float32Array(positions.length);
      var encodedResult = {
        high: 0,
        low: 0
      };
      var factor = 1e6;
      positions.forEach(function (value, i) {
        Cesium.EncodedCartesian3.encode(value * factor, encodedResult);
        positionHigh.array[i] = encodedResult.high;
        positionLow.array[i] = encodedResult.low;
      });
      delete attributes3js.position;
    } //indexBuffer


    var indexBuffer = createIndexBuffer3js({
      geometry: geometry,
      context: context,
      group: group,
      groupOptimized: groupOptimized,
      bufferUsage: bufferUsage,
      indices: options.indices
    }); //vertexBuffer

    var instanceCount,
        vaAttributeFromCache = group && groups.length > 1;

    for (var name in attributes3js) {
      if (attributes3js.hasOwnProperty(name) && defined(attributes3js[name])) {
        var attribute3js = attributes3js[name],
            vaAttribute = vaAttributeFromCache ? _webglAttributeCache.get(attribute3js) : undefined;

        if (!vaAttribute) {
          if (attribute3js.isInterleavedBufferAttribute) {
            vaAttribute = createInterleavedAttribute3js(name, attribute3js, attributeLocations, context);
          } else {
            vaAttribute = createAttribute3js(name, attribute3js, attributeLocations, context, bufferUsage, group);
          }

          if (vaAttribute.instanceDivisor) {
            instanceCount = vaAttribute.instanceDivisor * attribute3js.count;
          }

          _webglAttributeCache.set(attribute3js, vaAttribute, geometry);
        }

        vaAttributes.push(vaAttribute);
      }
    }

    var va = new VertexArray({
      context: context,
      attributes: vaAttributes,
      indexBuffer: indexBuffer
    });
    va._attributeLocations = attributeLocations;
    va.instanceCount = instanceCount;
    attributes3js = null;
    return va;
  }
  /**
   * 
   * 
   * @param {Cesium.Geometry|THREE.BufferGeometry} geometry 
   * @param {Mesh|THREE.Mesh} mesh 
   * @param {Cesium.Context} context 
   * @param {{start:number,count:number}|number}[group] group or materialIndex
   * @param {ArrayBufferView}[indices]
   * @param {boolean}[groupOptimized]  
   */


  this.create = function (geometry, mesh, group, indices, groupOptimized) {
    var frameSate = visualizer.frameState,
        context = frameSate.context;
    var useEncodedPosition = visualizer.useEncodedPosition;
    var mesh3js = mesh;
    var attributes = geometry.attributes;

    if (mesh3js && useEncodedPosition) {
      attributes = Object.assign({}, geometry.attributes);
      attributes.positionHigh = attributes.position;
      attributes.positionLow = attributes.position;
      delete attributes.position;
    }

    var attributeLocations = GeometryPipeline.createAttributeLocations({
      attributes: attributes
    });
    var maxAttribLocation = 0,
        instanceCount;
    var va;

    for (var location in attributeLocations) {
      if (attributeLocations.hasOwnProperty(location)) {
        maxAttribLocation = Math.max(maxAttribLocation, attributeLocations[location]);
      }
    }

    var vertexArrayAttributes;

    if (mesh._instances && mesh._instances.length) {
      createInstanceBoundingSphere(mesh);
      vertexArrayAttributes = [];
      mesh._pickIds = createPickIds(mesh, context);
      createInstanceMvMatrixVertexBuffer(mesh, context);
      var vertexSizeInFloats = 12;
      var componentSizeInBytes = ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT);
      var instancedAttributes = {
        czm_modelMatrixRow0: {
          index: maxAttribLocation + 1,
          vertexBuffer: mesh._vertexBuffer,
          componentsPerAttribute: 4,
          componentDatatype: ComponentDatatype.FLOAT,
          normalize: false,
          offsetInBytes: 0,
          strideInBytes: componentSizeInBytes * vertexSizeInFloats,
          instanceDivisor: 1
        },
        czm_modelMatrixRow1: {
          index: maxAttribLocation + 2,
          vertexBuffer: mesh._vertexBuffer,
          componentsPerAttribute: 4,
          componentDatatype: ComponentDatatype.FLOAT,
          normalize: false,
          offsetInBytes: componentSizeInBytes * 4,
          strideInBytes: componentSizeInBytes * vertexSizeInFloats,
          instanceDivisor: 1
        },
        czm_modelMatrixRow2: {
          index: maxAttribLocation + 3,
          vertexBuffer: mesh._vertexBuffer,
          componentsPerAttribute: 4,
          componentDatatype: ComponentDatatype.FLOAT,
          normalize: false,
          offsetInBytes: componentSizeInBytes * 8,
          strideInBytes: componentSizeInBytes * vertexSizeInFloats,
          instanceDivisor: 1
        }
      };
      instancedAttributes.a_pickColor = {
        index: maxAttribLocation + 4,
        vertexBuffer: mesh._pickIdBuffer,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,
        normalize: true,
        offsetInBytes: 0,
        strideInBytes: 0,
        instanceDivisor: 1
      };

      for (var location in instancedAttributes) {
        if (instancedAttributes.hasOwnProperty(location)) {
          attributeLocations[location] = ++maxAttribLocation;
          vertexArrayAttributes.push(instancedAttributes[location]);
        }
      }

      maxAttribLocation = createMeshInstancedAttributes(mesh, context, vertexArrayAttributes, attributeLocations, maxAttribLocation);
    } else if (mesh3js.isInstancedMesh) {
      vertexArrayAttributes = [];
      var instanceMatrix = mesh3js.instanceMatrix,
          instanceColor = mesh3js.instanceColor;
      var vertexSizeInFloats = 16;
      var componentSizeInBytes = ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT);
      var vertexBuffer = Buffer.createVertexBuffer({
        context: context,
        typedArray: instanceMatrix.array,
        usage: 35044
      });
      var instancedAttributes = {};

      for (var i = 0; i < 4; i++) {
        var location = 'instanceMatrix' + (i ? i : ''),
            index = ++maxAttribLocation;
        var instancedAttribute = {
          index: index,
          vertexBuffer: vertexBuffer,
          componentsPerAttribute: 4,
          componentDatatype: ComponentDatatype.FLOAT,
          normalize: false,
          offsetInBytes: i * vertexSizeInFloats,
          strideInBytes: componentSizeInBytes * vertexSizeInFloats,
          instanceDivisor: 1
        };
        vertexArrayAttributes.push(instancedAttribute);
        attributeLocations[location] = index;
      }

      if (mesh3js.instanceColor) {
        attributeLocations['instanceColor'] = ++maxAttribLocation;
        var instanceColor = createAttribute3js('instanceColor', mesh3js.instanceColor, attributeLocations, context, group, 35044);
        instanceColor.instanceDivisor = 1;
        vertexArrayAttributes.push(instanceColor);
      }

      instanceCount = mesh3js.count;
    }

    if (geometry.isBufferGeometry) {
      va = fromBufferGeometry3js({
        context: context,
        geometry: geometry,
        attributeLocations: attributeLocations,
        bufferUsage: 35044,
        vertexArrayAttributes: vertexArrayAttributes,
        group: group,
        indices: indices,
        groupOptimized: groupOptimized,
        useEncodedPosition: useEncodedPosition
      });
    } else {
      attributes = geometry.attributes;

      for (var key in attributes) {
        var attribute = attributes[key];
        if (!attribute) delete attributes[key];else if (attribute.componentDatatype == ComponentDatatype.DOUBLE) {
          attribute.values = new Float32Array(attribute.values);
        }
      }

      va = VertexArray.fromGeometry({
        context: context,
        geometry: geometry,
        attributeLocations: attributeLocations,
        bufferUsage: 35044,
        vertexArrayAttributes: vertexArrayAttributes
      });
    }

    if (vertexArrayAttributes && vertexArrayAttributes.length) {
      va._cacehVertexArrayAttributes = vertexArrayAttributes;
    }

    va._attributeLocations = attributeLocations;
    if (instanceCount) va.instanceCount = instanceCount;

    va._attributes.sort(function (a, b) {
      return a.index - b.index;
    });

    return va;
  };
  /**
   * 
   * @param {Mesh|THREE.Mesh} mesh  
   * @param {Cesium.DrawCommand} command 
   * @param {THREE.BufferGeometry}[geometry3js]
   * @param {boolean}[forceUpdate]
   * @private
   */


  this.update = function (mesh, command, geometry3js, forceUpdate) {
    var frameSate = visualizer.frameState,
        context = frameSate.context;
    var mesh3js = mesh;
    if (!geometry3js && mesh3js) geometry3js = _WebGLGeometries["default"].get(mesh3js.geometry);
    var geometry = mesh.geometry; //更新属性缓冲区

    var attributes = geometry.attributes;
    var attributes3js = geometry3js && geometry3js.attributes;
    var va = command.vertexArray;
    var vaNeedsUpdate = false;
    var morph = false,
        skinning = false;

    if (mesh3js) {
      morph = mesh3js.material.morphTargets || mesh3js.material.morphNormals;
      skinning = mesh3js.isSkinnedMesh;
    }

    if (!skinning && !morph) {
      for (var name in attributes) {
        var attribute = attributes[name];
        if (!attribute) continue; // if (morph && (name.includes('morphTarget') || name.includes('morphNormal'))) continue;

        var needsUpdate = forceUpdate || attribute.needsUpdate != false;
        if (!attributes3js && needsUpdate == false) continue;

        if (updateVerexAttribute(va, name, attributes3js && attributes3js[name] || attribute, needsUpdate)) {
          attribute.needsUpdate = false;
        } else {
          vaNeedsUpdate = true;
          break;
        }
      }
    } //更新索引缓冲区


    if (!vaNeedsUpdate && geometry.indexNeedsUpdate) {
      var ib = va.indexBuffer;
      geometry.indexNeedsUpdate = false;
      ib.copyFromArrayView(geometry.indices, 0);
    }

    if (!vaNeedsUpdate && mesh._instances && mesh._instances.length) {
      updateInstanceVertexBuffer(mesh, context);
    } //重建vertexArray


    if (vaNeedsUpdate) {
      var va = command.vertexArray;

      if (!va.isDestroyed()) {
        va.destroy();

        if (_webglAttributeCache) {
          for (var name in attributes3js) {
            if (attributes3js.hasOwnProperty(name) && attributes3js[name]) {
              _webglAttributeCache["delete"](attributes3js[name]);
            }
          }

          debugger;
        }
      }

      command.vertexArray = this.create(mesh, context);

      for (var name in attributes) {
        if (attributes.hasOwnProperty(name) && attributes[name]) {
          attributes[name].needsUpdate = false;
        }
      }

      mesh.geometry.indexNeedsUpdate = false;
    } else if (mesh3js && mesh3js.isInstancedMesh) {
      var instanceMatrix = mesh3js.instanceMatrix,
          instanceColor = mesh3js.instanceColor;

      if (va._attributes[va._attributeLocations['instanceMatrix']].version != instanceMatrix.version) {
        updateVerexAttribute(va, 'instanceMatrix', instanceMatrix);
      }

      if (instanceColor && va._attributes[va._attributeLocations['instanceColor']].version != instanceColor.version) {
        updateVerexAttribute(va, 'instanceColor', instanceColor);
      }
    }

    return vaNeedsUpdate;
  };
  /**
   * 
   * @param {Mesh|THREE.Mesh} mesh 
   * @param {string} attributeName 
   * @param {THREE.BufferAttribute|Cesium.GeometryAttribute}geometryAttribute
   * @private
   */


  this.updateVerexBuffer = function (mesh, attributeName, geometryAttribute) {
    var renderItems = mesh.renderItems; //(mesh._actualMesh || mesh).command;

    if (!renderItems) return;
    if (attributeName == 'position') debugger;
    renderItems.forEach(function (renderItem) {
      if (!renderItem) return;
      var drawCommand = renderItem.drawCommand;
      var va = drawCommand.vertexArray;
      updateVerexAttribute(va, attributeName, geometryAttribute, true);
    });
  };

  function updateVerexAttribute(va, name, geometryAttribute, needsUpdate) {
    var attrLocation = va._attributeLocations[name];
    if (attrLocation == undefined) return false;
    var vaAttr = va._attributes[attrLocation]; // needsUpdate = needsUpdate || vaAttr.version != geometryAttribute.version;
    // if (!needsUpdate) return true;

    var vb = vaAttr.vertexBuffer;
    var arrayView = geometryAttribute.values || geometryAttribute.array;
    var BYTES_PER_ELEMENT = arrayView.constructor.BYTES_PER_ELEMENT;

    if (vb._sizeInBytes != arrayView.length * BYTES_PER_ELEMENT) {
      return false;
    }

    vb.copyFromArrayView(arrayView, 0); // vaAttr.version = geometryAttribute.version;

    return true;
  }
  /**
   * 
   * @param {THREE.BufferGeometry} geometry3js 
   */


  this["delete"] = function (geometry3js) {
    if (_webglAttributeCache) {
      var attributes3js = geometry3js.attributes;

      for (var name in attributes3js) {
        if (attributes3js.hasOwnProperty(name) && attributes3js[name]) {
          _webglAttributeCache["delete"](attributes3js[name]);
        }
      }
    }
  };
}

var _default = CesiumVertextArrays;
exports["default"] = _default;

},{"s_24":2,"e_23":22,"3_27":35,"M_0":241}],12:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("e_45"));

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

/**
 * threejs constants=>cesium constants
 */
var ConstantMap = /*#__PURE__*/function () {
  function ConstantMap() {
    (0, _classCallCheck2["default"])(this, ConstantMap);
  }

  (0, _createClass2["default"])(ConstantMap, null, [{
    key: "init",
    value: function init() {
      var _this$_formatsMap, _this$_typesMap, _this$_minFilterMap, _this$_magFilterMap, _this$_textureWrapMap, _this$_depthFuncMap, _this$_factorMap, _this$_equationMap;

      if (this.hasInit) return;
      this.hasInit = true;
      this._formatsMap = (_this$_formatsMap = {}, (0, _defineProperty2["default"])(_this$_formatsMap, 1022, 6407), (0, _defineProperty2["default"])(_this$_formatsMap, 1023, 6408), (0, _defineProperty2["default"])(_this$_formatsMap, 1026, 6402), (0, _defineProperty2["default"])(_this$_formatsMap, 1021, 6406), (0, _defineProperty2["default"])(_this$_formatsMap, 1027, 34041), (0, _defineProperty2["default"])(_this$_formatsMap, 1024, 6409), (0, _defineProperty2["default"])(_this$_formatsMap, 1025, 6410), (0, _defineProperty2["default"])(_this$_formatsMap, 33777, 33777), (0, _defineProperty2["default"])(_this$_formatsMap, 33778, 33778), (0, _defineProperty2["default"])(_this$_formatsMap, 33779, 33779), (0, _defineProperty2["default"])(_this$_formatsMap, 35843, 35843), (0, _defineProperty2["default"])(_this$_formatsMap, 35842, 35842), (0, _defineProperty2["default"])(_this$_formatsMap, 33776, 33776), (0, _defineProperty2["default"])(_this$_formatsMap, 36196, 36196), (0, _defineProperty2["default"])(_this$_formatsMap, 35841, 35841), (0, _defineProperty2["default"])(_this$_formatsMap, 35840, 35840), _this$_formatsMap);
      this._typesMap = (_this$_typesMap = {}, (0, _defineProperty2["default"])(_this$_typesMap, 1015, 5126), (0, _defineProperty2["default"])(_this$_typesMap, 1009, 5121), (0, _defineProperty2["default"])(_this$_typesMap, 1016, 36193), (0, _defineProperty2["default"])(_this$_typesMap, 1014, 5125), (0, _defineProperty2["default"])(_this$_typesMap, 1020, 34042), (0, _defineProperty2["default"])(_this$_typesMap, 1012, 5123), (0, _defineProperty2["default"])(_this$_typesMap, 1017, 32819), (0, _defineProperty2["default"])(_this$_typesMap, 1018, 32820), (0, _defineProperty2["default"])(_this$_typesMap, 1019, 33635), _this$_typesMap);
      this._minFilterMap = (_this$_minFilterMap = {}, (0, _defineProperty2["default"])(_this$_minFilterMap, 1006, 9729), (0, _defineProperty2["default"])(_this$_minFilterMap, 1008, 9987), (0, _defineProperty2["default"])(_this$_minFilterMap, 1005, 9986), (0, _defineProperty2["default"])(_this$_minFilterMap, 1003, 9728), (0, _defineProperty2["default"])(_this$_minFilterMap, 1007, 9985), (0, _defineProperty2["default"])(_this$_minFilterMap, 1004, 9984), _this$_minFilterMap);
      this._magFilterMap = (_this$_magFilterMap = {}, (0, _defineProperty2["default"])(_this$_magFilterMap, 1003, 9728), (0, _defineProperty2["default"])(_this$_magFilterMap, 1006, 9729), _this$_magFilterMap);
      this._textureWrapMap = (_this$_textureWrapMap = {}, (0, _defineProperty2["default"])(_this$_textureWrapMap, 1001, 33071), (0, _defineProperty2["default"])(_this$_textureWrapMap, 1002, 33648), (0, _defineProperty2["default"])(_this$_textureWrapMap, 1000, 10497), _this$_textureWrapMap);
      this._depthFuncMap = (_this$_depthFuncMap = {}, (0, _defineProperty2["default"])(_this$_depthFuncMap, 0, 512), (0, _defineProperty2["default"])(_this$_depthFuncMap, 1, 519), (0, _defineProperty2["default"])(_this$_depthFuncMap, 2, 513), (0, _defineProperty2["default"])(_this$_depthFuncMap, 3, 515), (0, _defineProperty2["default"])(_this$_depthFuncMap, 4, 514), (0, _defineProperty2["default"])(_this$_depthFuncMap, 5, 518), (0, _defineProperty2["default"])(_this$_depthFuncMap, 6, 516), (0, _defineProperty2["default"])(_this$_depthFuncMap, 7, 517), _this$_depthFuncMap);
      this._factorMap = (_this$_factorMap = {}, (0, _defineProperty2["default"])(_this$_factorMap, 200, 0), (0, _defineProperty2["default"])(_this$_factorMap, 201, 1), (0, _defineProperty2["default"])(_this$_factorMap, 202, 768), (0, _defineProperty2["default"])(_this$_factorMap, 204, 770), (0, _defineProperty2["default"])(_this$_factorMap, 210, 776), (0, _defineProperty2["default"])(_this$_factorMap, 208, 774), (0, _defineProperty2["default"])(_this$_factorMap, 206, 772), (0, _defineProperty2["default"])(_this$_factorMap, 203, 769), (0, _defineProperty2["default"])(_this$_factorMap, 205, 771), (0, _defineProperty2["default"])(_this$_factorMap, 209, 775), (0, _defineProperty2["default"])(_this$_factorMap, 207, 773), _this$_factorMap);
      this._equationMap = (_this$_equationMap = {}, (0, _defineProperty2["default"])(_this$_equationMap, 100, 32774), (0, _defineProperty2["default"])(_this$_equationMap, 101, 32778), (0, _defineProperty2["default"])(_this$_equationMap, 102, 32779), (0, _defineProperty2["default"])(_this$_equationMap, 103, 32775), (0, _defineProperty2["default"])(_this$_equationMap, 104, 32776), _this$_equationMap);
    }
  }, {
    key: "formatsMap",
    get: function get() {
      this.init();
      return this._formatsMap;
    }
  }, {
    key: "typesMap",
    get: function get() {
      this.init();
      return this._typesMap;
    }
  }, {
    key: "magFilterMap",
    get: function get() {
      this.init();
      return this._magFilterMap;
    }
  }, {
    key: "minFilterMap",
    get: function get() {
      this.init();
      return this._minFilterMap;
    }
  }, {
    key: "textureWrapMap",
    get: function get() {
      this.init();
      return this._textureWrapMap;
    }
  }, {
    key: "depthFuncMap",
    get: function get() {
      this.init();
      return this._depthFuncMap;
    }
  }, {
    key: "factorMap",
    get: function get() {
      this.init();
      return this._factorMap;
    }
  }, {
    key: "equationMap",
    get: function get() {
      this.init();
      return this._equationMap;
    }
  }]);
  return ConstantMap;
}();

var _default = ConstantMap;
exports["default"] = _default;

},{"e_1":235,"s_2":236,"e_45":237,"M_0":241}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
// import Cartesian2 from "../core/Cartesian2.js";
// import Check from "../core/Check.js";
// import createGuid from "../core/createGuid.js";
// import defaultValue from "../core/defaultValue.js";
// import defined from "../core/defined.js";
// import destroyObject from "../core/destroyObject.js";
// import DeveloperError from "../core/DeveloperError.js";
// import CesiumMath from "../core/Math.js";
// import PixelFormat from "../core/PixelFormat.js";
// import WebGLConstants from "../core/WebGLConstants.js";
// import ContextLimits from "./ContextLimits.js";
// import MipmapHint from "./MipmapHint.js";
// import PixelDatatype from "./PixelDatatype.js";
// import Sampler from "./Sampler.js";
// import TextureMagnificationFilter from "./TextureMagnificationFilter.js";
// import TextureMinificationFilter from "./TextureMinificationFilter.js";
var Cartesian2, Check, createGuid, defaultValue, defined, destroyObject, DeveloperError, CesiumMath, PixelFormat, WebGLConstants, ContextLimits, MipmapHint, PixelDatatype, Sampler, TextureMagnificationFilter, TextureMinificationFilter;

function initDeps$DDSTexture() {
  if (Cartesian2) return;
  var _Cesium = Cesium;
  Cartesian2 = _Cesium.Cartesian2;
  Check = _Cesium.Check;
  createGuid = _Cesium.createGuid;
  defaultValue = _Cesium.defaultValue;
  defined = _Cesium.defined;
  destroyObject = _Cesium.destroyObject;
  DeveloperError = _Cesium.DeveloperError;
  CesiumMath = _Cesium.Math;
  PixelFormat = _Cesium.PixelFormat;
  WebGLConstants = _Cesium.WebGLConstants;
  ContextLimits = _Cesium.ContextLimits;
  MipmapHint = _Cesium.MipmapHint;
  PixelDatatype = _Cesium.PixelDatatype;
  Sampler = _Cesium.Sampler;
  TextureMagnificationFilter = _Cesium.TextureMagnificationFilter;
  TextureMinificationFilter = _Cesium.TextureMinificationFilter;
}
/**
 * @private
 */


function DDSTexture(options) {
  initDeps$DDSTexture();
  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);
  // Check.defined("options.context", options.context);
  //>>includeEnd('debug');

  var context = options.context;
  var width = options.width;
  var height = options.height;
  var source = options.source;

  if (defined(source)) {
    if (!defined(width)) {
      width = defaultValue(source.videoWidth, source.width);
    }

    if (!defined(height)) {
      height = defaultValue(source.videoHeight, source.height);
    }
  }

  var pixelFormat = defaultValue(options.pixelFormat, 6408);
  var pixelDatatype = defaultValue(options.pixelDatatype, 5121);
  var internalFormat = pixelFormat;
  var isCompressed = PixelFormat.isCompressedFormat(internalFormat);

  if (context.webgl2) {
    if (pixelFormat === 34041) {
      internalFormat = 35056;
    } else if (pixelFormat === 6402) {
      if (pixelDatatype === 5123) {
        internalFormat = 33189;
      } else if (pixelDatatype === 5125) {
        internalFormat = 33190;
      }
    }

    if (pixelDatatype === 5126) {
      switch (pixelFormat) {
        case 6408:
          internalFormat = 34836;
          break;

        case 6407:
          internalFormat = 34837;
          break;

        case PixelFormat.RG:
          internalFormat = 33328;
          break;

        case PixelFormat.R:
          internalFormat = 33326;
          break;
      }
    } else if (pixelDatatype === 36193) {
      switch (pixelFormat) {
        case 6408:
          internalFormat = 34842;
          break;

        case 6407:
          internalFormat = 34843;
          break;

        case PixelFormat.RG:
          internalFormat = 33327;
          break;

        case PixelFormat.R:
          internalFormat = 33325;
          break;
      }
    }
  } //>>includeStart('debug', pragmas.debug);
  // if (!defined(width) || !defined(height)) {
  //     throw new DeveloperError(
  //         "options requires a source field to create an initialized texture or width and height fields to create a blank texture."
  //     );
  // }
  // Check.typeOf.number.greaterThan("width", width, 0);
  // if (width > ContextLimits.maximumTextureSize) {
  //     throw new DeveloperError(
  //         "Width must be less than or equal to the maximum texture size (" +
  //         ContextLimits.maximumTextureSize +
  //         ").  Check maximumTextureSize."
  //     );
  // }
  // Check.typeOf.number.greaterThan("height", height, 0);
  // if (height > ContextLimits.maximumTextureSize) {
  //     throw new DeveloperError(
  //         "Height must be less than or equal to the maximum texture size (" +
  //         ContextLimits.maximumTextureSize +
  //         ").  Check maximumTextureSize."
  //     );
  // }
  // if (!PixelFormat.validate(pixelFormat)) {
  //     throw new DeveloperError("Invalid options.pixelFormat.");
  // }
  // if (!isCompressed && !PixelDatatype.validate(pixelDatatype)) {
  //     throw new DeveloperError("Invalid options.pixelDatatype.");
  // }
  // if (
  //     pixelFormat === 6402 &&
  //     pixelDatatype !== 5123 &&
  //     pixelDatatype !== 5125
  // ) {
  //     throw new DeveloperError(
  //         "When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT."
  //     );
  // }
  // if (
  //     pixelFormat === 34041 &&
  //     pixelDatatype !== 34042
  // ) {
  //     throw new DeveloperError(
  //         "When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8."
  //     );
  // }
  // if (pixelDatatype === 5126 && !context.floatingPointTexture) {
  //     throw new DeveloperError(
  //         "When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture."
  //     );
  // }
  // if (
  //     pixelDatatype === 36193 &&
  //     !context.halfFloatingPointTexture
  // ) {
  //     throw new DeveloperError(
  //         "When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture."
  //     );
  // }
  // if (PixelFormat.isDepthFormat(pixelFormat)) {
  //     if (defined(source)) {
  //         throw new DeveloperError(
  //             "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided."
  //         );
  //     }
  //     if (!context.depthTexture) {
  //         throw new DeveloperError(
  //             "When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture."
  //         );
  //     }
  // }
  // if (isCompressed) {
  //     if (!defined(source) || !defined(source.arrayBufferView)) {
  //         throw new DeveloperError(
  //             "When options.pixelFormat is compressed, options.source.arrayBufferView must be defined."
  //         );
  //     }
  //     if (PixelFormat.isDXTFormat(internalFormat) && !context.s3tc) {
  //         throw new DeveloperError(
  //             "When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_texture_compression_s3tc extension. Check context.s3tc."
  //         );
  //     } else if (PixelFormat.isPVRTCFormat(internalFormat) && !context.pvrtc) {
  //         throw new DeveloperError(
  //             "When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_texture_compression_pvrtc extension. Check context.pvrtc."
  //         );
  //     } else if (PixelFormat.isETC1Format(internalFormat) && !context.etc1) {
  //         throw new DeveloperError(
  //             "When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_texture_compression_etc1 extension. Check context.etc1."
  //         );
  //     }
  //     if (
  //         PixelFormat.compressedTextureSizeInBytes(
  //             internalFormat,
  //             width,
  //             height
  //         ) !== source.arrayBufferView.byteLength
  //     ) {
  //         throw new DeveloperError(
  //             "The byte length of the array buffer is invalid for the compressed texture with the given width and height."
  //         );
  //     }
  // }
  //>>includeEnd('debug');
  // Use premultiplied alpha for opaque textures should perform better on Chrome:
  // http://media.tojicode.com/webglCamp4/#20


  var preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === 6407 || pixelFormat === 6409;
  var flipY = defaultValue(options.flipY, true);
  var initialized = true;
  var gl = context._gl;
  var textureTarget = gl.TEXTURE_2D;
  var texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  var unpackAlignment = 4;

  if (defined(source) && defined(source.arrayBufferView) && !isCompressed) {
    unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, width);
  }

  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  var floor = Math.floor;

  if (defined(source)) {
    if (defined(source.arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); // Source: typed array

      var arrayBufferView = source.arrayBufferView;

      if (isCompressed) {
        gl.compressedTexImage2D(textureTarget, 0, internalFormat, width, height, 0, arrayBufferView);

        if (defined(source.mipLevels)) {
          var mipWidth = width;
          var mipHeight = height;

          for (var i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = floor(mipWidth / 2) | 0;

            if (mipWidth < 1) {
              mipWidth = 1;
            }

            mipHeight = floor(mipHeight / 2) | 0;

            if (mipHeight < 1) {
              mipHeight = 1;
            }

            gl.compressedTexImage2D(textureTarget, i + 1, internalFormat, mipWidth, mipHeight, 0, source.mipLevels[i]);
          }
        }
      } else {
        if (flipY) {
          arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);
        }

        gl.texImage2D(textureTarget, 0, internalFormat, width, height, 0, pixelFormat, pixelDatatype, arrayBufferView);

        if (defined(source.mipLevels)) {
          var mipWidth = width;
          var mipHeight = height;

          for (var i = 0; i < source.mipLevels.length; ++i) {
            mipWidth = floor(mipWidth / 2) | 0;

            if (mipWidth < 1) {
              mipWidth = 1;
            }

            mipHeight = floor(mipHeight / 2) | 0;

            if (mipHeight < 1) {
              mipHeight = 1;
            }

            gl.texImage2D(textureTarget, i + 1, internalFormat, mipWidth, mipHeight, 0, pixelFormat, pixelDatatype, source.mipLevels[i]);
          }
        }
      }
    } else if (defined(source.framebuffer)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); // Source: framebuffer

      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._bind();
      }

      gl.copyTexImage2D(textureTarget, 0, internalFormat, source.xOffset, source.yOffset, width, height, 0);

      if (source.framebuffer !== context.defaultFramebuffer) {
        source.framebuffer._unBind();
      }
    } else {
      // Only valid for DOM-Element uploads
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY); // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement

      gl.texImage2D(textureTarget, 0, internalFormat, pixelFormat, pixelDatatype, source);
    }
  } else {
    gl.texImage2D(textureTarget, 0, internalFormat, width, height, 0, pixelFormat, pixelDatatype, null);
    initialized = false;
  }

  gl.bindTexture(textureTarget, null);
  var sizeInBytes;

  if (isCompressed) {
    sizeInBytes = PixelFormat.compressedTextureSizeInBytes(pixelFormat, width, height);
  } else {
    sizeInBytes = PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, width, height);
  }

  this._id = createGuid();
  this._context = context;
  this._textureFilterAnisotropic = context._textureFilterAnisotropic;
  this._textureTarget = textureTarget;
  this._texture = texture;
  this._pixelFormat = pixelFormat;
  this._pixelDatatype = pixelDatatype;
  this._width = width;
  this._height = height;
  this._dimensions = new Cartesian2(width, height);
  this._hasMipmap = false;
  this._sizeInBytes = sizeInBytes;
  this._preMultiplyAlpha = preMultiplyAlpha;
  this._flipY = flipY;
  this._initialized = initialized;
  this._sampler = undefined;
  this.sampler = defined(options.sampler) ? options.sampler : new Sampler();
}
/**
 * This function is identical to using the DDSTexture constructor except that it can be
 * replaced with a mock/spy in tests.
 * @private
 */


DDSTexture.create = function (options) {
  return new DDSTexture(options);
};
/**
 * Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,
 * the texture is the same width and height as the framebuffer and contains its contents.
 *
 * @param {Object} options Object with the following properties:
 * @param {Context} options.context The context in which the DDSTexture gets created.
 * @param {PixelFormat} [options.pixelFormat=6407] The texture's internal pixel format.
 * @param {Number} [options.framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.
 * @param {Number} [options.framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.
 * @param {Number} [options.width=canvas.clientWidth] The width of the texture in texels.
 * @param {Number} [options.height=canvas.clientHeight] The height of the texture in texels.
 * @param {Framebuffer} [options.framebuffer=defaultFramebuffer] The framebuffer from which to create the texture.  If this
 *        parameter is not specified, the default framebuffer is used.
 * @returns {DDSTexture} A texture with contents from the framebuffer.
 *
 * @exception {DeveloperError} Invalid pixelFormat.
 * @exception {DeveloperError} pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.
 * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferXOffset + width must be less than or equal to canvas.clientWidth.
 * @exception {DeveloperError} framebufferYOffset + height must be less than or equal to canvas.clientHeight.
 *
 *
 * @example
 * // Create a texture with the contents of the framebuffer.
 * var t = DDSTexture.fromFramebuffer({
 *     context : context
 * });
 *
 * @see Sampler
 *
 * @private
 */


DDSTexture.fromFramebuffer = function (options) {
  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);
  // Check.defined("options.context", options.context);
  //>>includeEnd('debug');

  var context = options.context;
  var gl = context._gl;
  var pixelFormat = defaultValue(options.pixelFormat, 6407);
  var framebufferXOffset = defaultValue(options.framebufferXOffset, 0);
  var framebufferYOffset = defaultValue(options.framebufferYOffset, 0);
  var width = defaultValue(options.width, gl.drawingBufferWidth);
  var height = defaultValue(options.height, gl.drawingBufferHeight);
  var framebuffer = options.framebuffer; //>>includeStart('debug', pragmas.debug);
  // if (!PixelFormat.validate(pixelFormat)) {
  //     throw new DeveloperError("Invalid pixelFormat.");
  // }
  // if (
  //     PixelFormat.isDepthFormat(pixelFormat) ||
  //     PixelFormat.isCompressedFormat(pixelFormat)
  // ) {
  //     throw new DeveloperError(
  //         "pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format."
  //     );
  // }
  // Check.defined("options.context", options.context);
  // Check.typeOf.number.greaterThanOrEquals(
  //     "framebufferXOffset",
  //     framebufferXOffset,
  //     0
  // );
  // Check.typeOf.number.greaterThanOrEquals(
  //     "framebufferYOffset",
  //     framebufferYOffset,
  //     0
  // );
  // if (framebufferXOffset + width > gl.drawingBufferWidth) {
  //     throw new DeveloperError(
  //         "framebufferXOffset + width must be less than or equal to drawingBufferWidth"
  //     );
  // }
  // if (framebufferYOffset + height > gl.drawingBufferHeight) {
  //     throw new DeveloperError(
  //         "framebufferYOffset + height must be less than or equal to drawingBufferHeight."
  //     );
  // }
  //>>includeEnd('debug');

  var texture = new DDSTexture({
    context: context,
    width: width,
    height: height,
    pixelFormat: pixelFormat,
    source: {
      framebuffer: defined(framebuffer) ? framebuffer : context.defaultFramebuffer,
      xOffset: framebufferXOffset,
      yOffset: framebufferYOffset,
      width: width,
      height: height
    }
  });
  return texture;
};

Object.defineProperties(DDSTexture.prototype, {
  /**
   * A unique id for the texture
   * @memberof DDSTexture.prototype
   * @type {String}
   * @readonly
   * @private
   */
  id: {
    get: function get() {
      return this._id;
    }
  },

  /**
   * The sampler to use when sampling this texture.
   * Create a sampler by calling {@link Sampler}.  If this
   * parameter is not specified, a default sampler is used.  The default sampler clamps texture
   * coordinates in both directions, uses linear filtering for both magnification and minification,
   * and uses a maximum anisotropy of 1.0.
   * @memberof DDSTexture.prototype
   * @type {Object}
   */
  sampler: {
    get: function get() {
      return this._sampler;
    },
    set: function set(sampler) {
      var minificationFilter = sampler.minificationFilter;
      var magnificationFilter = sampler.magnificationFilter;
      var mipmap = minificationFilter === 9984 || minificationFilter === 9986 || minificationFilter === 9985 || minificationFilter === 9987;
      var context = this._context;
      var pixelDatatype = this._pixelDatatype; // float textures only support nearest filtering unless the linear extensions are supported, so override the sampler's settings

      if (pixelDatatype === 5126 && !context.textureFloatLinear || pixelDatatype === 36193 && !context.textureHalfFloatLinear) {
        minificationFilter = mipmap ? 9984 : 9728;
        magnificationFilter = 9728;
      }

      var gl = context._gl;
      var target = this._textureTarget;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(target, this._texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);

      if (defined(this._textureFilterAnisotropic)) {
        gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);
      }

      gl.bindTexture(target, null);
      this._sampler = sampler;
    }
  },
  pixelFormat: {
    get: function get() {
      return this._pixelFormat;
    }
  },
  pixelDatatype: {
    get: function get() {
      return this._pixelDatatype;
    }
  },
  dimensions: {
    get: function get() {
      return this._dimensions;
    }
  },
  preMultiplyAlpha: {
    get: function get() {
      return this._preMultiplyAlpha;
    }
  },
  flipY: {
    get: function get() {
      return this._flipY;
    }
  },
  width: {
    get: function get() {
      return this._width;
    }
  },
  height: {
    get: function get() {
      return this._height;
    }
  },
  sizeInBytes: {
    get: function get() {
      if (this._hasMipmap) {
        return Math.floor(this._sizeInBytes * 4 / 3);
      }

      return this._sizeInBytes;
    }
  },
  _target: {
    get: function get() {
      return this._textureTarget;
    }
  }
});
/**
 * Copy new image data into this texture, from a source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement}.
 * or an object with width, height, and arrayBufferView properties.
 *
 * @param {Object} source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement},
 *                        or an object with width, height, and arrayBufferView properties.
 * @param {Number} [xOffset=0] The offset in the x direction within the texture to copy into.
 * @param {Number} [yOffset=0] The offset in the y direction within the texture to copy into.
 *
 * @exception {DeveloperError} Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
 * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.
 * @exception {DeveloperError} xOffset must be greater than or equal to zero.
 * @exception {DeveloperError} yOffset must be greater than or equal to zero.
 * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.
 * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.
 * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
 *
 * @example
 * texture.copyFrom({
 *   width : 1,
 *   height : 1,
 *   arrayBufferView : new Uint8Array([255, 0, 0, 255])
 * });
 */

DDSTexture.prototype.copyFrom = function (source, xOffset, yOffset) {
  xOffset = defaultValue(xOffset, 0);
  yOffset = defaultValue(yOffset, 0); //>>includeStart('debug', pragmas.debug);
  // Check.defined("source", source);
  // if (PixelFormat.isDepthFormat(this._pixelFormat)) {
  //     throw new DeveloperError(
  //         "Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
  //     );
  // }
  // if (PixelFormat.isCompressedFormat(this._pixelFormat)) {
  //     throw new DeveloperError(
  //         "Cannot call copyFrom with a compressed texture pixel format."
  //     );
  // }
  // Check.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  // Check.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  // Check.typeOf.number.lessThanOrEquals(
  //     "xOffset + source.width",
  //     xOffset + source.width,
  //     this._width
  // );
  // Check.typeOf.number.lessThanOrEquals(
  //     "yOffset + source.height",
  //     yOffset + source.height,
  //     this._height
  // );
  //>>includeEnd('debug');

  var gl = this._context._gl;
  var target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  var width = source.width;
  var height = source.height;
  var arrayBufferView = source.arrayBufferView;
  var textureWidth = this._width;
  var textureHeight = this._height;
  var pixelFormat = this._pixelFormat;
  var pixelDatatype = this._pixelDatatype;
  var preMultiplyAlpha = this._preMultiplyAlpha;
  var flipY = this._flipY;
  var unpackAlignment = 4;

  if (defined(arrayBufferView)) {
    unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, width);
  }

  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  var uploaded = false;

  if (!this._initialized) {
    if (xOffset === 0 && yOffset === 0 && width === textureWidth && height === textureHeight) {
      // initialize the entire texture
      if (defined(arrayBufferView)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

        if (flipY) {
          arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, textureWidth, textureHeight);
        }

        gl.texImage2D(target, 0, pixelFormat, textureWidth, textureHeight, 0, pixelFormat, pixelDatatype, arrayBufferView);
      } else {
        // Only valid for DOM-Element uploads
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(target, 0, pixelFormat, pixelFormat, pixelDatatype, source);
      }

      uploaded = true;
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); // initialize the entire texture to zero

      var bufferView = PixelFormat.createTypedArray(pixelFormat, pixelDatatype, textureWidth, textureHeight);
      gl.texImage2D(target, 0, pixelFormat, textureWidth, textureHeight, 0, pixelFormat, pixelDatatype, bufferView);
    }

    this._initialized = true;
  }

  if (!uploaded) {
    if (defined(arrayBufferView)) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

      if (flipY) {
        arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);
      }

      gl.texSubImage2D(target, 0, xOffset, yOffset, width, height, pixelFormat, pixelDatatype, arrayBufferView);
    } else {
      // Only valid for DOM-Element uploads
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      gl.texSubImage2D(target, 0, xOffset, yOffset, pixelFormat, pixelDatatype, source);
    }
  }

  gl.bindTexture(target, null);
};
/**
 * @param {Number} [xOffset=0] The offset in the x direction within the texture to copy into.
 * @param {Number} [yOffset=0] The offset in the y direction within the texture to copy into.
 * @param {Number} [framebufferXOffset=0] optional
 * @param {Number} [framebufferYOffset=0] optional
 * @param {Number} [width=width] optional
 * @param {Number} [height=height] optional
 *
 * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
 * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.
 * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.
 * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.
 * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
 * @exception {DeveloperError} xOffset must be greater than or equal to zero.
 * @exception {DeveloperError} yOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
 * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
 * @exception {DeveloperError} xOffset + width must be less than or equal to width.
 * @exception {DeveloperError} yOffset + height must be less than or equal to height.
 */


DDSTexture.prototype.copyFromFramebuffer = function (xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
  xOffset = defaultValue(xOffset, 0);
  yOffset = defaultValue(yOffset, 0);
  framebufferXOffset = defaultValue(framebufferXOffset, 0);
  framebufferYOffset = defaultValue(framebufferYOffset, 0);
  width = defaultValue(width, this._width);
  height = defaultValue(height, this._height); //>>includeStart('debug', pragmas.debug);
  // if (PixelFormat.isDepthFormat(this._pixelFormat)) {
  //     throw new DeveloperError(
  //         "Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
  //     );
  // }
  // if (this._pixelDatatype === 5126) {
  //     throw new DeveloperError(
  //         "Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT."
  //     );
  // }
  // if (this._pixelDatatype === 36193) {
  //     throw new DeveloperError(
  //         "Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT."
  //     );
  // }
  // if (PixelFormat.isCompressedFormat(this._pixelFormat)) {
  //     throw new DeveloperError(
  //         "Cannot call copyFrom with a compressed texture pixel format."
  //     );
  // }
  // Check.typeOf.number.greaterThanOrEquals("xOffset", xOffset, 0);
  // Check.typeOf.number.greaterThanOrEquals("yOffset", yOffset, 0);
  // Check.typeOf.number.greaterThanOrEquals(
  //     "framebufferXOffset",
  //     framebufferXOffset,
  //     0
  // );
  // Check.typeOf.number.greaterThanOrEquals(
  //     "framebufferYOffset",
  //     framebufferYOffset,
  //     0
  // );
  // Check.typeOf.number.lessThanOrEquals(
  //     "xOffset + width",
  //     xOffset + width,
  //     this._width
  // );
  // Check.typeOf.number.lessThanOrEquals(
  //     "yOffset + height",
  //     yOffset + height,
  //     this._height
  // );
  //>>includeEnd('debug');

  var gl = this._context._gl;
  var target = this._textureTarget;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.copyTexSubImage2D(target, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
  gl.bindTexture(target, null);
  this._initialized = true;
};
/**
 * @param {MipmapHint} [hint=4352] optional.
 *
 * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.
 * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is a compressed format.
 * @exception {DeveloperError} hint is invalid.
 * @exception {DeveloperError} This texture's width must be a power of two to call generateMipmap().
 * @exception {DeveloperError} This texture's height must be a power of two to call generateMipmap().
 * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
 */


DDSTexture.prototype.generateMipmap = function (hint) {
  hint = defaultValue(hint, 4352); //>>includeStart('debug', pragmas.debug);
  // if (PixelFormat.isDepthFormat(this._pixelFormat)) {
  //     throw new DeveloperError(
  //         "Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL."
  //     );
  // }
  // if (PixelFormat.isCompressedFormat(this._pixelFormat)) {
  //     throw new DeveloperError(
  //         "Cannot call generateMipmap with a compressed pixel format."
  //     );
  // }
  // if (this._width > 1 && !CesiumMath.isPowerOfTwo(this._width)) {
  //     throw new DeveloperError(
  //         "width must be a power of two to call generateMipmap()."
  //     );
  // }
  // if (this._height > 1 && !CesiumMath.isPowerOfTwo(this._height)) {
  //     throw new DeveloperError(
  //         "height must be a power of two to call generateMipmap()."
  //     );
  // }
  // if (!MipmapHint.validate(hint)) {
  //     throw new DeveloperError("hint is invalid.");
  // }
  //>>includeEnd('debug');

  this._hasMipmap = true;
  var gl = this._context._gl;
  var target = this._textureTarget;
  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, this._texture);
  gl.generateMipmap(target);
  gl.bindTexture(target, null);
};

DDSTexture.prototype.isDestroyed = function () {
  return false;
};

DDSTexture.prototype.destroy = function () {
  this._context._gl.deleteTexture(this._texture);

  return destroyObject(this);
};

var _default = DDSTexture;
exports["default"] = _default;

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insertBeforeMain = insertBeforeMain;
exports.insertAfterMain = insertAfterMain;
exports.appendMain = appendMain;
exports.insertBefore = insertBefore;
exports.insertAfter = insertAfter;
exports["default"] = void 0;

/**
* shader工具，生成、处理顶着色器和片元着色器的代码，处理实例化shader，转换threejs shader
*@constructor
*/
function ShaderUtils() {}
/**
 * 
 * @param {string} source 
 * @param {string} chunck 
 */


function insertBeforeMain(source, chunck) {
  var renamedMain = chunck + "\nvoid main()";
  return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, renamedMain);
}

ShaderUtils.insertBeforeMain = insertBeforeMain;
/**
 * 
 * @param {string} source 
 * @param {string} chunck 
 */

function insertAfterMain(source, chunck) {
  var renamedMain = "void main(){\n" + chunck;
  return source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)\s*{/g, renamedMain);
}

ShaderUtils.insertAfterMain = insertAfterMain;
/**
 * 
 * @param {string} source 
 * @param {string} chunck 
 */

function appendMain(source, chunck) {
  if (!chunck) return source;
  var start = source.lastIndexOf('}');

  if (start >= 0 && chunck.length) {
    var a = source.substring(0, start);
    var b = source.substring(start);
    if (chunck[chunck.length - 1] != '\n') source = a + chunck + '\n' + b;else source = a + chunck + b;
  }

  return source;
}

ShaderUtils.appendMain = appendMain;
/**
 * 
 * @param {string} source 
 * @param {string} include
 * @param {string} chunck 
 */

ShaderUtils.replaceIncludes = function (source, include, chunck) {
  return source.replace(include, chunck);
};
/**
 * 
 * @param {string} source 
 * @param {RegExp} pattern 
 * @param {string} chunck 
 * @returns {string}
 */


function insertBefore(source, pattern, chunck) {
  var regex = pattern;

  if (typeof pattern == 'string') {
    regex = new RegExp(pattern, 'g');
  }

  var m = regex.exec(source);

  if (m) {
    var start = m.index;
    var a = source.substring(0, start);
    var b = source.substring(start);
    source = a + chunck + b;
  }

  return source;
}

ShaderUtils.insertBefore = insertBefore;
/**
 * 
 * @param {string} source 
 * @param {RegExp} pattern 
 * @param {string} chunck 
 * @returns {string}
 */

function insertAfter(source, pattern, chunck) {
  var regex = pattern;

  if (typeof pattern == 'string') {
    regex = new RegExp(pattern, 'g');
  }

  var m = regex.exec(source);

  if (m) {
    var start = m.index + m[0].length;
    var a = source.substring(0, start);
    var b = source.substring(start);
    source = a + chunck + b;
  }

  return source;
}

ShaderUtils.insertAfter = insertAfter;
var positionRegex = /attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g;

ShaderUtils._modifyShaderPosition = function (primitive, vertexShaderSource, scene3DOnly) {
  var match;
  var forwardDecl = "";
  var attributes = "";
  var computeFunctions = "";

  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {
    var name = match[1];
    var functionName = "vec4 czm_compute" + name[0].toUpperCase() + name.substr(1) + "()"; // Don't forward-declare czm_computePosition because computePosition.glsl already does.

    if (functionName !== "vec4 czm_computePosition()") {
      forwardDecl += functionName + ";\n";
    }

    if (!defined(primitive.rtcCenter)) {
      // Use GPU RTE
      if (!scene3DOnly) {
        attributes += "attribute vec3 " + name + "2DHigh;\n" + "attribute vec3 " + name + "2DLow;\n";
        computeFunctions += functionName + "\n" + "{\n" + "    vec4 p;\n" + "    if (czm_morphTime == 1.0)\n" + "    {\n" + "        p = czm_translateRelativeToEye(" + name + "3DHigh, " + name + "3DLow);\n" + "    }\n" + "    else if (czm_morphTime == 0.0)\n" + "    {\n" + "        p = czm_translateRelativeToEye(" + name + "2DHigh.zxy, " + name + "2DLow.zxy);\n" + "    }\n" + "    else\n" + "    {\n" + "        p = czm_columbusViewMorph(\n" + "                czm_translateRelativeToEye(" + name + "2DHigh.zxy, " + name + "2DLow.zxy),\n" + "                czm_translateRelativeToEye(" + name + "3DHigh, " + name + "3DLow),\n" + "                czm_morphTime);\n" + "    }\n" + "    return p;\n" + "}\n\n";
      } else {
        computeFunctions += functionName + "\n" + "{\n" + "    return czm_translateRelativeToEye(" + name + "3DHigh, " + name + "3DLow);\n" + "}\n\n";
      }
    } else {
      // Use RTC
      vertexShaderSource = vertexShaderSource.replace(/attribute\s+vec(?:3|4)\s+position3DHigh;/g, "");
      vertexShaderSource = vertexShaderSource.replace(/attribute\s+vec(?:3|4)\s+position3DLow;/g, "");
      forwardDecl += "uniform mat4 u_modifiedModelView;\n";
      attributes += "attribute vec4 position;\n";
      computeFunctions += functionName + "\n" + "{\n" + "    return u_modifiedModelView * position;\n" + "}\n\n";
      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewRelativeToEye\s+\*\s+/g, "");
      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewProjectionRelativeToEye/g, "czm_projection");
    }
  }

  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join("\n");
};

ShaderUtils.modifyShaderPosition = function (mesh, shader) {
  var vs = shader.vertexShader;
  if (!vs.includes('transformed')) return;
  vs = vs.replace('gl_Position = projectionMatrix * mvPosition', 'vec4 mvis_positionEC = vec4( transformed, 1.0 );\n\
        #ifdef USE_INSTANCING\n\
            mvis_positionEC = instanceMatrix * mvis_positionEC;\n\
        #endif\n\
        mvis_positionEC=vec4(mvis_positionEC.xyz - u_cameraPositionLC,1.);\n\
        gl_Position = czm_modelViewProjectionRelativeToEye * mvis_positionEC;\n\
        ');
  shader.vertexShader = vs;
};
/**
 *  positionHigh+positionLow
 * @param {Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */


ShaderUtils.modifyEncodedPosition = function (mesh, shader) {
  var vs = shader.vertexShader;
  vs = vs.replace(/attribute\s?vec3\s?position\s?;/g, '\
         attribute vec3 positionHigh;\n\
         attribute vec3 positionLow;\n\
         vec3 position;\n\
        ');
  shader.vertexShader = this.insertAfterMain(vs, 'position=(positionHigh+positionLow)*1e-6;\n');
};
/**
 * 修改threejs shader中shadowWorldPosition
 * @param {Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */


ShaderUtils.modifyShadowWorldPosition = function (mesh, shader) {
  var vs = shader.vertexShader;

  if (/vec4\s?shadowWorldPosition;/g.test(vs)) {
    vs = vs.replace(/vec4\s?shadowWorldPosition;/g, 'vec4 shadowWorldPosition;\n\
		vec4 worldPositionThree = vec4( transformed, 1.0 );\n\
		#ifdef USE_INSTANCING\n\
			worldPositionThree = instanceMatrix * worldPositionThree;\n\
        #endif\n\
        // vec3 transformedNormalThree = objectNormal;\n\
        // #ifdef USE_INSTANCING\n\
        //     mat3 m = mat3( instanceMatrix );\n\
        //     transformedNormalThree /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\
        //     transformedNormalThree = m * transformedNormalThree;\n\
        // #endif\n\
        // shadowWorldNormal= normalMatrixWorld*transformedNormalThree;\n\
        worldPositionThree=matrixWorld*worldPositionThree;\n');
    vs = vs.replace(/shadowWorldPosition\s?=\s?worldPosition\s?\+\s?/g, 'shadowWorldPosition = worldPositionThree + ');
  }

  if (vs.includes('#define DISTANCE')) {
    vs = vs.replace(/vWorldPosition\s?=\s?worldPosition.xyz\s?;/g, '\n\
        vec4 worldPositionThree = vec4(transformed, 1.0 );\n\
        #ifdef USE_INSTANCING\n\
            worldPositionThree = instanceMatrix * worldPositionThree;\n\
        #endif\n\
        worldPositionThree = matrixWorld * worldPositionThree;\n\
        vWorldPosition=worldPositionThree.xyz;\n');
  }

  shader.vertexShader = vs;
};
/**
 * 修改threejs shader中环境贴图相关代码
 * @param {Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */


ShaderUtils.modifyEnvMapQueryVec = function (mesh, shader) {
  var Matrix4 = Cesium.Matrix4; // if (Matrix4.equals(mesh.modelMatrix, Matrix4.IDENTITY)) return;

  var fs = shader.fragmentShader; // if (/cameraToVertex\s?=\s?normalize\(\s?worldPosition.xyz\s?-\s?cameraPosition \);/g.test(shader.vertexShader)) {

  fs = fs.replace(/textureCube\s?\(\s?envMap\s?,\s?vec3\s?\(\s?flipEnvMap\s?\*\s?reflectVec.x\s?,\s?reflectVec.yz\s?\)\s\)/g, ' textureCube( envMap,vec3( flipEnvMap *(_CesiumNormal2ThreeNormal* reflectVec).x, (_CesiumNormal2ThreeNormal*reflectVec).yz ) )'); // }

  fs = fs.replace(/\(\s?envMap\s?,\s?reflectVec/g, '( envMap,_CesiumNormal2ThreeNormal * reflectVec'); // if (/\(\s?envMap\s?,\s?queryVec/g.test(fs)) {

  fs = fs.replace(/\(\s?envMap\s?,\s?queryVec/g, '( envMap,_CesiumNormal2ThreeNormal* queryVec'); // }
  // if (/\(\s?envMap\s?,\s?queryReflectVec/g.test(fs)) {

  fs = fs.replace(/\(\s?envMap\s?,\s?queryReflectVec/g, '( envMap,_CesiumNormal2ThreeNormal* queryReflectVec'); // }
  // if (/equirectUv\(\s?reflectVec\s?\)/g.test(fs)) {

  fs = fs.replace(/equirectUv\(\s?reflectVec\s?\)/g, 'equirectUv( _CesiumNormal2ThreeNormal* reflectVec )'); // }
  // if (/equirectUv\(\s?direction\s?\)/g.test(fs)) {

  fs = fs.replace(/equirectUv\(\s?direction\s?\)/g, 'equirectUv( _CesiumNormal2ThreeNormal* direction )'); // }

  if (/textureCubeUV\s?\(\s?envMap\s?,\s?reflectVec/g.test(fs)) {
    fs = fs.replace(/textureCubeUV\s?\(\s?envMap\s?,\s?reflectVec/g, 'textureCubeUV(envMap, _CesiumNormal2ThreeNormal* reflectVec');
  }

  if (/textureCubeUV\s?\(\s?envMap\s?,\s?worldNormal/g.test(fs)) {
    fs = fs.replace(/textureCubeUV\s?\(\s?envMap\s?,\s?worldNormal/g, 'textureCubeUV(envMap, _CesiumNormal2ThreeNormal* worldNormal');
  }

  shader.fragmentShader = fs; // console.log(shader.fragmentShader);
};
/**
 * 处理实例化shader代码
 * @param {THREE.Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */


ShaderUtils.processInstanceShader = function (mesh, shader) {
  if (mesh._instances && mesh._instances.length) {
    var vs = shader.vertexShader;
    var renamedSource = Cesium.ShaderSource.replaceMain(vs, 'czm_instancing_main');
    renamedSource = renamedSource.replace(/.*uniform\s+mat4\s+modelViewMatrix/g, 'mat4 modelViewMatrix').replace(/.*uniform\s+mat4\s+u_modelViewMatrix/g, 'mat4 u_modelViewMatrix').replace(/.*uniform\s+mat4\s+modelMatrix/g, 'mat4 modelMatrix').replace(/.*uniform\s+mat4\s+u_modelMatrix/g, 'mat4 u_modelMatrix');
    var addFunctionCode = '';
    var u_mats = [];
    var getNormalMatrixCode = ''; //非threejs instanceMesh实例化渲染，增加计算实例的normalMatrix的glsl代码

    addFunctionCode = '\n\
        mat3 inverse_mat3(mat3 m)\n\
            {\n\
                float Determinant = \n\
                      m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])\n\
                    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])\n\
                    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\n\
                    \n\
                mat3 Inverse;\n\
                Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);\n\
                Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);\n\
                Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);\n\
                Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);\n\
                Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);\n\
                Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);\n\
                Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);\n\
                Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);\n\
                Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);\n\
                Inverse /= Determinant;\n\
                \n\
                return Inverse;\n\
            }\n\
            \n\
           mat3 transpose (mat3 m) {\n\
            \n\
                float tmp;\n\
                 \n\
                tmp = m[0][ 1 ]; m[0][ 1 ] = m[1][ 0 ]; m[1][ 0 ] = tmp;\n\
                tmp = m[0][ 2 ]; m[0][ 2 ] = m[2][ 0 ]; m[2][ 0 ] = tmp;\n\
                tmp = m[1][ 2 ]; m[1][ 2 ] = m[2][ 1 ]; m[2][ 1 ] = tmp;\n\
                \n\
                return m;\n\
            }\n\
            \n\
            ';
    renamedSource = renamedSource.replace(/.*uniform\s+mat3\s+u_normalMatrix/g, 'mat3 u_normalMatrix').replace(/.*uniform\s+mat3\s+normalMatrix/g, 'mat3 normalMatrix');
    if (!/mat3\s+normalMatrix/g.test(renamedSource)) u_mats.push('mat3 normalMatrix;');
    if (!/mat3\s+u_normalMatrix/g.test(renamedSource)) u_mats.push('mat3 u_normalMatrix;');
    getNormalMatrixCode = '\n\
                   normalMatrix=mat3(modelViewMatrix);\n\
                   normalMatrix=transpose(inverse_mat3(normalMatrix));\n\
                   u_normalMatrix=normalMatrix;\n\
                '; // 

    if (!/mat4\s+u_modelMatrix/g.test(renamedSource)) u_mats.push('mat4 u_modelMatrix;');
    if (!/mat4\s+u_modelViewMatrix/g.test(renamedSource)) u_mats.push('mat4 u_modelViewMatrix;');
    var pickAttribute = 'attribute vec4 a_pickColor;\n' + 'varying vec4 czm_pickColor;\n';
    var pickVarying = '    czm_pickColor = a_pickColor;\n';
    vs = //'mat4 czm_instanced_modelView;\n' +
    'attribute vec4 czm_modelMatrixRow0;\n' + 'attribute vec4 czm_modelMatrixRow1;\n' + 'attribute vec4 czm_modelMatrixRow2;\n' + 'uniform mat4 czm_instanced_modifiedModelView;\n' + // batchIdAttribute +
    u_mats.join('\n') + pickAttribute + renamedSource + addFunctionCode + 'void main()\n' + '{\n' + '    modelMatrix = mat4(czm_modelMatrixRow0.x, czm_modelMatrixRow1.x, czm_modelMatrixRow2.x, 0.0, czm_modelMatrixRow0.y, czm_modelMatrixRow1.y, czm_modelMatrixRow2.y, 0.0, czm_modelMatrixRow0.z, czm_modelMatrixRow1.z, czm_modelMatrixRow2.z, 0.0, czm_modelMatrixRow0.w, czm_modelMatrixRow1.w, czm_modelMatrixRow2.w, 1.0);\n' + '    modelViewMatrix = czm_instanced_modifiedModelView * modelMatrix;\n' + '    u_modelMatrix =modelMatrix;\n' + '    u_modelViewMatrix = modelViewMatrix ;\n' + // globalVarsMain +
    getNormalMatrixCode + '    czm_instancing_main();\n' + pickVarying + '}\n';
    shader.vertexShader = vs;
  }
};
/**
 * 处理实例化shader代码
 * @param {Mesh|THREE.Mesh} mesh 
 * @param {object} shader
 * @param {string} shader.vertexShader
 * @param {string} shader.fragmentShader
 */


ShaderUtils.processOcclusionCulling = function (mesh, shader) {
  if (mesh.material.transparent) return;
  shader.fragmentShader = Cesium.ShaderSource.replaceMain(shader.fragmentShader, 'mvis_OcclusionCulling');
  var mvis_OcclusionCulling = '\n\
    uniform sampler2D occlusionCullingMap;\n\
    uniform bool occlusionCullingToggle;\n\
    uniform vec2 occlusionCullingResolution;\n\
    void main(){\n\
        if(occlusionCullingToggle){\n\
            vec4 tPkColor=texture2D(occlusionCullingMap,gl_FragCoord.xy/occlusionCullingResolution);\n\
            if(tPkColor.r!=czm_pickColor.r||tPkColor.g!=czm_pickColor.g||tPkColor.b!=czm_pickColor.b||tPkColor.a!=czm_pickColor.a){\n\
               discard;\n\
            }\n\
            // gl_FragColor=tPkColor;\n\
        }\n\
        else{\n\
            mvis_OcclusionCulling();\n\
        }\n\
    }';
  shader.fragmentShader += mvis_OcclusionCulling;
};

var _default = ShaderUtils;
exports["default"] = _default;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default =
/*glsl*/
"\n#if NUM_STATIC_POINT_LIGHTS > 0 || NUM_PAITIAL_POINT_LIGHTS > 0\n    struct ExtensionPointLight {\n        vec3 position;\n        vec3 color;\n        vec2 decayDist;\n    };\n\n    #if NUM_STATIC_POINT_LIGHTS > 0 \n        #if defined(OES_texture_float_linear) &&  NUM_STATIC_POINT_LIGHTS>100\n            uniform sampler2D fixedPointLightMap;\n        #else \n            uniform vec3 fixedPointLightPositions[NUM_STATIC_POINT_LIGHTS];\n            uniform vec3 fixedPointLightColors[NUM_STATIC_POINT_LIGHTS];\n            uniform vec2 fixedPointLightDecayDists[NUM_STATIC_POINT_LIGHTS];\n        #endif \n        uniform bool fixedPointLightVisibles[NUM_STATIC_POINT_LIGHTS];\n    #endif\n\n    #if NUM_PAITIAL_POINT_LIGHTS > 0 \n        #if defined(OES_texture_float_linear) &&  NUM_PAITIAL_POINT_LIGHTS>100\n            uniform sampler2D partialPointLightMap;\n        #else \n            uniform vec3 partialPointLightPositions[NUM_PAITIAL_POINT_LIGHTS];\n            uniform vec3 partialPointLightColors[NUM_PAITIAL_POINT_LIGHTS];\n            uniform vec2 partialPointLightDecayDists[NUM_PAITIAL_POINT_LIGHTS];\n        #endif\n        uniform bool partialPointLightVisibles[NUM_PAITIAL_POINT_LIGHTS];\n    #endif\n\n    // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getExtPointDirectLightIrradiance( const in ExtensionPointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n        vec3 lVector = pointLight.position - geometry.position; \n        float lightDistance = length( lVector );\n\t\tdirectLight.direction = normalize( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.decayDist.y, pointLight.decayDist.x );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n    }\n    void getExtPointDirectLightIrradiance( const in vec4 posDecay,const in vec4 colorDist, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n        vec3 lVector = posDecay.xyz - geometry.position; \n        float lightDistance = length( lVector );\n\t\tdirectLight.direction = normalize( lVector );\n\t\tdirectLight.color = colorDist.rgb;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, colorDist.a, posDecay.w );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n    }\n#endif\n";
exports["default"] = _default;

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default =
/* glsl */
"\n#if ( NUM_STATIC_POINT_LIGHTS > 0 || NUM_PAITIAL_POINT_LIGHTS > 0) && defined( RE_Direct )\n\n    ExtensionPointLight ex_pointLight;\n    vec2 ex_uv1=vec2(0.,0.8);\n    vec2 ex_uv2=vec2(0.,0.4);\n    vec2 ex_uv3=vec2(0.,0.15);\n    #if (NUM_STATIC_POINT_LIGHTS > 0) \n\n        #if defined(OES_texture_float_linear)&&  NUM_STATIC_POINT_LIGHTS>100\n            vec4 ex_fixed_posDecay;\n            vec4 ex_fixed_colorDist;\n            float ex_num=float(NUM_STATIC_POINT_LIGHTS);\n            for ( int i = 0; i < NUM_STATIC_POINT_LIGHTS; i ++ ) {\n                ex_uv1.x=(float(i)+0.5)/ex_num;\n                ex_uv3.x=ex_uv1.x; \n                #if NUM_STATIC_POINT_LIGHTS>200\n                   if(texture2D(fixedPointLightMap, ex_uv3).a==1.){\n                #else \n                  if(fixedPointLightVisibles[i]){ \n                #endif\n                    ex_uv2.x=ex_uv1.x;\n                    ex_fixed_posDecay=texture2D(fixedPointLightMap, ex_uv1);\n                    ex_fixed_colorDist=texture2D(fixedPointLightMap,ex_uv2);\n                    getExtPointDirectLightIrradiance( ex_fixed_posDecay,ex_fixed_colorDist, geometry, directLight );\n                    RE_Direct( directLight, geometry, material, reflectedLight );\n                }\n            }\n        #else\n            for ( int i = 0; i < NUM_STATIC_POINT_LIGHTS; i ++ ) {\n                if(fixedPointLightVisibles[i]){ \n                    ex_pointLight.position = fixedPointLightPositions[ i ];\n                    ex_pointLight.color = fixedPointLightColors[ i ];\n                    ex_pointLight.decayDist= fixedPointLightDecayDists[ i ];\n                    getExtPointDirectLightIrradiance( ex_pointLight, geometry, directLight );\n                    RE_Direct( directLight, geometry, material, reflectedLight );\n                }\n            }\n        #endif\n            \n\t#endif\n    \n    #if (NUM_PAITIAL_POINT_LIGHTS > 0) \n        #if defined(OES_texture_float_linear)&&  NUM_PAITIAL_POINT_LIGHTS>100\n            vec4 ex_partial_posDecay;\n            vec4 ex_partial_colorDist;\n            float ex_num=float(NUM_PAITIAL_POINT_LIGHTS);\n            for ( int i = 0; i < NUM_PAITIAL_POINT_LIGHTS; i ++ ) {\n                   ex_uv1.x=(float( i )+0.5)/ex_num;\n                   ex_uv3.x=ex_uv1.x; \n                #if NUM_PAITIAL_POINT_LIGHTS>200\n                  if(texture2D(partialPointLightMap, ex_uv3).a==1.){\n                #else \n                  if(partialPointLightVisibles[ i ]){ \n                #endif \n                    ex_uv2.x=ex_uv1.x;\n                    ex_partial_posDecay=texture2D(partialPointLightMap, ex_uv1);\n                    ex_partial_colorDist=texture2D(partialPointLightMap,ex_uv2);\n                    getExtPointDirectLightIrradiance( ex_partial_posDecay,ex_partial_colorDist, geometry, directLight );\n                    RE_Direct( directLight, geometry, material, reflectedLight );\n                }\n            }\n        #else\n            for ( int i = 0; i < NUM_PAITIAL_POINT_LIGHTS; i ++ ) {\n                if(partialPointLightVisibles[i]){ \n                    ex_pointLight.position = partialPointLightPositions[ i ];\n                    ex_pointLight.color = partialPointLightColors[ i ];\n                    ex_pointLight.decayDist= partialPointLightDecayDists[ i ];\n                    getExtPointDirectLightIrradiance( ex_pointLight, geometry, directLight );\n                    RE_Direct( directLight, geometry, material, reflectedLight );\n                }\n            }\n        #endif\n            \n    #endif\n     \n#endif\n";
exports["default"] = _default;

},{}],17:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ConstantMap = _interopRequireDefault(require("._29"));

var _DDSTexture = _interopRequireDefault(require("D_50"));

/**
 * 纹理相关工具类，实现转换threejs纹理，重采样等功能
 * @class
 */
function TextureUtils() {}

TextureUtils.getPixelDataType = function (type3js) {
  return _ConstantMap["default"].typesMap[type3js];
};

TextureUtils.getPixelFormat = function (format3js) {
  return _ConstantMap["default"].formatsMap[format3js];
};

TextureUtils.createTexture = function (textureUniform, context, maximumTextureSize) {
  var _Cesium = Cesium,
      Texture = _Cesium.Texture,
      TextureMinificationFilter = _Cesium.TextureMinificationFilter,
      TextureWrap = _Cesium.TextureWrap,
      PixelFormat = _Cesium.PixelFormat,
      WebGLConstants = _Cesium.WebGLConstants,
      ContextLimits = _Cesium.ContextLimits;
  var _Math = Cesium.Math;
  var texture = textureUniform;
  var sampler = texture.sampler;
  var mipmap = sampler.minificationFilter === 9984 || sampler.minificationFilter === 9986 || sampler.minificationFilter === 9985 || sampler.minificationFilter === 9987;
  var requiresNpot = mipmap || sampler.wrapS === 10497 || sampler.wrapS === 33648 || sampler.wrapT === 10497 || sampler.wrapT === 33648;
  var source = texture.source;
  var width = texture.width,
      height = texture.height;
  var npot = source && (!_Math.isPowerOfTwo(source.width) || !_Math.isPowerOfTwo(source.height));

  if (requiresNpot && npot) {
    // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.
    var canvas = document.createElement('canvas');
    canvas.width = _Math.nextPowerOfTwo(source.width);
    canvas.height = _Math.nextPowerOfTwo(source.height);
    var canvasContext = canvas.getContext('2d');
    canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
    source = canvas;
    width = canvas.width;
    height = canvas.height;
  }

  var tx,
      pixelFormat = texture.internalFormat || texture.format;
  var isCompressed = PixelFormat.isCompressedFormat(pixelFormat);
  var textureCtor = isCompressed ? _DDSTexture["default"] : Texture;
  var needsResize = false;
  maximumTextureSize = maximumTextureSize || ContextLimits.maximumTextureSize;

  if (width > maximumTextureSize) {
    width = maximumTextureSize;
    needsResize = true;
    console.warn("Mesh3D.TextureUtils:Width should be less than or equal to the maximum texture size (" + maximumTextureSize + ").  Check maximumTextureSize.");
  }

  if (height > maximumTextureSize) {
    console.warn("Mesh3D.TextureUtils:Height should be less than or equal to the maximum texture size (" + maximumTextureSize + ").  Check maximumTextureSize.");
    height = maximumTextureSize;

    if (!needsResize) {
      width = maximumTextureSize * (width / height);
    }

    needsResize = true;
  } else if (needsResize) {
    height = maximumTextureSize * (height / width);
  }

  if (needsResize) {
    console.warn("Mesh3D.TextureUtils:Width and height must be less than or equal to the maximum texture size (" + maximumTextureSize + ").  Check maximumTextureSize."); // if (mipmap) {
    //     width = _Math.nextPowerOfTwo(width);
    //     height = _Math.nextPowerOfTwo(height);
    // }

    var canvas = TextureUtils._resampleImage(source, width, height, mipmap); // document.createElement('canvas');
    // canvas.width = width;
    // canvas.height = height;
    // var canvasContext = canvas.getContext('2d');
    // canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);


    source = canvas;
    width = canvas.width;
    height = canvas.height;
  }

  tx = new textureCtor({
    context: context,
    source: source,
    width: width,
    height: height,
    pixelFormat: pixelFormat,
    pixelDatatype: texture.type,
    sampler: sampler,
    flipY: texture.flipY,
    preMultiplyAlpha: texture.preMultiplyAlpha
  });

  if (mipmap && !isCompressed) {
    tx.generateMipmap();
  }

  return tx;
};

TextureUtils.createCubeTexture = function (textureUniform, context) {
  var images = textureUniform.value;
  var cubemap = new Cesium.CubeMap({
    context: context,
    source: {
      positiveX: images[0],
      negativeX: images[1],
      positiveY: images[2],
      negativeY: images[3],
      positiveZ: images[4],
      negativeZ: images[5]
    },
    pixelFormat: textureUniform.format,
    pixelDatatype: textureUniform.type,
    preMultiplyAlpha: textureUniform.preMultiplyAlpha,
    flipY: textureUniform.flipY //,
    // sampler: item.sampler ? new Cesium.Sampler(item.sampler) : undefined

  });
  return cubemap;
};

TextureUtils.fromTexure3js = function (val3js, valCesium) {
  if (val3js.isTexture) {
    var sampler = {};
    sampler.minificationFilter = _ConstantMap["default"].minFilterMap[val3js.minFilter];
    sampler.magnificationFilter = _ConstantMap["default"].magFilterMap[val3js.magFilter];
    sampler.wrapS = _ConstantMap["default"].textureWrapMap[val3js.wrapS];
    sampler.wrapT = _ConstantMap["default"].textureWrapMap[val3js.wrapT];
    sampler.maximumAnisotropy = val3js.anisotropy;

    if (!valCesium) {
      valCesium = {
        uuid: val3js.uuid
      };
      valCesium._disposeCallbacks = [];

      valCesium.onDispose = function (disposeCallback) {
        if (this._disposeCallbacks.indexOf(disposeCallback) == -1) {
          this._disposeCallbacks.push(disposeCallback);
        }
      };

      valCesium.destroy = function () {
        for (var i = 0; i < this._disposeCallbacks.length; i++) {
          var disposeCallback = this._disposeCallbacks[i];
          disposeCallback.call(this);
        }

        this._disposeCallbacks.splice(0);
      };
    }

    if (!valCesium.getCacheKey) {
      valCesium.getCacheKey = function () {
        var item = this;
        var cacheKey = !item.uuid && typeof item.value == 'string' ? item.value : item.uuid;

        if (!cacheKey) {
          if (item.value.uuid && (item._value instanceof HTMLImageElement || item.value instanceof HTMLCanvasElement || item.value instanceof HTMLVideoElement || item.value instanceof OffscreenCanvas)) {
            cacheKey = item._value.uuid;
          }
        }

        return cacheKey;
      };
    }

    valCesium.value = val3js.image;
    var needsUpdate = valCesium.version != val3js.version;
    var cacheKey = valCesium.getCacheKey();
    if (!needsUpdate && valCesium.cacheKey != cacheKey) needsUpdate = true;
    var isEmptyTextureUniform = false;

    if (val3js.isDataTexture) {
      valCesium.width = val3js.image.width;
      valCesium.height = val3js.image.height;
      valCesium.source = {
        arrayBufferView: val3js.image.data,
        width: val3js.image.width,
        height: val3js.image.height
      };
      valCesium.needsUpdate = !!val3js.image.data;
    } else if (val3js.isCompressedTexture) {
      if (!val3js.image.width || !val3js.image.height) {
        var images = val3js.image;

        if (Array.isArray(images) && images.length > 0 && images[0].width && images[0].width) {
          if (needsUpdate) {
            valCesium.value = images;
            valCesium.source = [];
            valCesium.width = images[0].width;
            valCesium.height = images[0].height;

            for (var i = 0; i < images.length; i++) {
              var image = images[i];
              var mipLevels = [];

              for (var _i = 1; _i < image.mipmaps.length; _i++) {
                mipLevels.push(image.mipmaps[_i].data);
              }

              var source = {
                arrayBufferView: image.mipmaps[0].data,
                width: image.width,
                height: image.height,
                mipLevels: mipLevels
              };
              valCesium.source.push(source);
            }
          }
        } else {
          valCesium.value = null;
          valCesium.source = null;
          isEmptyTextureUniform = true;
        }
      } else {
        valCesium.width = val3js.image.width;
        valCesium.height = val3js.image.height;
        valCesium.value = {
          width: val3js.image.width,
          height: val3js.image.height,
          arrayBufferView: val3js.image.data
        };

        if (needsUpdate && val3js.mipmaps && val3js.mipmaps.length > 0) {
          var _mipLevels = [];

          for (var _i2 = 1; _i2 < val3js.mipmaps.length; _i2++) {
            _mipLevels.push(val3js.mipmaps[_i2].data);
          }

          valCesium.source = {
            arrayBufferView: val3js.mipmaps[0].data,
            width: val3js.image.width,
            height: val3js.image.height,
            mipLevels: _mipLevels
          };
        }
      }
    } else if (val3js.isCanvasTexture || val3js.image instanceof ImageData) {
      valCesium.width = val3js.image.width;
      valCesium.height = val3js.image.height;
      valCesium.source = val3js.image;
    } else if (Array.isArray(valCesium.value)) {
      //hdr CubeTexture
      var _images = valCesium.value;
      var hasEmpty = false;
      _images = _images.map(function (image) {
        if (!image) hasEmpty = true;

        if (image.isDataTexture) {
          var tex = image;
          return {
            width: tex.image.width,
            height: tex.image.height,
            arrayBufferView: tex.image.data
          };
        }

        return image;
      });
      isEmptyTextureUniform = !_images.length && !hasEmpty;
    } else {
      isEmptyTextureUniform = true;
    }

    valCesium.type = _ConstantMap["default"].typesMap[val3js.type];
    valCesium.format = _ConstantMap["default"].formatsMap[val3js.format];
    valCesium.sampler = sampler;
    valCesium.flipY = val3js.flipY;
    valCesium.preMultiplyAlpha = val3js.premultiplyAlpha;
    valCesium.needsUpdate = true;
    valCesium.isEmptyTextureUniform = isEmptyTextureUniform || !valCesium.value && !valCesium.source;
    valCesium.version = val3js.version;
    valCesium.cacheKey = cacheKey;
    return valCesium;
  } else {
    return val3js;
  }
};
/**
* 初始化给定节点树中第一个没有初始化的纹理（map和lightMap），如果已经全部初始化，则返回true
* @param {Cesium.FrameState} frameState 
* @param {THREE.Group|THREE.Scene} content 
* @param {Object} textureCache 
* @param {string[]} textureCache 
* @param {string} [uuidPrefix] 
* @param {number} [maximumTextureSize]
* @param {boolean} [maxMipmapSize=1024]
* @returns {boolean} ready
*/


TextureUtils.initTexture = function (frameState, content, textureCache, textureIds, uuidPrefix, maximumTextureSize, maxMipmapSize) {
  var _Cesium2 = Cesium,
      WebGLConstants = _Cesium2.WebGLConstants,
      Sampler = _Cesium2.Sampler;
  var LinearFilter = 1006;
  var ready = true,
      textures = [];
  maxMipmapSize = maxMipmapSize || 1024;
  content.traverse(function (obj) {
    if (!obj.material) return;
    var material = obj.material;
    var tex = material.map;

    if (tex) {
      var img = tex.image;

      if (img.width >= maxMipmapSize || img.height >= maxMipmapSize) {
        tex.minFilter = LinearFilter;
      }

      if (uuidPrefix && !tex.uuid.startsWith(uuidPrefix)) {
        tex.uuid = uuidPrefix + tex.uuid;
      }

      if (!textureCache[tex.uuid]) textures.push(tex);else {
        var texCes = textureCache[tex.uuid];
        texCes.referenceCount = (texCes.referenceCount || 0) + 1; // if ((texCes.width > 2048 || texCes.height > 2048) && texCes.referenceCount > 5) {
        //     console.log(texCes.referenceCount);
        // }
      }
    }

    if (material.lightMap && !textureCache[material.lightMap.uuid]) {
      material.lightMap.minFilter = LinearFilter;
      material.lightMap.__isLightMap = true;
      textures.push(material.lightMap);
    }
  });

  if (textures.length > 0) {
    var item = {},
        tex = textures.shift();
    TextureUtils.fromTexure3js(tex, item);
    var image = item.value;
    var format = 6407;

    if (image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image.src && image.src.toLocaleLowerCase().indexOf(".png") >= 0) {
      format = 6408;
    }

    var sampler = item.sampler;
    var texture = TextureUtils.createTexture({
      context: frameState.context,
      source: item.source || image,
      // target: 3553,
      width: item.width || image.width,
      height: item.height || image.height,
      format: item.format || format,
      flipY: item.flipY,
      type: item.type,
      sampler: new Sampler(sampler),
      preMultiplyAlpha: item.preMultiplyAlpha
    }, frameState.context, tex.__isLightMap ? undefined : maximumTextureSize);
    delete tex.__isLightMap;
    textureCache[tex.uuid] = texture;
    ready = textures.length == 0;
    tex.addEventListener('dispose', function () {
      if (!texture.referenceCount) {
        if (!texture.isDestroyed || !texture.isDestroyed()) texture.destroy();
        delete textureCache[tex.uuid];
      } else {
        texture.referenceCount--;
      }
    });

    if (textureIds) {
      textureIds.push(tex.uuid);
    }
  }

  return ready;
};
/**
 * 
 * @param {THREE.Mesh} mesh  
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {undefined|THREE.Mesh} newMesh
 */


TextureUtils.clampToUV = function (mesh, forcePowerOfTwo) {
  var geometry = mesh.geometry,
      material = mesh.material,
      uv = geometry.getAttribute('uv');
  if (!uv || !material.map || !material.map.image) return;
  var minX = Number.MAX_VALUE,
      maxX = -Number.MAX_VALUE,
      minY = Number.MAX_VALUE,
      maxY = -Number.MAX_VALUE;

  for (var i = 0; i < uv.array.length; i += 2) {
    var x = uv.array[i],
        y = uv.array[i + 1];
    maxX = Math.max(maxX, x);
    minX = Math.min(minX, x);
    maxY = Math.max(maxY, y);
    minY = Math.min(minY, y);
  }

  var _Math = Cesium.Math;
  var deltX = maxX - minX,
      deltY = maxY - minY;

  if ((deltX < 1 || deltY <= 1) && minX >= 0 && _Math.lessThanOrEquals(maxX, 1, _Math.EPSILON2) && minY >= 0 && _Math.lessThanOrEquals(maxY, 1, _Math.EPSILON2)) {
    mesh = mesh.clone();
    geometry = geometry.clone();
    material = material.clone();
    mesh.material = material;
    mesh.geometry = geometry;
    uv = uv.clone();
    geometry.setAttribute('uv', uv);

    for (var _i3 = 0; _i3 < uv.array.length; _i3 += 2) {
      var _x2 = uv.array[_i3],
          _y2 = uv.array[_i3 + 1];
      _x2 = (_x2 - minX) / deltX;
      _y2 = (_y2 - minY) / deltY;
      uv.array[_i3] = _x2;
      uv.array[_i3 + 1] = _y2;
    }

    var map = material.map.clone(),
        image = map.image;
    map.wrapT = map.wrapS = 1001;
    map.uuid = THREE.Math.generateUUID();

    var width = Math.ceil(deltX * image.width),
        height = Math.ceil(deltY * image.height),
        _x = -Math.floor(minX * image.width),
        _y = -Math.floor(minY * image.height);

    if (forcePowerOfTwo && (!_Math.isPowerOfTwo(width) || !_Math.isPowerOfTwo(height))) {
      width = _Math.nextPowerOfTwo(width);
      height = _Math.nextPowerOfTwo(height);
    }

    var cv = document.createElement('canvas');
    cv.width = width;
    cv.height = height;
    var ctx = cv.getContext('2d');
    ctx.drawImage(image, _x, _y);
    cv.src = image.src;
    map.image = cv;
    material.map = map;
    return mesh;
  }
};
/**
 * 
 * @param {THREE.Texture} texture 
 * @param {number} scaleFactor  0~1
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {THREE.Texture} texture
 */


TextureUtils.resampleTexture = function (texture, scaleFactor, forcePowerOfTwo) {
  var source = texture.image;
  var minFilter = texture.minFilter,
      _THREE = THREE,
      LinearFilter = 1006,
      NearestFilter = 1003;

  if (!forcePowerOfTwo) {
    forcePowerOfTwo = minFilter != LinearFilter && minFilter != NearestFilter;
  }

  var dstCanvas = this.resampleImage(source, scaleFactor, forcePowerOfTwo);
  texture.width = dstCanvas.width;
  texture.height = dstCanvas.height;
  texture.image = dstCanvas;
  return texture;
};
/**
 * 
 * @param {HTMLImageElement|HTMLCanvasElement} source 
 * @param {number} scaleFactor  0~1
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {HTMLCanvasElement} result
 */


TextureUtils.resampleImage = function (source, scaleFactor, forcePowerOfTwo) {
  var _Math = Cesium.Math;
  var srcWidth = source.width,
      srcHeight = source.height;
  var width = parseInt(srcWidth * scaleFactor),
      height = parseInt(srcHeight * scaleFactor);
  var dstCanvas;

  if (scaleFactor != 1) {
    dstCanvas = this._resampleImage(source, width, height, forcePowerOfTwo); //document.createElement('canvas');
  } else {
    if (forcePowerOfTwo) {
      width = _Math.nextPowerOfTwo(width);
      height = _Math.nextPowerOfTwo(height);
    }

    dstCanvas = document.createElement('canvas');
    dstCanvas.width = width;
    dstCanvas.height = height;
    var destContext = dstCanvas.getContext('2d');
    destContext.drawImage(source, 0, 0, srcWidth, srcHeight, 0, 0, width, height);
  }

  return dstCanvas;
};
/**
 * 
 * @param {HTMLImageElement|HTMLCanvasElement} source 
 * @param {number} dstWidth  
 * @param {number} dstHeight  
 * @param {boolean} [forcePowerOfTwo]  
 * @returns {HTMLCanvasElement} result
 */


TextureUtils._resampleImage = function (source, dstWidth, dstHeight, forcePowerOfTwo) {
  var _Math = Cesium.Math;
  var srcWidth = source.width,
      srcHeight = source.height;
  var width = dstWidth,
      height = dstHeight;
  var dstCanvas = document.createElement('canvas');

  if (forcePowerOfTwo) {
    width = _Math.nextPowerOfTwo(width);
    height = _Math.nextPowerOfTwo(height);
  }

  dstCanvas.width = width;
  dstCanvas.height = height;
  var dstContext = dstCanvas.getContext('2d');
  var srcCanvas = source,
      srcContext;

  if (!(source instanceof HTMLCanvasElement)) {
    srcCanvas = document.createElement('canvas');
    srcCanvas.width = srcWidth;
    srcCanvas.height = srcHeight;
    srcContext = srcCanvas.getContext('2d');
    srcContext.drawImage(source, 0, 0);
  } else {
    srcContext = srcCanvas.getContext('2d');
  }

  var srcImageData = srcContext.getImageData(0, 0, srcWidth, srcHeight); //nearset

  var dstImageData = dstContext.getImageData(0, 0, width, height);
  var dstPtr = 0,
      scaleX = srcWidth / width,
      scaleY = srcHeight / height,
      stride = 4,
      srcRrow = 0,
      srcCol = 0,
      srcPtr = 0;

  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      srcRrow = parseInt(i * scaleY);
      srcCol = parseInt(j * scaleX);
      srcPtr = stride * (srcRrow * srcWidth + srcCol);

      for (var _j = 0; _j < stride; _j++) {
        dstImageData.data[dstPtr + _j] = srcImageData.data[srcPtr + _j];
      }

      dstPtr += stride;
    }
  }

  dstContext.putImageData(dstImageData, 0, 0);
  return dstCanvas;
};
/**
 * 
 * @param {Cesium.Texture|Cesium.CubeMapFace} destTexture 
 * @param {object} source
 */


TextureUtils.copyFromCompressData = function (destTexture, source) {
  var size = destTexture._size;
  var pixelFormat = destTexture._pixelFormat;
  var pixelDatatype = destTexture._pixelDatatype;
  var preMultiplyAlpha = destTexture._preMultiplyAlpha;
  var flipY = destTexture._flipY;
  /**
   * @type {WebGLRenderingContext}
   * @private
   */

  var gl = destTexture._gl || destTexture._context._gl;
  var textureTarget = destTexture._textureTarget;
  var texture = destTexture._texture;
  var targetFace = typeof destTexture._targetFace == 'number' ? destTexture._targetFace : textureTarget;
  var width = source.width;
  var height = source.height;
  var arrayBufferView = source.arrayBufferView;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(textureTarget, texture);
  var unpackAlignment = 4;
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); // Source: typed array

  var arrayBufferView = source.arrayBufferView;
  var _Cesium3 = Cesium,
      PixelFormat = _Cesium3.PixelFormat,
      defined = _Cesium3.defined;
  var isCompressed = PixelFormat.isCompressedFormat(pixelFormat);

  if (isCompressed) {
    gl.compressedTexImage2D(targetFace, 0, //level
    pixelFormat, width, height, 0, arrayBufferView);
  } else {
    gl.texImage2D(targetFace, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, arrayBufferView);
  }

  if (defined(source.mipLevels)) {
    var mipWidth = width;
    var mipHeight = height;

    for (var i = 0; i < source.mipLevels.length; ++i) {
      mipWidth = Math.floor(mipWidth / 2) | 0;

      if (mipWidth < 1) {
        mipWidth = 1;
      }

      mipHeight = Math.floor(mipHeight / 2) | 0;

      if (mipHeight < 1) {
        mipHeight = 1;
      }

      if (isCompressed) {
        gl.compressedTexImage2D(targetFace, i + 1, pixelFormat, mipWidth, mipHeight, 0, source.mipLevels[i]);
      } else {
        gl.texImage2D(targetFace, i + 1, pixelFormat, mipWidth, mipHeight, 0, pixelFormat, pixelDatatype, source.mipLevels[i]);
      }
    }
  }

  gl.bindTexture(textureTarget, null);
};

var _default = TextureUtils;
exports["default"] = _default;

},{"._29":12,"D_50":13,"M_0":241}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    var extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }
  /* eslint-disable no-undef */


  var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
  /* eslint-enable no-undef */

  var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  var maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('Mesh3D.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  var maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
  return {
    gl: gl,
    isWebGL2: isWebGL2,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}

var _default = WebGLCapabilities;
exports["default"] = _default;

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function WebGLClipping(properties, visualizer) {
  var _THREE = THREE,
      Matrix3 = _THREE.Matrix3,
      Plane = _THREE.Plane,
      Vector3 = _THREE.Vector3;
  var scope = this;
  var globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false;
  var plane = new Plane(),
      viewNormalMatrix = new Matrix3(),
      uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (material, camera, useCache) {
    var planes = material.clippingPlanes,
        clipIntersection = material.clipIntersection,
        clipShadows = material.clipShadows;
    var materialProperties = properties.get(material);

    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
          lGlobal = nGlobal * 4;
      var dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, useCache);

      for (var i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }

      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0;
    var dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4,
            viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}

var _default = WebGLClipping;
exports["default"] = _default;

},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function WebGLCubeMaps(renderer) {
  if (typeof THREE == 'undefined') {
    return {
      get: function get(texture) {
        return texture;
      },
      dispose: function dispose() {}
    };
  }

  var _THREE = THREE,
      CubeReflectionMapping = 301,
      CubeRefractionMapping = 302,
      EquirectangularReflectionMapping = 303,
      EquirectangularRefractionMapping = 304,
      WebGLCubeRenderTarget = _THREE.WebGLCubeRenderTarget;
  var cubemaps = new WeakMap();

  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }

    return texture;
  }

  function get(texture) {
    if (texture && texture.isTexture) {
      var mapping = texture.mapping;

      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          var cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          var image = texture.image;

          if (image && image.height > 0) {
            // const currentRenderList = renderer.getRenderList();
            var currentRenderTarget = renderer.getRenderTarget();
            var currentRenderState = renderer.renderState; //getRenderState();

            var currentAutoConvertCamera = renderer.autoConvertCamera;
            var renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderer.autoConvertCamera = true;
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.autoConvertCamera = currentAutoConvertCamera;
            renderer.setRenderTarget(currentRenderTarget); // renderer.setRenderList(currentRenderList); 

            renderer.renderState = currentRenderState; // renderer.setRenderState(currentRenderState);

            texture.addEventListener('dispose', onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            // image not yet ready. try the conversion next frame
            return null;
          }
        }
      }
    }

    return texture;
  }

  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    var cubemap = cubemaps.get(texture);

    if (cubemap !== undefined) {
      cubemaps["delete"](texture);
      cubemap.dispose();
    }
  }

  function dispose() {
    cubemaps = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

var _default = WebGLCubeMaps;
exports["default"] = _default;

},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function WebGLExtensions(gl) {
  var extensions = {};
  return {
    has: function has(name) {
      if (extensions[name] !== undefined) {
        return extensions[name] !== null;
      }

      var extension;

      switch (name) {
        case 'WEBGL_depth_texture':
          extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
          break;

        case 'EXT_texture_filter_anisotropic':
          extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
          break;

        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
          break;

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
      }

      extensions[name] = extension;
      return extension !== null;
    },
    get: function get(name) {
      if (!this.has(name)) {
        console.warn('Mesh3D.WebGLRenderer: ' + name + ' extension not supported.');
      }

      return extensions[name];
    }
  };
}

var _default = WebGLExtensions;
exports["default"] = _default;

},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function WebGLGeometries() {}

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  var max = array[0];

  for (var i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}
/**
 * @param {THREE.BufferGeometry}geometry
 * @returns {THREE.BufferAttribute}
 */


WebGLGeometries.getWireframeAttribute = function () {
  var wireframeAttributes = new WeakMap();

  function updateWireframeAttribute(geometry) {
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryPosition = geometry.attributes.position;
    var version = 0;

    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      version = geometryIndex.version;

      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var array = geometryPosition.array;
      version = geometryPosition.version;

      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        var a = i + 0;
        var b = i + 1;
        var c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }

    var _THREE = THREE,
        Uint32BufferAttribute = _THREE.Uint32BufferAttribute,
        Uint16BufferAttribute = _THREE.Uint16BufferAttribute;
    var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version; // attributes.update( attribute, 34963 );
    //

    var previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) previousAttribute.onGeometryDispose(); //attributes.remove( previousAttribute );
    //

    function onGeometryDispose() {
      wireframeAttributes["delete"](geometry);
      geometry.addEventListener('dispose', onGeometryDispose);
    }

    attribute.onGeometryDispose = onGeometryDispose;
    geometry.addEventListener('dispose', onGeometryDispose);
    wireframeAttributes.set(geometry, attribute);
  }
  /**
   * @param {THREE.BufferGeometry}geometry
   * @returns {THREE.BufferAttribute}
   * @private
   */


  function getWireframeAttribute(geometry) {
    var currentAttribute = wireframeAttributes.get(geometry);

    if (currentAttribute) {
      var geometryIndex = geometry.index;

      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }

    return wireframeAttributes.get(geometry);
  }

  return getWireframeAttribute;
}();
/**
 * 
 * @param {THREE.Geometry|THREE.BufferGeometry|THREE.LineSegments|THREE.Points|Cesium.Geometry} geometry 
 * @return {THREE.BufferGeometry|Cesium.Geometry}
 */


WebGLGeometries.get = function () {
  var geometries = new WeakMap();
  /**
   * 
   * @param {THREE.Geometry|THREE.BufferGeometry|THREE.LineSegments|THREE.Points} geometry
   * @param {THREE.Material[]}[materials]
   * @return {THREE.BufferGeometry}
   * @private
   */

  function get(geometry, materials) {
    var bufferGeometry;

    if (geometry.isBufferGeometry || geometry instanceof Cesium.Geometry) {
      bufferGeometry = geometry;
    } else {
      bufferGeometry = geometries.get(geometry);

      if (!bufferGeometry) {
        var onGeometryDispose = function onGeometryDispose() {
          bufferGeometry.dispose();
          geometries["delete"](geometry);
          bufferGeometry.removeEventListener('dispose', onGeometryDispose);
        };

        bufferGeometry = new THREE.BufferGeometry();
        bufferGeometry.fromGeometry(geometry);
        bufferGeometry.addEventListener('dispose', onGeometryDispose);
        geometries.set(geometry, bufferGeometry);
      }
    } //


    var BoundingSphere = Cesium.BoundingSphere;

    if (!bufferGeometry.boundingSphere) {
      if (bufferGeometry.computeBoundingSphere) {
        bufferGeometry.computeBoundingSphere();
      } else {
        var posAttr = bufferGeometry.attributes.position;
        geometry.boundingSphere = BoundingSphere.fromVertices(posAttr.values || posAttr.array);
      }
    }

    if (!bufferGeometry.boundingVolume) {
      bufferGeometry.boundingVolume = BoundingSphere.clone(bufferGeometry.boundingSphere);
    } //


    var groups = bufferGeometry.groups;

    if ( // materials &&
    groups && groups.length > 0 && !bufferGeometry.groupsOptimized) {
      var groupsOptimized = [],
          tempDic = {};
      var materialIndicesUsed = [];
      groups.forEach(function (g, groupIndex) {
        var materialIndex = g.materialIndex;

        if (!tempDic[materialIndex]) {
          materialIndicesUsed.push(materialIndex);
        } else {
          // var material = materials[materialIndex]
          // if (!material.transparent)  
          return;
        }

        groupsOptimized.push({
          materialIndex: materialIndex,
          groupIndex: groupIndex
        });
        tempDic[materialIndex] = true;
      });
      bufferGeometry.groupsOptimized = groupsOptimized;
      bufferGeometry.materialIndicesUsed = materialIndicesUsed;
    }

    return bufferGeometry;
  }

  return get;
}();

var _default = WebGLGeometries;
exports["default"] = _default;

},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * 改造threejs WebGLLights
 */
function WebGLLights() {
  var _Cesium2 = Cesium,
      Matrix4 = _Cesium2.Matrix4,
      Matrix3 = _Cesium2.Matrix3,
      Cartesian3 = _Cesium2.Cartesian3,
      Color = _Cesium2.Color,
      Texture = _Cesium2.Texture,
      PixelDatatype = _Cesium2.PixelDatatype,
      PixelFormat = _Cesium2.PixelFormat;
  var cache = new UniformsCache();
  var shadowCache = new ShadowUniformsCache();
  var extensionState = {
    point: {
      positions: [],
      colors: [],
      decalDists: [],
      visibles: [],
      map: null,
      array: null
    }
  };
  var state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: new Color(0, 0, 0, 1),

    /**
     * @type {Cesium.Cartesian3}
     * @private
     */
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],

    /**
     * @type {{
     * position:Cesium.Cartesian3,
     * color:Cesium.Color,
     * distance:number,
     * decay:number
     * }[]}
     */
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numDirectionalShadows: -1,
    numPointShadows: -1,
    numSpotShadows: -1
  };

  for (var i = 0; i < 9; i++) {
    state.probe.push(new Cartesian3());
  }

  var vector3 = new Cartesian3();
  var matrix4 = new Matrix4();
  var matrix42 = new Matrix4();
  var matrix3 = new Matrix3();
  /**
   * 
   * @param {Light[]} lights 
   * @param {*} shadows 
   * @param {Cesium.Camera} camera 
   * @param {Cesium.FrameState}frameState
   * @private
   */

  function setup(lights, shadows, camera, frameState) {
    var r = 0,
        g = 0,
        b = 0;

    for (var i = 0; i < 9; i++) {
      state.probe[i].set(0, 0, 0);
    }

    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var numDirectionalShadows = 0;
    var numPointShadows = 0;
    var numSpotShadows = 0;
    var viewMatrix = camera.viewMatrix; // camera.matrixWorldInverse;

    lights.sort(shadowCastingLightsFirst);
    extensionState.point.positions.length = 0;
    extensionState.point.colors.length = extensionState.point.decalDists.length = 0;

    for (var i = 0, l = lights.length; i < l; i++) {
      var light = lights[i];
      var color = light.color; //getColor(light.color);

      var intensity = light.intensity;
      var distance = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.red * intensity;
        g += color.green * intensity;
        b += color.blue * intensity;
      } else if (light.isLightProbe) {
        //未处理
        for (var j = 0; j < 9; j++) {
          // state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          // Cartesian3.add(
          //     state.probe[j],
          //     Cartesian3.multiplyByScalar(light.sh.coefficients[j],
          //         intensity, state.probe[j]));
          state.probe[j].x = light.sh.coefficients[j].x * intensity;
          state.probe[j].y = light.sh.coefficients[j].y * intensity;
          state.probe[j].z = light.sh.coefficients[j].z * intensity;
        }
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        Color.multiplyByScalar(color, intensity, uniforms.color); //uniforms.color.copy(light.color).multiplyScalar(light.intensity);

        Matrix4.getTranslation(light.modelMatrix, uniforms.direction); // uniforms.direction.setFromMatrixPosition(light.matrixWorld);

        Matrix4.getTranslation(light.target.modelMatrix, vector3); //vector3.setFromMatrixPosition(light.target.matrixWorld);

        Cartesian3.subtract(uniforms.direction, vector3, uniforms.direction); //uniforms.direction.sub(vector3);

        transformDirection(uniforms.direction, viewMatrix); // Cesium.Matrix4.multiplyByPoint(viewMatrix, uniforms.direction, uniforms.direction); //uniforms.direction.transformDirection(viewMatrix);

        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          var _shadow = light.shadow;
          var shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = _shadow.bias;
          shadowUniforms.shadowNormalBias = _shadow.normalBias;
          shadowUniforms.shadowRadius = _shadow.radius;
          shadowUniforms.shadowMapSize = _shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          var shadowMatrix = light.shadow.matrix;
          state.directionalShadowMatrix[directionalLength] = Matrix4.clone(shadowMatrix.elements || shadowMatrix, state.directionalShadowMatrix[directionalLength]);
          numDirectionalShadows++;
        }

        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var uniforms = cache.get(light);
        Matrix4.getTranslation(light.modelMatrix, uniforms.position); //uniforms.position.setFromMatrixPosition(light.matrixWorld);

        Matrix4.multiplyByPoint(viewMatrix, uniforms.position, uniforms.position); //uniforms.position.applyMatrix4(viewMatrix);

        Color.multiplyByScalar(color, intensity, uniforms.color); //uniforms.color.copy(color).multiplyScalar(intensity);

        uniforms.distance = distance; // uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        // vector3.setFromMatrixPosition(light.target.matrixWorld);
        // uniforms.direction.sub(vector3);
        // uniforms.direction.transformDirection(viewMatrix);

        Matrix4.getTranslation(light.modelMatrix, uniforms.direction); // uniforms.direction.setFromMatrixPosition(light.matrixWorld);

        Matrix4.getTranslation(light.target.modelMatrix, vector3); //vector3.setFromMatrixPosition(light.target.matrixWorld);

        Cartesian3.subtract(uniforms.direction, vector3, uniforms.direction); //uniforms.direction.sub(vector3);

        transformDirection(uniforms.direction, viewMatrix); //Cesium.Matrix4.multiplyByPoint(viewMatrix, uniforms.direction, uniforms.direction); //uniforms.direction.transformDirection(viewMatrix);

        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;

        if (light.castShadow) {
          //未处理
          var _shadow2 = light.shadow;

          var _shadowUniforms = shadowCache.get(light);

          _shadowUniforms.shadowBias = _shadow2.bias;
          _shadowUniforms.shadowNormalBias = _shadow2.normalBias;
          _shadowUniforms.shadowRadius = _shadow2.radius;
          _shadowUniforms.shadowMapSize = _shadow2.mapSize;
          state.spotShadow[spotLength] = _shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          var _shadowMatrix = light.shadow.matrix;
          state.spotShadowMatrix[spotLength] = Matrix4.clone(_shadowMatrix.elements || _shadowMatrix, state.spotShadowMatrix[spotLength]);
          numSpotShadows++;
        }

        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var uniforms = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light

        Color.multiplyByScalar(color, intensity, uniforms.color); //uniforms.color.copy(color).multiplyScalar(intensity);

        Matrix4.getTranslation(light.modelMatrix, uniforms.position); //uniforms.position.setFromMatrixPosition(light.matrixWorld);

        Matrix4.multiplyByPoint(viewMatrix, uniforms.position, uniforms.position); //uniforms.position.applyMatrix4(viewMatrix);
        // extract local rotation of light to derive width/height half vectors

        Matrix4.IDENTITY.clone(matrix42); //matrix42.identity();

        Matrix4.clone(light.modelMatrix, matrix4); //matrix4.copy(light.matrixWorld);

        Matrix4.multiply(viewMatrix, matrix4, matrix4); //matrix4.premultiply(viewMatrix);

        Matrix4.multiplyByMatrix3(matrix42, Matrix4.getMatrix3(matrix4, matrix3), matrix42); //matrix42.extractRotation(matrix4);  

        Cartesian3.fromElements(light.width * 0.5, 0.0, 0.0, uniforms.halfWidth); //uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);

        Cartesian3.fromElements(0.0, light.height * 0.5, 0.0, uniforms.halfHeight); //uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

        Matrix4.multiplyByPoint(matrix42, uniforms.halfWidth, uniforms.halfWidth); //uniforms.halfWidth.applyMatrix4(matrix42);

        Matrix4.multiplyByPoint(matrix42, uniforms.halfHeight, uniforms.halfHeight); //uniforms.halfHeight.applyMatrix4(matrix42);
        // TODO (abelnation): RectAreaLight distance?
        // uniforms.distance = distance;

        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var uniforms = cache.get(light);
        Matrix4.getTranslation(light.modelMatrix, uniforms.position); //uniforms.position.setFromMatrixPosition(light.matrixWorld);

        Matrix4.multiplyByPoint(viewMatrix, uniforms.position, uniforms.position); //uniforms.position.applyMatrix4(viewMatrix);
        // uniforms.position.setFromMatrixPosition(light.matrixWorld);
        // uniforms.position.applyMatrix4(viewMatrix);

        Color.multiplyByScalar(color, intensity, uniforms.color); //uniforms.color.copy(light.color).multiplyScalar(light.intensity);

        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;
        uniforms.visible = light._exVisible ? 1 : 0;
        var extension = extensionState.point;
        extension.positions[pointLength] = uniforms.position;
        extension.colors[pointLength] = uniforms.color;
        extension.decalDists[pointLength] = uniforms.decalDist;
        uniforms.decalDist.x = light.decay;
        uniforms.decalDist.y = light.distance;
        extension.visibles[pointLength] = uniforms.visible;

        if (light.castShadow) {
          var shadow = light.shadow;

          var _shadowUniforms2 = shadowCache.get(light);

          _shadowUniforms2.shadowBias = shadow.bias;
          _shadowUniforms2.shadowNormalBias = shadow.normalBias;
          _shadowUniforms2.shadowRadius = shadow.radius;

          _shadowUniforms2.shadowMapSize.copy(shadow.mapSize);

          _shadowUniforms2.shadowCameraNear = shadow.camera.near;
          _shadowUniforms2.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = _shadowUniforms2;
          state.pointShadowMap[pointLength] = shadowMap;
          var _shadowMatrix2 = light.shadow.matrix;
          state.pointShadowMatrix[pointLength] = Matrix4.clone(_shadowMatrix2.elements || _shadowMatrix2, state.pointShadowMatrix[pointLength]);
          numPointShadows++;
        }

        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var uniforms = cache.get(light);
        Matrix4.getTranslation(light.modelMatrix, uniforms.direction); //uniforms.direction.setFromMatrixPosition(light.matrixWorld);

        transformDirection(uniforms.direction, viewMatrix); //uniforms.direction.transformDirection(viewMatrix);

        Cartesian3.normalize(uniforms.direction, uniforms.direction); // uniforms.direction.normalize();

        Color.multiplyByScalar(color, intensity, uniforms.skyColor); // uniforms.skyColor.copy(light.color).multiplyScalar(intensity);

        Color.multiplyByScalar(light.groundColor, intensity, uniforms.groundColor); //uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }

    state.ambient.red = r;
    state.ambient.green = g;
    state.ambient.blue = b;
    var hash = state.hash;

    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }

    updateMap(frameState, 1);
    updateMap(frameState, 2);
  }
  /**
   * 
   * @param {Cesium.FrameState} frameState 
   */


  function updateMap(frameState) {
    var pointLights = extensionState.point;
    /**
     * @type {Cesium.Texture}
     */

    var map = pointLights['map'];
    var array = pointLights['array'];
    var num = state.hash.pointLength;
    if (!frameState || !num) return;

    if (!map || pointLights.length != num) {
      if (map && !map.isDestroyed) map.destroy();
      pointLights.length = num;
      var context = frameState.context;
      var _Cesium = Cesium;
      map = new Texture({
        context: context,
        width: num * 2,
        height: 6,
        pixelDatatype: 5126,
        pixelFormat: 6408,
        sampler: new _Cesium.Sampler({
          wrapS: 33071,
          wrapT: 33071,
          magnificationFilter: 9729,
          minificationFilter: 9729
        })
      });
      pointLights['map'] = map;
      array = new Float32Array(map.width * map.height * 4);
      pointLights['array'] = array;
    }

    num *= 2;

    for (var _i = 0; _i < num; _i += 2) {
      var pos = pointLights.positions[_i / 2];
      var decalDist = pointLights.decalDists[_i / 2];
      var color = pointLights.colors[_i / 2];
      var visible = pointLights.visibles[_i / 2]; //position+decay

      for (var j = 0; j < 2; j++) {
        for (var k = 0; k < 2; k++) {
          var ptr = (num * j + _i + k) * 4;
          array[ptr] = pos.x;
          array[ptr + 1] = pos.y;
          array[ptr + 2] = pos.z;
          array[ptr + 3] = decalDist.x;
        }
      } //color&distance


      for (var _j = 2; _j < 4; _j++) {
        for (var _k = 0; _k < 2; _k++) {
          var ptr = (num * _j + _i + _k) * 4;
          array[ptr] = color.red;
          array[ptr + 1] = color.green;
          array[ptr + 2] = color.blue;
          array[ptr + 3] = decalDist.y;
        }
      } //visible


      for (var _j2 = 4; _j2 < 6; _j2++) {
        for (var _k2 = 0; _k2 < 2; _k2++) {
          var ptr = (num * _j2 + _i + _k2) * 4;
          array[ptr] = visible;
          array[ptr + 1] = visible;
          array[ptr + 2] = visible;
          array[ptr + 3] = visible;
        }
      }
    }

    map.copyFrom({
      width: map.width,
      height: map.height,
      arrayBufferView: array
    });
  }

  this.setup = setup;
  this.state = state;
  this.uniforms = {
    ambientLightColor: {
      value: state.ambient
    },
    directionalLights: {
      value: state.directional
    },
    spotLights: {
      value: state.spot
    },
    rectAreaLights: {
      value: state.rectArea
    },
    pointLights: {
      value: state.point
    },
    hemisphereLights: {
      value: state.hemi
    },
    directionalShadowMap: {
      value: state.directionalShadowMap
    },
    directionalShadowMatrix: {
      value: state.directionalShadowMatrix
    },
    spotShadowMap: {
      value: state.spotShadowMap
    },
    spotShadowMatrix: {
      value: state.spotShadowMatrix
    },
    pointShadowMap: {
      value: state.pointShadowMap
    },
    pointShadowMatrix: {
      value: state.pointShadowMatrix
    },
    lightProbe: {
      value: state.probe
    }
  };
  this.extensionState = extensionState;
}

function UniformsCache() {
  var lights = {};
  var _Cesium3 = Cesium,
      Cartesian2 = _Cesium3.Cartesian2,
      Cartesian3 = _Cesium3.Cartesian3,
      Color = _Cesium3.Color;
  return {
    get: function get(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      var uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Cartesian3(),
            color: new Color(),
            shadow: false // shadowBias: 0,
            // shadowRadius: 1,
            // shadowMapSize: new Cesium.Cartesian2()

          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new Cartesian3(),
            direction: new Cartesian3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: false // shadowBias: 0,
            // shadowRadius: 1,
            // shadowMapSize: new Cesium.Cartesian2()

          };
          break;

        case 'PointLight':
          uniforms = {
            position: new Cartesian3(),
            color: new Color(),
            distance: 0,
            decay: 0,
            shadow: false,
            // shadowBias: 0,
            // shadowRadius: 1,
            // shadowMapSize: new Cesium.Cartesian2(),
            // shadowCameraNear: 1,
            // shadowCameraFar: 1000
            //extension
            decalDist: new Cartesian2(),
            visible: 1
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new Cartesian3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Cartesian3(),
            halfWidth: new Cartesian3(),
            halfHeight: new Cartesian3() // TODO (abelnation): set RectAreaLight shadow uniforms

          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

function ShadowUniformsCache() {
  var lights = {};
  var _Cesium4 = Cesium,
      Cartesian3 = _Cesium4.Cartesian3,
      Color = _Cesium4.Color,
      Cartesian2 = _Cesium4.Cartesian2;
  return {
    get: function get(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      var uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Cartesian2()
          };
          break;

        case 'SpotLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Cartesian2()
          };
          break;

        case 'PointLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Cartesian2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;
        // TODO (abelnation): set RectAreaLight shadow uniforms
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

var nextVersion = 0;

function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}

function transformDirection(p, m) {
  // input: THREE.Matrix4 affine matrix
  // vector interpreted as a direction
  var x = p.x,
      y = p.y,
      z = p.z;
  var e = m;
  p.x = e[0] * x + e[4] * y + e[8] * z;
  p.y = e[1] * x + e[5] * y + e[9] * z;
  p.z = e[2] * x + e[6] * y + e[10] * z;
  return Cesium.Cartesian3.normalize(p, p);
}

var _default = WebGLLights;
exports["default"] = _default;

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

// import { BackSide } from '../../constants.js';
function WebGLMaterials(properties) {
  if (typeof THREE == 'undefined') {
    return {
      refreshFogUniforms: function refreshFogUniforms() {},
      refreshMaterialUniforms: function refreshMaterialUniforms() {}
    };
  }

  var _THREE = THREE,
      BackSide = 1; //

  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);

      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);

      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false; // #15581
    }
  }

  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    var envMap = properties.get(material).envMap;

    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;

      var maxMipLevel = properties.get(envMap).__maxMipLevel;

      if (maxMipLevel !== undefined) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. displacementMap map
    // 4. normal map
    // 5. bump map
    // 6. roughnessMap map
    // 7. metalnessMap map
    // 8. alphaMap map
    // 9. emissiveMap map
    // 10. clearcoat map
    // 11. clearcoat normal map
    // 12. clearcoat roughnessMap map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    } // uv repeat and offset setting priorities for uv2
    // 1. ao map
    // 2. light map


    var uv2ScaleMap;

    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }

    if (uv2ScaleMap !== undefined) {
      // backwards compatibility
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }

      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }

      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    var envMap = properties.get(material).envMap;

    if (envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen) uniforms.sheen.value.copy(material.sheen);

    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }

    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }

    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }

    uniforms.transmission.value = material.transmission;

    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }

  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  return {
    refreshFogUniforms: refreshFogUniforms,
    refreshMaterialUniforms: refreshMaterialUniforms
  };
}

var _default = WebGLMaterials;
exports["default"] = _default;

},{}],25:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _WebGLGeometries = _interopRequireDefault(require("e_23"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

function numericalSort(a, b) {
  return a[0] - b[0];
}

function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
/**
 * 
 * @param {WebGLRenderingContext} gl 
 * @param {WebGLRenderer} renderer 
 * @returns 
 */


function WebGLMorphtargets(gl, renderer) {
  var cesiumVertextArrays = renderer._cesiumVertextArrays;
  var influencesList = {}; // const morphInfluences = new Float32Array( 8 );

  var workInfluences = [];

  for (var i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }

  function update(object, geometry, material, program) {
    geometry = _WebGLGeometries["default"].get(geometry);
    var uniforms = getUniforms(object);
    var morphInfluences = uniforms.morphTargetInfluences;
    var objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

    var length = objectInfluences === undefined ? 0 : objectInfluences.length;
    var influences = influencesList[geometry.id];

    if (influences === undefined) {
      // initialise list
      influences = [];

      for (var _i = 0; _i < length; _i++) {
        influences[_i] = [_i, 0];
      }

      influencesList[geometry.id] = influences;
    } // Collect influences


    for (var _i2 = 0; _i2 < length; _i2++) {
      var influence = influences[_i2];
      influence[0] = _i2;
      influence[1] = objectInfluences[_i2];
    }

    influences.sort(absNumericalSort);

    for (var _i3 = 0; _i3 < 8; _i3++) {
      if (_i3 < length && influences[_i3][1]) {
        workInfluences[_i3][0] = influences[_i3][0];
        workInfluences[_i3][1] = influences[_i3][1];
      } else {
        workInfluences[_i3][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[_i3][1] = 0;
      }
    }

    workInfluences.sort(numericalSort);
    var morphTargets = material.morphTargets && geometry.morphAttributes.position;
    var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    var morphInfluencesSum = 0;

    for (var _i4 = 0; _i4 < 8; _i4++) {
      var _influence = workInfluences[_i4];
      var index = _influence[0];
      var value = _influence[1];

      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute('morphTarget' + _i4) !== morphTargets[index]) {
          morphTargets[index].id = index;
          geometry.setAttribute('morphTarget' + _i4, morphTargets[index]);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + _i4) !== morphNormals[index]) {
          geometry.setAttribute('morphNormal' + _i4, morphNormals[index]);
        }

        morphInfluences[_i4] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.getAttribute('morphTarget' + _i4) !== undefined) {
          geometry.deleteAttribute('morphTarget' + _i4);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + _i4) !== undefined) {
          geometry.deleteAttribute('morphNormal' + _i4);
        }

        morphInfluences[_i4] = 0;
      }
    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
    // This allows us to switch between absolute morphs and relative morphs without changing shader code
    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


    var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    uniforms.morphTargetBaseInfluence = morphBaseInfluence;
    uniforms.morphTargetInfluences = morphInfluences;
    updateMorphAttribute(uniforms, geometry); // program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
    // program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
  }

  var uniformsCache = new WeakMap();
  var objectCache = new WeakMap();

  function updateMorphAttribute(uniforms, geometry) {
    var objects = objectCache.get(uniforms);
    var attributes = geometry.attributes;

    var _loop = function _loop(name) {
      var attribute = attributes[name];

      if (name.includes('morphTarget') || name.includes('morphNormal')) {
        objects.forEach(function (object) {
          cesiumVertextArrays.updateVerexBuffer(object, name, attribute);
        });
      }
    };

    for (var name in attributes) {
      _loop(name);
    }
  }

  function setObjectCache(uniforms, object) {
    var objects = objectCache.get(uniforms);

    if (!objects) {
      objects = [];
      objectCache.set(uniforms, objects);
    }

    if (!objects.includes(object)) {
      objects.push(object);
      object.geometry.addEventListener('dispose', function () {
        var id = objects.indexOf(object);

        if (id >= 0) {
          objects.splice(id, 1);
        }
      });
    }
  }

  function getUniforms(object) {
    var uniforms = uniformsCache.get(object);

    if (!uniforms) {
      uniforms = {
        morphTargetBaseInfluence: 1,
        morphTargetInfluences: new Float32Array(8)
      };
      object.geometry.addEventListener('dispose', function () {
        uniformsCache["delete"](object);
      });
      uniformsCache.set(object, uniforms);
      setObjectCache(uniforms, object);
    }

    return uniforms;
  }

  function setUniforms(object, uniforms) {
    if (uniforms && object) {
      if (uniformsCache.get(object) == uniforms) {
        return;
      }

      object.geometry.addEventListener('dispose', function () {
        uniformsCache["delete"](object);
      });
      uniformsCache.set(object, uniforms);
      setObjectCache(uniforms, object);
    }
  }

  return {
    setUniforms: setUniforms,
    getUniforms: getUniforms,
    update: update
  };
}

var _default = WebGLMorphtargets;
exports["default"] = _default;

},{"e_23":22,"3_27":35,"M_0":241}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unrollLoops = unrollLoops;
exports["default"] = void 0;
// import lights_fragment_begin from './Shaders/lights_fragment_begin.glsl.js';
// import lights_pars_begin from './Shaders/lights_pars_begin.glsl.js';
var ShaderChunk3js, NoToneMapping, AddOperation, MixOperation, MultiplyOperation, EquirectangularRefractionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, CubeUVRefractionMapping, CubeUVReflectionMapping, CubeReflectionMapping, PCFSoftShadowMap, PCFShadowMap, VSMShadowMap, ACESFilmicToneMapping, CineonToneMapping, CustomToneMapping, ReinhardToneMapping, LinearToneMapping, GammaEncoding, RGBDEncoding, RGBM16Encoding, RGBM7Encoding, RGBEEncoding, sRGBEncoding, LinearEncoding, LogLuvEncoding, GLSL3;
var programIdCount = 0;
var initDeps$WebGLProgramDone = false;

function initDeps$WebGLProgram(params) {
  if (initDeps$WebGLProgramDone) return;
  initDeps$WebGLProgramDone = true;
  var _THREE = THREE;
  ShaderChunk3js = _THREE.ShaderChunk, NoToneMapping = 0, AddOperation = 2, MixOperation = 1, MultiplyOperation = 0, EquirectangularRefractionMapping = 304, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, CubeUVRefractionMapping = 307, CubeUVReflectionMapping = 306, CubeReflectionMapping = 301, PCFSoftShadowMap = 2, PCFShadowMap = 1, VSMShadowMap = 3, ACESFilmicToneMapping = 4, CineonToneMapping = 3, CustomToneMapping = 5, ReinhardToneMapping = 2, LinearToneMapping = 1, GammaEncoding = 3007, RGBDEncoding = 3006, RGBM16Encoding = 3005, RGBM7Encoding = 3004, RGBEEncoding = 3002, sRGBEncoding = 3001, LinearEncoding = 3000, LogLuvEncoding = 3003, GLSL3 = THREE.GLSL3;
} //three


function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];

    case sRGBEncoding:
      return ['sRGB', '( value )'];

    case RGBEEncoding:
      return ['RGBE', '( value )'];

    case RGBM7Encoding:
      return ['RGBM', '( value, 7.0 )'];

    case RGBM16Encoding:
      return ['RGBM', '( value, 16.0 )'];

    case RGBDEncoding:
      return ['RGBD', '( value, 256.0 )'];

    case GammaEncoding:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

    case LogLuvEncoding:
      return ['LogLuv', '( value )'];

    default:
      console.warn('Mesh3D.WebGLProgram: Unsupported encoding:', encoding);
      return ['Linear', '( value )'];
  }
}

function getTexelDecodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;

  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;

    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;

    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;

    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;

    case CustomToneMapping:
      toneMappingName = 'Custom';
      break;

    default:
      console.warn('Mesh3D.WebGLProgram: Unsupported toneMapping:', toneMapping);
      toneMappingName = 'Linear';
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(parameters) {
  var chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  var chunks = [];

  for (var name in defines) {
    var value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }

  return chunks.join('\n');
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
} // Resolve Includes


var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}

function includeReplacer(match, include) {
  var string; // if (include == 'lights_fragment_begin') {
  // 	string = lights_fragment_begin;
  // }
  // else if (include == 'lights_pars_begin') string = lights_pars_begin;
  // else

  string = ShaderChunk3js[include];

  if (string === undefined) {
    throw new Error('Can not resolve #include <' + include + '>');
  }

  return resolveIncludes(string);
} // Unroll Loops


var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}

function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn('Mesh3D.WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
  return loopReplacer(match, start, end, snippet);
}

function loopReplacer(match, start, end, snippet) {
  var string = '';

  for (var i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i).replace(/\(\s*i\s*\)/g, ' ' + i + ' ');
  }

  return string;
}

//
function generatePrecision(parameters) {
  var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }

  return precisionstring;
}

function generateShadowMapTypeDefine(parameters) {
  var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }

  return shadowMapTypeDefine;
}

function generateEnvMapTypeDefine(parameters) {
  var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  }

  return envMapTypeDefine;
}

function generateEnvMapModeDefine(parameters) {
  var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  }

  return envMapModeDefine;
}

function generateEnvMapBlendingDefine(parameters) {
  var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  return envMapBlendingDefine;
}

function WebGLProgram(renderer, cacheKey, parameters) {
  initDeps$WebGLProgram();
  var defines = parameters.defines;
  var vertexShader = parameters.vertexShader;
  var fragmentShader = parameters.fragmentShader;
  var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  var envMapModeDefine = generateEnvMapModeDefine(parameters);
  var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
  var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
  var customDefines = generateDefines(defines);
  var prefixVertex, prefixFragment;
  var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + "\n" : '';

  if (parameters.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk3js['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk3js['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    // GLSL 3.0 conversion for built-in materials and ShaderMaterial
    versionString = '#version 300 es\n';
    prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  var vertexGlsl = versionString + prefixVertex + vertexShader;
  var fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );
  //

  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.vertexShader = vertexGlsl;
  this.fragmentShader = fragmentGlsl;
  return this;
}

var _default = WebGLProgram;
exports["default"] = _default;

},{}],27:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _WebGLProgram = _interopRequireDefault(require("s_35"));

function WebGLPrograms(renderer, cubemaps, extensions, capabilities, clipping) {
  var _THREE = THREE,
      ShaderLib = _THREE.ShaderLib,
      UniformsUtils = _THREE.UniformsUtils,
      BackSide = 1,
      DoubleSide = 2,
      CubeUVRefractionMapping = 307,
      CubeUVReflectionMapping = 306,
      LinearEncoding = 3000,
      ObjectSpaceNormalMap = 1,
      TangentSpaceNormalMap = 0,
      NoToneMapping = 0;
  var programs = [];
  var isWebGL2 = capabilities.isWebGL2;
  var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  var floatVertexTextures = capabilities.floatVertexTextures;
  var maxVertexUniforms = capabilities.maxVertexUniforms;
  var vertexTextures = capabilities.vertexTextures;
  var precision = capabilities.precision;
  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  var parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

  function getMaxBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;

    if (floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      var nVertexUniforms = maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('Mesh3D.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getTextureEncodingFromMap(map) {
    var encoding;

    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("Mesh3D.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    }

    return encoding;
  }

  function getParameters(material, lights, shadows, scene, object) {
    var fog = scene.fog;
    var environment = material.isMeshStandardMaterial ? scene.environment : null; // const environment = material.envMap == null ? scene.environment : null;//MeshVisualizer

    var envMap = cubemaps.get(material.envMap || environment);
    var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('Mesh3D.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    var vertexShader, fragmentShader;

    if (shaderID) {
      var shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }

    var currentRenderTarget = renderer.getRenderTarget();
    var parameters = {
      isWebGL2: isWebGL2,
      shaderID: shaderID,
      shaderName: material.type,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      skinning: (material.skinning || object.isSkinnedMesh) && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }

  function getProgramCacheKey(parameters) {
    var array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }

    if (parameters.defines !== undefined) {
      for (var name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }

    if (parameters.isRawShaderMaterial === false) {
      for (var i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }

      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }

    array.push(parameters.customProgramCacheKey);
    return array.join();
  }

  function getUniforms(material) {
    var shaderID = shaderIDs[material.type];
    var uniforms;

    if (shaderID) {
      var shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }

    return uniforms;
  }

  function acquireProgram(parameters, cacheKey) {
    var program; // Check if code has been already compiled
    // for ( let p = 0, pl = programs.length; p < pl; p ++ ) {
    // 	const preexistingProgram = programs[ p ];
    // 	if ( preexistingProgram.cacheKey === cacheKey ) {
    // 		program = preexistingProgram;
    // 		++ program.usedTimes;
    // 		break;
    // 	}
    // }
    // if ( program === undefined ) {

    program = new _WebGLProgram["default"](renderer, cacheKey, parameters); //, bindingStates );
    // 	programs.push( program );
    // }

    return program;
  }

  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources
      // program.destroy();
    }
  }

  return {
    getParameters: getParameters,
    getProgramCacheKey: getProgramCacheKey,
    getUniforms: getUniforms,
    acquireProgram: acquireProgram,
    releaseProgram: releaseProgram,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: programs
  };
}

var _default = WebGLPrograms;
exports["default"] = _default;

},{"s_35":26,"M_0":241}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function WebGLProperties() {
  var properties = new WeakMap();

  function get(object, initObject) {
    // return object;
    var map = properties.get(object);

    if (map === undefined) {
      var onMaterialDispose = function onMaterialDispose() {
        properties["delete"](object);
        object.removeEventListener('dispose', onMaterialDispose);
      };

      map = initObject || {};
      properties.set(object, map);
      object.addEventListener('dispose', onMaterialDispose);
    }

    return map;
  }

  function remove(object) {
    properties["delete"](object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  this.properties = properties;
  this.get = get;
  this.remove = remove;
  this.update = update;

  this.dispose = function () {
    properties = new WeakMap();
    this.properties = properties;
  };
}

var _default = WebGLProperties;
exports["default"] = _default;

},{}],29:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _MeshVisualizer = _interopRequireDefault(require("M_33"));

function findGroupOrder(object) {
  if (object.isGroup) {
    return object.renderOrder;
  } else if (!object.parent) {
    return object.renderOrder;
  }

  return findGroupOrder(object.parent);
}
/**
 * 
 * @param {Cesium.DrawCommand} drawCommand 
 * @param {THREE.Material} material 
 * @param {number} materialIndex 
 * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object
 * @param {THREE.BufferGeometry} geometry 
 * @param {MeshVisualizer}visualizer
 * @param {number} [groupIndex]
 */


function WebGLRenderItem(drawCommand, material, materialIndex, object, geometry, visualizer, groupIndex) {
  var _Cesium2 = Cesium,
      destroyObject = _Cesium2.destroyObject,
      BoundingSphere = _Cesium2.BoundingSphere,
      DrawCommand = _Cesium2.DrawCommand,
      RenderState = _Cesium2.RenderState;
  drawCommand.derivedProperties = {};
  this.id = object ? object.id : 0;
  this.drawCommand = drawCommand;
  this.material = material || null;
  this.geometry = geometry;
  this.materialIndex = materialIndex;
  this.groupIndex = groupIndex;
  this.object = object || null;
  this.groupOrder = object ? findGroupOrder(object) || 0 : 0;
  this.renderOrder = object ? object.renderOrder || 0 : 0;
  this.visualizer = visualizer;
  this.currentScene = null;
  this.currentCamera = null; //runtime state

  this.boundingSphere = new BoundingSphere(); //local

  this.boundingVolume = new BoundingSphere(); //world

  this.materialVersion = -1;
  this.renderVersion = -1;
  this.programCacheKey = null;
  this.wireframeIndices = null;
  this.frustumCulled = true;
  this.z = -1;
  this.distanceToCamera = -1;
  this.visible = undefined;
  this.loaded = false;
  this.initialized = false;

  function destroyDrawCommand(drawCommand, cesiumRenderStateCache) {
    var va = drawCommand.vertexArray,
        sp = drawCommand.shaderProgram;
    if (!va.isDestroyed()) va.destroy();

    if (!sp.isDestroyed || !sp.isDestroyed()) {
      sp.destroy();
    }

    drawCommand.isDestroyed = function returnTrue() {
      return true;
    };

    drawCommand.uniformMap = undefined;
    drawCommand.renderState = RenderState.removeFromCache(drawCommand.renderState); //

    var derivedCommands = drawCommand.derivedCommands;

    if (!derivedCommands) {
      return cesiumRenderStateCache["delete"](drawCommand);
    }

    for (var key in derivedCommands) {
      if (derivedCommands.hasOwnProperty(key)) {
        var derivedCommand = derivedCommands[key];
        derivedCommand = derivedCommand.drawCommand || derivedCommand;

        if (!derivedCommand.isDestroyed && derivedCommand instanceof DrawCommand) {
          derivedCommand.uniformMap = undefined;
          destroyDrawCommand(derivedCommand, cesiumRenderStateCache);
        }

        derivedCommands[key] = undefined;
      }
    }

    cesiumRenderStateCache["delete"](drawCommand);
  }

  this.destroy = function () {
    var renderer = visualizer.renderer;

    renderer._cesiumRenderStateCache["delete"](drawCommand);

    destroyDrawCommand(drawCommand, renderer._cesiumRenderStateCache);
    destroyObject(drawCommand);

    for (var key in this) {
      this[key] = null;
    }
  };
}

Object.defineProperties(WebGLRenderItem.prototype, {
  pass: {
    get: function get() {
      return this.drawCommand._v_pass;
    }
  },
  renderPass: {
    get: function get() {
      return this.drawCommand.pass;
    }
  },
  modelMatrix: {
    get: function get() {
      return this.drawCommand.modelMatrix;
    }
  }
});

WebGLRenderItem.prototype.update = function (object, drawCommand, geometry, modelMatrixNeedsUpdate) {
  var _Cesium = Cesium;
  var renderItem = this;
  var boundingVolume = renderItem.boundingVolume;
  var isInstancedMesh = object.isInstancedMesh,
      frustumCulled = object.frustumCulled,
      modelMatrix = object.modelMatrix; //instanceCount

  if (isInstancedMesh) {
    drawCommand.instanceCount = object.count;
  } else if (isFinite(geometry.instanceCount)) {
    drawCommand.instanceCount = geometry.instanceCount;
  }

  if (drawCommand.instanceCount) {
    renderItem.frustumCulled = false;
  } else {
    renderItem.frustumCulled = frustumCulled;
  }

  if (object.isCustomInstancedMesh) {
    drawCommand.instanceCount = object._availableInstances.length;
    if (frustumCulled) _Cesium.BoundingSphere.clone(object._boundingSphere, boundingVolume);
  } else if (modelMatrixNeedsUpdate || object.modelMatrixNeedsUpdate || !renderItem.initialized) {
    var boundingSphere = this.boundingSphere;
    var Matrix4 = _Cesium.Matrix4;
    Matrix4.multiplyByPoint(modelMatrix, boundingSphere.center, boundingVolume.center);
    boundingVolume.radius = boundingSphere.radius * Matrix4.getMaximumScale(modelMatrix);
    renderItem.initialized = true;
  }

  drawCommand.boundingVolume = frustumCulled ? boundingVolume : undefined;
  drawCommand.modelMatrix = modelMatrix;
};

var _default = WebGLRenderItem;
exports["default"] = _default;

},{"M_33":5,"M_0":241}],30:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _GeometryUtils = _interopRequireDefault(require("s_24"));

var _WebGLGeometries = _interopRequireDefault(require("e_23"));

var _WebGLProperties = _interopRequireDefault(require("D_61"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

var _WebGLRenderItem = _interopRequireDefault(require("h_25"));

var _WebGLRenderState = _interopRequireDefault(require("o_64"));

var computeBoundingSphereAndIndices = _GeometryUtils["default"].computeBoundingSphereAndIndices;

function MaterialProperties() {
  this.fog = null;
  this.environment = null;
  this.lightsStateVersion = 0;
  this.numClippingPlanes = 0;
  this.numIntersection = 0;
  this.clippingUniform = {
    value: []
  };
  this.clippingState = [];
  this.outputEncoding = -1;
  this.envMap = null;
  this.version = 0;
  this.renderVersion = 0;
  this.wireframe = false;
}
/**
 * 
 * @param {WebGLRenderer} renderer 
 */


function WebGLRenderItems(renderer) {
  var _Cesium = Cesium,
      DrawCommand = _Cesium.DrawCommand,
      Cartesian4 = _Cesium.Cartesian4;
  var visualizer = renderer._visualizer;
  var uniforms = renderer._uniforms;
  var properties = renderer._properties;
  var cubemaps = renderer._cubemaps;
  var cesiumRenderStates = renderer._cesiumRenderStates;
  var cesiumCommands = renderer._cesiumCommands;
  var cesiumShaderPrograms = renderer._cesiumShaderPrograms;
  var cesiumVertextArrays = renderer._cesiumVertextArrays;
  var objectDrawAttributes = new _WebGLProperties["default"]();
  var renderItemsCache = new WeakMap();
  var materialsUsed = new WeakMap(); //

  var changingState = {
    frameNumber: -1,
    changingCount: 0,
    maxChangingCount: visualizer.maxChangingCount
  };
  Object.defineProperties(this, {
    changingState: {
      get: function get() {
        return changingState;
      }
    },
    objectDrawAttributes: {
      get: function get() {
        return objectDrawAttributes;
      }
    },
    renderItemsCache: {
      get: function get() {
        return renderItemsCache;
      }
    },
    materialsUsed: {
      get: function get() {
        return materialsUsed;
      }
    }
  }); //

  function dispose() {
    objectDrawAttributes = new _WebGLProperties["default"]();
    renderItemsCache = new WeakMap();
    materialsUsed = new WeakMap();
  }
  /**
   * 
   * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object 
   * @param {THREE.Material} objectMaterial 
   * @param {WebGLRenderItem[]} renderItems 
   */


  function set(object, objectMaterial, renderItems) {
    var commandsSet = renderItemsCache.get(object);
    var materialSet = materialsUsed.get(object);

    if (!commandsSet) {
      commandsSet = new WeakMap();
      materialSet = [];
      renderItemsCache.set(object, commandsSet);
      materialsUsed.set(object, materialSet);
    }

    commandsSet.useTimes = commandsSet.useTimes || 0;

    function onObjectMaterialDispose() {
      commandsSet["delete"](objectMaterial);
      commandsSet.useTimes--;

      if (commandsSet.useTimes == 0) {
        renderItemsCache["delete"](object);
        materialsUsed["delete"](object);
      }
    }

    renderItems.forEach(function (renderItem) {
      var material = renderItem.material;

      function onSubMaterialDispose() {
        renderItem.destroy();
        var itemIndex = renderItems.indexOf(renderItem);
        if (itemIndex >= 0) renderItems.splice(itemIndex, 1);
        if (renderItems.length == 0) onObjectMaterialDispose();
        material.removeEventListener('dispose', onSubMaterialDispose);
      }

      material.addEventListener('dispose', onSubMaterialDispose);
    });
    commandsSet.useTimes++;
    commandsSet.set(objectMaterial, renderItems);
    materialSet.push(objectMaterial);
  }

  function updateSkinningAndMorphTargets(object, geometry, material, frameState) {
    //skinning
    var objectProperties = properties.get(object);

    if (object.isSkinnedMesh && objectProperties.skinningFrameNumber != frameState.frameNumber) {
      objectProperties.skinningFrameNumber = frameState.frameNumber;
      var skeleton = object.skeleton;
      skeleton.update();

      if (skeleton.boneTextureCesium) {
        skeleton.boneTextureCesium.needsUpdate = true;
      }
    } //morph


    if (object.material.morphTargets || object.material.morphNormals) {
      if (objectProperties.morphtargetFrameNumber != frameState.frameNumber) {
        //避免同一帧反复计算morph参数
        objectProperties.morphtargetFrameNumber = frameState.frameNumber;
        renderer.morphtargets.update(object, geometry, material);
      }
    }
  } //


  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }

  function initMaterial(material, wireframe, lights, shadows, firstTime) {
    var clipping = renderer._clipping;
    var currentRenderTarget = renderer.getRenderTarget();
    var fog = visualizer.fog;
    var environment = material.isMeshStandardMaterial ? visualizer.environment : null;
    var encoding = currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.texture.encoding;
    var envMap = cubemaps.get(material.envMap || environment); //initMaterial

    var materialProperties = properties.get(material, firstTime ? new MaterialProperties() : undefined);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.fog = fog;
    materialProperties.environment = environment;
    materialProperties.lightsStateVersion = lights.state.version;
    materialProperties.numClippingPlanes = clipping.numPlanes;
    materialProperties.numIntersection = clipping.numIntersection;
    materialProperties.outputEncoding = encoding;
    materialProperties.envMap = envMap;
    materialProperties.shadows = shadows.length;
    materialProperties.wireframe = wireframe;
    materialProperties.version = material.version;
    materialProperties.shadowMapType = renderer.shadowMap.type;
    materialProperties.rendererVersion = renderer.version;
  } //

  /**
   * 创建`pickId`或者`pickIds`，用于实现点击拾取对象功能
   * * `pickId` —— 根据对象的`pickObject`创建，允许对象作为一个独立的整体被点击拾取；
   * * `pickIds` —— 根据对象的`pickObjects`数组创建，允许将对象按材质拆分成多个子部件分别被场景点击拾取，同一次点击只能拾取到一个子部件。
   * @private
   */


  function initPickObject(object, context) {
    var pickObjects = object.pickObjects,
        objectMaterial = object.material;

    if (!object.pickObject && !pickObjects && Array.isArray(objectMaterial)) {
      var materials = objectMaterial;
      pickObjects = [];

      for (var materialIndex = 0; materialIndex < materials.length; materialIndex++) {
        var material = materials[materialIndex];
        pickObjects.push({
          primitive: visualizer,
          id: object,
          mesh: object,
          material: material,
          materialIndex: materialIndex
        });
      }

      object.pickObjects = pickObjects;
    }

    if (pickObjects && pickObjects.length) {
      var pickIds = [];

      for (var i = 0; i < pickObjects.length; i++) {
        var _pickObject = pickObjects[i];
        var pickId = _pickObject.pickId;

        if (pickId == undefined) {
          pickId = context.createPickId(_pickObject);
        }

        var globalPickIds = visualizer._pickIds;

        if (!globalPickIds.includes(pickId)) {
          globalPickIds.push(pickId);
        }

        _pickObject.pickId = pickId;
        pickIds.push(pickId);
      }

      object.pickIds = pickIds;
    } else {
      var pickObject = object.pickObject ? object.pickObject : {
        primitive: visualizer,
        id: object,
        mesh: object
      };
      object.pickObject = pickObject;
      var pickId = pickObject.pickId;

      if (pickId == undefined) {
        pickId = context.createPickId(pickObject);
      }

      var _pickIds = visualizer._pickIds;

      if (!_pickIds.includes(pickId)) {
        _pickIds.push(pickId);
      }

      pickObject.pickId = pickId;
      object.pickId = pickId;
    }
  } //


  function updateVerexAttribute(vertexArray, name, arrayView) {
    var attrLocation = vertexArray._attributeLocations[name];
    var vaAttribute = vertexArray._attributes[attrLocation];
    var vertexBuffer = vaAttribute.vertexBuffer;

    if (vertexBuffer._sizeInBytes != arrayView.length * arrayView.constructor.BYTES_PER_ELEMENT) {
      console.warn('Mesh3D.WebGLRenderItems:vertexBuffer [' + name + '] size has changed');
      return;
    }

    if (arrayView instanceof Uint32Array) {
      arrayView = new Float32Array(arrayView);
      console.warn('Mesh3D.WebGLRenderItems：暂不支持Uint32Array类型顶点数组，已经强制替换为Float32Array（这会增加内存开销）');
    }

    vertexBuffer.copyFromArrayView(arrayView, 0);
  }

  function updateVertexArray(geometryAttributes, drawAttributes, vertexArrayList, object) {
    var objectMaterial = object.material;
    var morph = objectMaterial.morphTargets || objectMaterial.morphNormals,
        skinning = object.isSkinnedMesh;
    var useEncodedPosition = visualizer.useEncodedPosition;

    if (!skinning && !morph) {
      for (var key in geometryAttributes) {
        var drawAttribute = drawAttributes[key];
        var geometryAttribute = geometryAttributes[key];

        if (drawAttribute.version != geometryAttribute.version) {
          var arrayView = geometryAttribute.array;

          if (key == 'position' && useEncodedPosition) {
            debugger;
            var factor = 1e6;
            var positionHigh = new Float32Array(arrayView.length);
            var positionLow = new Float32Array(arrayView.length);
            var encodedResult = {
              high: 0,
              low: 0
            };

            for (var i = 0; i < arrayView.length; i++) {
              var value = arrayView[i];
              Cesium.EncodedCartesian3.encode(value * factor, encodedResult);
              positionHigh[i] = encodedResult.high;
              positionLow[i] = encodedResult.low;
            }

            for (var _i = 0; _i < vertexArrayList.length; _i++) {
              var vertexArray = vertexArrayList[_i];
              updateVerexAttribute(vertexArray, 'positionHigh', positionHigh);
              updateVerexAttribute(vertexArray, 'positionLow', positionLow);
            }
          } else {
            for (var _i2 = 0; _i2 < vertexArrayList.length; _i2++) {
              var _vertexArray = vertexArrayList[_i2];
              updateVerexAttribute(_vertexArray, key, arrayView);
            }
          }

          drawAttribute.version = geometryAttribute.version;
        }
      }
    }

    if (object.isInstancedMesh) {
      var instanceMatrix = object.instanceMatrix,
          instanceColor = object.instanceColor;
      if (!drawAttributes.instanceMatrix) drawAttributes.instanceMatrix = {
        version: -1
      };
      if (instanceColor && !drawAttributes.instanceColor) drawAttributes.instanceColor = {
        version: -1
      };

      if (drawAttributes.instanceMatrix.version != instanceMatrix.version) {
        var _arrayView = instanceMatrix.array;

        for (var _i3 = 0; _i3 < vertexArrayList.length; _i3++) {
          var _vertexArray2 = vertexArrayList[_i3];
          updateVerexAttribute(_vertexArray2, 'instanceMatrix', _arrayView);
        }

        drawAttributes.instanceMatrix.version = instanceMatrix.version;
      }

      if (instanceColor && drawAttributes.instanceColor.version != instanceColor.version) {
        var _arrayView2 = instanceColor.array;

        for (var _i4 = 0; _i4 < vertexArrayList.length; _i4++) {
          var _vertexArray3 = vertexArrayList[_i4];
          updateVerexAttribute(_vertexArray3, 'instanceColor', _arrayView2);
        }

        drawAttributes.instanceColor.version = instanceColor.version;
      }
    }
  } //


  var _currentCamera3js, _currentMaterialId;

  function updateLocalClipping(material, camera3js, useCache, defaultMaterialProperties) {
    var clipping = renderer._clipping;
    useCache = useCache && material.id === _currentMaterialId;
    properties.get(material, defaultMaterialProperties); // we might want to call this function with some ClippingGroup
    // object instead of the material, once it becomes feasible
    // (#8465, #8379)

    clipping.setState(material, camera3js, useCache);
    _currentMaterialId = material.id;
  }

  function updateClippingUniform(material, materialProperties) {
    materialProperties = materialProperties || properties.get(material);
    var clipping = renderer._clipping;
    var clippingPlanes = clipping.uniform.value;
    var materialClippingPlanes = materialProperties.clippingUniform.value;
    if (clippingPlanes) Cartesian4.unpackArray(clippingPlanes, materialClippingPlanes);else materialClippingPlanes.length = 0;
  }
  /**
   * 
   * @param {THREE.Mesh|THREE.Line|THREE.Points} object 
   * @param {Cesium.FrameState} frameState 
   * @param {boolean}sysWireframe
   * @param {WebGLRenderState}currentRenderState
   * @param {THREE.Camera}camera3js
   * @returns {WebGLRenderItem[]}
   */


  function getAndUpdate(object, frameState, sysWireframe, currentRenderState, camera3js) {
    if (changingState.frameNumber != frameState.frameNumber) {
      changingState.changingCount = 0;
      changingState.frameNumber = frameState.frameNumber;
    }

    sysWireframe = !!sysWireframe && !object.isLine && !object.isPoints;
    var wireframe = sysWireframe;
    var context = frameState.context;

    var geometry = _WebGLGeometries["default"].get(object.geometry, object.material);

    var groupsOptimized = geometry.groupsOptimized;
    var materialIndicesUsed = geometry.materialIndicesUsed;
    var programs = renderer._programs;
    var lights = currentRenderState.lights;
    var clipping = renderer._clipping;
    var shadows = currentRenderState.shadowsArray;
    var objectMaterial = object.material;
    var geometryAttributes = geometry.attributes;
    var objectProperties = properties.get(object);
    var drawAttributes = objectDrawAttributes.get(object);
    var drawRange = geometry.drawRange;

    if (!geometryAttributes.position.count || objectMaterial.visible == false || drawRange.count == 0) {
      return [];
    } //clipping


    var camera3jsChanged = camera3js !== _currentCamera3js;
    var _clippingEnabled = currentRenderState.clippingEnabled;
    var _localClippingEnabled = currentRenderState.localClippingEnabled;
    var clippingNeedsUpdate = false;

    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera3jsChanged) {
        clippingNeedsUpdate = true;
      }
    }

    _currentCamera3js = camera3js; //

    updateSkinningAndMorphTargets(object, geometry, objectMaterial, frameState);
    /**
     * @type {WebGLRenderItem[]}
     * @private
     */

    var renderItems = object.renderItems;

    if (objectProperties.material != object.material) {
      var commandsSet = renderItemsCache.get(object);
      renderItems = commandsSet && commandsSet.get(objectMaterial);
      objectProperties.material = object.material;
    }

    var oldIndex = geometry.index;

    if (renderItems == undefined) {
      //create renderItems
      initPickObject(object, context);

      if (Array.isArray(objectMaterial)) {
        materialIndicesUsed.forEach(function (materialIndex) {
          var material = objectMaterial[materialIndex];
          if (material.wireframe) wireframe = true;
        });
        materialIndicesUsed.forEach(function (materialIndex) {
          var material = objectMaterial[materialIndex];

          if (clippingNeedsUpdate) {
            updateLocalClipping(material, camera3js, !camera3jsChanged, new MaterialProperties());
          }

          initMaterial(material, wireframe, lights, shadows, !clippingNeedsUpdate);
          updateClippingUniform(material);
        }); //use wireframe indices

        if (wireframe) geometry.index = _WebGLGeometries["default"].getWireframeAttribute(geometry);
        renderItems = cesiumCommands.createArray(object, lights, shadows);
      } else {
        wireframe = wireframe || !!objectMaterial.wireframe;
        if (wireframe) geometry.index = _WebGLGeometries["default"].getWireframeAttribute(geometry);

        if (clippingNeedsUpdate) {
          updateLocalClipping(objectMaterial, camera3js, !camera3jsChanged, new MaterialProperties());
        }

        initMaterial(objectMaterial, wireframe, lights, shadows, true);
        updateClippingUniform(objectMaterial);
        var renderItem = cesiumCommands.create(object, lights, shadows);
        renderItem.boundingSphere = geometry.boundingSphere;
        renderItems = [renderItem];
      }

      if (geometry.index != oldIndex) geometry.index = oldIndex;

      for (var i = 0; i < renderItems.length; i++) {
        var _renderItem = renderItems[i];
        var drawCommand = _renderItem.drawCommand;
        var material = _renderItem.material;
        var parameters = programs.getParameters(material, lights.state, shadows, visualizer, object);

        var _programCacheKey = programs.getProgramCacheKey(parameters);

        if (wireframe) {
          _renderItem.primitiveType = drawCommand.primitiveType;
          drawCommand.primitiveType = 1;
        }

        _renderItem.renderVersion = properties.get(material).renderVersion;
        _renderItem.programCacheKey = _programCacheKey;
        _renderItem.materialVersion = material.version;
        _renderItem.wireframe = wireframe;

        _renderItem.update(object, drawCommand, geometry, visualizer.modelMatrixNeedsUpdate);
      }

      set(object, objectMaterial, renderItems); //

      for (var key in geometryAttributes) {
        if (geometryAttributes.hasOwnProperty(key)) {
          drawAttributes[key] = {
            version: geometryAttributes[key].version
          };
        }
      }
    } else {
      //update renderItems
      var attributesChanged = false;

      for (var _key in geometryAttributes) {
        if (!(_key in drawAttributes)) {
          attributesChanged = true;
          drawAttributes[_key] = {
            version: geometryAttributes[_key].version
          };
        }
      }

      var positionChanged = geometryAttributes.position.version != drawAttributes.position.version;
      if (positionChanged) geometry.computeBoundingSphere();
      var vaToUpdateList = [];

      var _currentRenderTarget = renderer.getRenderTarget();

      var fog = visualizer.fog;
      var encoding = _currentRenderTarget === null ? renderer.outputEncoding : _currentRenderTarget.texture.encoding;

      for (var _i5 = 0; _i5 < renderItems.length; _i5++) {
        var _renderItem2 = renderItems[_i5];
        var _material = _renderItem2.material;
        var _drawCommand = _renderItem2.drawCommand;
        var materialIndex = _renderItem2.materialIndex;
        var groupIndex = _renderItem2.groupIndex;
        var materialProperties = properties.get(_material);

        if (clippingNeedsUpdate) {
          updateLocalClipping(_material, camera3js, !camera3jsChanged);
        }

        updateClippingUniform(_material, materialProperties); //

        var materialChanged = false;
        var environment = _material.isMeshStandardMaterial ? visualizer.environment : null;
        var envMap = cubemaps.get(_material.envMap || environment);
        var renderStateNeedsUpdate = false;

        if (_renderItem2.materialVersion == _material.version) {
          if (_material.fog && materialProperties.fog !== fog) {
            materialChanged = true;
          } else if (materialProperties.environment !== environment) {
            materialChanged = true;
          } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
            materialChanged = true;
          } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
            materialChanged = true;
          } else if (materialProperties.outputEncoding !== encoding) {
            materialChanged = true;
          } else if (materialProperties.envMap !== envMap) {
            materialChanged = true;
          } else if (materialProperties.shadows !== shadows.length) {
            materialChanged = true;
          } else if (materialProperties.shadowMapType != renderer.shadowMap.type) {
            materialChanged = true;
          } else if (materialProperties.rendererVersion != renderer.version) {
            materialChanged = true;
          }

          if (materialChanged) {
            if (!isFinite(materialProperties.renderVersion)) debugger;
            materialProperties.renderVersion++;
          } else {
            if (_renderItem2.renderVersion != materialProperties.renderVersion) {
              materialChanged = true;
            }

            if (_renderItem2.renderStateVersion != _material.renderStateVersion) {
              _renderItem2.renderStateVersion = _material.renderStateVersion;
              renderStateNeedsUpdate = true;
            }
          }
        } else {
          materialChanged = true;
        }

        wireframe = _material.wireframe || sysWireframe;

        if (materialChanged) {
          if (changingState.maxChangingCount > changingState.changingCount) {
            initMaterial(_material, wireframe, lights, shadows);

            var _parameters = programs.getParameters(_material, lights.state, shadows, visualizer, object);

            var programCacheKey = programs.getProgramCacheKey(_parameters);
            materialChanged = _renderItem2.programCacheKey !== programCacheKey;
            _renderItem2.programCacheKey = programCacheKey;
            _renderItem2.renderVersion = materialProperties.renderVersion;
            _renderItem2.materialVersion = _material.version;
            changingState.changingCount++;
          } else {
            materialChanged = false;
          }
        } //update shaderProgram,uniformMap


        var wireframeChanged = _renderItem2.wireframe != wireframe;
        var geometryChanged = _renderItem2.geometry != object.geometry;

        if (attributesChanged || materialChanged || wireframeChanged || geometryChanged) {
          //wireframe index & boundingSphere
          var wireframeIndices = _renderItem2.wireframeIndices;

          if (wireframe && !wireframeIndices) {
            geometry.index = _WebGLGeometries["default"].getWireframeAttribute(geometry);
            var boundingSphereAndIndices = computeBoundingSphereAndIndices(geometry, _material.transparent ? groupIndex : materialIndex, !_material.transparent, _renderItem2.boundingSphere);
            wireframeIndices = boundingSphereAndIndices.indices;
            _renderItem2.wireframeIndices = wireframeIndices;
            _renderItem2.boundingSphere = boundingSphereAndIndices.boundingSphere;
            geometry.index = oldIndex;
          } else if (positionChanged) {
            //boundingSphere 
            var boundingSphereAndIndices = computeBoundingSphereAndIndices(geometry, _material.transparent ? groupIndex : materialIndex, !_material.transparent, _renderItem2.boundingSphere);
            _renderItem2.boundingSphere = boundingSphereAndIndices.boundingSphere;
          } //new vertexArray


          if (attributesChanged || wireframeChanged || geometryChanged) {
            //TODO:groups=>release vaAttributeCache 
            var va = _drawCommand.vertexArray;

            if (!va.isDestroyed()) {
              if (_i5 > 0 || wireframeChanged) {
                //1、几何属性变化或者使用新几何体时，同一个几何体第二组及以后只更新索引缓冲区（indexBuffer）；
                //2、在线框和面两种模式切换时，只更新索引缓冲区（indexBuffer）。
                var indexBuffer = va._indexBuffer;

                if (defined(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {
                  indexBuffer.destroy();
                }
              } else {
                va.destroy();
              }
            }

            va = cesiumVertextArrays.create(geometry, object, materialIndex, wireframe ? wireframeIndices : undefined);
            _drawCommand.vertexArray = va;
          } //new shaderProgram, uniformMap


          var shaderProgram = _drawCommand.shaderProgram;
          if (!shaderProgram.isDestroyed || !shaderProgram.isDestroyed()) shaderProgram.destroy();
          var attributeLocations = _drawCommand.vertexArray._attributeLocations;
          shaderProgram = cesiumShaderPrograms.get(_material, attributeLocations, object, lights, shadows);
          _drawCommand.shaderProgram = shaderProgram;
          _drawCommand.renderState = cesiumRenderStates.create(_material, object);
          _drawCommand.uniformMap = uniforms.getUniformMap(_material, object, frameState, lights); //

          if (wireframe) {
            if (_renderItem2.primitiveType == undefined) _renderItem2.primitiveType = _drawCommand.primitiveType;
            _drawCommand.primitiveType = 1;
          } else if (_renderItem2.primitiveType != undefined) {
            _drawCommand.primitiveType = _renderItem2.primitiveType;
          }

          _renderItem2.wireframe = wireframe;
        } else {
          if (renderStateNeedsUpdate) {
            _drawCommand.renderState = cesiumRenderStates.create(_material, object);
          }

          uniforms.refresh(_material, object);
          vaToUpdateList.push(_drawCommand.vertexArray); //boundingSphere

          if (positionChanged) {
            var boundingSphereAndIndices = computeBoundingSphereAndIndices(geometry, _material.transparent ? groupIndex : materialIndex, !_material.transparent, _renderItem2.boundingSphere);
            _renderItem2.boundingSphere = boundingSphereAndIndices.boundingSphere;
          }
        }

        _renderItem2.update(object, _drawCommand, geometry, visualizer.modelMatrixNeedsUpdate);
      }

      updateVertexArray(geometryAttributes, drawAttributes, vaToUpdateList, object);
    }

    object.renderItems = renderItems;
    return renderItems;
  }
  /**
   * 
   * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object  
   * @returns {WebGLRenderItem[]}
   */


  function get(object) {
    var objectProperties = properties.get(object);
    var objectMaterial = object.material;
    if (!objectProperties.material) return;
    if (objectProperties.material == objectMaterial) return object.renderItems;
    var commandsSet = renderItemsCache.get(object);
    var renderItems = commandsSet && commandsSet.get(objectMaterial);
    return renderItems;
  }
  /**
   * 
   * @param {THREE.Mesh|THREE.Line|THREE.Points} object 
   * @param {THREE.Geometry|THREE.BufferGeometry} geometry 
   * @param {THREE.Material} material 
   * @param {WebGLRenderItem} renderItem 
   * @param {string} name 
   * @param {Cesium.FrameState} frameState 
   * @param {WebGLRenderState} [currentRenderState] 
   * @param {THREE.Camera}camera3js
   * @returns {Cesium.DrawCommand}
   */


  function getAndUpdateDerived(object, geometry, material, renderItem, name, frameState, currentRenderState, camera3js) {
    var lights = currentRenderState.lights,
        shadows = currentRenderState.shadowsArray;
    geometry = _WebGLGeometries["default"].get(geometry);
    var geometryAttributes = geometry.attributes;
    var drawAttributes = objectDrawAttributes.get(object); //clipping

    var clipping = renderer._clipping;
    var camera3jsChanged = camera3js !== _currentCamera3js;
    var _clippingEnabled = currentRenderState.clippingEnabled;
    var _localClippingEnabled = currentRenderState.localClippingEnabled;
    var clippingNeedsUpdate = false;

    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera3jsChanged) {
        clippingNeedsUpdate = true;
      }
    }

    _currentCamera3js = camera3js; // updateSkinningAndMorphTargets(object, geometry, material, frameState);

    var originalDrawCommand = renderItem.drawCommand;
    var drawCommand = originalDrawCommand.derivedCommands[name];
    var derivedProperties = originalDrawCommand.derivedProperties;
    var derivedCommandProperties = derivedProperties[name];

    if (!derivedCommandProperties) {
      derivedCommandProperties = {};
      derivedProperties[name] = derivedCommandProperties;
    }

    var attributeLocations = originalDrawCommand.vertexArray._attributeLocations;
    var commandNeedsUpdate = !drawCommand;

    if (!commandNeedsUpdate) {
      if (derivedCommandProperties.materialVersion != renderItem.materialVersion || derivedCommandProperties.renderStateVersion != renderItem.material.renderStateVersion) {
        commandNeedsUpdate = true;
        derivedCommandProperties.materialVersion = renderItem.materialVersion;
        derivedCommandProperties.renderStateVersion = renderItem.material.renderStateVersion;
      } else commandNeedsUpdate = drawCommand.vertexArray._attributeLocations != attributeLocations;

      if (commandNeedsUpdate) drawCommand.onMaterialDispose && drawCommand.onMaterialDispose();
    }

    if (commandNeedsUpdate) {
      var onMaterialDispose = function onMaterialDispose() {
        drawCommand.shaderProgram.destroy();
        var isDestroyed = originalDrawCommand.isDestroyed;

        if (!isDestroyed || !isDestroyed()) {
          delete originalDrawCommand.derivedCommands[name];
        }

        material.removeEventListener('dispose', onMaterialDispose);
      };

      if (clippingNeedsUpdate) {
        updateLocalClipping(material, camera3js, !camera3jsChanged, new MaterialProperties());
      } else {
        properties.get(material, new MaterialProperties());
      }

      updateClippingUniform(material);
      drawCommand = DrawCommand.shallowClone(originalDrawCommand);
      originalDrawCommand.derivedCommands[name] = drawCommand;
      drawCommand.shaderProgram = cesiumShaderPrograms.get(material, attributeLocations, object, lights, shadows);
      drawCommand.uniformMap = uniforms.getUniformMap(material, object, frameState, lights);
      drawCommand.renderState = cesiumRenderStates.create(material, object, false);

      if (material._isShadowDepthMaterial) {
        object.addEventListener('dispose', onMaterialDispose);
      } else {
        material.addEventListener('dispose', onMaterialDispose);
      }

      drawCommand.onMaterialDispose = onMaterialDispose;
    } else {
      if (clippingNeedsUpdate) {
        updateLocalClipping(material, camera3js, !camera3jsChanged, new MaterialProperties());
      }

      updateClippingUniform(material);

      if (derivedCommandProperties.numClippingPlanes !== undefined && (derivedCommandProperties.numClippingPlanes !== clipping.numPlanes || derivedCommandProperties.numIntersection !== clipping.numIntersection)) {
        var shaderProgram = drawCommand.shaderProgram;
        if (!shaderProgram.isDestroyed || !shaderProgram.isDestroyed()) shaderProgram.destroy();
        drawCommand.shaderProgram = cesiumShaderPrograms.get(material, attributeLocations, object, lights, shadows);
        drawCommand.uniformMap = uniforms.getUniformMap(material, object, frameState, lights);
        drawCommand.renderState = cesiumRenderStates.create(material, object, false);
      }

      uniforms.refresh(material, object);
      drawCommand.vertexArray = originalDrawCommand.vertexArray;
    }

    derivedCommandProperties.numClippingPlanes = clipping.numPlanes;
    derivedCommandProperties.numIntersection = clipping.numIntersection;
    renderItem.update(object, drawCommand, geometry, visualizer.modelMatrixNeedsUpdate);
    updateVertexArray(geometryAttributes, drawAttributes, [drawCommand.vertexArray], object);
    return drawCommand;
  }
  /**
   * 
   * @param {THREE.Mesh|THREE.Line|THREE.Points} object 
   */


  function remove(object) {
    var materialSet = materialsUsed.get(object);
    var commandsSet = renderItemsCache.get(object);

    if (materialSet && commandsSet) {
      materialSet.forEach(function (material) {
        var renderItems = commandsSet.get(material);
        if (!renderItems) return;
        renderItems.forEach(function (renderItem) {
          var wireframeIndexBuffer = renderItem.wireframeIndexBuffer;
          var isDestroyed = wireframeIndexBuffer.isDestroyed;
          if (!isDestroyed || !isDestroyed()) wireframeIndexBuffer.destroy();
          delete renderItem.wireframeIndexBuffer;
          delete renderItem.indexBuffer;
        });
      });
    }

    materialsUsed["delete"](object);
    renderItemsCache["delete"](object);
  }

  this.get = get;
  this.remove = remove;
  this.getAndUpdate = getAndUpdate;
  this.getAndUpdateDerived = getAndUpdateDerived;
  this.dispose = dispose;
}

var _default = WebGLRenderItems;
exports["default"] = _default;

},{"s_24":2,"e_23":22,"D_61":28,"h_25":29,"o_64":32,"3_27":35,"M_0":241}],31:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _WebGLRenderItem = _interopRequireDefault(require("h_25"));

function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList() {
  /**
   * @type {WebGLRenderItem[]}
   * @private
   */
  var environment = [];
  /**
   * @type {WebGLRenderItem[]}
   * @private
   */

  var opaque = [];
  /**
   * @type {WebGLRenderItem[]}
   * @private
   */

  var transparent = [];

  function init() {
    environment.length = 0;
    opaque.length = 0;
    transparent.length = 0;
  }

  function push(renderItem) {
    if (renderItem.pass == 0) environment.push(renderItem);else {
      var material = renderItem.material;
      (material.transparent === true || material.translucent ? transparent : opaque).push(renderItem);
    }
  }

  function unshift(renderItem) {
    if (renderItem.pass == 0) environment.unshift(renderItem);else {
      var material = renderItem.material;
      (material.transparent === true || material.translucent ? transparent : opaque).unshift(renderItem);
    }
  }

  function sort(customOpaqueSort, customTransparentSort) {
    if (environment.length > 1) environment.sort(customOpaqueSort || painterSortStable);
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }

  function shouldRender(renderItem, frameState) {
    var object = renderItem.object,
        material = renderItem.material;
    if (frameState.passes.pick && object.allowPick == false) return false;
    return object.visible && material.visible;
  }

  function getDrawCommands(commandList, frameState) {
    for (var i = 0, l = environment.length; i < l; i++) {
      if (!shouldRender(environment[i], frameState)) continue;
      commandList.push(environment[i].drawCommand);
    }

    for (var _i = 0, _l = opaque.length; _i < _l; _i++) {
      if (!shouldRender(opaque[_i], frameState)) continue;
      commandList.push(opaque[_i].drawCommand);
    }

    for (var _i2 = 0, _l2 = transparent.length; _i2 < _l2; _i2++) {
      if (!shouldRender(transparent[_i2], frameState)) continue;
      commandList.push(transparent[_i2].drawCommand);
    }
  }

  function setCurrentScene(currentScene, currentCamera) {
    for (var i = 0, l = environment.length; i < l; i++) {
      environment[i].currentScene = currentScene;
      environment[i].currentCamera = currentCamera;
    }

    for (var _i3 = 0, _l3 = opaque.length; _i3 < _l3; _i3++) {
      opaque[_i3].currentScene = currentScene;
      opaque[_i3].currentCamera = currentCamera;
    }

    for (var _i4 = 0, _l4 = transparent.length; _i4 < _l4; _i4++) {
      transparent[_i4].currentScene = currentScene;
      transparent[_i4].currentCamera = currentCamera;
    }
  }

  this.environment = environment;
  this.opaque = opaque;
  this.transparent = transparent;
  this.init = init;
  this.push = push;
  this.unshift = unshift;
  this.sort = sort;
  this.getDrawCommands = getDrawCommands;
  this.setCurrentScene = setCurrentScene;
}

var _default = WebGLRenderList;
exports["default"] = _default;

},{"h_25":29,"M_0":241}],32:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _WebGLLights = _interopRequireDefault(require("-_26"));

var _WebGLRenderList = _interopRequireDefault(require("h_69"));

/**
 * @constructor
 */
function WebGLRenderState() {
  var renderList = new _WebGLRenderList["default"]();
  var renderables = [];
  var dynamicRenderables = [];
  var shadowsArray = [];
  var lightsArray = [];
  var lights = new _WebGLLights["default"]();

  function init() {
    renderList.init();
    renderables.length = 0;
    dynamicRenderables.length = 0;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function pushRenderable(object) {
    renderables.push(object);
  }

  var scope = this;

  function setupLights(camera) {
    scope.lights.setup(lightsArray, shadowsArray, camera);
  } //for onBeforeRender


  function setCurrentScene(scene, camera) {
    renderList.setCurrentScene(scene, camera);
  }

  function getDrawCommands(commandList, frameState) {
    renderList.getDrawCommands(commandList, frameState);
  }

  this.renderList = renderList;
  this.renderables = renderables;
  this.dynamicRenderables = dynamicRenderables;
  this.shadowsArray = shadowsArray;
  this.lightsArray = lightsArray;
  this.lights = lights;
  this.init = init;
  this.pushRenderable = pushRenderable;
  this.setupLights = setupLights;
  this.pushShadow = pushShadow;
  this.pushLight = pushLight;
  this.setCurrentScene = setCurrentScene;
  this.getDrawCommands = getDrawCommands;
}

var _default = WebGLRenderState;
exports["default"] = _default;

},{"-_26":23,"h_69":31,"M_0":241}],33:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _WebGLRenderState = _interopRequireDefault(require("o_64"));

function WebGLRenderStates() {
  var states = new WeakMap();
  /**
   * 
   * @param {Object} scene 
   * @param {Object} camera 
   * @returns {WebGLRenderState}
   */

  this.get = function get(scene, camera) {
    var cameras = states.get(scene);
    var state;

    if (cameras === undefined) {
      state = new _WebGLRenderState["default"]();
      states.set(scene, new WeakMap());
      states.get(scene).set(camera, state);
    } else {
      state = cameras.get(camera);

      if (state === undefined) {
        state = new _WebGLRenderState["default"]();
        state.camera = camera;
        cameras.set(camera, state);
      }
    }

    return state;
  };

  this.dispose = function dispose() {
    states = new WeakMap();
  };

  Object.defineProperties(this, {
    states: {
      get: function get() {
        return states;
      }
    }
  });
}

var _default = WebGLRenderStates;
exports["default"] = _default;

},{"o_64":32,"M_0":241}],34:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = WebGLRenderTargets;

var _MeshVisualizer = _interopRequireDefault(require("M_33"));

var _ConstantMap = _interopRequireDefault(require("._29"));

var _TextureUtils = _interopRequireDefault(require("o_75"));

/**
 * 处理Threejs RenderTarget
 * @param {MeshVisualizer} visualizer 
 */
function WebGLRenderTargets(visualizer) {
  var _Cesium = Cesium,
      WebGLConstants = _Cesium.WebGLConstants,
      Sampler = _Cesium.Sampler,
      RenderbufferFormat = _Cesium.RenderbufferFormat,
      Renderbuffer = _Cesium.Renderbuffer,
      Framebuffer = _Cesium.Framebuffer;
  /**
  * @type {Map<THREE.WebGLRenderTarget|THREE.WebGLCubeRenderTarget,Cesium.Framebuffer>}
  * @private
  */

  var fbs = new Map();
  /**
   * 
   * @param {THREE.WebGLRenderTarget} renderTarget  
   * @param {Cesium.Texture} colorTexture  
   * @returns {Cesium.Framebuffer}
   * @private
   */

  function createFramebuffer(renderTarget, colorTexture) {
    var frameState = visualizer.frameState,
        context = frameState.context;
    var width = renderTarget.width || context.drawingBufferWidth,
        height = renderTarget.height || context.drawingBufferHeight;

    if (!colorTexture) {
      var texParams = _TextureUtils["default"].fromTexure3js(renderTarget.texture);

      colorTexture = _TextureUtils["default"].createTexture({
        target: 3553,
        width: width,
        height: height,
        format: texParams.format,
        flipY: texParams.flipY,
        type: texParams.type,
        sampler: new Sampler(texParams.sampler),
        preMultiplyAlpha: texParams.preMultiplyAlpha
      }, context);
      colorTexture.name = renderTarget.texture.name;
    }

    var depthTexture;

    if (renderTarget.depthTexture) {
      var _texParams = _TextureUtils["default"].fromTexure3js(renderTarget.depthTexture);

      depthTexture = _TextureUtils["default"].createTexture({
        target: 3553,
        width: width,
        height: height,
        format: _texParams.format,
        flipY: _texParams.flipY,
        type: _texParams.type,
        sampler: new Sampler(_texParams.sampler),
        preMultiplyAlpha: _texParams.preMultiplyAlpha
      }, context);
    }

    var depthRenderbuffer, stencilBuffer;

    if (renderTarget.stencilBuffer) {
      stencilBuffer = new Renderbuffer({
        context: context,
        format: 34041,
        width: width,
        height: height
      });
    } else if (renderTarget.depthBuffer) {
      depthRenderbuffer = new Renderbuffer({
        context: context,
        format: 33189,
        width: width,
        height: height
      });
    }

    var framebuffer = new Framebuffer({
      context: context,
      colorTextures: [colorTexture],
      destroyAttachments: false,
      depthTexture: depthTexture,
      depthRenderbuffer: depthRenderbuffer,
      depthStencilRenderbuffer: stencilBuffer
    });
    return framebuffer;
  }
  /**
   * 
   * @param {THREE.WebGLRenderTarget|THREE.WebGLCubeRenderTarget} renderTarget
   */


  this.set = function (renderTarget) {
    var frameState = visualizer.frameState,
        context = frameState.context;

    if (fbs.has(renderTarget)) {
      return;
    }

    var texture = renderTarget.texture,
        depthTexture = renderTarget.depthTexture,
        framebuffers = [];

    if (renderTarget.isWebGLCubeRenderTarget) {
      var format = _ConstantMap["default"].formatsMap[texture.format];
      var face = {
        width: renderTarget.width,
        height: renderTarget.height,
        arrayBufferView: new Uint8Array(4 * renderTarget.width * renderTarget.height)
      };
      var cubeMap = new Cesium.CubeMap({
        context: context,
        source: {
          positiveX: face,
          negativeX: face,
          positiveY: face,
          negativeY: face,
          positiveZ: face,
          negativeZ: face
        },
        width: renderTarget.width,
        height: renderTarget.height,
        pixelDatatype: _ConstantMap["default"].typesMap[texture.type],
        pixelFormat: format,
        flipY: texture.flipY,
        preMultiplyAlpha: texture.premultiplyAlpha
      });
      visualizer._textureCache[texture.uuid] = cubeMap;
      var cubeFaces = [cubeMap.positiveX, cubeMap.negativeX, cubeMap.positiveY, cubeMap.negativeY, cubeMap.positiveZ, cubeMap.negativeZ];

      for (var i = 0; i < 6; i++) {
        var framebuffer = createFramebuffer(renderTarget, cubeFaces[i]);
        framebuffers.push(framebuffer);
      }
    } else {
      var _framebuffer = createFramebuffer(renderTarget);

      visualizer._textureCache[texture.uuid] = _framebuffer.getColorTexture(0);

      if (depthTexture) {
        debugger;
        visualizer._textureCache[depthTexture.uuid] = _framebuffer.depthTexture;
      }

      framebuffers.push(_framebuffer);
    }

    fbs.set(renderTarget, framebuffers);

    function onDispose() {
      framebuffers.forEach(function (framebuffer) {
        framebuffer.destroy();
      });
      fbs["delete"](renderTarget);
      var textureCesium = visualizer._textureCache[texture.uuid]; //= framebuffer.getColorTexture(0);

      if (textureCesium) {
        //&& ()) {
        if (!textureCesium.isDestroyed || !textureCesium.isDestroyed()) textureCesium.destroy();
        delete visualizer._textureCache[texture.uuid];
      }

      renderTarget.removeEventListener('dispose', onDispose);
    }

    renderTarget.__onDispose = onDispose;
    renderTarget.addEventListener('dispose', onDispose);
  };
  /**
   * 
   * @param {THREE.WebGLRenderTarget|THREE.WebGLCubeRenderTarget} renderTarget  
   * @returns {Cesium.Framebuffer|Cesium.Framebuffer[]}
   */


  this.get = function (renderTarget) {
    if (!fbs.has(renderTarget)) {
      this.set(renderTarget);
    }

    var framebuffers = fbs.get(renderTarget);
    return framebuffers;
  };

  this.dispose = function () {
    fbs.forEach(function (val, key) {
      if (key.__onDispose) {
        key.__onDispose();

        delete key.__onDispose;
      }
    });
    fbs.clear();
  };
}

},{"M_33":5,"._29":12,"o_75":17,"M_0":241}],35:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _WebGLExtensions = _interopRequireDefault(require("s_79"));

var _WebGLCapabilities = _interopRequireDefault(require("h_80"));

var _WebGLPrograms = _interopRequireDefault(require("h_36"));

var _RendererUtils = _interopRequireDefault(require("3_82"));

var _WebGLMorphtargets = _interopRequireDefault(require("D_83"));

var _WebGLShadowMap = _interopRequireDefault(require("._84"));

var _CameraUtils = _interopRequireDefault(require("C_85"));

var _WebGLProperties = _interopRequireDefault(require("D_61"));

var _WebGLClipping = _interopRequireDefault(require("m_87"));

var _WebGLCubeMaps = _interopRequireDefault(require("M_88"));

var _ConstantMap = _interopRequireDefault(require("._29"));

var _WebGLUniforms = _interopRequireDefault(require("s_90"));

var _WebGLMaterials = _interopRequireDefault(require("h_91"));

var _WebGLTextures = _interopRequireDefault(require("-_92"));

var _WebGLRenderItems = _interopRequireDefault(require("3_93"));

var _MeshVisualizer = _interopRequireDefault(require("M_33"));

var _WebGLRenderStates = _interopRequireDefault(require("._95"));

var _WebGLRenderState = _interopRequireDefault(require("o_64"));

var _WebGLRenderTargets = _interopRequireDefault(require("o_97"));

var _CesiumRenderStates = _interopRequireDefault(require("m_98"));

var _CesiumCommands = _interopRequireDefault(require("M_99"));

var _CesiumShaderPrograms = _interopRequireDefault(require("e_100"));

var _CesiumVertextArrays = _interopRequireDefault(require("s_101"));

var clearCommandScratch;
/**
 * 实现部分threejs WebGLRenderer接口，支持渲染到THREE.WebGLRenderTarget等功能
 */

var WebGLRenderer = /*#__PURE__*/function () {
  /**
   * 
   * @param {MeshVisualizer} visualizer 
   */
  function WebGLRenderer(visualizer) {
    (0, _classCallCheck2["default"])(this, WebGLRenderer);
    var _Cesium = Cesium,
        Camera = _Cesium.Camera,
        Matrix4 = _Cesium.Matrix4,
        RenderState = _Cesium.RenderState,
        ClearCommand = _Cesium.ClearCommand,
        Color = _Cesium.Color;
    var _THREE = THREE;
    var LinearEncoding = 3000,
        NoToneMapping = 0,
        Matrix3 = _THREE.Matrix3,
        Vector3 = _THREE.Vector3;

    function CesiumRenderStateCache() {
      var list = new WeakMap();

      this.get = function (drawCommand, camera) {
        var cameras = list.get(drawCommand);

        if (cameras == undefined) {
          cameras = new WeakMap();
          list.set(drawCommand, cameras);
        }

        var rs = cameras.get(camera);

        if (rs == undefined) {
          rs = new RenderState(drawCommand.renderState);
          cameras.set(camera, rs);
        }

        return rs;
      };

      this["delete"] = function (drawCommand) {
        list["delete"](drawCommand);
      };

      this.dispose = function () {
        list = new WeakMap();
      };
    }

    var scope = this;
    var colorBuffer = {
      setMask: function setMask(colorMask) {},
      setLocked: function setLocked(lock) {},
      setClear: function setClear(r, g, b, a, premultipliedAlpha) {},
      reset: function reset() {}
    };
    var depthBuffer = {
      setTest: function setTest(enabled) {
        var gl = getGL();
        var glEnum = gl.DEPTH_TEST;

        if (enabled) {
          gl.enable(glEnum);
        } else {
          gl.disable(glEnum);
        }
      },
      setMask: function setMask(depthMask) {},
      setFunc: function setFunc(depthFunc) {},
      setLocked: function setLocked(lock) {},
      setClear: function setClear(depth) {},
      reset: function reset() {}
    };
    var stencilBuffer = {
      setTest: function setTest(stencilTest) {},
      setMask: function setMask(stencilMask) {},
      setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {},
      setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {},
      setLocked: function setLocked(lock) {},
      setClear: function setClear(stencil) {},
      reset: function reset() {}
    };
    this.state = {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      viewport: function viewport(_viewport) {
        getGL().viewport(_viewport.x, _viewport.y, _viewport.width, _viewport.height);
      }
    };

    function getGL() {
      return scope._capabilities.gl;
    } //


    this._visualizer = visualizer; //threejs renderer params 

    this.gammaOutput = false;
    this.gammaInput = false;
    this._nClipPlanes = 0;
    this._nClipIntersection = 0;
    this._currentRenderTarget = null; // user-defined clipping

    this.clippingPlanes = [];
    this.localClippingEnabled = false; // physically based shading

    this.gammaFactor = 2.0; // for backwards compatibility

    this._outputEncoding = null; // physical lights

    this._physicallyCorrectLights = false; // tone mapping

    this._toneMapping = null; // NoToneMapping;

    this.toneMappingExposure = 1.0;
    this.toneMappingWhitePoint = 1.; // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this._outputEncoding = LinearEncoding;
    this._toneMapping = NoToneMapping;
    this.vr = {
      enabled: false
    };
    this.xr = {
      enabled: false
    };
    /**
     * @type {WebGLShadowMap}
     */

    this.shadowMap = new _WebGLShadowMap["default"](this, null, 16000);
    this._cubemaps = new _WebGLCubeMaps["default"](this);
    this._properties = new _WebGLProperties["default"]();
    this._materials = new _WebGLMaterials["default"](this._properties);
    this._textures = new _WebGLTextures["default"](visualizer);
    this._uniforms = new _WebGLUniforms["default"](this);
    this._cesiumRenderStateCache = new CesiumRenderStateCache();
    this._cesiumRenderStates = new _CesiumRenderStates["default"](this);
    this._cesiumShaderPrograms = new _CesiumShaderPrograms["default"](this);
    this._cesiumVertextArrays = new _CesiumVertextArrays["default"](this);
    this._cesiumCommands = new _CesiumCommands["default"](this);
    var webglRenderItems = this._webglRenderItems = new _WebGLRenderItems["default"](this);
    this._webglRenderStates = new _WebGLRenderStates["default"]();
    var webGLRenderTargets = new _WebGLRenderTargets["default"](visualizer);
    /**
     * @type {WebGLClipping}
     */

    this._clipping = null;
    /**
     * @type {WebGLPrograms}
     */

    this._programs = null;
    /**
     * @type {WebGLCapabilities}
     */

    this._capabilities = null;
    /**
     * @type {WebGLExtensions}
     */

    this._extensions = null;
    this._pixelRatio = 1.0;
    /**
     * @type {WebGLMorphtargets}
     */

    this.morphtargets = null;
    /**
     * @type {Boolean}
     */

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this._currentActiveCubeFace = 0;
    this._currentActiveMipmapLevel = 0;
    this.renderState = null;
    this.autoConvertCamera = false;
    this.overrideModelMatrix = null;
    this._clearColor = new _THREE.Color('black');
    this._clearAlpha = 0;
    this.isCesiumRenderer = true;
    this.version = 0; // 

    /**
     * 
     * @param {Cesium.FrameState} frameState 
     */

    function init(frameState) {
      var gl = frameState.context._gl;

      if (!this._capabilities) {
        var extensions = this._extensions = new _WebGLExtensions["default"](gl);
        var capabilities = this._capabilities = new _WebGLCapabilities["default"](gl, extensions, {});

        if (capabilities.isWebGL2 === false) {
          extensions.get('WEBGL_depth_texture');
          extensions.get('OES_texture_float');
          extensions.get('OES_texture_half_float');
          extensions.get('OES_texture_half_float_linear');
          extensions.get('OES_standard_derivatives');
          extensions.get('OES_element_index_uint');
          extensions.get('ANGLE_instanced_arrays');
        }

        this.shadowMap.maxTextureSize = capabilities.maxTextureSize;
        extensions.get('OES_texture_float_linear');
        this._clipping = new _WebGLClipping["default"](this._properties, this._visualizer);
        this._programs = new _WebGLPrograms["default"](this, this._cubemaps, extensions, capabilities, this._clipping);
        this.morphtargets = new _WebGLMorphtargets["default"](gl, this);
      }

      this._pixelRatio = frameState.pixelRatio;
      if (!this._frameState) this._frameState = frameState;
    }
    /**
     * 
     * @param {THREE.Object3D|MeshVisualizer} scene  
     * @param {Cesium.Camera|THREE.PerspectiveCamera|THREE.OrthographicCamera} camera
     * @param {Cesium.FrameState} [frameState] 
     */


    function render(scene, camera, frameState) {
      var _this = this;

      frameState = frameState || this._frameState;

      if (!scene) {
        throw new Error('WebGLRenderer.render:缺少参数scene');
      }

      if (!frameState) {
        throw new Error('WebGLRenderer.render:MeshVisualizer未初始化，需要传递参数frameState');
      }
      /**
       * @type {THREE.WebGLRenderTarget}
       * @private
       */


      var renderTarget = this._currentRenderTarget;
      var visualizer = this._visualizer;
      if (!renderTarget) throw new Error('WebGLRenderer.render:未设置renderTarget');

      if (this.autoClear) {
        this.clear(null, 1, 0);
      }

      var framebuffers = webGLRenderTargets.get(renderTarget);
      var framebuffer = framebuffers[this._currentActiveCubeFace || 0];
      var context = frameState.context;
      var us = context.uniformState;
      var globalCamera = frameState.camera;
      var currentCullingVolume = frameState.cullingVolume;
      var referenceFrame;

      if (this.autoConvertCamera) {
        referenceFrame = {};
        referenceFrame.matrix = visualizer._actualModelMatrixYup || visualizer.modelMatrix;
        referenceFrame.inverseMatrix = visualizer._actualModelMatrixYupInverse || visualizer._actualModelMatrixInverse;
      }

      var customCamera, camera3js;
      /**
       * @type {THREE.Frustum}
       * @private
       */
      // let frustum3js;

      if (camera && !(camera instanceof Camera)) {
        camera3js = camera;

        if (camera.isPerspectiveCamera) {
          camera = _CameraUtils["default"].fromPerspectiveCamera3js(camera, visualizer._scene, referenceFrame);
        } else if (camera.isOrthographicCamera) camera = _CameraUtils["default"].fromOrthographicCamera3js(camera, visualizer._scene, referenceFrame);else {
          visualizer.traverseObject3D(scene, function (object) {
            object.currentFrustumCulled = object.frustumCulled;
            object.frustumCulled = false;
            object.modelMatrixNeesUpdate = false;
          });
          customCamera = {
            camera: camera,
            _normalMatrix: new Matrix3(),
            cameraPosition: new Vector3()
          };
          globalCamera.customCamera = customCamera; // console.warn('unsupport camera ' + camera.type);

          camera = null; // return
        } // if (!referenceFrame && !camera3js._referenceFrame)
        //     frustum3js = CameraUtils.getFrustum3js(camera3js)

      }

      var currenCamera = camera || globalCamera;
      var cemeraChanged = currenCamera != globalCamera;
      frameState.camera = currenCamera;

      if (cemeraChanged) {
        us.update(frameState); // frameState.cullingVolume = currenCamera.frustum.computeCullingVolume(
        //     currenCamera.position,
        //     currenCamera.direction,
        //     currenCamera.up
        // );
      }

      if (this.overrideModelMatrix) {
        visualizer.traverseObject3D(scene, function (object) {
          object.currentFrustumCulled = object.frustumCulled;
          object.frustumCulled = false;
          object.modelMatrix = Matrix4.multiply(object.matrixWorld.elements, _this.overrideModelMatrix, object.modelMatrix || new Matrix4());
          if (object.up.y) _RendererUtils["default"].yUp2Zup(object.modelMatrix, object.modelMatrix);
          object.modelMatrixNeesUpdate = false;
        });
      } //execute drawCommand


      var drawCommands = [];
      visualizer.update(frameState, scene, drawCommands);
      drawCommands.forEach(function (drawCommand) {
        //
        if (customCamera) {
          var object = drawCommand.owner;
          object = object.mesh3js || object;
          customCamera.modelMatrix = object.matrixWorld.elements;
          object.modelViewMatrix.multiplyMatrices(customCamera.camera.matrixWorldInverse, object.matrixWorld);
          customCamera.modelViewMatrix = object.modelViewMatrix.elements;
          customCamera.projectionMatrix = customCamera.camera.projectionMatrix.elements;

          customCamera._normalMatrix.getNormalMatrix(object.modelViewMatrix);

          customCamera.normalMatrix = customCamera._normalMatrix.elements;
          customCamera.cameraPosition.setFromMatrixPosition(customCamera.camera.matrixWorld);
        } //


        var originalRs = drawCommand.renderState; // var rs=this._cesiumRenderStateCache.get(drawCommand,currenCamera);

        /**
         * @type {Cesium.RenderState}
         * @private
         */

        var rs = drawCommand.renderState;
        var viewport = renderTarget.viewport;
        rs = Object.assign({}, rs);

        if (_this.renderState) {
          rs = Object.assign(rs, _this.renderState); // rs = new RenderState(rs);
        }

        if (viewport) rs.viewport = viewport;

        if (!renderTarget.stencilBuffer) {
          rs.stencilTest = {
            enabled: false
          }; // rs.stencilTest.enabled = false
        }

        if (!renderTarget.depthBuffer && !renderTarget.depthTexture) {
          rs.depthTest = {
            enabled: false
          }; // rs.depthTest.enabled = false
        }

        if (renderTarget.scissorTest) {
          var scissor = renderTarget.scissor;
          rs.scissorTest = {
            enabled: true,
            rectangle: {
              x: scissor.x,
              y: scissor.y,
              width: scissor.width,
              height: scissor.height
            }
          }; // rs.scissorTest.enabled = true
          // rs.rectangle = { x: scissor.x, y: scissor.y, width: scissor.width, height: scissor.height }
        } else {
          // rs.scissorTest.enabled = false
          rs.scissorTest = {
            enabled: false
          };
        }

        rs = new RenderState(rs);
        var oldFramebuffer = drawCommand.framebuffer;
        drawCommand.renderState = rs;
        drawCommand.framebuffer = framebuffer;
        drawCommand.execute(context);
        drawCommand.framebuffer = oldFramebuffer;
        drawCommand.renderState = originalRs;
      });

      if (globalCamera.customCamera || this.overrideModelMatrix) {
        visualizer.traverseObject3D(scene, function (object) {
          object.frustumCulled = object.currentFrustumCulled;
        });
      }

      delete globalCamera.customCamera;
      frameState.camera = globalCamera;

      if (cemeraChanged) {
        frameState.cullingVolume = currentCullingVolume;
        us.update(frameState);
      } // console.log('renderToRenderTarget', drawCommands.length);


      drawCommands.length = 0;
    } //for shadowMap

    /**
     * 
     * @param {Cesium.Camera|THREE.Camera} camera 
     * @param {THREE.Scene|MeshVisualizer} scene 
     * @param {THREE.BufferGeometry} geometry 
     * @param {THREE.Material} material 
     * @param {THREE.Mesh|THREE.Line|THREE.Points|THREE.Sprite} object 
     * @param {{materialIndex:number,renderItemIndex:number,groupIndex:number}} group 
     * @param {WebGLRenderState} currentWebglRenderState
     * @param {THREE.Camera}camera3js
     * @param {string} [passName] 
     * @param {Cesium.FrameState} [frameState] 
     * @private
     */


    function renderBufferDirect(camera, scene, geometry, material, object, group, currentWebglRenderState, camera3js, passName, frameState) {
      frameState = this._frameState || frameState;

      if (!frameState) {
        throw new Error('WebGLRenderer.renderBufferDirect:MeshVisualizer未初始化，需要传递参数frameState');
      }

      var renderItems = webglRenderItems.get(object, currentWebglRenderState.camera);
      if (!renderItems) return;
      /**
       * @type {THREE.WebGLRenderTarget}
       * @private
       */

      var renderTarget = this._currentRenderTarget;
      var visualizer = this._visualizer,
          cesScene = visualizer._scene;
      if (!renderTarget) throw new Error('WebGLRenderer.renderBufferDirect:未设置renderTarget');
      if (this.autoClear) this.clear();
      var framebuffers = webGLRenderTargets.get(renderTarget);
      var framebuffer = framebuffers[this._currentActiveCubeFace || 0];
      var context = frameState.context;
      var us = context.uniformState;
      var globalCamera = frameState.camera; //copy camera

      if (camera && !(camera instanceof Camera)) {
        if (camera.isPerspectiveCamera) camera = _CameraUtils["default"].fromPerspectiveCamera3js(camera, null, cesScene);else if (camera.isOrthographicCamera) camera = _CameraUtils["default"].fromOrthographicCamera3js(camera, null, cesScene);else {
          throw new Error('unsupport camera ' + camera.type);
        }
      } //save original camera


      var currenCamera = camera || globalCamera;
      frameState.camera = currenCamera; //use new camera

      if (currenCamera !== globalCamera) us.update(frameState); //modelMatrix

      if (object.modelMatrixNeesUpdate || object.needsUpdate) {
        visualizer.computeModelMatrix(object, frameState);
      } //copy drawCommand


      var renderItemIndex = renderItems.length > 1 ? group.renderItemIndex : 0;
      passName = passName ? passName : ['_renderBufferDirect', material.uuid, geometry.uuid, renderItemIndex].join('_');
      var renderItem = renderItems[renderItemIndex];
      var drawCommand = webglRenderItems.getAndUpdateDerived(object, geometry, material, renderItem, passName, frameState, currentWebglRenderState, camera3js);
      var renerable = !!drawCommand; // var _frustum=CameraUtils.getFrustum3js(camera);

      if (renerable && renderItem.frustumCulled) {
        var boundingVolume = renderItem.boundingVolume; // var distanceToCamera = Cartesian3.distance(boundingVolume.center, currenCamera.positionWC) //currenCamera.distanceToBoundingSphere(boundingVolume);
        // var range = visualizer._minRange;
        // if (distanceToCamera > 0) range = RendererUtils.computeRange(distanceToCamera, boundingVolume.radius, frameState)
        // if (range < visualizer._minRange) {
        //     debugger
        //     renerable = false;
        // } else {
        // var visibility = frameState.cullingVolume.computeVisibility(boundingVolume)
        // if (visibility == -1) {
        //     renerable = false;
        // }
        // }
      } //render


      if (renerable) {
        var oldRS = drawCommand.renderState;
        var viewport = renderTarget.viewport;

        var rs = this._cesiumRenderStateCache.get(drawCommand, currenCamera); // rs = new RenderState(rs)


        rs.depthMask = true;
        rs.depthTest.enabled = true;
        rs.stencilTest.enabled = false;
        rs.blending.enabled = false;
        rs.viewport = viewport;
        drawCommand.renderState = rs;
        var gl = context._gl;
        RenderState.apply(gl, rs, context._defaultPassState);
        drawCommand.framebuffer = framebuffer;
        drawCommand.execute(context);
        drawCommand.framebuffer = null;
        drawCommand.renderState = oldRS;
      } //restore camera


      frameState.camera = globalCamera;
      if (currenCamera !== globalCamera) us.update(frameState);
    }

    function clear(clearColor, depth, stencil) {
      if (!clearCommandScratch) {
        clearCommandScratch = new ClearCommand({
          color: new Color(0.0, 0.0, 0.0, 0.0)
        });
      }

      if (clearColor) {
        Color.clone(clearColor, clearCommandScratch.color);
      } else {
        Color.clone(Color.TRANSPARENT, clearCommandScratch.color);
      }

      if (this._currentRenderTarget) {
        var framebuffers = webGLRenderTargets.get(this._currentRenderTarget);
        if (!framebuffers) return;
        var framebuffer = framebuffers[this._currentActiveCubeFace || 0];
        if (!framebuffer) return;
        var frameState = this._frameState;
        var clearCommand = clearCommandScratch;

        if (typeof depth == 'number') {
          clearCommand.depth = depth;
        } else {
          clearCommand.depth = this.autoClearDepth ? 1 : undefined;
        }

        if (typeof stencil == 'number') {
          clearCommand.stencil = stencil;
        } else {
          clearCommand.stencil = this.autoClearStencil ? 0 : undefined;
        }

        clearCommand.framebuffer = framebuffer;
        clearCommand.renderState = frameState.context._defaultRenderState;
        clearCommand.execute(frameState.context);
      }
    }
    /**
     * 
     * @param {THREE.WebGLRenderTarget|THREE.WebGLRenderTargetCube} renderTarget 
     * @param {number} [activeCubeFace] 
     */


    function readPixels(renderTarget, activeCubeFace) {
      renderTarget = renderTarget || this._currentRenderTarget;
      activeCubeFace = activeCubeFace || this._currentActiveCubeFace;
      var framebuffers = webGLRenderTargets.get(renderTarget);
      if (!framebuffers) return;
      var framebuffer = framebuffers[activeCubeFace || 0];
      return _RendererUtils["default"].readPixels(this._frameState, {
        framebuffer: framebuffer,
        x: 0,
        y: 0,
        width: renderTarget.width,
        height: renderTarget.height
      });
    }
    /**
     * 
     * @param {THREE.WebGLRenderTarget|THREE.WebGLRenderTargetCube} renderTarget 
     * @param {number} [x] 
     * @param {number} [y] 
     * @param {number} [width] 
     * @param {number} [height] 
     * @param {ArrayBufferView} [buffer] 
     * @param {number} [activeCubeFaceIndex] 
     */


    function readRenderTargetPixels(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      renderTarget = renderTarget || this._currentRenderTarget;
      activeCubeFaceIndex = activeCubeFaceIndex || this._currentActiveCubeFace;
      var texture = renderTarget.texture;
      var framebuffers = webGLRenderTargets.get(renderTarget);
      if (!framebuffers) return;
      var framebuffer = framebuffers[activeCubeFaceIndex || 0];
      return _RendererUtils["default"].readPixels(this._frameState, {
        framebuffer: framebuffer,
        x: x || 0,
        y: y || 0,
        width: width || renderTarget.width,
        height: height || renderTarget.height,
        pixelFormat: _ConstantMap["default"].formatsMap[texture.format],
        pixelDatatype: _ConstantMap["default"].typesMap[texture.type]
      }, buffer);
    }

    function dispose() {
      webglRenderItems.dispose();
      webGLRenderTargets.dispose();
    }

    this.init = init;
    this.render = render;
    this.renderBufferDirect = renderBufferDirect;
    this.clear = clear;
    this.readPixels = readPixels;
    this.readRenderTargetPixels = readRenderTargetPixels;
    this.dispose = dispose;
  }

  (0, _createClass2["default"])(WebGLRenderer, [{
    key: "capabilities",
    get: function get() {
      return this._capabilities;
    }
  }, {
    key: "extensions",
    get: function get() {
      return this._extensions;
    }
  }, {
    key: "needsUpdate",
    set: function set(val) {
      if (val) this.version++;
    }
  }, {
    key: "outputEncoding",
    get: function get() {
      return this._outputEncoding;
    },
    set: function set(val) {
      if (val != this._outputEncoding) {
        this._outputEncoding = val;
        this.needsUpdate = true;
      }
    }
  }, {
    key: "toneMapping",
    get: function get() {
      return this._toneMapping;
    },
    set: function set(val) {
      if (val != this._toneMapping) {
        this._toneMapping = val;
        this.needsUpdate = true;
      }
    }
  }, {
    key: "physicallyCorrectLights",
    get: function get() {
      return this._physicallyCorrectLights;
    },
    set: function set(val) {
      if (val != this._physicallyCorrectLights) {
        this._physicallyCorrectLights = val;
        this.needsUpdate = true;
      }
    }
  }, {
    key: "setRenderTarget",
    value: function setRenderTarget(renderTarget, activeCubeFace, activeMipmapLevel) {
      this._currentActiveCubeFace = activeCubeFace;
      this._currentActiveMipmapLevel = activeMipmapLevel;

      if (this._currentRenderTarget != renderTarget) {
        this._currentRenderTarget = renderTarget;
      }
    }
  }, {
    key: "getClearAlpha",
    value: function getClearAlpha() {
      return this._clearAlpha;
    }
  }, {
    key: "setClearAlpha",
    value: function setClearAlpha(clearAlpha) {
      this._clearAlpha = clearAlpha;
    }
  }, {
    key: "getClearColor",
    value: function getClearColor() {
      return this._clearColor;
    }
  }, {
    key: "setClearColor",
    value: function setClearColor(clearColor) {
      if (this._clearColor.isColor) {
        this._clearColor.set(clearColor);
      } else {
        this._clearColor = clearColor;
      }
    }
  }, {
    key: "getRenderTarget",
    value: function getRenderTarget() {
      return this._currentRenderTarget;
    }
  }, {
    key: "getActiveCubeFace",
    value: function getActiveCubeFace() {
      return this._currentActiveCubeFace;
    }
  }, {
    key: "getActiveMipmapLevel",
    value: function getActiveMipmapLevel() {
      return this._currentActiveMipmapLevel;
    }
    /**
     * @return {WebGLRenderingContext|WebGL2RenderingContext}
     */

  }, {
    key: "getContext",
    value: function getContext() {
      if (!this._frameState) return;
      return this._frameState.context._gl;
    }
  }, {
    key: "setPixelRatio",
    value: function setPixelRatio(pixelRatio) {
      this._pixelRatio = pixelRatio;
    }
    /**
     * 
     * @param {THREE.WebGLRenderer} renderer 
     */

  }, {
    key: "copy",
    value: function copy(renderer) {
      this.autoClear = renderer.autoClear;
      this.autoClearColor = renderer.autoClearColor;
      this.autoClearDepth = renderer.autoClearDepth;
      this.autoClearStencil = renderer.autoClearStencil;
      this.shadowMap.enabled = renderer.shadowMap.enabled;
      this.shadowMap.type = renderer.shadowMap.type;
      this.shadowMap.autoUpdate = renderer.shadowMap.autoUpdate; // this.gammaFactor=renderer.gammaFactor;
      // this.gammaOutput=renderer.gammaOutput

      this.outputEncoding = renderer.outputEncoding; // physical lights

      this.physicallyCorrectLights = renderer.physicallyCorrectLights; // tone mapping

      this.toneMapping = renderer.toneMapping;
      this.toneMappingExposure = renderer.toneMappingExposure; // this.toneMappingWhitePoint = renderer.toneMappingWhitePoint
      // morphs

      this.maxMorphTargets = renderer.maxMorphTargets;
      this.maxMorphNormals = renderer.maxMorphNormals;
      this.clippingPlanes = renderer.clippingPlanes; // GUI sets it to globalPlanes

      this.localClippingEnabled = renderer.localClippingEnabled;
    } //仅保留定义，部分外部依赖可能会调用这些函数

  }, {
    key: "compile",
    value: function compile(scene, camera) {}
  }, {
    key: "setSize",
    value: function setSize() {}
  }, {
    key: "clearDepth",
    value: function clearDepth() {}
  }]);
  return WebGLRenderer;
}();

var _default = WebGLRenderer;
exports["default"] = _default;

},{"C_85":1,"M_33":5,"3_82":6,"M_99":8,"m_98":9,"e_100":10,"s_101":11,"._29":12,"h_80":18,"m_87":19,"M_88":20,"s_79":21,"h_91":24,"D_83":25,"h_36":27,"D_61":28,"3_93":30,"o_64":32,"._95":33,"o_97":34,"._84":36,"-_92":37,"s_90":38,"e_1":235,"s_2":236,"M_0":241}],36:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _CameraUtils = _interopRequireDefault(require("C_85"));

var _MeshVisualizer = _interopRequireDefault(require("M_33"));

var _WebGLGeometries = _interopRequireDefault(require("e_23"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

// import vsm_frag from '../Shaders/vsm_frag.glsl.js';
// import vsm_vert from '../Shaders/vsm_vert.glsl.js';
var vsm_frag = "uniform sampler2D shadow_pass;\n\
uniform vec2 resolution;\n\
uniform float radius;\n\
#include <packing>\n\
void main() {\n\
	float mean = 0.0;\n\
	float squared_mean = 0.0;\n\
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\
		#ifdef HORIZONAL_PASS\n\
		vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\
		mean += distribution.x;\n\
		squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\
		#else\n\
		float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\
		mean += depth;\n\
		squared_mean += depth * depth;\n\
		#endif\n\
	}\n\
	mean = mean * HALF_SAMPLE_RATE;\n\
	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n\
	float std_dev = sqrt( squared_mean - mean * mean );\n\
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\
}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
/**
 * 
 * @param {WebGLRenderer} _renderer 
 * @param {*} _objects 
 * @param {number} maxTextureSize 
 */

function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.initialized = false;

  if (typeof THREE == 'undefined') {
    this.render = function () {};

    return;
  }

  var _THREE = THREE,
      FrontSide = 0,
      BackSide = 1,
      DoubleSide = 2,
      RGBAFormat = 1023,
      NearestFilter = 1003,
      LinearFilter = 1006,
      PCFShadowMap = 1,
      VSMShadowMap = 3,
      RGBADepthPacking = 3201,
      NoBlending = 0,
      WebGLRenderTarget = _THREE.WebGLRenderTarget,
      MeshDepthMaterial = _THREE.MeshDepthMaterial,
      MeshDistanceMaterial = _THREE.MeshDistanceMaterial,
      ShaderMaterial = _THREE.ShaderMaterial,
      BufferAttribute = _THREE.BufferAttribute,
      BufferGeometry = _THREE.BufferGeometry,
      Mesh = _THREE.Mesh,
      Vector4 = _THREE.Vector4,
      Vector2 = _THREE.Vector2,
      Frustum = _THREE.Frustum;

  var _frustum = new Frustum();

  var _shadowMapSize = new Vector2(),
      _viewportSize = new Vector2(),
      _viewport = new Vector4(),
      _depthMaterials = [],
      _distanceMaterials = [],
      _materialCache = {};

  var shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  var shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2.0 / 8.0,
      HALF_SAMPLE_RATE: 1.0 / 8.0
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  shadowMaterialVertical.autoRefresh = true;
  var shadowMaterialHorizonal = shadowMaterialVertical.clone();
  shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
  shadowMaterialHorizonal.autoRefresh = true;
  var fullScreenTri = new BufferGeometry();
  var setAttributeFun = fullScreenTri.setAttribute ? 'setAttribute' : 'addAttribute';
  fullScreenTri[setAttributeFun]("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  var scope = this;
  Object.defineProperty(this, 'maxTextureSize', {
    get: function get() {
      return maxTextureSize;
    },
    set: function set(val) {
      maxTextureSize = val;
    }
  });
  var _type = PCFShadowMap,
      mapVersion = 0;
  Object.defineProperties(this, {
    mapNeedsUpdate: {
      set: function set(val) {
        if (val) mapVersion++;
      }
    },
    type: {
      get: function get() {
        return _type;
      },
      set: function set(val) {
        if (val != _type) {
          _type = val;
          this.mapNeedsUpdate = true;
        }
      }
    }
  });
  var shadowMapRenderState,
      shadowMapRenderStateOpts = {
    blending: {
      enabled: false
    },
    scissorTest: {
      enabled: false
    },
    depthTest: {
      enabled: true
    },
    depthMask: true,
    colorMask: {
      red: true,
      green: true,
      blue: true,
      alpha: true
    },
    stencilTest: {
      enabled: false
    }
  };

  try {
    shadowMapRenderState = new Cesium.RenderState(shadowMapRenderStateOpts);
  } catch (err) {
    shadowMapRenderState.lineWidth = 0;
    shadowMapRenderState = new Cesium.RenderState(shadowMapRenderStateOpts);
  }
  /**
   * 
   * @param {*} lights 
   * @param {*} scene 
   * @param {Cesium.FrameState} frameState 
   * @param {MeshVisualizer} visualizer 
   */


  this.render = function (lights, scene, frameState, visualizer) {
    var _this = this;

    // if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    lights = lights.slice();
    var uniformState = frameState.context.uniformState;
    var camera = frameState.camera;
    var currentCullingVolume = frameState.cullingVolume;

    var currentWebglRenderState = _renderer._webglRenderStates.get(scene, camera);

    var currentRenderTarget = _renderer.getRenderTarget();

    var activeCubeFace = _renderer.getActiveCubeFace();

    var activeMipmapLevel = _renderer.getActiveMipmapLevel();

    var autoClear = _renderer.autoClear;
    var currentRenderState = _renderer.renderState;
    _renderer.autoClear = false;
    /**
     * @type {Cesium.RenderState}
     */

    var renderState = shadowMapRenderState;
    _renderer.renderState = renderState; //camera reference frame

    var _referenceFrame = this._referenceFrame || {};

    this._referenceFrame = _referenceFrame;
    _referenceFrame.matrix = visualizer._actualModelMatrixYup || visualizer.modelMatrix;
    _referenceFrame.inverseMatrix = visualizer._actualModelMatrixYupInverse || visualizer._actualModelMatrixInverse; // render depth map

    var _loop = function _loop(i, il) {
      var light = lights[i];
      var shadow = light.shadow;
      var shadowCameraCesium = void 0,
          shadowCamera = shadow.camera;
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) return "continue";

      if (shadow === undefined) {
        console.warn('Mesh3D.WebGLShadowMap:', light, 'has no shadow.');
        return "continue";
      }

      if (!shadowCamera.isPerspectiveCamera && !shadowCamera.isOrthographicCamera) {
        console.warn('Mesh3D.WebGLShadowMap:', light, 'camera is not supported.');
        return "continue";
      }

      _shadowMapSize.copy(shadow.mapSize);

      var shadowFrameExtents = shadow.getFrameExtents();

      _shadowMapSize.multiply(shadowFrameExtents);

      _viewportSize.copy(shadow.mapSize);

      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }

        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      } //TODO:处理阴影贴图尺寸变化的情况
      // // if (shadow.map && (shadow.map.width != _viewport.width || shadow.map.height != _viewport.height)) {
      // if (shadow.map && (shadow.mapSize.x != _viewport.width || shadow.mapSize.y != _viewport.height)) {
      // 	if (shadow.mapPass) {
      // 		shadow.mapPass.texture.dispose();
      // 		shadow.mapPass.dispose()
      // 		shadow.mapPass = null;
      // 	}
      // 	shadow.map.dispose()
      // 	shadow.map.texture.dispose();
      // 	shadow.map = null;
      // }

      /*<<阴影类型type变化时更新阴影贴图 */


      mapNeedsUpdate = shadow.__mapVersion != mapVersion;

      if (mapNeedsUpdate) {
        if (shadow.mapPass) {
          shadow.mapPass.texture.dispose();
          shadow.mapPass.dispose();
          shadow.mapPass = null;
        }

        if (shadow.map) {
          shadow.map.dispose();
          shadow.map.texture.dispose();
          shadow.map = null;
        }

        shadow.__mapVersion = mapVersion;
      }
      /*阴影类型type变化时更新阴影贴图>> */


      if (_this.type !== VSMShadowMap && shadow.mapPass) {
        if (shadow.map) {
          shadow.map.texture.dispose();
          shadow.map.dispose();
          shadow.map = null;
        }

        shadow.mapPass.dispose();
        shadow.mapPass.texture.dispose();
        shadow.mapPass = null;
      }

      if (shadow.mapPass === null && !shadow.isPointLightShadow && _this.type === VSMShadowMap) {
        if (shadow.map) {
          shadow.map.texture.dispose();
          shadow.map.dispose();
        }

        var pars = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat,
          stencilBuffer: false
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }

      if (shadow.map === null) {
        var _pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat,
          stencilBuffer: false
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, _pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }

      _renderer.setRenderTarget(shadow.map);

      _renderer.clear(Cesium.Color.WHITE, 1, 0);

      if (_this.enabled) {
        var viewportCount = shadow.getViewportCount();

        for (var vp = 0; vp < viewportCount; vp++) {
          var viewport = shadow.getViewport(vp);

          _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

          var currentViewport = shadow.map.viewport;
          shadow.map.viewport = _viewport;
          shadow.updateMatrices(light, vp);
          if (shadow.camera.isPerspectiveCamera) shadowCameraCesium = _CameraUtils["default"].fromPerspectiveCamera3js(shadowCamera, visualizer._scene, _referenceFrame);else if (shadow.camera.isOrthographicCamera) shadowCameraCesium = _CameraUtils["default"].fromOrthographicCamera3js(shadowCamera, visualizer._scene, _referenceFrame);
          _frustum = shadow.getFrustum(); //

          frameState.camera = shadowCameraCesium;
          uniformState.update(frameState); // frameState.cullingVolume = shadowCameraCesium.frustum.computeCullingVolume(
          // 	shadowCameraCesium.position,
          // 	shadowCameraCesium.direction,
          // 	shadowCameraCesium.up
          // );
          //
          // const currentWebglRenderState = visualizer.getAndUpdateRenderState(scene, frameState, shadowCamera);

          renderState.viewport = _viewport;
          currentWebglRenderState.renderables.forEach(function (object) {
            renderObject(object, camera, shadowCameraCesium, light, _this.type, false, currentWebglRenderState, shadow.camera);
          });
          frameState.camera = camera;
          frameState.cullingVolume = currentCullingVolume;
          uniformState.update(frameState);
          shadow.map.viewport = currentViewport;
          shadow.camera._referenceFrame = null;
        } // do blur pass for VSM


        if (!shadow.isPointLightShadow && _this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }

        shadow.needsUpdate = false;

        if (shadow.onCameraChanged) {
          shadow.onCameraChanged(shadow.map);
        }
      }
    };

    for (var i = 0, il = lights.length; i < il; i++) {
      var mapNeedsUpdate;

      var _ret = _loop(i, il);

      if (_ret === "continue") continue;
    }

    _renderer.renderState = currentRenderState;
    _renderer.autoClear = autoClear;
    scope.needsUpdate = false;

    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  }; //<<2020.10.23


  var VSMPassObjects = new WeakMap();
  /**
   * 
   * @param {THREE.Geometry|THREE.BufferGeometry} geometry 
   * @param {THREE.Material} material 
   */

  function getVSMPassMesh(geometry, material) {
    var objects = VSMPassObjects.get(geometry);

    if (objects === undefined) {
      objects = new WeakMap();
      VSMPassObjects.set(geometry, objects);
      geometry.addEventListener('dispose', function () {
        VSMPassObjects["delete"](geometry);
      });
    }

    var object = objects.get(material);

    if (object == undefined) {
      object = new Mesh(geometry, material);
      material.addEventListener('dispose', function () {
        objects["delete"](material);
      });
      objects.set(material, object);
    }

    return object;
  } //>>2020.10.23


  function VSMPass(shadow, camera) {
    var Color = Cesium.Color;
    var geometry = fullScreenMesh.geometry; //orig:
    // const geometry = _objects.update(fullScreenMesh);
    // vertical pass

    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.renderState.depthTest.enabled = false;
    _renderer.renderState.depthMask = false;
    _renderer.shadowMap.enabled = false;

    _renderer.setRenderTarget(shadow.mapPass);

    _renderer.clear(Color.WHITE, 1, 0); //orig:
    // _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    //<<2020.10.23


    var vsmMesh = getVSMPassMesh(geometry, shadowMaterialVertical);
    vsmMesh.frustumCulled = false;

    _renderer.render(vsmMesh, camera); //>>2020.10.23
    // horizonal pass


    shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.map);

    _renderer.clear(Color.WHITE, 1, 0); //<<2020.10.23


    vsmMesh = getVSMPassMesh(geometry, shadowMaterialHorizonal);
    vsmMesh.frustumCulled = false;

    _renderer.render(vsmMesh, camera); //>>2020.10.23


    _renderer.shadowMap.enabled = true;
    _renderer.renderState.depthTest.enabled = true;
    _renderer.renderState.depthMask = true; //orig:
    // _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );
  }

  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    var index = useMorphing << 0; //| useSkinning << 1 | useInstancing << 2;

    var material = _depthMaterials[index];

    if (material === undefined) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing // skinning: useSkinning,
        //
        // depthTest: true,
        // depthWrite: true,
        // blending: NoBlending,
        // stencilWrite: false

      });
      _depthMaterials[index] = material;
    }

    return material;
  }

  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    var index = useMorphing << 0; //| useSkinning << 1 | useInstancing << 2;

    var material = _distanceMaterials[index];

    if (material === undefined) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing // skinning: useSkinning
        //
        // , depthTest: true,
        // depthWrite: true,
        // blending: NoBlending,
        // stencilWrite: false

      });
      _distanceMaterials[index] = material;
    }

    return material;
  }

  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    var result = null;
    var getMaterialVariant = getDepthMaterialVariant;
    var customMaterial = object.customDepthMaterial;

    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }

    if (customMaterial === undefined) {
      var useMorphing = false;

      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }

      var useSkinning = false;
      /*three.js<1.3
      if (object.isSkinnedMesh === true) {
      		if (material.skinning === true) {
      			useSkinning = true;
      		} else {
      			console.warn('Mesh3D.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
      		}
      	}*/

      var useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      var keyA = result.uuid,
          keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      var cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;

    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }

    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    } //for WebGLUinforms,WebGLRenderItems


    result._isShadowDepthMaterial = true;
    return result;
  }

  var shadowMapRenderPassName = 'shadowMap';

  function renderObject(object, camera, shadowCamera, light, type, recursive, currentWebglRenderState, shadowCamera3js) {
    if (object.visible === false) return;
    var visible = !object.layers || !camera.layers || object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (object.castShadow || object.receiveShadow && type === VSMShadowMap) {
        //} && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        if ( //light.name != "sunLight" &&
        object.frustumCulled && !_frustum.intersectsObject(object)) {
          return;
        } // object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        //orig:
        // const geometry = _objects.update(object);


        var geometry = _WebGLGeometries["default"].get(object.geometry, object.material);

        var material = object.material;

        if (Array.isArray(material)) {
          var groupsOptimized = geometry.groupsOptimized;

          for (var renderItemIndex = 0; renderItemIndex < groupsOptimized.length; renderItemIndex++) {
            var _groupsOptimized$rend = groupsOptimized[renderItemIndex],
                materialIndex = _groupsOptimized$rend.materialIndex,
                groupIndex = _groupsOptimized$rend.groupIndex;
            var groupMaterial = material[materialIndex];

            if (groupMaterial.visible) {
              var depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera3js.near, shadowCamera3js.far, type);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, {
                materialIndex: materialIndex,
                groupIndex: groupIndex,
                renderItemIndex: renderItemIndex
              }, currentWebglRenderState, shadowCamera3js, shadowMapRenderPassName + light.uuid);
            }
          }
        } else if (material.visible) {
          var _depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera3js.near, shadowCamera3js.far, type);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial, object, null, currentWebglRenderState, shadowCamera3js, shadowMapRenderPassName + light.uuid);
        }
      }
    }

    var children = object.children;
    if (recursive == false || !children) return;

    for (var i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type, recursive, currentWebglRenderState, shadowCamera3js);
    }
  }
}

var _default = WebGLShadowMap;
exports["default"] = _default;

},{"C_85":1,"M_33":5,"e_23":22,"3_27":35,"M_0":241}],37:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _ConstantMap = _interopRequireDefault(require("._29"));

function WebGLTextures(visualizer) {
  var _Cesium = Cesium,
      TextureMinificationFilter = _Cesium.TextureMinificationFilter,
      TextureWrap = _Cesium.TextureWrap,
      ContextLimits = _Cesium.ContextLimits,
      Sampler = _Cesium.Sampler,
      PixelFormat = _Cesium.PixelFormat,
      defined = _Cesium.defined,
      Texture = _Cesium.Texture,
      CubeMap = _Cesium.CubeMap;
  var _Math = Cesium.Math; // var renderer = visualizer.renderer;
  // var cubemaps = renderer._cubemaps;

  var textureCache = visualizer._textureCache;
  var textures = new WeakMap();
  var textureReferences = new WeakMap();
  var disposeCallbacks = new WeakMap();
  /**
   * 
   * @param {Cesium.Texture|Cesium.CubeMapFace} destTexture 
   * @param {object} source
   * @param {ArrayBufferView} source.arrayBufferView
   * @param {number} source.width
   * @param {number} source.height
   * @param {ArrayBufferView[]} source.mipLevels
   * @private
   */

  function uploadTextureData(destTexture, source) {
    var size = destTexture._size;
    var pixelFormat = destTexture._pixelFormat;
    var pixelDatatype = destTexture._pixelDatatype;
    var preMultiplyAlpha = destTexture._preMultiplyAlpha;
    var flipY = destTexture._flipY;
    /**
     * @type {WebGLRenderingContext}
     * @private
     */

    var gl = destTexture._gl || destTexture._context._gl;
    var textureTarget = destTexture._textureTarget;
    var texture = destTexture._texture;
    var targetFace = typeof destTexture._targetFace == 'number' ? destTexture._targetFace : textureTarget;
    var width = source.width;
    var height = source.height;
    var arrayBufferView = source.arrayBufferView;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(textureTarget, texture);
    var unpackAlignment = 4;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); // Source: typed array

    var arrayBufferView = source.arrayBufferView;
    var isCompressed = PixelFormat.isCompressedFormat(pixelFormat);

    if (isCompressed) {
      gl.compressedTexImage2D(targetFace, 0, //level
      pixelFormat, width, height, 0, arrayBufferView);
    } else {
      gl.texImage2D(targetFace, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, arrayBufferView);
    }

    if (defined(source.mipLevels)) {
      var mipWidth = width;
      var mipHeight = height;

      for (var i = 0; i < source.mipLevels.length; ++i) {
        mipWidth = Math.floor(mipWidth / 2) | 0;

        if (mipWidth < 1) {
          mipWidth = 1;
        }

        mipHeight = Math.floor(mipHeight / 2) | 0;

        if (mipHeight < 1) {
          mipHeight = 1;
        }

        if (isCompressed) {
          gl.compressedTexImage2D(targetFace, i + 1, pixelFormat, mipWidth, mipHeight, 0, source.mipLevels[i]);
        } else {
          gl.texImage2D(targetFace, i + 1, pixelFormat, mipWidth, mipHeight, 0, pixelFormat, pixelDatatype, source.mipLevels[i]);
        }
      }
    }

    gl.bindTexture(textureTarget, null);
  }

  function convertSampler(texture3js) {
    var sampler = {};
    sampler.minificationFilter = _ConstantMap["default"].minFilterMap[texture3js.minFilter];
    sampler.magnificationFilter = _ConstantMap["default"].magFilterMap[texture3js.magFilter];
    sampler.wrapS = _ConstantMap["default"].textureWrapMap[texture3js.wrapS];
    sampler.wrapT = _ConstantMap["default"].textureWrapMap[texture3js.wrapT];
    sampler.maximumAnisotropy = texture3js.anisotropy;
    return new Sampler(sampler);
  }
  /**
   * 
   * @param {THREE.Texture} texture3js 
   * @param {Cesium.Context} frameState 
   * @private
   */


  function createTexture(texture3js, context) {
    var format = formatsMap[texture3js.format];
    var type = typesMap[texture3js.type];
    var preMultiplyAlpha = texture3js.premultiplyAlpha;
    var flipY = texture3js.flipY;
    var sampler = convertSampler(texture3js);
    var image = texture3js.image;
    var mipmaps = texture3js.mipmaps;
    var width = image.width;
    var height = image.height;
    var hasMipmaps = mipmaps && mipmaps.length > 0; //gen mipmap

    var mipmap = sampler.minificationFilter === 9984 || sampler.minificationFilter === 9986 || sampler.minificationFilter === 9985 || sampler.minificationFilter === 9987; //PowerOfTwo

    var requiresNpot = mipmap || sampler.wrapS === 10497 || sampler.wrapS === 33648 || sampler.wrapT === 10497 || sampler.wrapT === 33648;
    var source = image;
    var npot = source && (!_Math.isPowerOfTwo(source.width) || !_Math.isPowerOfTwo(source.height));

    if (requiresNpot && npot) {
      // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.
      var canvas = document.createElement('canvas');
      canvas.width = _Math.nextPowerOfTwo(source.width);
      canvas.height = _Math.nextPowerOfTwo(source.height);
      var canvasContext = canvas.getContext('2d');
      canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
      source = canvas;
      width = canvas.width;
      height = canvas.height;
    } //maximumTextureSize


    var needsResize = false;

    if (width > ContextLimits.maximumTextureSize) {
      width = ContextLimits.maximumTextureSize;
      needsResize = true;
      console.warn("Mesh3D.WebGLTextures:Width should be less than or equal to the maximum texture size (" + ContextLimits.maximumTextureSize + ").  Check maximumTextureSize.");
    }

    if (height > ContextLimits.maximumTextureSize) {
      console.warn("Mesh3D.WebGLTextures:Height should be less than or equal to the maximum texture size (" + ContextLimits.maximumTextureSize + ").  Check maximumTextureSize.");
      height = ContextLimits.maximumTextureSize;
      needsResize = true;
    }

    if (needsResize) {
      console.warn("Mesh3D.WebGLTextures:Width and height must be less than or equal to the maximum texture size (" + ContextLimits.maximumTextureSize + ").  Check maximumTextureSize.");
      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      var canvasContext = canvas.getContext('2d');
      canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
      source = canvas;
      width = canvas.width;
      height = canvas.height;
    } //new Texture


    var texture = new Texture({
      context: context,
      source: hasMipmaps ? undefined : source,
      width: width,
      height: height,
      pixelFormat: format,
      pixelDatatype: type,
      sampler: sampler,
      flipY: flipY,
      preMultiplyAlpha: preMultiplyAlpha
    });

    if (mipmap) {
      texture.generateMipmap();
    }

    return texture;
  }
  /**
   * 
   * @param {THREE.Texture} texture3js 
   * @param {Cesium.Context} context 
   * @private
   */


  function createDataTexture(texture3js, context) {
    var format = formatsMap[texture3js.format];
    var type = typesMap[texture3js.type];
    var preMultiplyAlpha = texture3js.premultiplyAlpha;
    var flipY = texture3js.flipY;
    var sampler = convertSampler(texture3js);
    var image = texture3js.image;
    var mipmaps = texture3js.mipmaps;
    var width = image.width > 1 ? image.width : 1;
    var height = image.height > 1 ? image.height : 1;
    var hasMipmaps = mipmaps && mipmaps.length > 0;
    var texture = new Texture({
      context: context,
      source: hasMipmaps ? undefined : {
        arrayBufferView: image.data,
        width: width,
        height: height
      },
      width: width,
      height: height,
      pixelFormat: format,
      pixelDatatype: type,
      sampler: sampler,
      flipY: flipY,
      preMultiplyAlpha: preMultiplyAlpha
    });

    if (hasMipmaps) {
      debugger;
      var source = {
        width: width,
        height: height
      };
      source.arrayBufferView = mipmaps[0].data;

      if (mipmaps.length > 1) {
        var mipLevels = [];

        for (var i = 1; i < mipmaps.length; i++) {
          mipLevels.push(mipmaps[i].data);
        }

        source.mipLevels = mipLevels;
      }

      texture._pixelFormat = format;
      uploadTextureData(texture, source);
      texture._initialized = true;
    }

    return texture;
  }
  /**
   * 
   * @param {THREE.Texture} texture3js 
   * @param {Cesium.Context} context 
   * @private
   */


  function createCompressedTexture(texture3js, context) {
    var format = formatsMap[texture3js.format];
    var type = typesMap[texture3js.type];
    var preMultiplyAlpha = texture3js.premultiplyAlpha;
    var flipY = texture3js.flipY;
    var sampler = convertSampler(texture3js);
    var image = texture3js.image;
    var mipmaps = texture3js.mipmaps;
    var width = image.width;
    var height = image.height;
    var isCompressed = PixelFormat.isCompressedFormat(format);
    var texture = new Texture({
      context: context,
      width: width,
      height: height,
      pixelFormat: isCompressed ? 6408 : format,
      pixelDatatype: type,
      sampler: sampler,
      flipY: flipY,
      preMultiplyAlpha: preMultiplyAlpha
    });
    var source = {
      width: width,
      height: height
    };
    source.arrayBufferView = mipmaps[0].data;

    if (mipmaps.length > 1) {
      var mipLevels = [];

      for (var i = 1; i < mipmaps.length; i++) {
        mipLevels.push(mipmaps[i].data);
      }

      source.mipLevels = mipLevels;
    }

    texture._pixelFormat = format;
    uploadTextureData(texture, source);
    texture._initialized = true;
    return texture;
  }
  /**
   * 
   * @param {THREE.Texture} texture3js 
   * @param {Cesium.Context} context 
   * @private
   */


  function createCubeMap(texture3js, context) {
    var format = formatsMap[texture3js.format];
    var type = typesMap[texture3js.type];
    var images = texture3js.image;
    var mipmaps = texture3js.mipmaps;
    images = images.map(function (image) {
      if (image.isDataTexture) {
        debugger;
        return {
          arrayBufferView: image.data,
          width: image.data,
          height: image.height
        };
      }

      return image;
    });
    var cubeMap = new CubeMap({
      context: context,
      source: {
        positiveX: images[0],
        negativeX: images[1],
        positiveY: images[2],
        negativeY: images[3],
        positiveZ: images[4],
        negativeZ: images[5]
      },
      pixelFormat: format,
      pixelDatatype: type,
      preMultiplyAlpha: texture3js.preMultiplyAlpha,
      flipY: texture3js.flipY
    });

    if (mipmaps && mipmaps.length) {
      debugger;
    }

    return cubeMap;
  }
  /**
   * 
   * @param {THREE.Texture} texture3js 
   * @param {Cesium.Context} context 
   * @private
   */


  function createCompressedCubeMap(texture3js, context) {
    var format = formatsMap[texture3js.format];
    var type = typesMap[texture3js.type];
    var preMultiplyAlpha = texture3js.premultiplyAlpha;
    var flipY = texture3js.flipY;
    var images = texture3js.image;
    var width = images.width || images[0].width;
    var height = images.height || images[0].height;
    var isCompressed = PixelFormat.isCompressedFormat(format);
    var cubemap = new CubeMap({
      width: width,
      height: height,
      context: context,
      pixelFormat: isCompressed ? 6408 : format,
      pixelDatatype: type,
      preMultiplyAlpha: preMultiplyAlpha,
      flipY: flipY
    });
    var faces = ["positiveX", "negativeX", "positiveY", "negativeY", "positiveZ", "negativeZ"];
    faces.forEach(function (face, faceId) {
      var cubeFace = cubemap[face],
          image = images[faceId],
          mipmaps = image.mipmaps,
          source = {
        width: width,
        height: height
      };
      source.arrayBufferView = mipmaps[0].data;

      if (mipmaps.length > 1) {
        var mipLevels = [];

        for (var i = 1; i < mipmaps.length; i++) {
          mipLevels.push(mipmaps[i].data);
        }

        source.mipLevels = mipLevels;
      }

      cubeFace._pixelFormat = format;
      uploadTextureData(cubeFace, source);
      cubeFace._initialized = true;
    });
    return cubemap;
  }
  /**
   * 
   * @param {THREE.Texture} texture3js 
   * @param {Cesium.Context} context 
   * @private
   */


  function createHdrCubeMap(texture3js, context) {
    var format = formatsMap[texture3js.format];
    var type = typesMap[texture3js.type];
    var preMultiplyAlpha = texture3js.premultiplyAlpha;
    var flipY = texture3js.flipY;
    var images = texture3js.image.map(function (image) {
      if (image.isDataTexture) {
        var tex = image;
        return {
          width: tex.image.width,
          height: tex.image.height,
          arrayBufferView: tex.image.data
        };
      }

      return image;
    });
    var cubeMap = new CubeMap({
      context: context,
      source: {
        positiveX: images[0],
        negativeX: images[1],
        positiveY: images[2],
        negativeY: images[3],
        positiveZ: images[4],
        negativeZ: images[5]
      },
      pixelFormat: format,
      pixelDatatype: type,
      preMultiplyAlpha: preMultiplyAlpha,
      flipY: flipY
    });
    return cubeMap;
  }

  function isImagesLoaded(texture3js) {
    var images = texture3js.image,
        imagesLoaded = true;
    if (!images || !images.length) return false;

    for (var i = 0; i < images.length; i++) {
      var image = images[i];

      if (!image) {
        imagesLoaded = false;
        break;
      }
    }

    return imagesLoaded;
  }

  this.has = function has(texture3js) {
    return textures.has(texture3js);
  };
  /**
   * 
   * @param {THREE.Texture|THREE.CanvasTexture|THREE.DataTexture|THREE.CubeTexture|THREE.DataTexture3D|THREE.DepthTexture|THREE.VideoTexture|THREE.CompressedTexture} texture3js 
   * @param {Cesium.FrameState} frameState  
   * @returns {Cesium.Texture|Cesium.CubeMap}
   */


  this.get = function get(texture3js, frameState, defaultVal) {
    // if (!texture3js) return defaultVal;
    if (textureCache[texture3js.uuid]) {
      return textureCache[texture3js.uuid];
    }

    var context = frameState.context;
    var texture = textures.get(texture3js);

    if (texture && texture.version != texture3js.version) {
      texture = this["delete"](texture3js);
    }

    if (!texture) {
      var defaultTexture = visualizer.defaultTexture,
          defaultCubeMap = visualizer.defaultCubeMap;
      var image = texture3js.image;

      if (texture3js.isCanvasTexture || texture3js.isVideoTexture) {
        if (image) {
          texture = createTexture(texture3js, context);
        } else {
          return defaultTexture;
        }
      } else if (texture3js.isDataTexture) {
        if (image && image.data) {
          texture = createDataTexture(texture3js, context);
        } else {
          return defaultVal || defaultTexture;
        }
      } else if (texture3js.isCubeTexture) {
        if (image.length == 6 && isImagesLoaded(texture3js)) {
          texture = createCubeMap(texture3js, context);
        } else {
          return defaultCubeMap;
        }
      } else if (texture3js.isCompressedTexture) {
        if (image) {
          if (Array.isArray(image)) {
            if (texture3js.mipmaps) {
              texture = createCompressedTexture(texture3js, context);
            } else {
              if (isImagesLoaded(texture3js)) {
                texture = createCompressedCubeMap(texture3js, context);
              } else {
                return defaultVal || defaultCubeMap;
              }
            }
          } else {
            texture = createCompressedTexture(texture3js, context);
          }
        } else {
          return defaultTexture;
        }
      } else if (Array.isArray(image)) {
        //hdr CubeTexture
        if (isImagesLoaded(texture3js)) {
          texture = createHdrCubeMap(texture3js, context);
        } else {
          return defaultVal || defaultCubeMap;
        }
      } else if (image && (image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof HTMLImageElement || image instanceof ImageData || image instanceof OffscreenCanvas || image instanceof ImageBitmap)) {
        texture = createTexture(texture3js, context);
      } else {
        return defaultVal || defaultTexture;
      }

      this.set(texture3js, texture);
    }

    return texture;
  };

  this.set = function set(texture3js, texture) {
    if (!texture || !texture3js) {
      console.warn('Mesh3D.WebGLTextures:texture3js or texture is empty');
      return;
    }

    texture.version = texture3js.version;
    textures.set(texture3js, texture);

    function disposeCallback() {
      var latestTexture = textures.get(texture3js);

      if (latestTexture !== undefined) {
        if (!latestTexture.isDestroyed || !latestTexture.isDestroyed()) latestTexture.destroy();
        textures["delete"](texture3js);
      }

      texture3js.removeEventListener('dispose', disposeCallback);
      disposeCallbacks["delete"](texture3js);
    }

    texture3js.addEventListener('dispose', disposeCallback);
    disposeCallbacks.set(texture3js, disposeCallback);
  };

  this["delete"] = function (texture3js) {
    var disposeCallback = disposeCallbacks.get(texture3js);
    if (disposeCallback) disposeCallback();
  };
  /**
   * 
   * @param {THREE.Texture} texture3js 
   */


  this.addReference = function (texture3js) {
    var reference = textureReferences.get(texture3js) || 0;
    textureReferences.set(texture3js, ++reference);
  };
  /**
   * 
   * @param {THREE.Texture} texture3js 
   */


  this.removeReference = function (texture3js) {
    var reference = textureReferences.get(texture3js);

    if (reference != undefined) {
      reference--;

      if (reference == 0) {
        this["delete"](texture3js);
        textureReferences["delete"](texture3js);
      } else {
        textureReferences.set(texture3js, reference);
      }
    }
  };

  Object.defineProperties(this, {
    textures: {
      get: function get() {
        return textures;
      }
    },
    textureReferences: {
      get: function get() {
        return textureReferences;
      }
    }
  });
  if (typeof THREE == 'undefined') return;
  var formatsMap = _ConstantMap["default"].formatsMap,
      typesMap = _ConstantMap["default"].typesMap;
}

var _default = WebGLTextures;
exports["default"] = _default;

},{"._29":12,"M_0":241}],38:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("M_110"));

var _MeshVisualizer = _interopRequireDefault(require("M_33"));

var _WebGLLights = _interopRequireDefault(require("-_26"));

var _WebGLRenderer = _interopRequireDefault(require("3_27"));

function getModifiedModelViewCallback(context, object) {
  var Matrix4 = Matrix4;
  return function () {
    if (!object._rtcTransform) {
      object._rtcTransform = new Matrix4();
    }

    if (!object._rtcModelView) {
      object._rtcModelView = new Matrix4();
    }

    Matrix4.multiplyByTranslation(object.modelMatrix, object._center, object._rtcTransform);
    return Matrix4.multiply(context.uniformState.view, object._rtcTransform, object._rtcModelView);
  };
}
/**
 * 
 * @param {WebGLRenderer} renderer 
 */


function WebGLUniforms(renderer) {
  var _Cesium = Cesium,
      OrthographicFrustum = _Cesium.OrthographicFrustum,
      Texture = _Cesium.Texture,
      Matrix4 = _Cesium.Matrix4,
      Matrix3 = _Cesium.Matrix3,
      Matrix2 = _Cesium.Matrix2,
      Color = _Cesium.Color,
      Cartesian2 = _Cesium.Cartesian2,
      Cartesian3 = _Cesium.Cartesian3,
      Cartesian4 = _Cesium.Cartesian4;
  /**
   * @type {MeshVisualizer}
   * @private
   */

  var visualizer = renderer._visualizer;
  var textures = renderer._textures;
  var materials = renderer._materials;
  var properties = renderer._properties;
  var capabilities = renderer._capabilities;
  var extensions = renderer._extensions;
  var uniformCache = new WeakMap();
  Object.defineProperties(this, {
    uniforms: {
      get: function get() {
        return uniformCache;
      }
    }
  });
  var _THREE = THREE,
      DataTexture = _THREE.DataTexture,
      UniformsLib = _THREE.UniformsLib,
      MathUtils = _THREE.MathUtils;
  var rectAreaLTC1, rectAreaLTC2; //

  function getStructUniformCallback(valObj, name) {
    return function structPropertyUniformCallback() {
      return valObj[name];
    };
  }

  function setStructureUniform(name, val, uniformMap) {
    for (var key in val) {
      if (val.hasOwnProperty(key)) {
        var uniformName = name + "." + key;
        uniformMap[uniformName] = getStructUniformCallback(val, key);
      }
    }
  }

  function isPrimitiveTypeUniform(val) {
    var type = (0, _typeof2["default"])(val);
    if (type == 'undefined' || val == null) return false;
    return type == 'number' || type == 'boolean' || val instanceof Color || val instanceof Cartesian2 || val instanceof Cartesian3 || val instanceof Cartesian4 || val instanceof Matrix2 || val instanceof Matrix3 || val instanceof Matrix4 || val instanceof Texture || val.isColor || val.isVector2 || val.isVector3 || val.isVector4 || val.isCartesian2 || val.isCartesian3 || val.isCartesian4 || val.isMatrix2 || val.isMatrix3 || val.isMatrix4;
  }

  function isStructureArrayUniform(vals) {
    if (!Array.isArray(vals) || !vals.length) return false;
    var el0 = vals[0];

    if (isPrimitiveTypeUniform(el0)) {
      return false;
    }

    return true;
  }

  function setArrayUniform(name, vals, uniformMap) {
    if (!isStructureArrayUniform(vals)) {
      uniformMap[name] = function () {
        return vals;
      };
    } else {
      for (var i = 0; i < vals.length; i++) {
        var val = vals[i];
        var thisName = name + "[" + i + "]";

        if (isStructureArrayUniform(val)) {
          setArrayUniform(thisName, val, uniformMap);
        } else {
          setStructureUniform(thisName, val, uniformMap);
        }
      }
    }
  } /////
  //


  var cameraPositionLC = new Cartesian3();

  function setBuiltinUniforms(material, object, frameState, uniformMap) {
    var pickId = object.pickId,
        pickIds = object.pickIds;

    if (pickIds) {
      var objectMaterial = object.material;
      var materialIndex = Array.isArray(objectMaterial) ? objectMaterial.indexOf(material) : 0;

      if (materialIndex != -1) {
        pickId = pickIds[materialIndex] || pickId;
      }
    }

    uniformMap.czm_pickColor = function () {
      return pickId.color;
    };

    uniformMap.cameraPosition = function () {
      var customCamera = frameState.camera.customCamera;

      if (customCamera && customCamera.cameraPosition) {
        return customCamera.cameraPosition;
      }

      return frameState.camera.position;
    };

    uniformMap.u_cameraPosition = uniformMap.cameraPosition;

    uniformMap.cameraPositionLC = function () {
      var camera = frameState.camera;
      var customCamera = camera.customCamera;

      if (customCamera && customCamera.cameraPosition) {
        return customCamera.cameraPosition;
      }

      visualizer.worldCoordinatesToLocal(camera.position, cameraPositionLC, object.up);
      return cameraPositionLC;
    };

    uniformMap.u_cameraPositionLC = uniformMap.cameraPositionLC; //base matrix

    uniformMap.normalMatrix = function () {
      var customCamera = frameState.camera.customCamera;

      if (customCamera && customCamera.normalMatrix) {
        return customCamera.normalMatrix;
      }

      return frameState.context.uniformState.normal;
    };

    uniformMap.u_normalMatrix = uniformMap.normalMatrix;

    uniformMap.projectionMatrix = function () {
      var customCamera = frameState.camera.customCamera;

      if (customCamera && customCamera.projectionMatrix) {
        return customCamera.projectionMatrix;
      }

      return frameState.context.uniformState.projection;
    };

    uniformMap.u_projectionMatrix = uniformMap.projectionMatrix;

    uniformMap.modelViewMatrix = function () {
      var customCamera = frameState.camera.customCamera;

      if (customCamera && customCamera.modelViewMatrix) {
        return customCamera.modelViewMatrix;
      }

      return frameState.context.uniformState.modelView;
    };

    uniformMap.u_modelViewMatrix = uniformMap.modelViewMatrix;
    var modelViewMatrixInverse = new Matrix4();

    uniformMap.modelViewMatrixInverse = function () {
      var mv = frameState.context.uniformState.modelView;
      return Matrix4.inverse(mv, modelViewMatrixInverse);
    }; //


    uniformMap.modelMatrix = function () {
      var customCamera = frameState.camera.customCamera;

      if (customCamera && customCamera.modelMatrix) {
        return customCamera.modelMatrix;
      }

      return frameState.context.uniformState.model;
    };

    uniformMap.u_modelMatrix = uniformMap.modelMatrix; //

    var matrixWorld = new Matrix4();

    uniformMap.matrixWorld = function () {
      var cesiumModel2ThreeModel = uniformMap._CesiumModel2ThreeModel();

      return Matrix4.multiply(cesiumModel2ThreeModel, frameState.context.uniformState.model, matrixWorld);
    }; //


    var normalMatrixWorld = new Matrix3();

    uniformMap.normalMatrixWorld = function () {
      var CesiumNormal2ThreeNormal = uniformMap._CesiumNormal2ThreeNormal();

      return Matrix3.multiply(CesiumNormal2ThreeNormal, frameState.context.uniformState.normal, normalMatrixWorld);
    }; //


    var yup = object.up.y == 1;

    uniformMap._CesiumModel2ThreeModel = function () {
      if (yup) {
        return visualizer._actualModelMatrixYupInverse;
      } else {
        return visualizer._actualModelMatrixInverse;
      }
    };

    uniformMap._ThreeModel2CesiumModel = function () {
      if (yup) {
        return visualizer._actualModelMatrixYup;
      } else {
        return visualizer._actualModelMatrix;
      }
    };

    var _CesiumNormal2ThreeNormal = new Matrix3();

    uniformMap._CesiumNormal2ThreeNormal = function () {
      if (yup) {
        return Matrix4.getMatrix3(visualizer._actualModelMatrixYupInverse, _CesiumNormal2ThreeNormal);
      } else {
        return Matrix4.getMatrix3(visualizer._actualModelMatrixInverse, _CesiumNormal2ThreeNormal);
      }
    };

    var _ThreeNormal2CesiumNormal = new Matrix3();

    uniformMap._ThreeNormal2CesiumNormal = function () {
      var up = object.up;

      if (up.y == 1) {
        return Matrix4.getMatrix3(that._actualModelMatrixYup, _ThreeNormal2CesiumNormal);
      } else {
        return Matrix4.getMatrix3(that._actualModelMatrix, _ThreeNormal2CesiumNormal);
      }
    }; //


    uniformMap.viewMatrix = function () {
      return frameState.context.uniformState.view;
    };

    uniformMap.u_viewMatrix = uniformMap.viewMatrix;

    uniformMap.logDepthBufFC = function () {
      return 2.0 / (Math.log(frameState.camera.frustum.far + 1.0) / Math.LN2);
    }; //


    uniformMap.isOrthographic = function () {
      var camera = frameState.camera;
      var isOrthographic = camera.isOrthographicCamera == true;
      return isOrthographic;
    };

    uniformMap.toneMappingExposure = function () {
      return renderer.toneMappingExposure;
    };

    uniformMap.toneMappingWhitePoint = function () {
      return renderer.toneMappingWhitePoint;
    };

    uniformMap.receiveShadow = function () {
      return object.receiveShadow == true;
    };

    uniformMap.center = function () {
      return !!object.center;
    };

    if (material.uniformStateUsed && material.uniformStateUsed.length) {
      material.uniformStateUsed.forEach(function (item) {
        if (!uniformMap[item.glslVarName]) {
          if (!frameState.context.uniformState[item.uniformStateName]) {
            throw new Error(item.uniformStateName + "不是Cesium引擎的内置对象");
          }

          uniformMap[item.glslVarName] = function () {
            return frameState.context.uniformState[item.uniformStateName];
          };
        }
      });
    }
  } //


  function setLightsUniforms(material3js, object3js, frameState, uniformMap, uniforms, lights) {
    if (properties.get(material3js).needsLights) {
      var getShadowMapCallback = function getShadowMapCallback(shadowMapName) {
        return function () {
          var textureArr = _lights[shadowMapName].map(function (texture3js) {
            if (texture3js) return textures.get(texture3js);else return visualizer.defaultShadowMap;
          });

          return textureArr;
        };
      };

      var _lights = lights.state;
      var lightUniforms = {};
      lightUniforms.lightProbe = {
        value: _lights.probe
      };
      lightUniforms.directionalLights = {
        value: _lights.directional
      };
      lightUniforms.directionalLightShadows = {
        value: _lights.directionalShadow
      };
      lightUniforms.spotLights = {
        value: _lights.spot
      };
      lightUniforms.spotLightShadows = {
        value: _lights.spotShadow
      };
      lightUniforms.rectAreaLights = {
        value: _lights.rectArea
      };
      lightUniforms.pointLights = {
        value: _lights.point
      };
      lightUniforms.pointLightShadows = {
        value: _lights.pointShadow
      };
      lightUniforms.hemisphereLights = {
        value: _lights.hemi
      };
      uniformMap.directionalShadowMap = getShadowMapCallback('directionalShadowMap');

      uniformMap.directionalShadowMatrix = function () {
        return _lights.directionalShadowMatrix;
      };

      uniformMap.spotShadowMap = getShadowMapCallback('spotShadowMap');

      uniformMap.spotShadowMatrix = function () {
        return _lights.spotShadowMatrix;
      };

      uniformMap.pointShadowMap = getShadowMapCallback('pointShadowMap');

      uniformMap.pointShadowMatrix = function () {
        return _lights.pointShadowMatrix;
      };

      setCommonUniforms(lightUniforms, frameState, uniformMap);

      if (uniforms.ambientLightColor) {
        if (material3js.lightMap) {
          uniformMap.ambientLightColor = function ambientLightColorCallback() {
            return Color.BLACK;
          };
        } else {
          uniformMap.ambientLightColor = function ambientLightColorCallback() {
            return _lights.ambient;
          };
        }
      }

      uniformMap.ltc_1 = function () {
        var texture = textures.get(rectAreaLTC1, frameState);
        return texture || visualizer.defaultTexture;
      };

      uniformMap.ltc_2 = function () {
        var texture = textures.get(rectAreaLTC2, frameState);
        return texture || visualizer.defaultTexture;
      }; //extension:point lights


      var fixedWebGLLights = visualizer._fixedWebGLLights.extensionState;
      var partialWebGLLights = visualizer._partialWebGLLights.extensionState; // if (capabilities.floatFragmentTextures) {

      uniformMap.fixedPointLightMap = function () {
        return fixedWebGLLights.point.map;
      };

      uniformMap.partialPointLightMap = function () {
        return partialWebGLLights.point.map;
      }; // } else {


      uniformMap.fixedPointLightPositions = function () {
        return fixedWebGLLights.point.positions;
      };

      uniformMap.fixedPointLightColors = function () {
        return fixedWebGLLights.point.colors;
      };

      uniformMap.fixedPointLightDecayDists = function () {
        return fixedWebGLLights.point.decalDists;
      }; //


      uniformMap.partialPointLightPositions = function () {
        return partialWebGLLights.point.positions;
      };

      uniformMap.partialPointLightColors = function () {
        return partialWebGLLights.point.colors;
      };

      uniformMap.partialPointLightDecayDists = function () {
        return partialWebGLLights.point.decalDists;
      };

      uniformMap.partialPointLightDecayDists = function () {
        return partialWebGLLights.point.decalDists;
      }; // }


      uniformMap.fixedPointLightVisibles = function () {
        return fixedWebGLLights.point.visibles;
      };

      uniformMap.partialPointLightVisibles = function () {
        return partialWebGLLights.point.visibles;
      };
    }
  } //


  function setClippingUniforms(material3js, object3js, frameState, uniformMap) {
    if (!material3js.isShaderMaterial && !material3js.isRawShaderMaterial || material3js.clipping === true) {
      // materialProperties.numClippingPlanes = clipping.numPlanes;
      // materialProperties.numIntersection = clipping.numIntersection;
      // material.uniforms.clippingPlanes = that.renderer._clipping.uniform;
      var clippingUniform = properties.get(material3js).clippingUniform;

      uniformMap.clippingPlanes = function () {
        if (clippingUniform) return clippingUniform.value;else return [];
      };
    }
  } //

  /**
   * 
   * @param {*} material3js 
   * @param {THREE.SkinnedMesh|THREE.Mesh|THREE.Points|THREE.Line} object3js 
   * @param {*} frameState 
   * @param {*} uniformMap 
   */


  function setSkinningUniforms(material3js, object3js, frameState, uniformMap) {
    if (material3js && (material3js.skinning || object3js.isSkinnedMesh)) {
      // skinning uniforms must be set even if material didn't change
      // auto-setting of texture unit for bone texture must go before other textures
      // not sure why, but otherwise weird things happen
      var object = object3js;

      uniformMap.bindMatrix = function () {
        return object.bindMatrix.elements;
      };

      uniformMap.bindMatrixInverse = function () {
        return object.bindMatrixInverse.elements;
      }; // p_uniforms.setOptional(_gl, object, 'bindMatrix');
      // p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');


      var skeleton = object.skeleton;

      if (skeleton) {
        var bones = skeleton.bones;

        if (capabilities.floatVertexTextures) {
          var boneTextureCesium = skeleton.boneTextureCesium,
              boneTexture = skeleton.boneTexture;

          if (boneTexture === undefined //threejs<1.3
          || boneTexture === null) {
            if (skeleton.computeBoneTexture) {
              skeleton.computeBoneTexture();
              boneTexture = skeleton.boneTexture;
            } else {
              // layout (1 matrix = 4 pixels)
              //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
              //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
              //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
              //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
              //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
              var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

              size = MathUtils.ceilPowerOfTwo(size);
              size = Math.max(size, 4);
              var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

              boneMatrices.set(skeleton.boneMatrices); // copy current values

              boneTexture = new DataTexture(boneMatrices, size, size, 1023, 1015);
              skeleton.boneMatrices = boneMatrices;
              skeleton.boneTexture = boneTexture;
              skeleton.boneTextureSize = size;
            }

            boneTextureCesium = textures.get(skeleton.boneTexture, frameState); // TextureUtils.fromTexure3js(skeleton.boneTexture);

            boneTextureCesium.name = 'boneTexture';
            skeleton.boneTextureCesium = boneTextureCesium;
          }

          uniformMap.boneTexture = function () {
            if (boneTextureCesium.version != boneTexture.version) {
              //update 
              var source = boneTexture.image;
              source.arrayBufferView = source.data;

              try {
                boneTextureCesium.copyFrom({
                  source: source
                });
              } catch (err) {
                boneTextureCesium.copyFrom(source);
              }

              boneTextureCesium.version = boneTexture.version;
            } else {
              boneTextureCesium.version = boneTexture.version;
            }

            return boneTextureCesium;
          };

          uniformMap.boneTextureSize = function () {
            return skeleton.boneTextureSize;
          }; // p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
          // p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);

        } else {
          // p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
          uniformMap.boneMatrices = function () {
            return skeleton.boneMatrices.elements;
          };
        }
      }
    }
  } //


  function setMorphTargetsUniforms(material, object, uniformMap) {
    if (material && (material.morphTargets || material.morphNormals)) {
      // program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
      // program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
      var morpTargethUniforms = renderer.morphtargets.getUniforms(object);

      uniformMap.morphTargetBaseInfluence = function () {
        return morpTargethUniforms.morphTargetBaseInfluence; // return object.geometry._morphBaseInfluence
      };

      uniformMap.morphTargetInfluences = function () {
        return morpTargethUniforms.morphTargetInfluences; // return object.geometry._morphInfluences
      };
    }
  } //


  function getCommonUniformCallback(uniformName, uniform, frameState) {
    var uniformVal = uniform.value;
    var typeOfVal = (0, _typeof2["default"])(uniformVal);

    if (uniform.type == 'f') {
      return function floatUniformCallbak() {
        return uniform.value || 0;
      };
    } else if (typeOfVal == 'number' || typeOfVal == 'boolean') {
      return function boolOrNumUniformCallbak() {
        return uniform.value;
      };
    } else if (!uniformVal) {
      var defaultVal = uniformName == 'envMap' ? visualizer.defaultCubeMap : visualizer.defaultTexture;
      return function nullOrTextureUniformCallback() {
        var texture3js = uniform.value;

        if (texture3js) {
          var texture = textures.get(texture3js, frameState, defaultVal);
          return texture;
        } else {
          return defaultVal;
        }
      };
    } else if (uniformVal.isTexture) {
      var defaultVal = uniformName == 'envMap' ? visualizer.defaultCubeMap : visualizer.defaultTexture;
      return function textureUniformCallback() {
        var texture = textures.get(uniform.value, frameState, defaultVal);
        return texture;
      };
    } else if (uniformVal.isVector2 | uniformVal.isVector3 | uniformVal.isVector4 | uniformVal.isColor) {
      return function vecUniformCallbak() {
        return uniform.value;
      };
    } else if (uniformVal.isMatrix2 | uniformVal.isMatrix3 | uniformVal.isMatrix4) {
      return function matrixUniformCallbak() {
        return uniform.value.elements;
      };
    } else if (Array.isArray(uniformVal)) {
      if (!uniformVal.length) return;

      if (isPrimitiveTypeUniform(uniformVal[0])) {
        return function arrayUniformCallback() {
          return uniform.value;
        };
      }
    } else {
      debugger;
    }
  }

  function setCommonUniforms(uniforms, frameState, uniformMap) {
    for (var name in uniforms) {
      var uniform = uniforms[name];

      if (uniforms.hasOwnProperty(name) && uniform) {
        var uniformVal = uniform.value;
        var callback = getCommonUniformCallback(name, uniform, frameState);

        if (callback) {
          uniformMap[name] = callback;
        } else if (isStructureArrayUniform(uniformVal)) {
          setArrayUniform(name, uniformVal, uniformMap);
        } else {
          setStructureUniform(name, uniformVal, uniformMap);
        }
      }
    }

    if (uniforms.datetime) {
      uniformMap.datetime = function () {
        return performance.now();
      };
    }
  }
  /**
   * 
   * @param {THREE.Material} material3js 
   * @param {THREE.Mesh} object3js 
   * @param {Cesium.FrameState} frameState 
   * @param {WebGLLights}lights
   * @return {{[key:string]:()=>Cesium.Texture|Cesium.CubeMap|boolean|number|{x:number,y:number,z?:number,w:number}|number[]|{red:number,green:number,blue:number:alpha:number}}}
   */


  this.getUniformMap = function (material3js, object3js, frameState, lights) {
    var uniformMap = {};
    var context = frameState.context;
    var uniformsSet = uniformCache.get(material3js);
    if (!uniformsSet || !uniformsSet.has(object3js)) return uniformMap;
    var uniforms = uniformsSet.get(object3js);
    setCommonUniforms(uniforms, frameState, uniformMap);
    setBuiltinUniforms(material3js, object3js, frameState, uniformMap);
    setLightsUniforms(material3js, object3js, frameState, uniformMap, uniforms, lights);
    setClippingUniforms(material3js, object3js, frameState, uniformMap);
    setMorphTargetsUniforms(material3js, object3js, uniformMap);
    setSkinningUniforms(material3js, object3js, frameState, uniformMap);

    if (object3js._instances) {
      uniformMap.czm_instanced_modifiedModelView = getModifiedModelViewCallback(context, object3js);
    }

    if (object3js.uniformMapLoadedCallback) {
      object3js.uniformMapLoadedCallback(uniformMap, frameState, object3js);
    }

    return uniformMap;
  };
  /**
   * 
   * @param {*} material3js 
   * @param {*} uniforms 
   * @param {*} object 
   * @private
   */


  this.set = function (material3js, uniforms, object) {
    if (!capabilities) capabilities = renderer.capabilities;
    if (!extensions) extensions = renderer.extensions;
    var uniformsSet = uniformCache.get(material3js);

    if (!uniformsSet) {
      uniformsSet = new WeakMap();
      uniformsSet.useTimes = 0;
      uniformCache.set(material3js, uniformsSet);
    }

    uniformsSet.useTimes++;
    var oldUniforms = uniformsSet.get(object);

    if (oldUniforms) {
      oldUniforms.materialDisposeCallback();
    }

    function onMaterialDispose() {
      uniformsSet["delete"](object);

      if (material3js._isShadowDepthMaterial) {
        object.removeEventListener('dispose', onMaterialDispose);
      } else {
        material3js.removeEventListener('dispose', onMaterialDispose);
      }

      uniformsSet.useTimes--;

      if (uniformsSet.useTimes == 0) {
        uniformCache["delete"](material3js);
      } //remove texture reference


      for (var key in uniforms) {
        var uniform = uniforms[key];

        if (uniforms.hasOwnProperty(key) && uniform) {
          var uniformVal = uniform.value;

          if (uniformVal && uniformVal.isTexture) {
            textures.removeReference(uniformVal);
          }
        }
      }
    }

    uniforms.materialDisposeCallback = onMaterialDispose;

    if (material3js._isShadowDepthMaterial) {
      object.addEventListener('dispose', onMaterialDispose);
    } else {
      material3js.addEventListener('dispose', onMaterialDispose);
    }

    uniformsSet.set(object, uniforms);
    this.refresh(material3js, object); //add texture reference

    for (var key in uniforms) {
      var uniform = uniforms[key];

      if (uniforms.hasOwnProperty(key) && uniform) {
        var uniformVal = uniform.value;

        if (uniformVal && uniformVal.isTexture) {
          textures.addReference(uniformVal);
        }
      }
    } //reactLights


    if (capabilities.isWebGL2) {
      // WebGL 2
      rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
      rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
    } else {
      // WebGL 1
      if (extensions.has('OES_texture_float_linear') === true) {
        rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else if (extensions.has('OES_texture_half_float_linear') === true) {
        rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      } else {
        console.error('WebGLUniforms: Unable to use RectAreaLight. Missing WebGL extensions.');
      }
    }
  };
  /**
   * 
   * @param {THREE.Material} material3js 
   * @param {THREE.Mesh} object 
   * @param {object} [uniforms] 
   */


  this.refresh = function (material3js, object, uniforms) {
    if (!uniforms) {
      var uniformsSet = uniformCache.get(material3js); // if (!uniformsSet || !uniformsSet.has(object)) return;

      uniforms = uniformsSet.get(object); //>>includeStart('debug')
      // if (!uniforms) {
      //     debugger
      // }
      //>>includeEnd('debug')
    }

    if (!uniforms) {
      return;
    } //


    if (uniforms.version == material3js.version) {
      if (material3js.autoRefresh == false) return;
    }

    if (visualizer.fog && uniforms.fogColor) {
      materials.refreshFogUniforms(uniforms, visualizer.fog);
    }

    var height = capabilities.gl.canvas.height;
    var pixelRatio = renderer._pixelRatio;
    materials.refreshMaterialUniforms(uniforms, material3js, pixelRatio, height);
    uniforms.version = material3js.version;
  };
}

var _default = WebGLUniforms;
exports["default"] = _default;

},{"M_33":5,"-_26":23,"3_27":35,"M_0":241,"M_110":245}],39:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CameraUtils", {
  enumerable: true,
  get: function get() {
    return _CameraUtils["default"];
  }
});
Object.defineProperty(exports, "GeometryUtils", {
  enumerable: true,
  get: function get() {
    return _GeometryUtils["default"];
  }
});
Object.defineProperty(exports, "IEffect", {
  enumerable: true,
  get: function get() {
    return _IEffect["default"];
  }
});
Object.defineProperty(exports, "IRenderable", {
  enumerable: true,
  get: function get() {
    return _IRenderable["default"];
  }
});
Object.defineProperty(exports, "MeshVisualizer", {
  enumerable: true,
  get: function get() {
    return _MeshVisualizer["default"];
  }
});
Object.defineProperty(exports, "polyfill", {
  enumerable: true,
  get: function get() {
    return _polyfill["default"];
  }
});
Object.defineProperty(exports, "RendererUtils", {
  enumerable: true,
  get: function get() {
    return _RendererUtils["default"];
  }
});
exports["default"] = void 0;

var _CameraUtils = _interopRequireDefault(require("3_115"));

var _GeometryUtils = _interopRequireDefault(require("D_116"));

var _IEffect = _interopRequireDefault(require("._117"));

var _IRenderable = _interopRequireDefault(require("C_118"));

var _MeshVisualizer = _interopRequireDefault(require("o_119"));

var _polyfill = _interopRequireDefault(require("m_120"));

var _RendererUtils = _interopRequireDefault(require("M_121"));

var _default = {
  MeshVisualizer: _MeshVisualizer["default"],
  polyfill: _polyfill["default"],
  GeometryUtils: _GeometryUtils["default"],
  CameraUtils: _CameraUtils["default"],
  IEffect: _IEffect["default"],
  IRenderable: _IRenderable["default"],
  RendererUtils: _RendererUtils["default"]
};
exports["default"] = _default;

},{"3_115":1,"D_116":2,"._117":3,"C_118":4,"o_119":5,"M_121":6,"m_120":7,"M_0":241}],40:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _MeshVisualizer = _interopRequireDefault(require("s_123"));

var _ImageTileLayer = _interopRequireDefault(require("h_124"));

var _imageryLayersOrderByZIndex = _interopRequireDefault(require("-_125"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * 
 * @param {object} params 
 * @param {string|HTMLElement}params.container
 */
function Earth(params) {
  var _this = this;

  // CesiumCoreExt();
  //import Cesium Class
  var _Cesium = Cesium,
      Camera = _Cesium.Camera,
      Viewer = _Cesium.Viewer,
      Cartesian3 = _Cesium.Cartesian3,
      Transforms = _Cesium.Transforms,
      Matrix4 = _Cesium.Matrix4,
      Rectangle = _Cesium.Rectangle,
      TileProviderError = _Cesium.TileProviderError; //get params

  var container = params.container,
      viewBox = params.viewBox;
  viewBox = viewBox || [70, -1, 140, 60];

  if (viewBox) {
    Camera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(viewBox[0], viewBox[1], viewBox[2], viewBox[3]);
  } else {
    Camera.DEFAULT_VIEW_RECTANGLE = new Rectangle(1.28283693362122, 0.05999788534537946, 2.3577393069441595, 0.9348140736573897);
  } //consts


  var viewer = new Viewer(container, params);
  var homeButton = viewer.homeButton,
      baseLayerPicker = viewer.baseLayerPicker,
      scene = viewer.scene,
      entities = viewer.entities,
      imageryLayers = viewer.imageryLayers,
      postProcessStages = viewer.postProcessStages;
  var globe = scene.globe,
      primitives = scene.primitives,
      camera = scene.camera;

  if (baseLayerPicker) {
    var imageryProviderViewModels = baseLayerPicker.viewModel.imageryProviderViewModels;
    container = viewer.container;
    baseLayerPicker.viewModel.selectedImagery = imageryProviderViewModels[imageryProviderViewModels.length - 1];
  }

  postProcessStages.fxaa.enabled = true;

  if (scene.highDynamicRangeSupported && params.highDynamicRange) {
    scene.highDynamicRange = true;
  } //


  var globalScene = null; // const globalScene = new MeshVisualizer()
  // globalScene.init(viewer.scene.frameState);
  // globalScene.useSunLight = true;
  // requestAnimationFrame(() => {
  //     primitives.add(globalScene);
  // })
  // 
  //

  var _localScenes = [];
  var _layers = [];

  function findLayerIndex(pLayer) {
    var layerIndex = -1;

    for (var i = 0; i < _layers.length; i++) {
      var layer = _layers[i];

      if (layer == pLayer) {
        layerIndex = i;
        break;
      }
    }

    return layerIndex;
  }

  function look(lon, lat, alt, offsetX, offsetY, offsetZ) {
    if (!viewer || viewer.isDestroyed()) {
      return;
    }

    var center;

    if (lon instanceof Cartesian3) {
      center = lon;
      offsetZ = offsetX;
      offsetY = alt;
      offsetX = lat;
    } else {
      center = Cartesian3.fromDegrees(lon, lat, alt);
    }

    var transform = Transforms.eastNorthUpToFixedFrame(center);
    camera.constrainedAxis = Cartesian3.UNIT_Z;
    camera.lookAtTransform(transform, new Cartesian3(offsetX, offsetY, offsetZ));
    setTimeout(function () {
      camera.lookAtTransform(Matrix4.IDENTITY);
    }, 100);
  }

  this.look = look;

  this.flyTo = function (target, options) {
    if (!target) return;

    if (target.boundingSphere) {
      return viewer.camera.flyToBoundingSphere(target.boundingSphere, options);
    } else if (target instanceof Cesium.Rectangle || target instanceof Cesium.Cartesian3) {
      return viewer.camera.flyTo(Object.assign(options || {}, {
        destination: target
      }));
    } else if (target) {
      return viewer.flyTo(target, options);
    }
  };
  /**
   * 
   * @param {MeshVisualizer} localScene 
   */


  this.addLocalScene = function (localScene) {
    localScene = localScene instanceof _MeshVisualizer["default"] ? localScene : new _MeshVisualizer["default"](localScene);
    localScene.init(viewer.scene.frameState);
    scene.primitives.add(localScene);

    _localScenes.push(localScene);

    return localScene;
  };
  /**
   * 
   * @param {MeshVisualizer} localScene 
   */


  this.removeLocalScene = function (localScene) {
    if (!localScene) return;

    var i = _localScenes.indexOf(localScene);

    if (i !== -1) {
      scene.primitives.remove(localScene);

      _localScenes.splice(i, 1);
    }
  };

  this.addLayer = function addLayer(layer) {
    if (findLayerIndex(layer) >= 0) {
      console.warn('图层 `' + layer.name + '` 已经存在，不能重复添加。');
      return;
    }

    layer.load(this);

    _layers.push(layer);

    return layer;
  };

  this.removeLayer = function removeLayer(layer) {
    var layerIndex = findLayerIndex(layer);
    if (layerIndex == -1) return false;

    _layers.splice(layerIndex, 1);

    layer.unload(this);
    return true;
  };
  /**
   * 
   * @param {ImageTileLayer} imgLayer 
   * @returns {ImageTileLayer}
   */


  this.addImageryLayer = function addImageryLayer(imgLayer) {
    if (!(imgLayer instanceof _ImageTileLayer["default"])) {
      imgLayer = new _ImageTileLayer["default"](imgLayer);
    }

    this.addLayer(imgLayer);
    (0, _imageryLayersOrderByZIndex["default"])(imageryLayers);
    return imgLayer;
  };
  /**
   * 
   * @param {ImageTileLayer} imgLayer 
   * @returns {ImageTileLayer}
   */


  this.removeImageryLayer = function removeImageryLayer(imgLayer) {
    if (!this.removeLayer(imgLayer)) return;
    (0, _imageryLayersOrderByZIndex["default"])(imageryLayers);
  };

  this.updateOrder = function updateOrder() {
    (0, _imageryLayersOrderByZIndex["default"])(imageryLayers);
  };

  this.onHomeClick = new Cesium.Event();
  homeButton.viewModel.command.beforeExecute.addEventListener(function (evt) {
    _this.onHomeClick.raiseEvent(evt); // evt.cancel = this.onHomeClick.numberOfListeners > 0;

  });
  var oldTileProviderErrorHandleError = TileProviderError.handleError;

  TileProviderError.handleError = function (previousError, provider, event, message, x, y, level, retryFunction, errorDetails) {
    if (provider.constructor.name == 'VectorTileImageryProvider') {
      return;
    }

    oldTileProviderErrorHandleError(previousError, provider, event, message, x, y, level, retryFunction, errorDetails);
  };

  var viewRectangle = new Cesium.Rectangle();
  Object.defineProperties(this, {
    /**
     * 获取当前视野中影像图层的最大级别
     */
    maxTileLevel: {
      enumerable: false,
      get: function get() {
        var tilesToRender = globe._surface._tilesToRender;
        var maxTileLevel = -1;

        var _iterator = _createForOfIteratorHelper(tilesToRender),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var tile = _step.value;
            maxTileLevel = Math.max(tile.level, maxTileLevel);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return maxTileLevel;
      }
    },

    /**
     * 获取当前视野所有可见瓦片的四至范围
     */
    viewRectangle: {
      enumerable: false,
      get: function get() {
        var tilesToRender = globe._surface._tilesToRender;

        if (tilesToRender.length == 0) {
          Rectangle.clone(Rectangle.MAX_VALUE, viewRectangle);
        }

        Rectangle.clone(tilesToRender[0]._rectangle, viewRectangle);

        for (var i = 1; i < tilesToRender.length; i++) {
          var tile = tilesToRender[i];
          Rectangle.union(tile._rectangle, viewRectangle, viewRectangle);
        }

        return viewRectangle;
      }
    },
    viewer: {
      enumerable: false,
      get: function get() {
        return viewer;
      }
    },
    scene: {
      enumerable: false,
      get: function get() {
        return scene;
      }
    },
    globalScene: {
      enumerable: false,
      get: function get() {
        globalScene = new _MeshVisualizer["default"]();
        globalScene.init(viewer.scene.frameState);
        globalScene.useSunLight = true;
        primitives.add(globalScene);
        return globalScene;
      }
    },
    localScenes: {
      enumerable: false,
      get: function get() {
        return _localScenes;
      }
    },
    globe: {
      enumerable: false,
      get: function get() {
        return globe;
      }
    },
    layers: {
      enumerable: false,
      get: function get() {
        return _layers;
      }
    },
    imageryLayers: {
      enumerable: false,
      get: function get() {
        return imageryLayers;
      }
    },
    entities: {
      enumerable: false,
      get: function get() {
        return entities;
      }
    },
    primitives: {
      enumerable: false,
      get: function get() {
        return primitives;
      }
    },
    postProcessStages: {
      enumerable: false,
      get: function get() {
        return postProcessStages;
      }
    }
  });
}

var _default = Earth;
exports["default"] = _default;

},{"s_123":5,"h_124":56,"-_125":58,"M_0":241}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalSkyBoxAnimation = LocalSkyBoxAnimation;
exports.LocalSkyBox = void 0;

var LocalSkyBox = function LocalSkyBox(config) {
  config = config || {};
  var _THREE = THREE,
      BackSide = 1,
      BoxBufferGeometry = _THREE.BoxBufferGeometry,
      Mesh = _THREE.Mesh,
      ShaderMaterial = _THREE.ShaderMaterial,
      Vector3 = _THREE.Vector3,
      LinearMipmapLinearFilter = 1008,
      WebGLCubeRenderTarget = _THREE.WebGLCubeRenderTarget,
      CubeCamera = _THREE.CubeCamera,
      MathUtils = _THREE.MathUtils;
  var _Cesium = Cesium,
      JulianDate = _Cesium.JulianDate,
      Event = _Cesium.Event;
  var shader = LocalSkyBox.SkyShader;

  function defaultNum(inVal, defaltVal) {
    return typeof inVal == 'number' ? inVal : defaltVal;
  }

  var material = new ShaderMaterial({
    name: 'SkyShader',
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: {
      "turbidity": {
        value: defaultNum(config.turbidity, 2)
      },
      "rayleigh": {
        value: defaultNum(config.rayleigh, 1)
      },
      "mieCoefficient": {
        value: defaultNum(config.mieCoefficient, 0.005)
      },
      "mieDirectionalG": {
        value: defaultNum(config.mieDirectionalG, 0.8)
      },
      "sunPosition": {
        value: new Vector3()
      },
      "up": {
        value: new Vector3(0, 1, 0)
      }
    },
    side: BackSide,
    depthWrite: false
  });
  var inclination = config.inclination;
  var azimuth = config.azimuth;
  var lockCesiumSun = config.lockCesiumSun;
  var animation = config.animation;
  var skyNeedsUpdate = true;

  if (typeof animation == 'boolean' && animation) {
    animation = new LocalSkyBoxAnimation();
  }

  var skyMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), material);
  skyMesh.modelMatrixNeedsUpdate = false;
  skyMesh.frustumCulled = false;
  var sun = new Vector3();
  var renderTarget = new WebGLCubeRenderTarget(512, {
    generateMipmaps: true,
    minFilter: LinearMipmapLinearFilter
  });
  var cubeCamera = new CubeCamera(0.1, 1, renderTarget);

  var _localScene, beforeUpdateRemoveCb, _currTime;

  this.update = function () {
    var localScene = _localScene;
    if (!localScene) return;
    var _Math = Math;
    var renderer = localScene.renderer;

    if (lockCesiumSun) {
      sun.copy(localScene.sunDirectionLC);

      var phi = _Math.acos(sun.x);

      var theta = _Math.sin(phi);

      if (theta != 0) {
        theta = MathUtils.clamp(sun.y / theta, -1, 1);
        theta = _Math.asin(theta);
      }

      inclination = theta / _Math.PI + 0.5;
      azimuth = phi / (2 * _Math.PI) + 0.5;
      this.sunPositionChanged.raiseEvent(this);
    } else {
      var _theta = _Math.PI * (inclination - 0.5);

      var _phi = 2 * _Math.PI * (azimuth - 0.5);

      sun.x = _Math.cos(_phi);
      sun.y = _Math.sin(_phi) * _Math.sin(_theta);
      sun.z = _Math.sin(_phi) * _Math.cos(_theta);
    }

    if (animation) {
      animation.update(this);
      this.animationTick.raiseEvent(this);
    }

    uniforms["sunPosition"].value.copy(sun);
    cubeCamera.update(renderer, skyMesh); // skyNeedsUpdate = false;
  };

  this.load = function (localScene) {
    var _this = this;

    _localScene = localScene;
    localScene.background = renderTarget.texture;
    localScene.backgroundIsSkybox = true;
    localScene.backgroundVisibleDistance = 1e4;
    localScene.environment = localScene.background;
    this.update(localScene);
    beforeUpdateRemoveCb = localScene.beforeUpdate.addEventListener(function (frameState) {
      if (skyNeedsUpdate || !_currTime || lockCesiumSun && !JulianDate.equals(_currTime, frameState.time)) {
        _this.update();

        skyNeedsUpdate = false;
        _currTime = JulianDate.clone(frameState.time, _currTime);
      }
    });
  };

  this.unload = function () {
    if (!beforeUpdateRemoveCb) return;
    _localScene.background = null;
    _localScene.environment = null;
    _localScene.backgroundIsSkybox = false;
    _localScene = null;
    _currTime = null;
    beforeUpdateRemoveCb();
  };

  this.animationTick = new Event();
  this.sunPositionChanged = new Event();
  var uniforms = material.uniforms;
  Object.defineProperties(this, {
    texture: {
      get: function get() {
        return renderTarget.texture;
      }
    },
    lockCesiumSun: {
      get: function get() {
        return lockCesiumSun;
      },
      set: function set(val) {
        lockCesiumSun = val;
        skyNeedsUpdate = true;
      }
    },
    inclination: {
      get: function get() {
        return inclination;
      },
      set: function set(val) {
        inclination = val;
        skyNeedsUpdate = true;
      }
    },
    azimuth: {
      get: function get() {
        return azimuth;
      },
      set: function set(val) {
        azimuth = val;
        skyNeedsUpdate = true;
      }
    },
    turbidity: {
      get: function get() {
        return uniforms.turbidity.value;
      },
      set: function set(val) {
        uniforms.turbidity.value = val;
        skyNeedsUpdate = true;
      }
    },
    rayleigh: {
      get: function get() {
        return uniforms.rayleigh.value;
      },
      set: function set(val) {
        uniforms.rayleigh.value = val;
        skyNeedsUpdate = true;
      }
    },
    mieCoefficient: {
      get: function get() {
        return uniforms.mieCoefficient.value;
      },
      set: function set(val) {
        uniforms.mieCoefficient.value = val;
        skyNeedsUpdate = true;
      }
    },
    mieDirectionalG: {
      get: function get() {
        return uniforms.mieDirectionalG.value;
      },
      set: function set(val) {
        uniforms.mieDirectionalG.value = val;
        skyNeedsUpdate = true;
      }
    },
    sunPosition: {
      get: function get() {
        return uniforms.sunPosition.value;
      },
      set: function set(val) {
        uniforms.sunPosition.value.copy(val);
        skyNeedsUpdate = true;
      }
    },
    animation: {
      get: function get() {
        return animation && animation.enabled;
      },
      set: function set(val) {
        if (animation && animation.enabled != val) {
          animation.enabled = val;
          skyNeedsUpdate = true;
        }
      }
    }
  });
};

exports.LocalSkyBox = LocalSkyBox;
LocalSkyBox.SkyShader = {
  // uniforms: {
  //     "turbidity": { value: 2 },
  //     "rayleigh": { value: 1 },
  //     "mieCoefficient": { value: 0.005 },
  //     "mieDirectionalG": { value: 0.8 },
  //     "sunPosition": { value: new Vector3() },
  //     "up": { value: new Vector3(0, 1, 0) }
  // },
  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering
  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham
  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff
  // K coefficient for the primaries
  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack
  // cutoffAngle = pi / 1.95;
  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '	float c = ( 0.2 * T ) * 10E-18;', '	return 0.434 * c * MieConst;', '}', 'void main() {', '	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '	vWorldPosition = worldPosition.xyz;', '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '	gl_Position.z = gl_Position.w;', // set z to camera.far
  '	vSunDirection = normalize( sunPosition );', '	vSunE = sunIntensity( dot( vSunDirection, up ) );', '	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)
  // rayleigh coefficients
  '	vBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients
  '	vBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\n'),
  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering
  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air
  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)
  // optical length at zenith for molecules
  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that
  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )
  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )
  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '	float g2 = pow( g, 2.0 );', '	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', // '#ifdef CESIUM_MESH_VISUALIZER',
  // '	vec3 direction = normalize( (_CesiumModel2ThreeModel*vec4(vWorldPosition,1.)).xyz - cameraPos );',
  // '#else', 
  '	vec3 direction = normalize( vWorldPosition - cameraPos );', // '#endif ',
  // optical length
  // cutoff angle at 90 to avoid singularity in next formula.
  '	float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '	float sR = rayleighZenithLength * inverse;', '	float sM = mieZenithLength * inverse;', // combined extinction factor
  '	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering
  '	float cosTheta = dot( direction, vSunDirection );', '	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '	vec3 betaRTheta = vBetaR * rPhase;', '	float mPhase = hgPhase( cosTheta, mieDirectionalG );', '	vec3 betaMTheta = vBetaM * mPhase;', '	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky
  '	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '	vec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc
  '	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '	vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '	gl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\n')
};

function LocalSkyBoxAnimation(options) {
  options = options || {}; //自变量

  this.inclinationRange = options.inclinationRange || [0.4913, 0.5509]; //因变量

  this.turbidityRange = options.turbidityRange || [0.01, 0.2];
  this.rayleighRange = options.rayleighRange || [0.12, 2.4];
  this.enabled = typeof options.enabled == 'boolean' ? options.enabled : true;
}
/**
 * 
 * @param {LocalSkyBox} skyBox 
 */


LocalSkyBoxAnimation.prototype.update = function (skyBox) {
  if (!this.enabled) return;
  var inclination = skyBox.inclination;
  var deltInd = this.inclinationRange[1] - this.inclinationRange[0];
  var percent = (inclination - this.inclinationRange[0]) / deltInd;
  if (percent > 1) percent = 1;else if (percent < 0) percent = 0;
  var turbidity = this.turbidityRange[1] - (this.turbidityRange[1] - this.turbidityRange[0]) * percent;
  skyBox.turbidity = turbidity;
  skyBox.rayleigh = this.rayleighRange[1] - (this.rayleighRange[1] - this.rayleighRange[0]) * percent;
};

},{}],42:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _GeometryUtils = _interopRequireDefault(require("M_132"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ExtrudedPolygonGeometry = /*#__PURE__*/function (_Cesium$PolygonGeomet) {
  (0, _inherits2["default"])(ExtrudedPolygonGeometry, _Cesium$PolygonGeomet);

  var _super = _createSuper(ExtrudedPolygonGeometry);

  function ExtrudedPolygonGeometry(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, ExtrudedPolygonGeometry);
    _this = _super.call(this, options);
    _this.options = options;
    return _this;
  }

  (0, _createClass2["default"])(ExtrudedPolygonGeometry, [{
    key: "generateExtrudedUvNormal",
    get: function get() {
      return this.options.generateExtrudedUvNormal;
    },
    set: function set(val) {
      this.options.generateExtrudedUvNormal = val;
    }
    /**
     * 
     * @param {ExtrudedPolygonGeometry} geometry 
     * @returns {Cesium.Geometry}
     */

  }], [{
    key: "createGeometry",
    value: function createGeometry(geometry) {
      var PolygonGeometry = Cesium.PolygonGeometry;
      var options = geometry.options;
      var generateExtrudedUvNormal = options.generateExtrudedUvNormal;

      if (generateExtrudedUvNormal) {
        geometry = this.createGeometryWithExtrudedUvNormal(geometry);
      } else {
        geometry = PolygonGeometry.createGeometry(geometry);
      }

      return geometry;
    }
  }, {
    key: "createGeometryWithExtrudedUvNormal",
    value: function createGeometryWithExtrudedUvNormal(extrudedPolygonGeometry) {
      var _Cesium = Cesium;
      var PolygonGeometry = _Cesium.PolygonGeometry,
          GeometryAttribute = _Cesium.GeometryAttribute,
          ComponentDatatype = _Cesium.ComponentDatatype,
          Cartesian3 = _Cesium.Cartesian3,
          Cartesian2 = _Cesium.Cartesian2,
          Geometry = _Cesium.Geometry,
          Cartographic = _Cesium.Cartographic,
          Ellipsoid = _Cesium.Ellipsoid,
          BoundingSphere = _Cesium.BoundingSphere,
          PrimitiveType = _Cesium.PrimitiveType;
      var EPSILON5 = _Cesium.Math.EPSILON5;
      var minHeight = extrudedPolygonGeometry.options.height || 0;
      var geometry = PolygonGeometry.createGeometry(extrudedPolygonGeometry);
      geometry = this.createExtrudedUvNormal(geometry, minHeight);
      return geometry;
    }
    /**
     * 
     * @param {*} geometry 
     * @param {*} minHeight 
     * @param {THREE.Vector2|Cesium.Cartesian2} [uvUnit] 
     * @param {boolean}[roundUv]
     * @param {boolean}[createTopExtrudedUvNormal]
     * @returns 
     */

  }, {
    key: "createExtrudedUvNormal",
    value: function createExtrudedUvNormal(geometry, minHeight, uvUnit, roundUv, createTopExtrudedUvNormal, createBottomExtrudedUvNormal) {
      minHeight = minHeight || 0;
      var _Cesium = Cesium;
      var GeometryAttribute = _Cesium.GeometryAttribute,
          ComponentDatatype = _Cesium.ComponentDatatype,
          Cartesian3 = _Cesium.Cartesian3,
          Cartesian2 = _Cesium.Cartesian2,
          Geometry = _Cesium.Geometry,
          Cartographic = _Cesium.Cartographic,
          Ellipsoid = _Cesium.Ellipsoid,
          BoundingSphere = _Cesium.BoundingSphere,
          PrimitiveType = _Cesium.PrimitiveType,
          defaultValue = _Cesium.defaultValue;
      var EPSILON5 = _Cesium.Math.EPSILON5;

      var newAttributes = _GeometryUtils["default"].cloneGeometryAttributes(geometry.attributes);

      var indices = geometry.indices;
      var attributes = geometry.attributes;
      var positions = Cartesian3.unpackArray(attributes.position.values);
      var normals = Cartesian3.unpackArray(attributes.normal.values);
      var sts = Cartesian2.unpackArray(attributes.st.values);
      createTopExtrudedUvNormal = defaultValue(createTopExtrudedUvNormal, true);
      createBottomExtrudedUvNormal = defaultValue(createBottomExtrudedUvNormal, true);
      var carg0 = new Cartographic(),
          carg1 = new Cartographic(),
          carg2 = new Cartographic();
      var ellipsoid = Ellipsoid.WGS84;

      function makeRoundUv(num) {
        if (Math.abs(num) < 1 || num % 1 == 0) {
          return num;
        }

        if (Math.abs(num) % 1 < 0.5) {
          return Math.floor(num);
        } else {
          return Math.ceil(num);
        }
      }

      var newPositions = [],
          newNormals = [],
          newSts = [];
      var extrudedUvs = [],
          extrudedNormals = [];

      for (var i = 0; i < indices.length; i += 3) {
        var i0 = indices[i],
            i1 = indices[i + 1],
            i2 = indices[i + 2];
        var p0 = positions[i0],
            p1 = positions[i1],
            p2 = positions[i2];
        var n0 = normals[i0],
            n1 = normals[i1],
            n2 = normals[i2];
        var st0 = sts[i0],
            st1 = sts[i1],
            st2 = sts[i2];
        Cartographic.fromCartesian(p0, ellipsoid, carg0);
        Cartographic.fromCartesian(p1, ellipsoid, carg1);
        Cartographic.fromCartesian(p2, ellipsoid, carg2);
        newPositions.push(p0, p1, p2);
        newNormals.push(n0, n1, n2);
        newSts.push(st0, st1, st2);
        st0 = st0.clone(), st1 = st1.clone(), st2 = st2.clone();
        extrudedUvs.push(st0, st1, st2);
        var tempVertices = {
          cartographic: [carg0, carg1, carg2],
          position: [p0, p1, p2],
          st: [st0, st1, st2],
          normal: [0, 0, 0]
        };
        var tops = [],
            bottoms = [];

        if (carg0.height - minHeight >= EPSILON5) {
          tops.push(0);
        } else {
          bottoms.push(0);
        }

        if (carg1.height - minHeight >= EPSILON5) {
          tops.push(1);
        } else {
          bottoms.push(1);
        }

        if (carg2.height - minHeight >= EPSILON5) {
          tops.push(2);
        } else {
          bottoms.push(2);
        }

        if (tops.length == 2) {
          /**    
           *   ·--·
           *   | /
           *   |/ 
           *   ·
           */
          var t0 = tops[0],
              t1 = tops[1],
              b0 = bottoms[0];
          st0 = tempVertices.st[t0], st1 = tempVertices.st[t1], st2 = tempVertices.st[b0];

          if (uvUnit) {
            carg0 = tempVertices.cartographic[t0], carg1 = tempVertices.cartographic[t1], carg2 = tempVertices.cartographic[b0];
            p0 = tempVertices.position[t0], p1 = tempVertices.position[t1], p2 = tempVertices.position[b0];
            var h = carg0.height - minHeight,
                d = Cartesian3.distance(p0, p1);
            st0.x = 0;
            st1.x = uvUnit.x ? 1 * d / uvUnit.x : 1;
            st2.x = 0;
            st0.y = uvUnit.y ? 1 * h / uvUnit.y : 1;
            st1.y = uvUnit.y ? 1 * h / uvUnit.y : 1;
            st2.y = 0;
          } else {
            st0.x = 0;
            st1.x = 1;
            st2.x = 0;
            st0.y = 1;
            st1.y = 1;
            st2.y = 0;
          }
        } else if (bottoms.length == 2) {
          /**    
           *      ·
           *     /|
           *    / |
           *   ·--·
           */
          var _b = bottoms[0],
              b1 = bottoms[1],
              _t = tops[0];
          st0 = tempVertices.st[_b], st1 = tempVertices.st[b1], st2 = tempVertices.st[_t];

          if (uvUnit) {
            carg0 = tempVertices.cartographic[_b], carg1 = tempVertices.cartographic[b1], carg2 = tempVertices.cartographic[_t];
            p0 = tempVertices.position[_b], p1 = tempVertices.position[b1], p2 = tempVertices.position[_t];
            var h = carg2.height - minHeight,
                d = Cartesian3.distance(p0, p1);
            st0.x = 0;
            st1.x = uvUnit.x ? 1 * d / uvUnit.x : 1;
            st2.x = uvUnit.x ? 1 * d / uvUnit.x : 1;
            st0.y = 0;
            st1.y = 0;
            st2.y = uvUnit.y ? 1 * h / uvUnit.y : 1;
          } else {
            st0.x = 0;
            st1.x = 1;
            st2.x = 1;
            st0.y = 0;
            st1.y = 0;
            st2.y = 1;
          }
        } else if (createBottomExtrudedUvNormal && bottoms.length == 3) {
          //bottom
          tempVertices.normal.fill(-1);
          st0.x = 0;
          st1.x = 0;
          st2.x = 0;
          st0.y = 0;
          st1.y = 0;
          st2.y = 0;
        } else if (createTopExtrudedUvNormal) {
          //top 
          tempVertices.normal.fill(1);

          if (uvUnit) {
            var topY = uvUnit.y ? (carg0.height - minHeight) / uvUnit.y : 1;
            st0.x = 1;
            st1.x = 1;
            st2.x = 1;
            st0.y = 1 * topY;
            st1.y = 1 * topY;
            st2.y = 1 * topY;
          } else {
            st0.x = 1;
            st1.x = 1;
            st2.x = 1;
            st0.y = 1;
            st1.y = 1;
            st2.y = 1;
          }
        }

        extrudedNormals.push(tempVertices.normal[0], tempVertices.normal[1], tempVertices.normal[2]);
      }

      newPositions = Cartesian3.packArray(newPositions, new Float32Array(newPositions.length * 3));
      newNormals = Cartesian3.packArray(newNormals, new Float32Array(newNormals.length * 3));
      newSts = Cartesian2.packArray(newSts, new Float32Array(newSts.length * 2));
      extrudedNormals = new Int8Array(extrudedNormals);
      extrudedUvs = Cartesian2.packArray(extrudedUvs, new Float32Array(extrudedUvs.length * 2));

      if (uvUnit && roundUv) {
        for (var _i = 0; _i < extrudedUvs.length; _i++) {
          extrudedUvs[_i] = makeRoundUv(extrudedUvs[_i]);
        }
      }

      newAttributes.position.values = newPositions;
      newAttributes.normal.values = newNormals;
      newAttributes.st.values = newSts;
      newAttributes.extrudedNormal = new GeometryAttribute({
        componentDatatype: ComponentDatatype.BYTE,
        componentsPerAttribute: 1,
        values: extrudedNormals,
        normalize: false
      });
      newAttributes.extrudedUv = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 2,
        values: extrudedUvs,
        normalize: false
      });
      geometry = new Geometry({
        attributes: newAttributes,
        primitiveType: 4,
        boundingSphere: BoundingSphere.fromVertices(newPositions)
      });
      return geometry;
    }
  }]);
  return ExtrudedPolygonGeometry;
}(Cesium.PolygonGeometry);

exports["default"] = ExtrudedPolygonGeometry;

},{"M_132":2,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],43:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _GeometryUtils = _interopRequireDefault(require("M_132"));

function parsePolygon(coordinates, height, extrudedHeight, uvGenerator, closeTop) {
  var _Cesium = Cesium,
      Cartesian3 = _Cesium.Cartesian3,
      PolygonHierarchy = _Cesium.PolygonHierarchy,
      PolygonGeometry = _Cesium.PolygonGeometry;
  var contour = coordinates[0].map(function (pt) {
    return Cartesian3.fromDegrees(pt[0], pt[1]);
  });
  var holes = [];

  for (var i = 1; i < coordinates.length; i++) {
    var hole = coordinates[i].map(function (pt) {
      return Cartesian3.fromDegrees(pt[0], pt[1]);
    });
    holes.push(new new PolygonHierarchy(hole)());
  }

  if (typeof closeTop != 'boolean') {
    closeTop = true;
  }

  var polygon = new PolygonGeometry({
    polygonHierarchy: new PolygonHierarchy(contour, holes),
    extrudedHeight: extrudedHeight,
    height: height,
    arcType: Cesium.ArcType.RHUMB,
    granularity: Cesium.Math.RADIANS_PER_DEGREE * 0.1,
    closeTop: closeTop,
    closeBottom: closeTop
  });
  var geometry = PolygonGeometry.createGeometry(polygon);

  if (uvGenerator) {
    var positions = geometry.attributes.position.values;
    var uvs = uvGenerator.generate(positions);

    if (uvs.length / 2 == positions.length / 3) {
      geometry.attributes.st.values = new Float32Array(uvs);
    } else {
      console.warn('返回的uv与顶点数量不一致');
    }
  }

  return geometry;
}
/**
 * 
 * @param {object} geometry 
 * @param {number} height 
 * @param {number} extrudedHeight 
 * @param {boolean} [closeTop]
 * @returns {Cesium.Geometry}
 */


function parseGeometry(geometry, height, extrudedHeight, uvGenerator, closeTop) {
  var type = geometry.type;

  if (type == 'Polygon') {
    geometry = parsePolygon(geometry.coordinates, height, extrudedHeight, uvGenerator, closeTop);
  } else if (type == 'MultiPolygon') {
    var geometries = geometry.coordinates.map(function (polygon) {
      return parsePolygon(polygon, height, extrudedHeight, uvGenerator, closeTop);
    });
    geometry = _GeometryUtils["default"].mergeGeometries(geometries);
  } else if (type == 'MultiGeometry') {
    var _geometries = geometry.geometry.map(function (geometry) {
      return parseGeometry(geometry, height, extrudedHeight, uvGenerator, closeTop);
    });

    geometry = _GeometryUtils["default"].mergeGeometries(_geometries);
  }

  return geometry;
}

var GeoPolygonGeometry = /*#__PURE__*/function () {
  function GeoPolygonGeometry(geojsonGeometry, height, extrudedHeight, uvGenerator) {
    (0, _classCallCheck2["default"])(this, GeoPolygonGeometry);
    this.geojsonGeometry = geojsonGeometry;
    this.height = height;
    this.extrudedHeight = extrudedHeight;
    this.uvGenerator = uvGenerator;
  }

  (0, _createClass2["default"])(GeoPolygonGeometry, null, [{
    key: "createGeometry",
    value: function createGeometry(geoPolygonGeometry) {
      return parseGeometry(geoPolygonGeometry.geojsonGeometry, geoPolygonGeometry.height, geoPolygonGeometry.extrudedHeight, geoPolygonGeometry.uvGenerator);
    }
  }, {
    key: "fromFeature",
    value: function fromFeature(feature, height, extrudedHeight, uvGenerator, closeTop) {
      if (!feature.geometry) {
        return;
      }

      var geometry = parseGeometry(feature.geometry, height, extrudedHeight, uvGenerator, closeTop);
      return geometry;
    }
  }, {
    key: "fromFeatures",
    value: function fromFeatures(features, height, extrudedHeight, uvGenerator) {
      var geometries = [];

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];

        if (!feature.geometry) {
          continue;
        }

        var geometry = parseGeometry(feature.geometry, height, extrudedHeight, uvGenerator);
        geometries.push(geometry);
      }

      var geometry = _GeometryUtils["default"].mergeGeometries(geometries);

      return geometry;
    }
  }]);
  return GeoPolygonGeometry;
}();

exports["default"] = GeoPolygonGeometry;

},{"M_132":2,"e_1":235,"s_2":236,"M_0":241}],44:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _GeometryUtils = _interopRequireDefault(require("M_132"));

var _geojsonHelper = _interopRequireDefault(require("C_140"));

var _index = _interopRequireDefault(require("o_141"));

var turf = _interopRequireWildcard(require("m_142"));

var _index3 = _interopRequireDefault(require("M_143"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 
 * @param {geojson.Feature<geojson.LineString>} feature 
 * @param {THREE.Vector2|Cesium.Cartesian2}[uvUnit]
 * @constructor
 */
function GeoPolylineGeometry(feature, lineWidth, uvUnit, clampToGround) {
  var line = feature.geometry.coordinates;
  var line1 = (0, _index["default"])(feature, lineWidth / 2, {
    units: 'meters'
  }).geometry.coordinates;
  var line2 = (0, _index["default"])(feature, -lineWidth / 2, {
    units: 'meters'
  }).geometry.coordinates;
  var lineCart = [],
      lineCart1 = [],
      lineCart2 = [];

  for (var i = 0; i < line.length; i++) {
    var pt = line[i];
    var pt1 = line1[i];
    var pt2 = line2[i];
    lineCart.push(Cesium.Cartesian3.fromDegrees(pt[0], pt[1], clampToGround ? pt[2] : undefined));
    lineCart1.push(Cesium.Cartesian3.fromDegrees(pt1[0], pt1[1], clampToGround ? pt[2] : undefined));
    lineCart2.push(Cesium.Cartesian3.fromDegrees(pt2[0], pt2[1], clampToGround ? pt[2] : undefined));
  }

  var distances = [0],
      d = 0;

  for (var _i = 1; _i < line.length; _i++) {
    var p0 = lineCart[_i - 1],
        p1 = lineCart[_i];
    var a = Cesium.Cartesian3.distance(p0, p1);
    d += a;
    distances.push(d);
  }

  d = uvUnit ? uvUnit.x : d;
  var uvs = [],
      positions = [],
      vertices = [];

  for (var _i2 = 0; _i2 < line.length; _i2++) {
    var x = distances[_i2] / d,
        p1 = lineCart1[_i2],
        p2 = lineCart2[_i2];
    uvs.push(x, 0);
    uvs.push(x, 1);
    positions.push(p1.x, p1.y, p1.z);
    positions.push(p2.x, p2.y, p2.z);
    vertices.push(lineCart1[_i2], lineCart2[_i2]);
  }

  var indices = [];

  for (var _i3 = 1; _i3 < line.length; _i3++) {
    var i0 = 2 * (_i3 - 1),
        i1 = 2 * _i3 - 1,
        i2 = 2 * _i3,
        i3 = 2 * _i3 + 1;
    var _p = line1[_i3 - 1];
    var _p2 = line2[_i3 - 1];
    var _p3 = line1[_i3];
    var p3 = line2[_i3];

    var cw = _geojsonHelper["default"].isClockWise([_p, _p2, p3, _p3]);

    if (!cw) {
      indices.push(i3, i0, i1, i3, i2, i0);
    } else {
      indices.push(i0, i3, i1, i0, i2, i3);
    }
  }

  uvs = new Float32Array(uvs);
  positions = new Float32Array(positions);
  var geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3, false));
  geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2, false));
  geometry.setIndex(indices);
  lineCart = [], lineCart1 = [], lineCart2 = [];
  return geometry;
}
/**
 * 
 * @param {geojson.Feature<geojson.LineString>[]} features 
 * @param {number}[epsilon=0.01] 单位是：m/米
 * @returns {geojson.Feature<geojson.LineString>[]}
 */


GeoPolylineGeometry.union = function (features, epsilon) {
  epsilon = typeof epsilon == 'number' ? epsilon : 0.01;
  if (epsilon < 0) epsilon = 0;
  epsilon /= 1000.0;

  function coordEquals(c1, c2) {
    var from = turf.point(c1);
    var to = turf.point(c2);
    var options = {
      units: 'kilometers'
    };
    var distance = (0, _index3["default"])(from, to, options);
    return distance <= epsilon;
  }

  function getStart(feature) {
    var coordinates = feature.geometry.coordinates;
    return coordinates[0];
  }

  function getStop(feature) {
    var coordinates = feature.geometry.coordinates;
    return coordinates[coordinates.length - 1];
  }

  function union(prev, next, reverseNext, reversePrev) {
    var coordinatesPre = prev.geometry.coordinates.slice();
    var coordinatesNext = next.geometry.coordinates.slice();
    if (reverseNext) coordinatesNext = coordinatesNext.reverse();
    if (reversePrev) coordinatesPre = coordinatesPre.reverse();
    coordinatesPre.pop();
    return {
      type: 'Feature',
      geometry: {
        type: 'LineString',
        coordinates: coordinatesPre.concat(coordinatesNext),
        properties: Object.assign({}, prev.properties, next.properties)
      }
    };
  }

  var stack = features.slice();
  var newFeatures = [];

  do {
    var feature = stack.pop();
    var tempStack = stack.slice();
    var changed = false;

    while (tempStack.length) {
      var tempFeature = tempStack.pop();
      var deleted = false;

      if (coordEquals(getStart(tempFeature), getStop(feature))) {
        //0-->(0 0)-->0
        feature = union(feature, tempFeature);
        deleted = true;
      } else if (coordEquals(getStop(tempFeature), getStart(feature))) {
        //0<--(0 0)<--0
        feature = union(tempFeature, feature);
        deleted = true;
      } else if (coordEquals(getStop(tempFeature), getStop(feature))) {
        //0-->(0 0)<--0
        feature = union(tempFeature, feature, true);
        deleted = true;
      } else if (coordEquals(getStart(tempFeature), getStart(feature))) {
        //0<--(0 0)-->0
        feature = union(tempFeature, feature, false, true);
        deleted = true;
      }

      if (deleted) {
        var id = stack.indexOf(tempFeature);
        stack.splice(id, 1);
        changed = true;
      }
    }

    changed ? stack.push(feature) : newFeatures.push(feature);
  } while (stack.length);

  return newFeatures;
};
/**
 * 
 * @param {geojson.Feature<geojson.LineString>} feature 
 * @param {number} lineWidth 
 * @param {{x:number,y:number}} [uvUnit] 
 * @param {boolean} [clampToGround] 
 * @returns {THREE.BufferGeometry}
 */


GeoPolylineGeometry.fromFeature = function (feature, lineWidth, uvUnit, clampToGround) {
  if (!feature.geometry) {
    return;
  }

  return new GeoPolylineGeometry(feature, lineWidth, uvUnit, clampToGround);
};
/**
 * 
 * @param {geojson.PolylineFeatureCollection} features 
 * @param {number} lineWidth 
 * @param {object} [options]
 * @param {THREE.Vector2|Cesium.Cartesian2}[options.uvUnit]
 * @param {boolean}[options.union]
 * @param {number}[options.unionEpsilon=0.01] 单位是：m/米
 * @param {boolean}[options.clampToGround]
 * @returns {THREE.BufferGeometry}
 */


GeoPolylineGeometry.fromFeatures = function (features, lineWidth, options) {
  var geometries = [];

  try {
    var union = options.union,
        unionEpsilon = options.unionEpsilon,
        uvUnit = options.uvUnit,
        clampToGround = options.clampToGround;
    if (union) features = this.union(features, unionEpsilon);

    for (var i = 0; i < features.length; i++) {
      var g = new GeoPolylineGeometry(features[i], lineWidth, uvUnit, clampToGround);
      geometries.push(g);
    }

    var geometry = _GeometryUtils["default"].mergeGeometries3js(geometries);

    geometry.computeVertexNormals();
    geometry.computeBoundingSphere();
    return geometry;
  } catch (er) {
    console.error(er);
  }
};

var _default = GeoPolylineGeometry;
exports["default"] = _default;

},{"M_143":213,"m_142":214,"o_141":216,"M_132":2,"C_140":199,"M_0":241,"M_110":245}],45:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = SolidWireframeGeometry;

var _GeometryUtils = _interopRequireDefault(require("M_132"));

function Vertex(x, y, z, center, id) {
  this.id = id;
  center = center || [0, 0, 0, 0];
  this.position = new THREE.Vector3(x, y, z);
  this.center = new THREE.Vector4().fromArray(center);
  /**
   * @type {Edge[]}
   */

  this.edges = [];
  this.onSharedLine = false;
}

function Edge(v1, v2, id) {
  this.id = id;
  this.v1 = v1;
  this.v2 = v2;
  this.isShared = false;
  /**
   * @type {Triangle}
   */

  this.triangles = [];
}
/**
 * 
 * @param {Vertex} a 
 * @param {Vertex} b 
 * @param {Vertex} c 
 */


function Triangle(a, b, c) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = null;
  this.edges = [];
  this.vertices = [a, b, c];
}

var centers4 = [[1, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 1], [0, 1, 0, 1]],
    centers3 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]],
    centerEmpty = [0, 0, 0, 0];
/**
 * 
 * @param {THREE.BufferGeometry|THREE.Geometry} geometry 
 * @param {boolean} [quadMode=false] 
 * @constructor
 * @extends THREE.BufferGeometry
 */

function SolidWireframeGeometry(geometry, quadMode) {
  if (quadMode) return new SolidWireframeGeometry2(geometry);
  var _THREE = THREE,
      BufferGeometry = _THREE.BufferGeometry,
      BufferAttribute = _THREE.BufferAttribute;

  if (geometry.isGeometry) {
    geometry = new BufferGeometry().fromGeometry(geometry);
  }

  var srcPosition = geometry.attributes.position;

  var index = _GeometryUtils["default"].genGeometryIndicesAll(geometry);

  var positions = [],
      centers = [];

  var _vector3 = new THREE.Vector3();

  function pushFinalVertex(idx, center) {
    _vector3.fromBufferAttribute(srcPosition, idx);

    var x = _vector3.x,
        y = _vector3.y,
        z = _vector3.z;
    positions.push(x, y, z);
    centers.push(center[0], center[1], center[2], center[3]);
  }

  for (var i = 0; i < index.length; i += 3) {
    var a = index[i],
        b = index[i + 1],
        c = index[i + 2];
    pushFinalVertex(a, centers3[0]);
    pushFinalVertex(b, centers3[1]);
    pushFinalVertex(c, centers3[2]);
  }

  positions = new Float32Array(positions);
  centers = new Float32Array(centers);
  geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new BufferAttribute(positions, 3, false));
  geometry.setAttribute('center', new BufferAttribute(centers, 4, false));
  return geometry;
}

function SolidWireframeGeometry2(geometry) {
  var _THREE2 = THREE,
      BufferGeometry = _THREE2.BufferGeometry,
      BufferAttribute = _THREE2.BufferAttribute;

  if (geometry.isGeometry) {
    geometry = new BufferGeometry().fromGeometry(geometry);
  }

  var srcPositions = geometry.attributes.position.array;

  var index = _GeometryUtils["default"].genGeometryIndicesAll(geometry);

  var positions = [],
      centers = [];

  function pushFinalVertex(v, center) {
    var position = v.position;
    var x = position.x,
        y = position.y,
        z = position.z;
    positions.push(x, y, z);
    centers.push(center[0], center[1], center[2], center[3]);
  }
  /**
   * @type {Triangle[]}
   */


  var triangles = [];
  /**
   * @type {Edge[]}
   */

  var edges = [];
  var edgeMap = new Map();
  /**
   * @type {Vertex[]}
   */

  var vertices = [];
  var vertexMap = new Map();

  function pushVertex(srcIdx, center) {
    var off = srcIdx * 3;
    var x = srcPositions[off],
        y = srcPositions[off + 1],
        z = srcPositions[off + 2];
    var key = x + ',' + y + ',' + z;
    var vertex = vertexMap.get(key);

    if (vertex == undefined) {
      vertex = new Vertex(x, y, z, center, vertices.length);
      vertices.push(vertex);
      vertexMap.set(key, vertex);
    }

    return vertex;
  }

  function pushEdge(a, b, triangle) {
    var ia = a.id,
        ib = b.id;
    var va = a,
        vb = b;
    var key = ia > ib ? [ib, a] : [a, b];

    if (ia > ib) {
      vb = a;
      va = b;
      key = [ib, ia].join(',');
    } else {
      key = [ia, ib].join(',');
    }

    var edge = edgeMap.get(key);

    if (edge == undefined) {
      edge = new Edge(va, vb, edges.length);
      edges.push(edge);
      va.edges.push(edge);
      vb.edges.push(edge);
      edgeMap.set(key, edge);
    }

    edge.triangles.push(triangle);
    triangle.edges.push(edge);
    return edge;
  }

  function pushTriangle(a, b, c) {
    a = pushVertex(a, [1, 0, 0, 0]);
    b = pushVertex(b, [0, 1, 0, 0]);
    c = pushVertex(c, [0, 0, 1, 0]);
    var triangle = new Triangle(a, b, c);
    pushEdge(a, b, triangle);
    pushEdge(b, c, triangle);
    pushEdge(c, a, triangle);
    triangles.push(triangle);
  }

  for (var i = 0; i < index.length; i += 3) {
    var a = index[i],
        b = index[i + 1],
        c = index[i + 2];
    pushTriangle(a, b, c);
  }

  var N = new THREE.Vector3();
  var removeCoplanar = true;
  var angleEpsilon = 1;

  for (var _i = 0; _i < edges.length; _i++) {
    var edge = edges[_i];
    var _triangles = edge.triangles;

    if (_triangles.length > 1) {
      var isCoplanar = true;

      if (removeCoplanar) {
        _triangles.forEach(function (triangle) {
          if (triangle.normal) return;
          var a = triangle.a,
              b = triangle.b,
              c = triangle.c;
          a = a.position;
          b = b.position;
          c = c.position;

          _GeometryUtils["default"].computeNormal(a, b, c, N, false);

          triangle.normal = N.clone();
        });

        var N0 = _triangles[0].normal;

        for (var j = 1; j < _triangles.length; j++) {
          var triangle = _triangles[j];
          var angle = N0.angleTo(triangle.normal);

          if (angle > angleEpsilon) {
            isCoplanar = false;
            break;
          }
        }
      }

      if (isCoplanar) edge.isShared = true;
    }
  } //


  var vs = [];

  for (var _i2 = 0; _i2 < edges.length; _i2++) {
    var _edge = edges[_i2];

    if (_edge.isShared) {
      vs.length = 0;
      var done = false;
      var triangles = _edge.triangles;
      triangles.forEach(function (triangle) {
        if (triangle._done) done = true;
      });
      if (done) continue;
      triangles.forEach(function (triangle) {
        triangle.vertices.forEach(function (v) {
          var vi = vs.indexOf(v);

          if (vi == -1) {
            vi = vs.length;
            vs.push(v);
          }

          var center = centers4[vi];
          pushFinalVertex(v, center);
        });
        triangle._done = true;
      });
    }
  }

  for (var _i3 = 0; _i3 < triangles.length; _i3++) {
    var _triangle = triangles[_i3];
    if (_triangle._done) continue;
    var a = _triangle.a,
        b = _triangle.b,
        c = _triangle.c;
    pushFinalVertex(a, centers3[0]);
    pushFinalVertex(b, centers3[1]);
    pushFinalVertex(c, centers3[2]);
  }

  positions = new Float32Array(positions);
  centers = new Float32Array(centers);
  geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new BufferAttribute(positions, 3, false));
  geometry.setAttribute('center', new BufferAttribute(centers, 4, false));
  return geometry;
}

},{"M_132":2,"M_0":241}],46:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _GeometryUtils = _interopRequireDefault(require("M_132"));

var triangulateShape = _GeometryUtils["default"].triangulateShape;

function VectorPolygonGeometry(contour, holes, height) {
  this.contour = contour || [];
  this.holes = holes || [];
  this.height = height || 0;
}

VectorPolygonGeometry.createGeometry = function (vectorPolygonGeometry) {
  var Vector3 = THREE.Vector3;
  var contour = vectorPolygonGeometry.contour;
  var holes = vectorPolygonGeometry.holes;
  var height = vectorPolygonGeometry.height;
  var vertices = [],
      indices = [];
  contour = contour.map(function (vertex) {
    return Array.isArray(vertex) ? new Vector3(vertex[0], vertex[1], height) : vertex;
  });
  holes = holes.map(function (hole) {
    return hole.map(function (vertex) {
      return Array.isArray(vertex) ? new Vector3(vertex[0], vertex[1], height) : vertex;
    });
  });
  triangulateShape(contour, holes, vertices, indices);
  return buildGeometry(vertices, indices);
};

function buildGeometry(vertices, indices) {
  var _THREE = THREE,
      BufferGeometry = _THREE.BufferGeometry,
      BufferAttribute = _THREE.BufferAttribute;
  var positions = new Float32Array(vertices.length * 3),
      ptr = 0;
  vertices.forEach(function (v) {
    positions[ptr++] = v.x;
    positions[ptr++] = v.y;
    positions[ptr++] = v.z;
  });
  var geometry = new BufferGeometry();
  geometry.setAttribute('position', new BufferAttribute(positions, 3, false));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  return geometry;
}

function parsePolygon(polygonCoordinates, height, outVertices, outIndices) {
  var Vector3 = THREE.Vector3;
  var contour = polygonCoordinates[0],
      holes = [];

  for (var i = 1; i < polygonCoordinates.length; i++) {
    holes.push(polygonCoordinates[i]);
  }

  contour = contour.map(function (vertex) {
    return Array.isArray(vertex) ? new Vector3(vertex[0], vertex[1], height) : vertex;
  });
  holes = holes.map(function (hole) {
    return hole.map(function (vertex) {
      return Array.isArray(vertex) ? new Vector3(vertex[0], vertex[1], height) : vertex;
    });
  });
  triangulateShape(contour, holes, outVertices, outIndices);
}

VectorPolygonGeometry.fromFeature = function (feature, height) {
  var vertices = [],
      indices = [];
  height = height || 0.01;

  if (!feature.geometry) {
    return;
  }

  var geom = feature.geometry,
      geomType = geom.type;
  var coordinates = geom.coordinates;

  if (geomType == 'Polygon') {
    parsePolygon(coordinates, height, vertices, indices);
  } else if (geomType == 'MultiPolygon') {
    coordinates.forEach(function (polygon) {
      parsePolygon(polygon, height, vertices, indices);
    });
  }

  if (!vertices.length) return;
  return buildGeometry(vertices, indices);
};

VectorPolygonGeometry.fromFeatures = function (features, height) {
  var vertices = [],
      indices = [];
  height = height || 0.01;
  features.forEach(function (f) {
    if (!f.geometry) {
      return;
    }

    var geom = f.geometry,
        geomType = geom.type;
    var coordinates = geom.coordinates;

    if (geomType == 'Polygon') {
      parsePolygon(coordinates, height, vertices, indices);
    } else if (geomType == 'MultiPolygon') {
      coordinates.forEach(function (polygon) {
        parsePolygon(polygon, height, vertices, indices);
      });
    }
  });
  if (!vertices.length) return;
  return buildGeometry(vertices, indices);
};

var _default = VectorPolygonGeometry;
exports["default"] = _default;

},{"M_132":2,"M_0":241}],47:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Earth", {
  enumerable: true,
  get: function get() {
    return _Earth["default"];
  }
});
Object.defineProperty(exports, "GeoPolygonGeometry", {
  enumerable: true,
  get: function get() {
    return _GeoPolygonGeometry["default"];
  }
});
Object.defineProperty(exports, "GeoPolylineGeometry", {
  enumerable: true,
  get: function get() {
    return _GeoPolylineGeometry["default"];
  }
});
Object.defineProperty(exports, "ExtrudedPolygonGeometry", {
  enumerable: true,
  get: function get() {
    return _ExtrudedPolygonGeometry["default"];
  }
});
Object.defineProperty(exports, "SolidWireframeGeometry", {
  enumerable: true,
  get: function get() {
    return _SolidWireframeGeometry["default"];
  }
});
Object.defineProperty(exports, "VectorPolygonGeometry", {
  enumerable: true,
  get: function get() {
    return _VectorPolygonGeometry["default"];
  }
});
Object.defineProperty(exports, "SolidWireframeMaterial", {
  enumerable: true,
  get: function get() {
    return _SolidWireframeMaterial["default"];
  }
});
Object.defineProperty(exports, "TiandituLayer", {
  enumerable: true,
  get: function get() {
    return _TiandituLayer["default"];
  }
});
Object.defineProperty(exports, "TiandituImgLayer", {
  enumerable: true,
  get: function get() {
    return _TiandituLayer.TiandituImgLayer;
  }
});
Object.defineProperty(exports, "TiandituTerLayer", {
  enumerable: true,
  get: function get() {
    return _TiandituLayer.TiandituTerLayer;
  }
});
Object.defineProperty(exports, "TiandituVecLayer", {
  enumerable: true,
  get: function get() {
    return _TiandituLayer.TiandituVecLayer;
  }
});
Object.defineProperty(exports, "C3DTilesLayer", {
  enumerable: true,
  get: function get() {
    return _C3DTilesLayer["default"];
  }
});
Object.defineProperty(exports, "OsgbLayer", {
  enumerable: true,
  get: function get() {
    return _OsgbLayer["default"];
  }
});
Object.defineProperty(exports, "GeoMesh", {
  enumerable: true,
  get: function get() {
    return _GeoMesh["default"];
  }
});
Object.defineProperty(exports, "GeoPolygonMesh", {
  enumerable: true,
  get: function get() {
    return _GeoPolygonMesh["default"];
  }
});
Object.defineProperty(exports, "GeoPolylineMesh", {
  enumerable: true,
  get: function get() {
    return _GeoPolylineMesh["default"];
  }
});
Object.defineProperty(exports, "GeoWaterMesh", {
  enumerable: true,
  get: function get() {
    return _GeoWaterMesh["default"];
  }
});
Object.defineProperty(exports, "Vector2dLayer", {
  enumerable: true,
  get: function get() {
    return _Vector2dLayer["default"];
  }
});
Object.defineProperty(exports, "HighlightPolygonLayer", {
  enumerable: true,
  get: function get() {
    return _Vector2dLayer.HighlightPolygonLayer;
  }
});
Object.defineProperty(exports, "SealandVec2dLayer", {
  enumerable: true,
  get: function get() {
    return _Vector2dLayer.SealandVec2dLayer;
  }
});
Object.defineProperty(exports, "HighlightMarkerLayer", {
  enumerable: true,
  get: function get() {
    return _Vector2dLayer.HighlightMarkerLayer;
  }
});
Object.defineProperty(exports, "LabelVec2dLayer", {
  enumerable: true,
  get: function get() {
    return _Vector2dLayer.LabelVec2dLayer;
  }
});
Object.defineProperty(exports, "CountryVec2dLayer", {
  enumerable: true,
  get: function get() {
    return _Vector2dLayer.CountryVec2dLayer;
  }
});
Object.defineProperty(exports, "Vector3dLayer", {
  enumerable: true,
  get: function get() {
    return _Vector3dLayer["default"];
  }
});
Object.defineProperty(exports, "ImageTileLayer", {
  enumerable: true,
  get: function get() {
    return _ImageTileLayer["default"];
  }
});
Object.defineProperty(exports, "ILayer", {
  enumerable: true,
  get: function get() {
    return _ILayer["default"];
  }
});
Object.defineProperty(exports, "LocalSkyBox", {
  enumerable: true,
  get: function get() {
    return _LocalSkyBox.LocalSkyBox;
  }
});
Object.defineProperty(exports, "LocalSkyBoxAnimation", {
  enumerable: true,
  get: function get() {
    return _LocalSkyBox.LocalSkyBoxAnimation;
  }
});
Object.defineProperty(exports, "interactive", {
  enumerable: true,
  get: function get() {
    return _index["default"];
  }
});
Object.defineProperty(exports, "getPoint", {
  enumerable: true,
  get: function get() {
    return _index.getPoint;
  }
});
Object.defineProperty(exports, "getLine", {
  enumerable: true,
  get: function get() {
    return _index.getLine;
  }
});
Object.defineProperty(exports, "getPolyline", {
  enumerable: true,
  get: function get() {
    return _index.getPolyline;
  }
});
Object.defineProperty(exports, "getRactangle", {
  enumerable: true,
  get: function get() {
    return _index.getRactangle;
  }
});
Object.defineProperty(exports, "pickPosition", {
  enumerable: true,
  get: function get() {
    return _index.pickPosition;
  }
});
Object.defineProperty(exports, "MeshVisualizer", {
  enumerable: true,
  get: function get() {
    return _index2.MeshVisualizer;
  }
});
Object.defineProperty(exports, "polyfill", {
  enumerable: true,
  get: function get() {
    return _index2.polyfill;
  }
});
Object.defineProperty(exports, "GeometryUtils", {
  enumerable: true,
  get: function get() {
    return _index2.GeometryUtils;
  }
});
Object.defineProperty(exports, "CameraUtils", {
  enumerable: true,
  get: function get() {
    return _index2.CameraUtils;
  }
});
Object.defineProperty(exports, "IEffect", {
  enumerable: true,
  get: function get() {
    return _index2.IEffect;
  }
});
Object.defineProperty(exports, "IRenderable", {
  enumerable: true,
  get: function get() {
    return _index2.IRenderable;
  }
});
Object.defineProperty(exports, "RendererUtils", {
  enumerable: true,
  get: function get() {
    return _index2.RendererUtils;
  }
});
Object.defineProperty(exports, "MeshVisModel", {
  enumerable: true,
  get: function get() {
    return _index3.MeshVisModel;
  }
});
Object.defineProperty(exports, "MeshVisModelUtil", {
  enumerable: true,
  get: function get() {
    return _index3.MeshVisModelUtil;
  }
});
Object.defineProperty(exports, "releaseResources", {
  enumerable: true,
  get: function get() {
    return _index3.releaseResources;
  }
});
Object.defineProperty(exports, "VISMLoader", {
  enumerable: true,
  get: function get() {
    return _index3.VISMLoader;
  }
});
Object.defineProperty(exports, "OSGLoader", {
  enumerable: true,
  get: function get() {
    return _index3.OSGLoader;
  }
});
Object.defineProperty(exports, "GLTFLoader", {
  enumerable: true,
  get: function get() {
    return _index3.GLTFLoader;
  }
});
Object.defineProperty(exports, "DDSLoader", {
  enumerable: true,
  get: function get() {
    return _index3.DDSLoader;
  }
});
Object.defineProperty(exports, "TGALoader", {
  enumerable: true,
  get: function get() {
    return _index3.TGALoader;
  }
});
Object.defineProperty(exports, "BMPLoader", {
  enumerable: true,
  get: function get() {
    return _index3.BMPLoader;
  }
});
Object.defineProperty(exports, "DRACOLoader", {
  enumerable: true,
  get: function get() {
    return _index3.DRACOLoader;
  }
});
Object.defineProperty(exports, "RGBELoader", {
  enumerable: true,
  get: function get() {
    return _index3.RGBELoader;
  }
});
Object.defineProperty(exports, "BmpDecoder", {
  enumerable: true,
  get: function get() {
    return _index3.BmpDecoder;
  }
});
Object.defineProperty(exports, "Osg", {
  enumerable: true,
  get: function get() {
    return _index3.Osg;
  }
});
Object.defineProperty(exports, "parseOsg", {
  enumerable: true,
  get: function get() {
    return _index3.parseOsg;
  }
});
Object.defineProperty(exports, "readOsg", {
  enumerable: true,
  get: function get() {
    return _index3.readOsg;
  }
});
Object.defineProperty(exports, "GLTFExporter", {
  enumerable: true,
  get: function get() {
    return _index3.GLTFExporter;
  }
});
Object.defineProperty(exports, "DRACOExporter", {
  enumerable: true,
  get: function get() {
    return _index3.DRACOExporter;
  }
});
Object.defineProperty(exports, "VISMExporter", {
  enumerable: true,
  get: function get() {
    return _index3.VISMExporter;
  }
});
Object.defineProperty(exports, "PagedLOD", {
  enumerable: true,
  get: function get() {
    return _index3.PagedLOD;
  }
});
Object.defineProperty(exports, "QuadtreeLOD", {
  enumerable: true,
  get: function get() {
    return _index3.QuadtreeLOD;
  }
});
Object.defineProperty(exports, "QuadtreeLODUtil", {
  enumerable: true,
  get: function get() {
    return _index3.QuadtreeLODUtil;
  }
});
Object.defineProperty(exports, "LODUtils", {
  enumerable: true,
  get: function get() {
    return _index3.LODUtils;
  }
});
Object.defineProperty(exports, "QuadtreeNode", {
  enumerable: true,
  get: function get() {
    return _index3.QuadtreeNode;
  }
});
Object.defineProperty(exports, "QuatreeContentSet", {
  enumerable: true,
  get: function get() {
    return _index3.QuatreeContentSet;
  }
});
Object.defineProperty(exports, "BuildingVector3DLoader", {
  enumerable: true,
  get: function get() {
    return _index3.BuildingVector3DLoader;
  }
});
Object.defineProperty(exports, "CameraHelper", {
  enumerable: true,
  get: function get() {
    return _index3.CameraHelper;
  }
});
Object.defineProperty(exports, "computeArea", {
  enumerable: true,
  get: function get() {
    return _index4.computeArea;
  }
});
Object.defineProperty(exports, "defineProperty", {
  enumerable: true,
  get: function get() {
    return _index4.defineProperty;
  }
});
Object.defineProperty(exports, "determinant", {
  enumerable: true,
  get: function get() {
    return _index4.determinant;
  }
});
Object.defineProperty(exports, "esExtends", {
  enumerable: true,
  get: function get() {
    return _index4.esExtends;
  }
});
Object.defineProperty(exports, "GenericWorker", {
  enumerable: true,
  get: function get() {
    return _index4.GenericWorker;
  }
});
Object.defineProperty(exports, "geojsonHelper", {
  enumerable: true,
  get: function get() {
    return _index4.geojsonHelper;
  }
});
Object.defineProperty(exports, "ImageUtils", {
  enumerable: true,
  get: function get() {
    return _index4.ImageUtils;
  }
});
Object.defineProperty(exports, "isTypedArray", {
  enumerable: true,
  get: function get() {
    return _index4.isTypedArray;
  }
});
Object.defineProperty(exports, "lineBufferDir3", {
  enumerable: true,
  get: function get() {
    return _index4.lineBufferDir3;
  }
});
Object.defineProperty(exports, "MathUtils", {
  enumerable: true,
  get: function get() {
    return _index4.MathUtils;
  }
});
Object.defineProperty(exports, "matrix4LookAt", {
  enumerable: true,
  get: function get() {
    return _index4.matrix4LookAt;
  }
});
Object.defineProperty(exports, "mergeBuffers", {
  enumerable: true,
  get: function get() {
    return _index4.mergeBuffers;
  }
});
Object.defineProperty(exports, "parseDefines", {
  enumerable: true,
  get: function get() {
    return _index4.parseDefines;
  }
});
Object.defineProperty(exports, "decodeGeojson", {
  enumerable: true,
  get: function get() {
    return _index4.decodeGeojson;
  }
});
Object.defineProperty(exports, "decodeGeojsonAsync", {
  enumerable: true,
  get: function get() {
    return _index4.decodeGeojsonAsync;
  }
});
Object.defineProperty(exports, "decodeGeojsonCoords", {
  enumerable: true,
  get: function get() {
    return _index4.decodeGeojsonCoords;
  }
});
Object.defineProperty(exports, "decodeGeojsonCoordsAsync", {
  enumerable: true,
  get: function get() {
    return _index4.decodeGeojsonCoordsAsync;
  }
});
Object.defineProperty(exports, "decodeObject", {
  enumerable: true,
  get: function get() {
    return _index4.decodeObject;
  }
});
Object.defineProperty(exports, "encodeGeojson", {
  enumerable: true,
  get: function get() {
    return _index4.encodeGeojson;
  }
});
Object.defineProperty(exports, "encodeGeojsonCoords", {
  enumerable: true,
  get: function get() {
    return _index4.encodeGeojsonCoords;
  }
});
Object.defineProperty(exports, "encodeObject", {
  enumerable: true,
  get: function get() {
    return _index4.encodeObject;
  }
});
Object.defineProperty(exports, "encodeObjectValues", {
  enumerable: true,
  get: function get() {
    return _index4.encodeObjectValues;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _index4.Path;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function get() {
    return _index4.save;
  }
});
Object.defineProperty(exports, "saveArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _index4.saveArrayBuffer;
  }
});
Object.defineProperty(exports, "saveString", {
  enumerable: true,
  get: function get() {
    return _index4.saveString;
  }
});
Object.defineProperty(exports, "stringToArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _index4.stringToArrayBuffer;
  }
});
Object.defineProperty(exports, "StringUtil", {
  enumerable: true,
  get: function get() {
    return _index4.StringUtil;
  }
});
Object.defineProperty(exports, "triangulate", {
  enumerable: true,
  get: function get() {
    return _index4.triangulate;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function get() {
    return _index4.traverse;
  }
});
Object.defineProperty(exports, "getPaddedBuffer", {
  enumerable: true,
  get: function get() {
    return _index4.getPaddedBuffer;
  }
});
Object.defineProperty(exports, "getPaddedBufferSize", {
  enumerable: true,
  get: function get() {
    return _index4.getPaddedBufferSize;
  }
});

var _Earth = _interopRequireDefault(require("._150"));

var _GeoPolygonGeometry = _interopRequireDefault(require("C_151"));

var _GeoPolylineGeometry = _interopRequireDefault(require("o_152"));

var _ExtrudedPolygonGeometry = _interopRequireDefault(require("m_153"));

var _SolidWireframeGeometry = _interopRequireDefault(require("M_154"));

var _VectorPolygonGeometry = _interopRequireDefault(require("e_155"));

var _SolidWireframeMaterial = _interopRequireDefault(require("s_156"));

var _TiandituLayer = _interopRequireWildcard(require("h_157"));

var _C3DTilesLayer = _interopRequireDefault(require("-_158"));

var _OsgbLayer = _interopRequireDefault(require("3_159"));

var _GeoMesh = _interopRequireDefault(require("D_160"));

var _GeoPolygonMesh = _interopRequireDefault(require("._161"));

var _GeoPolylineMesh = _interopRequireDefault(require("C_162"));

var _GeoWaterMesh = _interopRequireDefault(require("o_163"));

var _Vector2dLayer = _interopRequireWildcard(require("m_164"));

var _Vector3dLayer = _interopRequireDefault(require("M_165"));

var _ImageTileLayer = _interopRequireDefault(require("h_124"));

var _ILayer = _interopRequireDefault(require("s_167"));

var _LocalSkyBox = require("h_168");

var _index = _interopRequireWildcard(require("-_169"));

var _index2 = require("3_170");

var _index3 = require("D_171");

var _index4 = require("._172");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"3_170":39,"D_171":187,"._172":209,"._150":40,"h_168":41,"m_153":42,"C_151":43,"o_152":44,"M_154":45,"e_155":46,"-_169":53,"s_167":55,"h_124":56,"h_157":57,"-_158":59,"D_160":60,"._161":61,"C_162":62,"o_163":63,"3_159":64,"m_164":66,"M_165":69,"s_156":70,"M_0":241,"M_110":245}],48:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getLine;

var _defineProperty2 = _interopRequireDefault(require("e_45"));

var _pickPosition = _interopRequireDefault(require("m_175"));

/**
 * 通过绘制获取线段
 * @param {Cesium.Viewer} viewer 
 * @param {(line:Cesium.Cartographic[],entities:Cesium.Entity[])=>void}callback
 * @param {object}[options]
 * @param {Cesium.Color}[options.lineColor=Color.DARKORANGE]
 * @param {Cesium.Color}[options.pointColor=Color.DARKORANGE]
 * @param {number}[options.pointSize=8]
 * @param {(line:Cesium.Cartographic[])=>void}[options.onMove]
 * @param {(point:Cesium.Cartographic)=>void}[options.onStart]
 * @returns {()=>void} cancelCallback
 */
function getLine(viewer, callback, options) {
  var _state;

  if (!callback) throw new Error('缺少callback参数');
  options = options || {};
  var _Cesium = Cesium,
      ScreenSpaceEventType = _Cesium.ScreenSpaceEventType,
      CallbackProperty = _Cesium.CallbackProperty,
      Color = _Cesium.Color,
      Cartesian3 = _Cesium.Cartesian3,
      HeightReference = _Cesium.HeightReference,
      Cartographic = _Cesium.Cartographic;
  var LEFT_CLICK = ScreenSpaceEventType.LEFT_CLICK,
      MOUSE_MOVE = ScreenSpaceEventType.MOUSE_MOVE;
  var handler = viewer.screenSpaceEventHandler;
  var lineColor = options.lineColor || Color.DARKORANGE;
  var pointColor = options.pointColor || Color.DARKORANGE;
  var pointSize = options.pointSize || 8;
  var onMove = options.onMove;
  var onStart = options.onStart; //保存之前的鼠标事件监听器

  var state = (_state = {}, (0, _defineProperty2["default"])(_state, LEFT_CLICK, handler.getInputAction(LEFT_CLICK)), (0, _defineProperty2["default"])(_state, MOUSE_MOVE, handler.getInputAction(MOUSE_MOVE)), _state);
  var points = []; //矩形及其边框entity

  var lineEntity = viewer.entities.add({
    show: false,
    polyline: {
      positions: new CallbackProperty(function () {
        return points;
      }, false),
      show: new CallbackProperty(function () {
        return lineEntity.show && points.length > 1;
      }, false),
      clampToGround: true,
      width: 1.5,
      material: lineColor
    }
  });

  function addPointEntity(idx) {
    return viewer.entities.add({
      position: new CallbackProperty(function () {
        return points[idx];
      }, false),
      point: {
        show: new CallbackProperty(function () {
          if (idx == 0) return points.length > 0;else return points.length > 1;
        }, false),
        pixelSize: pointSize,
        color: pointColor,
        heightReference: HeightReference.CLAMP_TO_GROUND
      }
    });
  } //线段端点


  var pointEntities = [addPointEntity(0), addPointEntity(1)];
  handler.setInputAction(function (e) {
    if (points.length == 2) {
      return end();
    }

    var p = (0, _pickPosition["default"])(viewer.scene, e.position);

    if (!p || Cartesian3.equals(p, points[1])) {
      return;
    }

    if (points.length == 0) {
      //第一个点 
      points[0] = p;

      if (onStart) {
        onStart(Cartographic.fromCartesian(p));
      }
    } else {
      //斜对角点
      points[1] = p;
    }
  }, LEFT_CLICK);
  handler.setInputAction(function (e) {
    if (points.length == 0) return;
    var p = (0, _pickPosition["default"])(viewer.scene, e.endPosition);

    if (!p || Cartesian3.equals(p, points[1])) {
      return;
    }

    points[1] = p;
    lineEntity.show = true;

    if (onMove) {
      onMove(points.map(function (p) {
        return Cartographic.fromCartesian(p);
      }));
    }
  }, MOUSE_MOVE); //恢复之前的鼠标事件监听器

  function end(cancel) {
    if (state[LEFT_CLICK]) handler.setInputAction(state[LEFT_CLICK], LEFT_CLICK);else handler.removeInputAction(LEFT_CLICK);
    if (state[MOUSE_MOVE]) handler.setInputAction(state[MOUSE_MOVE], MOUSE_MOVE);else handler.removeInputAction(MOUSE_MOVE);
    viewer.entities.remove(lineEntity);

    for (var i = 0; i < pointEntities.length; i++) {
      viewer.entities.remove(pointEntities[i]);
    }

    if (!cancel) {
      var entities = [{
        polyline: {
          positions: points,
          clampToGround: true,
          width: 1.5,
          material: lineColor
        }
      }];
      points = points.map(function (p) {
        entities.push({
          position: p,
          point: {
            pixelSize: pointSize,
            color: pointColor,
            heightReference: HeightReference.CLAMP_TO_GROUND
          }
        });
        return Cartographic.fromCartesian(p);
      });
      callback(points, entities);
    }

    pointEntities = lineEntity = null;
    state = points = null;
  }

  function cancel() {
    end(true);
  }

  return cancel;
}

},{"m_175":54,"e_45":237,"M_0":241}],49:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getPoint;

var _defineProperty2 = _interopRequireDefault(require("e_45"));

var _pickPosition = _interopRequireDefault(require("m_175"));

/**
 * 通过绘制获取点
 * @param {Cesium.Viewer} viewer 
 * @param {(point:Cesium.Cartographic)=>void}callback
 * @param {object}[options]
 * @param {object}[options.pointSize=8]
 * @param {Cesium.Color}[options.pointColor=Cesium.Color.DARKORANGE]
 * @param {(point:Cesium.Cartographic)=>void}[options.onMove]
 * @returns {()=>void} cancelCallback
 */
function getPoint(viewer, callback, options) {
  var _state;

  if (!callback) throw new Error('缺少callback参数');
  options = options || {};
  var _Cesium = Cesium,
      ScreenSpaceEventType = _Cesium.ScreenSpaceEventType,
      CallbackProperty = _Cesium.CallbackProperty,
      Color = _Cesium.Color,
      Cartesian3 = _Cesium.Cartesian3,
      HeightReference = _Cesium.HeightReference,
      Cartographic = _Cesium.Cartographic;
  var LEFT_CLICK = ScreenSpaceEventType.LEFT_CLICK,
      MOUSE_MOVE = ScreenSpaceEventType.MOUSE_MOVE;
  var handler = viewer.screenSpaceEventHandler;
  var pointSize = options.pointSize || 8;
  var pointColor = options.pointColor || Color.DARKORANGE;
  var onMove = options.onMove; //保存之前的鼠标事件监听器

  var state = (_state = {}, (0, _defineProperty2["default"])(_state, LEFT_CLICK, handler.getInputAction(LEFT_CLICK)), (0, _defineProperty2["default"])(_state, MOUSE_MOVE, handler.getInputAction(MOUSE_MOVE)), _state);
  var position = new Cartesian3();
  var positionCarg = new Cartographic();
  var ellipsoid = viewer.scene.globe.ellipsoid;
  var entity = viewer.entities.add({
    position: new CallbackProperty(function () {
      return position;
    }, false),
    show: false,
    point: {
      pixelSize: pointSize,
      color: Color.fromAlpha(pointColor, 1),
      outlineColor: pointColor,
      outlineWidth: 1.5,
      outline: true,
      heightReference: HeightReference.CLAMP_TO_GROUND
    }
  });
  handler.setInputAction(function (e) {
    var p = (0, _pickPosition["default"])(viewer.scene, e.position);

    if (!p) {
      return;
    }

    position = p;
    end();
  }, LEFT_CLICK);
  handler.setInputAction(function (e) {
    var p = (0, _pickPosition["default"])(viewer.scene, e.endPosition);

    if (!p) {
      return;
    }

    position = p;
    entity.show = true;
    onMove && onMove(Cartographic.fromCartesian(position, ellipsoid, positionCarg));
  }, MOUSE_MOVE); //恢复之前的鼠标事件监听器

  function end(cancel) {
    if (state[LEFT_CLICK]) handler.setInputAction(state[LEFT_CLICK], LEFT_CLICK);else handler.removeInputAction(LEFT_CLICK);
    if (state[MOUSE_MOVE]) handler.setInputAction(state[MOUSE_MOVE], MOUSE_MOVE);else handler.removeInputAction(MOUSE_MOVE);
    viewer.entities.remove(entity);

    if (!cancel) {
      callback(Cartographic.fromCartesian(position, ellipsoid, positionCarg), {
        position: position,
        point: {
          pixelSize: pointSize,
          color: Color.fromAlpha(pointColor, 1),
          outlineColor: pointColor,
          outlineWidth: 1.5,
          outline: true,
          heightReference: HeightReference.CLAMP_TO_GROUND
        }
      });
    }

    state = entity = position = positionCarg = null;
  }

  function cancel() {
    end(true);
  }

  return cancel;
}

},{"m_175":54,"e_45":237,"M_0":241}],50:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getPolyline;

var _defineProperty2 = _interopRequireDefault(require("e_45"));

var _pickPosition = _interopRequireDefault(require("m_175"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * 通过绘制获取多段线
 * @param {Cesium.Viewer} viewer 
 * @param {(line:Cesium.Cartographic[],entities:Cesium.Entity[])=>void}callback
 * @param {object}[options]
 * @param {Cesium.Color}[options.lineColor=Color.DARKORANGE]
 * @param {Cesium.Color}[options.pointColor=Color.DARKORANGE]
 * @param {number}[options.pointSize=8]
 * @param {(line:Cesium.Cartographic[])=>void}[options.onMove]
 * @returns {()=>void} cancelCallback
 */
function getPolyline(viewer, callback, options) {
  var _state;

  if (!callback) throw new Error('缺少callback参数');
  options = options || {};
  var _Cesium = Cesium,
      ScreenSpaceEventType = _Cesium.ScreenSpaceEventType,
      CallbackProperty = _Cesium.CallbackProperty,
      Color = _Cesium.Color,
      Cartesian3 = _Cesium.Cartesian3,
      HeightReference = _Cesium.HeightReference,
      Cartographic = _Cesium.Cartographic;
  var LEFT_CLICK = ScreenSpaceEventType.LEFT_CLICK,
      MOUSE_MOVE = ScreenSpaceEventType.MOUSE_MOVE,
      LEFT_DOUBLE_CLICK = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;
  var handler = viewer.screenSpaceEventHandler;
  var lineColor = options.lineColor || Color.DARKORANGE;
  var pointColor = options.pointColor || Color.DARKORANGE;
  var pointSize = options.pointSize || 8;
  var onMove = options.onMove; //保存之前的鼠标事件监听器

  var state = (_state = {}, (0, _defineProperty2["default"])(_state, LEFT_CLICK, handler.getInputAction(LEFT_CLICK)), (0, _defineProperty2["default"])(_state, MOUSE_MOVE, handler.getInputAction(MOUSE_MOVE)), (0, _defineProperty2["default"])(_state, LEFT_DOUBLE_CLICK, handler.getInputAction(LEFT_DOUBLE_CLICK)), _state);
  var points = [],
      polyline = []; //矩形及其边框entity

  var lineEntity = viewer.entities.add({
    show: false,
    polyline: {
      positions: new CallbackProperty(function () {
        return points;
      }, false),
      show: new CallbackProperty(function () {
        return lineEntity.show && points.length > 1;
      }, false),
      clampToGround: true,
      width: 1.5,
      material: lineColor
    }
  }); //线段端点

  var pointEntities = [];

  function addPoint(point, isEnding) {
    var pointEntity = viewer.entities.add({
      position: point,
      point: {
        pixelSize: pointSize,
        color: pointColor,
        heightReference: HeightReference.CLAMP_TO_GROUND
      }
    });
    pointEntities.push(pointEntity);
    points.push(point);

    if (isEnding) {
      polyline.push(point);
    }
  }

  handler.setInputAction(function (e) {
    var p = (0, _pickPosition["default"])(viewer.scene, e.position);

    if (!p || points.length == 1 && Cartesian3.equals(p, points[points.length - 1])) {
      return;
    }

    addPoint(p, true);
  }, LEFT_CLICK);
  handler.setInputAction(function (e) {
    if (points.length == 0) return;
    var p = (0, _pickPosition["default"])(viewer.scene, e.endPosition);

    if (!p || points.length == 1 && Cartesian3.equals(p, points[points.length - 1])) {
      return;
    }

    if (polyline.length == points.length) {
      addPoint(p, false);
    } else {
      points[points.length - 1] = p;
    }

    if (onMove) {
      onMove(points.map(function (p) {
        return Cartographic.fromCartesian(p);
      }));
    }

    lineEntity.show = true;
  }, MOUSE_MOVE);
  handler.setInputAction(function () {
    return end();
  }, LEFT_DOUBLE_CLICK); //恢复之前的鼠标事件监听器

  function end(cancel) {
    if (state[LEFT_CLICK]) {
      handler.setInputAction(state[LEFT_CLICK], LEFT_CLICK);
    } else {
      handler.removeInputAction(LEFT_CLICK);
    }

    if (state[MOUSE_MOVE]) {
      handler.setInputAction(state[MOUSE_MOVE], MOUSE_MOVE);
    } else {
      handler.removeInputAction(MOUSE_MOVE);
    }

    if (state[LEFT_DOUBLE_CLICK]) {
      handler.setInputAction(state[LEFT_DOUBLE_CLICK], LEFT_DOUBLE_CLICK);
    } else {
      handler.removeInputAction(LEFT_DOUBLE_CLICK);
    }

    viewer.entities.remove(lineEntity);

    for (var i = 0; i < pointEntities.length; i++) {
      viewer.entities.remove(pointEntities[i]);
    }

    if (!cancel) {
      //
      var entities = [{
        polyline: {
          positions: points,
          clampToGround: true,
          width: 1.5,
          material: lineColor
        }
      }];

      var _iterator = _createForOfIteratorHelper(points),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var point = _step.value;
          entities.push({
            position: point,
            point: {
              pixelSize: pointSize,
              color: pointColor,
              heightReference: HeightReference.CLAMP_TO_GROUND
            }
          });
        } //

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      callback(polyline.map(function (p) {
        return Cartographic.fromCartesian(p);
      }), entities);
    }

    pointEntities = lineEntity = null;
    state = points = null;
  }

  function cancel() {
    end(true);
  }

  return cancel;
}

},{"m_175":54,"e_45":237,"M_0":241}],51:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getRactangle;

var _defineProperty2 = _interopRequireDefault(require("e_45"));

var _getRactangleCornersWC = _interopRequireDefault(require("C_184"));

var _pickPosition = _interopRequireDefault(require("m_175"));

/**
 * 通过绘制获取矩形范围
 * @param {Cesium.Viewer} viewer 
 * @param {(rectangle:Cesium.Rectangle)=>void}callback
 * @param {object}[options]
 * @param {Cesium.Color}[options.areaColor=Color.DARKORANGE]
 * @param {Cesium.Color}[options.pointColor=Color.DARKORANGE]
 * @param {number}[options.pointSize=8]
 * @param {(rectangle:Cesium.Rectangle)=>void}[options.onMove]
 * @returns {()=>void} cancelCallback
 */
function getRactangle(viewer, callback, options) {
  var _state;

  if (!callback) throw new Error('缺少callback参数');
  options = options || {};
  var _Cesium = Cesium,
      ScreenSpaceEventType = _Cesium.ScreenSpaceEventType,
      CallbackProperty = _Cesium.CallbackProperty,
      Color = _Cesium.Color,
      Rectangle = _Cesium.Rectangle,
      Cartographic = _Cesium.Cartographic,
      HeightReference = _Cesium.HeightReference;
  var LEFT_CLICK = ScreenSpaceEventType.LEFT_CLICK,
      MOUSE_MOVE = ScreenSpaceEventType.MOUSE_MOVE,
      LEFT_DOUBLE_CLICK = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;
  var handler = viewer.screenSpaceEventHandler;
  var areaColor = options.areaColor || Color.DARKORANGE;
  var pointColor = options.pointColor || Color.DARKORANGE;
  var pointSize = options.pointSize || 8;
  var onMove = options.onMove; //保存之前的鼠标事件监听器

  var state = (_state = {}, (0, _defineProperty2["default"])(_state, LEFT_CLICK, handler.getInputAction(LEFT_CLICK)), (0, _defineProperty2["default"])(_state, MOUSE_MOVE, handler.getInputAction(MOUSE_MOVE)), _state);
  var rectangle = new Rectangle(),
      points = [],
      polyline = []; //矩形及其边框entity

  var rectangleEntity = viewer.entities.add({
    show: false,
    rectangle: {
      coordinates: new CallbackProperty(function () {
        return rectangle;
      }, false),
      outline: true,
      fill: true,
      material: Color.fromAlpha(areaColor, 0.15),
      show: new CallbackProperty(function () {
        return rectangleEntity.show && polyline.length > 2;
      }, false)
    },
    polyline: {
      positions: new CallbackProperty(function () {
        return polyline;
      }, false),
      show: new CallbackProperty(function () {
        return rectangleEntity.show && polyline.length > 2;
      }, false),
      clampToGround: true,
      width: 1.5,
      material: areaColor
    }
  });

  function addVertEntity(idx) {
    return viewer.entities.add({
      position: new CallbackProperty(function () {
        return polyline[idx];
      }, false),
      point: {
        show: new CallbackProperty(function () {
          if (idx == 0) return polyline.length > 0 || points.length > 0;else return polyline.length > 1;
        }, false),
        pixelSize: pointSize,
        color: pointColor,
        outlineColor: pointColor,
        outlineWidth: 1.5,
        outline: true,
        heightReference: HeightReference.CLAMP_TO_GROUND
      }
    });
  } //矩形顶点


  var vertEntities = [addVertEntity(0), addVertEntity(1), addVertEntity(2), addVertEntity(3)];

  function udpateRectangle() {
    polyline = (0, _getRactangleCornersWC["default"])(rectangle);
    polyline.push(polyline[0]);
    Rectangle.fromCartographicArray(points, rectangle);
  }

  handler.setInputAction(function (e) {
    if (points.length == 2) {
      points.length = 0;
      return end();
    }

    var p = (0, _pickPosition["default"])(viewer.scene, e.position);

    if (!p || !(p = Cartographic.fromCartesian(p)) || Cartographic.equals(p, points[1])) {
      return;
    }

    if (points.length == 0) {
      //第一个点
      polyline.length = 0;
      points[0] = p;
      polyline[0] = Cesium.Cartesian3.fromRadians(p.longitude, p.latitude, p.height);
    } else {
      //斜对角点
      points[1] = p;
      udpateRectangle();
    }
  }, LEFT_CLICK);
  handler.setInputAction(function (e) {
    if (points.length == 0) return;
    var p = (0, _pickPosition["default"])(viewer.scene, e.endPosition);

    if (!p || !(p = Cartographic.fromCartesian(p)) || Cartographic.equals(p, points[1])) {
      return;
    }

    points[1] = p;
    rectangleEntity.show = true;
    udpateRectangle();

    if (onMove) {
      onMove(rectangle);
    }
  }, MOUSE_MOVE); //恢复之前的鼠标事件监听器

  function end(cancel) {
    if (state[LEFT_CLICK]) {
      handler.setInputAction(state[LEFT_CLICK], LEFT_CLICK);
    } else {
      handler.removeInputAction(LEFT_CLICK);
    }

    if (state[MOUSE_MOVE]) {
      handler.setInputAction(state[MOUSE_MOVE], MOUSE_MOVE);
    } else {
      handler.removeInputAction(MOUSE_MOVE);
    }

    viewer.entities.remove(rectangleEntity);

    for (var i = 0; i < vertEntities.length; i++) {
      viewer.entities.remove(vertEntities[i]);
    }

    if (!cancel) {
      callback(rectangle);
    }

    vertEntities = rectangle = rectangleEntity = null;
    state = points = polyline = null;
  }

  function cancel() {
    end(true);
  }

  return cancel;
}

},{"C_184":52,"m_175":54,"e_45":237,"M_0":241}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getRactangleCornersWC;

/**
 * 获取矩形四个角的顶点世界坐标
 * @param {Cesium.Rectangle} rectangle 
 */
function getRactangleCornersWC(rectangle) {
  var points = [Cesium.Rectangle.northwest(rectangle), Cesium.Rectangle.southwest(rectangle), Cesium.Rectangle.southeast(rectangle), Cesium.Rectangle.northeast(rectangle)].map(function (p) {
    return Cesium.Cartesian3.fromRadians(p.longitude, p.latitude, p.height);
  });
  return points;
}

},{}],53:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getLine", {
  enumerable: true,
  get: function get() {
    return _getLine["default"];
  }
});
Object.defineProperty(exports, "getPoint", {
  enumerable: true,
  get: function get() {
    return _getPoint["default"];
  }
});
Object.defineProperty(exports, "getPolyline", {
  enumerable: true,
  get: function get() {
    return _getPolyline["default"];
  }
});
Object.defineProperty(exports, "getRactangle", {
  enumerable: true,
  get: function get() {
    return _getRactangle["default"];
  }
});
Object.defineProperty(exports, "pickPosition", {
  enumerable: true,
  get: function get() {
    return _pickPosition["default"];
  }
});
exports["default"] = void 0;

var _getLine = _interopRequireDefault(require("M_187"));

var _getPoint = _interopRequireDefault(require("e_188"));

var _getPolyline = _interopRequireDefault(require("s_189"));

var _getRactangle = _interopRequireDefault(require("h_190"));

var _pickPosition = _interopRequireDefault(require("m_175"));

var _default = {
  getPoint: _getPoint["default"],
  getLine: _getLine["default"],
  getPolyline: _getPolyline["default"],
  getRactangle: _getRactangle["default"],
  pickPosition: _pickPosition["default"]
};
exports["default"] = _default;

},{"M_187":48,"e_188":49,"s_189":50,"h_190":51,"m_175":54,"M_0":241}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = pickPosition;

var _ray;
/**
 * 点击拾取坐标，考虑了有无地形的差别
 * @param {Cesium.Scene} scene 
 * @param {Cesium.Cartesian2} mousePosition 
 * @param {Cesium.Cartesian3} [result]
 * @returns {Cesium.Cartesian3} result
 */


function pickPosition(scene, mousePosition, result) {
  var _Cesium = Cesium,
      Ray = _Cesium.Ray,
      Cartesian3 = _Cesium.Cartesian3,
      EllipsoidTerrainProvider = _Cesium.EllipsoidTerrainProvider;
  if (!_ray) _ray = new Ray();

  if (!result) {
    result = new Cartesian3();
  }

  if (!scene.pickPositionSupported || !scene.globe.depthTestAgainstTerrain || scene.terrainProvider instanceof EllipsoidTerrainProvider) {
    if (scene.camera.getPickRay(mousePosition, _ray)) {
      return scene.globe.pick(_ray, scene, result);
    }
  }

  return scene.pickPosition(mousePosition, result);
}

},{}],55:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _Earth = _interopRequireDefault(require("C_195"));

var ILayer = /*#__PURE__*/function () {
  /**
   * 
   * @param {ILayer} params 
   */
  function ILayer(params) {
    (0, _classCallCheck2["default"])(this, ILayer);
    params = params || {};
    var _Cesium = Cesium,
        defaultValue = _Cesium.defaultValue;
    this.name = defaultValue(params.name, '未命名图层' + ++ILayer.NumUnName);
    this.parent = defaultValue(params.parent, null);
    this.zIndex = defaultValue(params.zIndex, 1);
    this.provider = defaultValue(params.provider, null);
    this._show = defaultValue(params.show, true);
  }

  (0, _createClass2["default"])(ILayer, [{
    key: "show",
    get: function get() {
      return this._show;
    }
    /**
     * 
     * @param {Earth} earth 
     */
    ,
    set: function set(val) {
      this._show = val;
    }
  }, {
    key: "load",
    value: function load(earth) {}
    /**
     * 
     * @param {Earth} earth 
     */

  }, {
    key: "unload",
    value: function unload(earth) {}
  }]);
  return ILayer;
}();

exports["default"] = ILayer;
ILayer.NumUnName = 0;

},{"C_195":40,"e_1":235,"s_2":236,"M_0":241}],56:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _ILayer2 = _interopRequireDefault(require("-_202"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ImageTileLayer = /*#__PURE__*/function (_ILayer) {
  (0, _inherits2["default"])(ImageTileLayer, _ILayer);

  var _super = _createSuper(ImageTileLayer);

  /**
   * 
   * @param {ImageTileLayer} params 
   */
  function ImageTileLayer(params) {
    var _this;

    (0, _classCallCheck2["default"])(this, ImageTileLayer);
    _this = _super.call(this, params);
    _this._imageryLayer = null;
    return _this;
  }

  (0, _createClass2["default"])(ImageTileLayer, [{
    key: "show",
    get: function get() {
      return this._show;
    }
    /**
     * 
     * @param {Earth} earth 
     */
    ,
    set: function set(val) {
      this._show = val;
      if (this._imageryLayer) this._imageryLayer.show = val;
    }
  }, {
    key: "load",
    value: function load(earth) {
      if (!this.provider) {
        throw new Error('ImageTileLayer#provider is required.');
      }

      var imageryLayers = earth.imageryLayers;
      this.provider.zIndex = this.zIndex;
      this._imageryLayer = imageryLayers.addImageryProvider(this.provider);
    }
    /**
     * 
     * @param {Earth} earth 
     */

  }, {
    key: "unload",
    value: function unload(earth) {
      if (!this._imageryLayer) return;
      var imageryLayers = earth.imageryLayers;
      imageryLayers.remove(this._imageryLayer);
    }
  }]);
  return ImageTileLayer;
}(_ILayer2["default"]);

exports["default"] = ImageTileLayer;

},{"-_202":55,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],57:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTdtImageryProvider = createTdtImageryProvider;
exports["default"] = exports.TiandituTerLayer = exports.TiandituVecLayer = exports.TiandituImgLayer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _ImageTileLayer2 = _interopRequireDefault(require("M_209"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function createTdtImageryProvider(params) {
  var tileMatrixSet = 'w';
  var host = params.host || 'http://t{s}.tianditu.com/';
  var subdomains = ['0', '1', '2', '3', '4', '5', '6', '7'];

  if (host[host.length - 1] == '/') {
    host = host.substr(0, host.length - 1);
  }

  var url = host + "/" + params.layer + '_' + tileMatrixSet + "/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=" + params.layer + "&tileMatrixSet=" + tileMatrixSet + "&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}&style=default&format=tiles";
  url += '&tk=' + params.appKey;
  var provider = new Cesium.WebMapTileServiceImageryProvider({
    url: url,
    layer: params.layer,
    style: 'default',
    subdomains: subdomains,
    tileMatrixSetID: tileMatrixSet,
    maximumLevel: params.maximumLevel,
    minimumLevel: params.minimumLevel
  });
  return provider;
}

var TiandituLayer = /*#__PURE__*/function (_ImageTileLayer) {
  (0, _inherits2["default"])(TiandituLayer, _ImageTileLayer);

  var _super = _createSuper(TiandituLayer);

  function TiandituLayer(params) {
    var _this;

    (0, _classCallCheck2["default"])(this, TiandituLayer);
    params = params || {};
    params.name = params.name || '天地图图层';
    _this = _super.call(this, params);
    _this._minimumLevel = params.minimumLevel;
    _this._maximumLevel = params.maximumLevel;
    _this._host = params.host;
    _this._imageLayerName = params.imageLayer;
    _this._labelLayerName = params.labelLayer;
    _this._imageLayer = null;
    _this._labelLayer = null;
    return _this;
  }

  (0, _createClass2["default"])(TiandituLayer, [{
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
      if (this._imageLayer) this._imageLayer.show = this._show;
      if (this._labelLayer) this._labelLayer.show = this._show;
    }
  }, {
    key: "load",
    value: function load(earth) {
      var _imageLayer = this._imageLayer,
          _labelLayer = this._labelLayer;

      if (!_imageLayer && this._imageLayerName) {
        _imageLayer = new _ImageTileLayer2["default"]({
          name: this.name,
          zIndex: this.zIndex,
          provider: createTdtImageryProvider({
            host: this.host,
            appKey: TiandituLayer.AppKey,
            layer: this._imageLayerName,
            minimumLevel: this._minimumLevel,
            maximumLevel: this._maximumLevel
          })
        });
        this._imageLayer = _imageLayer;
      }

      if (!_labelLayer && this._labelLayerName) {
        _labelLayer = new _ImageTileLayer2["default"]({
          name: this.name + "-注记",
          zIndex: this.zIndex + 1,
          provider: createTdtImageryProvider({
            host: this.host,
            appKey: TiandituLayer.AppKey,
            layer: this._labelLayerName,
            minimumLevel: this._minimumLevel,
            maximumLevel: this._maximumLevel
          })
        });
        this._labelLayer = _labelLayer;
      }

      if (_imageLayer) {
        _imageLayer.show = this._show;

        _imageLayer.load(earth);
      }

      if (_labelLayer) {
        _labelLayer.show = this._show;

        _labelLayer.load(earth);
      }
    }
  }, {
    key: "unload",
    value: function unload(earth) {
      this._imageLayer = this._imageLayer && this._imageLayer.unload(earth);
      this._labelLayer = this._labelLayer && this._labelLayer.unload(earth);
    }
  }]);
  return TiandituLayer;
}(_ImageTileLayer2["default"]);

TiandituLayer.AppKey = '3669131581c051178afabed885766ac2';

var TiandituImgLayer = /*#__PURE__*/function (_TiandituLayer) {
  (0, _inherits2["default"])(TiandituImgLayer, _TiandituLayer);

  var _super2 = _createSuper(TiandituImgLayer);

  function TiandituImgLayer(params) {
    (0, _classCallCheck2["default"])(this, TiandituImgLayer);
    params = params || {};
    params.name = params.name || '天地图影像';
    params.imageLayer = 'img';
    params.labelLayer = 'cia';
    return _super2.call(this, params);
  }

  return TiandituImgLayer;
}(TiandituLayer);

exports.TiandituImgLayer = TiandituImgLayer;

var TiandituVecLayer = /*#__PURE__*/function (_TiandituLayer2) {
  (0, _inherits2["default"])(TiandituVecLayer, _TiandituLayer2);

  var _super3 = _createSuper(TiandituVecLayer);

  function TiandituVecLayer(params) {
    (0, _classCallCheck2["default"])(this, TiandituVecLayer);
    params = params || {};
    params.name = params.name || '天地图矢量';
    params.imageLayer = 'vec';
    params.labelLayer = 'cva';
    return _super3.call(this, params);
  }

  return TiandituVecLayer;
}(TiandituLayer);

exports.TiandituVecLayer = TiandituVecLayer;

var TiandituTerLayer = /*#__PURE__*/function (_TiandituLayer3) {
  (0, _inherits2["default"])(TiandituTerLayer, _TiandituLayer3);

  var _super4 = _createSuper(TiandituTerLayer);

  function TiandituTerLayer(params) {
    (0, _classCallCheck2["default"])(this, TiandituTerLayer);
    params = params || {};
    params.name = params.name || '天地图地形晕渲';
    params.imageLayer = 'ter';
    params.labelLayer = 'cta';
    return _super4.call(this, params);
  }

  return TiandituTerLayer;
}(TiandituLayer);

exports.TiandituTerLayer = TiandituTerLayer;
var _default = TiandituLayer;
exports["default"] = _default;

},{"M_209":56,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = imageryLayersOrderByZIndex;

function imageryLayersOrderByZIndex(imageryLayers) {
  //调整带有index的图层顺序
  var layersHasIndex = [];

  for (var i = 0; i < imageryLayers.length; i++) {
    var l = imageryLayers.get(i);

    if (l.imageryProvider.zIndex || l.zIndex) {
      layersHasIndex.push(l);

      if (!l.zIndex) {
        l.zIndex = l.imageryProvider.zIndex;
      } else if (!l.imageryProvider.zIndex) {
        l.imageryProvider.zIndex = l.zIndex;
      }
    }
  }

  if (layersHasIndex && layersHasIndex.length) {
    layersHasIndex.sort(function (a, b) {
      if (a.zIndex > b.zIndex) {
        return 1;
      } else if (a.zIndex < b.zIndex) {
        return -1;
      } else {
        return 0;
      }
    });
  }

  layersHasIndex.forEach(function (l) {
    imageryLayers.raiseToTop(l);
  });
  if (typeof CesiumVectorTile == 'undefined') return;
  var defined = Cesium.defined;

  for (var i = 0; i < imageryLayers.length; i++) {
    var l = imageryLayers.get(i); //调整矢量图层顺序

    if (!defined(l.imageryProvider.zIndex) && !defined(l.zIndex) && l.imageryProvider instanceof CesiumVectorTile.VectorTileImageryProvider) {
      imageryLayers.raiseToTop(l);
    }
  }

  for (var i = 0; i < imageryLayers.length; i++) {
    var l = imageryLayers.get(i); //调整矢量图层顺序

    if (!defined(l.imageryProvider.zIndex) && !defined(l.zIndex) && l.imageryProvider instanceof CesiumVectorTile.VectorTileImageryProvider && (l.imageryProvider._lineOnly || l.imageryProvider._onlyPoint)) {
      imageryLayers.raiseToTop(l);
    }
  }
}

},{}],59:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Cesium3DTileExtension = _interopRequireDefault(require("._216"));

var _Earth = _interopRequireDefault(require("C_217"));

var _ILayer2 = _interopRequireDefault(require("-_202"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var C3DTilesLayer = /*#__PURE__*/function (_ILayer) {
  (0, _inherits2["default"])(C3DTilesLayer, _ILayer);

  var _super = _createSuper(C3DTilesLayer);

  function C3DTilesLayer(params) {
    var _this;

    (0, _classCallCheck2["default"])(this, C3DTilesLayer);
    _this = _super.call(this, params);
    _this.renderer = params.renderer || 'Cesium';
    _this.tileset = new Cesium.Cesium3DTileset(params);
    return _this;
  }
  /**
   * 
   * @param {Earth|MeshVisualizer} earth 
   */


  (0, _createClass2["default"])(C3DTilesLayer, [{
    key: "load",
    value: function load(earth) {
      if (this.renderer == 'Three') {
        _Cesium3DTileExtension["default"].init();

        var localScene = earth.isMeshVisualizer ? earth : earth.globalScene;
        localScene.add(this.tileset);
      } else if (!earth.isMeshVisualizer) {
        earth.primitives.add(this.tileset);
      } else {
        throw new Error('局部场景3d tiles不支持Cesium渲染器');
      }
    }
    /**
     * 
     * @param {Earth|MeshVisualizer} earth 
     */

  }, {
    key: "unload",
    value: function unload(earth) {
      if (this.renderer == 'Three') {
        _Cesium3DTileExtension["default"].init();

        var localScene = earth.isMeshVisualizer ? earth : earth.globalScene;
        localScene.remove(this.tileset, true);
      } else if (!earth.isMeshVisualizer) {
        earth.primitives.remove(this.tileset, true);
      }
    }
  }]);
  return C3DTilesLayer;
}(_ILayer2["default"]);

exports["default"] = C3DTilesLayer;

},{"._216":73,"C_217":40,"-_202":55,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],60:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _IRenderable2 = _interopRequireDefault(require("3_225"));

var _geojsonHelper = _interopRequireDefault(require("D_226"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var scratchTranslationRtc;

var CESIUM_RTC_MODELVIEW = function CESIUM_RTC_MODELVIEW(uniformState, model) {
  // CESIUM_RTC extension
  var _Cesium = Cesium,
      Matrix4 = _Cesium.Matrix4,
      defined = _Cesium.defined,
      Cartesian3 = _Cesium.Cartesian3;
  var mvRtc = new Matrix4();
  if (!scratchTranslationRtc) scratchTranslationRtc = new Matrix4();
  return function () {
    if (defined(model._rtcCenter)) {
      Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);
      Cartesian3.add(scratchTranslationRtc, model._rtcCenter, scratchTranslationRtc);
      Matrix4.multiplyByPoint(uniformState.view, scratchTranslationRtc, scratchTranslationRtc);
      return Matrix4.setTranslation(uniformState.modelView, scratchTranslationRtc, mvRtc);
    }

    return uniformState.modelView;
  };
};

var GeoMesh = /*#__PURE__*/function (_IRenderable) {
  (0, _inherits2["default"])(GeoMesh, _IRenderable);

  var _super = _createSuper(GeoMesh);

  function GeoMesh(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, GeoMesh);
    var _Cesium2 = Cesium,
        when = _Cesium2.when,
        Resource = _Cesium2.Resource,
        Cartesian3 = _Cesium2.Cartesian3,
        Rectangle = _Cesium2.Rectangle,
        BoundingSphere = _Cesium2.BoundingSphere,
        defaultValue = _Cesium2.defaultValue;

    if (!options.url) {
      throw new Error('GeoMesh#constructor:url is required');
    }

    _this = _super.call(this, options);
    _this._rtcCenter = null;
    _this.url = options.url;
    _this.rectangle = new Rectangle();
    _this.boundingSphere = new BoundingSphere();
    _this.bbox = [-180, -90, 180, 90];
    _this.source = null;
    _this.ready = false;
    _this.show = defaultValue(options.show, true);
    _this._deferred = when.defer();
    _this.readyPromise = _this._deferred.promise;
    _this._pickIdMap = new Map();
    _this._pickIds = [];
    _this._lazyLoad = defaultValue(options.lazyLoad, false);
    _this._isLoading = false;

    if (!_this._lazyLoad) {
      if (typeof _this.url == 'string') {
        _this._isLoading = true;
        Resource.fetchJson(_this.url).then(function (json) {
          _this.onLoad(json);
        });
      } else {
        _this.onLoad(_this.url);
      }
    }

    return _this;
  }

  (0, _createClass2["default"])(GeoMesh, [{
    key: "pickIds",
    get: function get() {
      return this._pickIds;
    }
    /**
    * 
    * @param {Earth|MeshVisualizer} earth 
    */

  }, {
    key: "load",
    value: function load(earth) {
      if (this.visualizer) return;
      earth = earth.isMeshVisualizer ? earth : earth.globalScene;
      earth.add(this);
    }
    /**
    * 
    * @param {Earth|MeshVisualizer} earth 
    */

  }, {
    key: "unload",
    value: function unload(earth) {
      if (!this.visualizer) return;
      earth = earth.isMeshVisualizer ? earth : earth.globalScene;
      earth.remove(this);
    }
  }, {
    key: "onAdded",
    value: function onAdded() {
      var _this2 = this;

      if (this.lazyLoad && !this.ready && !this._isLoading) {
        if (typeof this.url == 'string') {
          this._isLoading = true;
          Resource.fetchJson(this.url).then(function (json) {
            _this2.onLoad(json);
          });
        } else {
          this.onLoad(this.url);
        }
      }
    }
  }, {
    key: "onRemoved",
    value: function onRemoved() {
      var mesh = this.mesh,
          visualizer = this.visualizer;

      if (mesh && visualizer) {
        visualizer.remove(mesh, true);
        this._pickIds.length = 0;

        this._pickIdMap.clear();
      }
    }
  }, {
    key: "onLoad",
    value: function onLoad(json) {
      var _Cesium3 = Cesium,
          Rectangle = _Cesium3.Rectangle;
      var deferred = this._deferred;

      var bbox = _geojsonHelper["default"].calcBBox(json);

      for (var i = 0; i < 4; i++) {
        this.bbox[i] = bbox[i];
      }

      Rectangle.fromDegrees(bbox[0], bbox[1], bbox[2], bbox[3], this.rectangle);

      try {
        this.source = json;
        this.initMesh();
        deferred.resolve(this);
        this.ready = true;
      } catch (err) {
        deferred.reject(err);
      }
    }
  }, {
    key: "setPickId",
    value: function setPickId(feature, geometry) {
      var _Cesium4 = Cesium,
          GeometryAttribute = _Cesium4.GeometryAttribute,
          ComponentDatatype = _Cesium4.ComponentDatatype;
      var pickIdMap = this._pickIdMap;
      var pickId = pickIdMap.get(feature);

      if (!pickId) {
        var context = this.visualizer.frameState.context;
        pickId = context.createPickId({
          feature: feature,
          primitive: this,
          boundingSphere: geometry.boundingSphere
        });
        pickIdMap.set(feature, pickId);

        this._pickIds.push(pickId);
      }

      var positions = geometry.attributes.position;
      positions = positions.values || positions.array;
      var ptCount = positions.length / 3;
      var pickColors = [],
          _pickId$color = pickId.color,
          red = _pickId$color.red,
          green = _pickId$color.green,
          blue = _pickId$color.blue,
          alpha = _pickId$color.alpha;

      for (var i = 0; i < ptCount; i++) {
        pickColors.push(red, green, blue, alpha);
      }

      pickColors = new Float32Array(pickColors);
      if (geometry.isBufferGeometry) geometry.setAttribute('pickColor', new THREE.BufferAttribute(pickColors, 4, false));else {
        geometry.attributes.pickColor = new GeometryAttribute({
          componentDatatype: ComponentDatatype.FLOAT,
          componentsPerAttribute: 4,
          normalize: false,
          values: pickColors
        });
      }
      return geometry;
    }
  }, {
    key: "initMesh",
    value: function initMesh() {
      var _this3 = this;

      var mesh = this.createMesh(this.source);

      if (this._rtcCenter) {
        mesh.uniformMapLoadedCallback = function (uniformMap, frameState, mesh) {
          var cesiumRtcModelViewUniform = CESIUM_RTC_MODELVIEW(frameState.context.uniformState, _this3);
          uniformMap.modelView = cesiumRtcModelViewUniform;
          uniformMap.u_modelView = cesiumRtcModelViewUniform;
          uniformMap.modelViewMatrix = cesiumRtcModelViewUniform;
          uniformMap.u_modelViewMatrix = cesiumRtcModelViewUniform;
        };
      }

      this.mesh = mesh;
    }
  }, {
    key: "rtcCenterTransform",
    value: function rtcCenterTransform(geometry, rtcCenter) {
      var postionAtt = geometry.attributes.position;
      var positions = postionAtt.array || postionAtt.values;

      for (var i = 0; i < positions.length; i += 3) {
        var x = positions[i],
            y = positions[i + 1],
            z = positions[i + 2];
        positions[i] = x - rtcCenter.x;
        positions[i + 1] = y - rtcCenter.y;
        positions[i + 2] = z - rtcCenter.z;
      }

      return geometry;
    }
  }, {
    key: "transformGeometry",
    value: function transformGeometry(geometry, rtcCenter) {
      if (rtcCenter) {
        this.rtcCenterTransform(geometry, rtcCenter);
      } else {
        var localScene = this.visualizer;
        var positions = geometry.attributes.position.array;
        var cartesian3 = {
          x: 0,
          y: 0,
          z: 0
        };

        for (var i = 0; i < positions.length; i += 3) {
          cartesian3.x = positions[i];
          cartesian3.y = positions[i + 1];
          cartesian3.z = positions[i + 2];
          localScene.worldCoordinatesToLocal(cartesian3, cartesian3, {
            y: 1
          });
          positions[i] = cartesian3.x;
          positions[i + 1] = cartesian3.y;
          positions[i + 2] = cartesian3.z;
        }

        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();
      }

      return geometry;
    }
  }, {
    key: "createMesh",
    value: function createMesh(json) {
      throw new Error('GeoMesh#createMesh未实现');
    }
  }, {
    key: "createHighlightGeometry",
    value: function createHighlightGeometry(feature) {
      throw new Error('GeoMesh#createHighlightGeometry未实现');
    }
  }, {
    key: "createHighlightMesh",
    value: function createHighlightMesh(feature, material) {
      var _this4 = this;

      var geometry = this.createHighlightGeometry(feature);
      if (!geometry.boundingSphere) geometry.computeBoundingSphere();
      var mesh = new THREE.Mesh(geometry, material);

      if (this._rtcCenter) {
        mesh.uniformMapLoadedCallback = function (uniformMap, frameState, mesh) {
          var cesiumRtcModelViewUniform = CESIUM_RTC_MODELVIEW(frameState.context.uniformState, _this4);
          uniformMap.modelView = cesiumRtcModelViewUniform;
          uniformMap.u_modelView = cesiumRtcModelViewUniform;
          uniformMap.modelViewMatrix = cesiumRtcModelViewUniform;
          uniformMap.u_modelViewMatrix = cesiumRtcModelViewUniform;
        };

        mesh.up.set(0, 0, 1);
        mesh.modelMatrixNeedsUpdate = false;
        mesh.matrixAutoUpdate = false;
      }

      mesh.receiveShadow = false;
      mesh.castShadow = false;
      this.transformGeometry(geometry, this._rtcCenter);
      return mesh;
    }
    /**
     * 
     * @param {Cesium.FrameState} frameSate 
     * @param {(THREE.Object3D|Object3D)[]} renderList 
     * @override IRenderable#render
     * @returns 
     */

  }, {
    key: "render",
    value: function render(frameSate, renderList) {
      if (!this.ready || !this.mesh || !this.show) return;
      this.pickId = this.mesh.pickId;
      renderList.push(this.mesh);
    }
  }]);
  return GeoMesh;
}(_IRenderable2["default"]);

exports["default"] = GeoMesh;
GeoMesh.prototype.isGeoMesh = true;

},{"3_225":4,"D_226":199,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],61:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _get2 = _interopRequireDefault(require("m_230"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _GeometryUtils = _interopRequireDefault(require("h_234"));

var _GeoPolygonGeometry = _interopRequireDefault(require("-_235"));

var _GeoMesh2 = _interopRequireDefault(require("3_236"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var GeoPolygonMesh = /*#__PURE__*/function (_GeoMesh) {
  (0, _inherits2["default"])(GeoPolygonMesh, _GeoMesh);

  var _super = _createSuper(GeoPolygonMesh);

  function GeoPolygonMesh(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, GeoPolygonMesh);
    var _THREE = THREE,
        MeshBasicMaterial = _THREE.MeshBasicMaterial;
    var _Cesium = Cesium,
        defaultValue = _Cesium.defaultValue;
    _this = _super.call(this, options);
    _this.useRtcCenter = defaultValue(options.useRtcCenter, true);
    _this.height = options.height || 0;
    _this._material = options.material || new MeshBasicMaterial({
      color: 'yellow',
      opacity: 0.5
    });
    _this.uvGenerator = options.uvGenerator;
    _this.needsUpdate = false;
    return _this;
  }

  (0, _createClass2["default"])(GeoPolygonMesh, [{
    key: "material",
    get: function get() {
      return this._material;
    },
    set: function set(val) {
      this._material = val;
      if (this.mesh) this.mesh.material = val;
    }
  }, {
    key: "createHighlightGeometry",
    value: function createHighlightGeometry(feature) {
      var height = this.height,
          uvGenerator = this.uvGenerator;

      var geometry = _GeoPolygonGeometry["default"].fromFeature(feature, height, null, uvGenerator);

      geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
      return geometry;
    }
  }, {
    key: "createMesh",
    value: function createMesh(json) {
      var _Cesium2 = Cesium,
          BoundingSphere = _Cesium2.BoundingSphere;
      var _THREE2 = THREE,
          Mesh = _THREE2.Mesh;
      var material = this.material,
          visualizer = this.visualizer;
      var geometries = [],
          features = json.features;
      var needsCreatePickId = !!visualizer._frameState && !!visualizer._frameState.context;

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];

        if (!feature.geometry) {
          continue;
        }

        var tempGeometry = _GeoPolygonGeometry["default"].fromFeature(feature, this.height, null, this.uvGenerator);

        needsCreatePickId && this.setPickId(feature, tempGeometry);
        geometries.push(tempGeometry);
      }

      var geometry = _GeometryUtils["default"].mergeGeometries(geometries);

      geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
      if (!geometry.boundingSphere) geometry.computeBoundingSphere();
      BoundingSphere.clone(geometry.boundingSphere, this.boundingSphere);
      material.pickColorQualifier = 'varying';
      material.pickColorName = 'pickColor'; //

      var mesh = new Mesh(geometry, this.material);

      if (this._rtcCenter) {
        this._rtcCenter = this.boundingSphere.center;
        mesh.up.set(0, 0, 1);
        mesh.modelMatrixNeedsUpdate = false;
        mesh.matrixAutoUpdate = false;
      } else {
        this._rtcCenter = null;
      }

      mesh.receiveShadow = true;
      this.transformGeometry(geometry, this._rtcCenter);
      return mesh;
    }
  }, {
    key: "render",
    value: function render(frameSate, renderList) {
      if (this.needsUpdate && this.mesh) {
        this.visualizer.remove(this.mesh, true);
        this.initMesh();
        this.needsUpdate = false;
      }

      (0, _get2["default"])((0, _getPrototypeOf2["default"])(GeoPolygonMesh.prototype), "render", this).call(this, frameSate, renderList);
    }
  }]);
  return GeoPolygonMesh;
}(_GeoMesh2["default"]);

exports["default"] = GeoPolygonMesh;

function DefaultUvGenerator(uvUnit) {
  return {
    uvUnit: uvUnit ? Object.assign({
      x: 40,
      y: 50
    }, uvUnit) : {
      x: 40,
      y: 50
    },
    generate: function generate(positions) {
      var _this2 = this;

      var _Cesium3 = Cesium,
          Cartesian3 = _Cesium3.Cartesian3,
          Cartographic = _Cesium3.Cartographic;
      var _Math = Cesium.Math;
      var bbox = [Math.PI, Math.PI / 2, -Math.PI, -Math.PI / 2];
      positions = Cartesian3.unpackArray(positions);
      positions = positions.map(function (p) {
        var p2 = Cartographic.fromCartesian(p);
        bbox[0] = Math.min(bbox[0], p2.longitude); // bbox[2] = Math.max(bbox[2], p2.longitude)

        bbox[1] = Math.min(bbox[1], p2.latitude); // bbox[3] = Math.max(bbox[3], p2.latitude)

        return p2;
      });
      var uvs = [];
      positions.forEach(function (p) {
        uvs.push(1000 * 110 * _Math.toDegrees(p.longitude - bbox[0]) / _this2.uvUnit.x, 2 * 1000 * 110 * _Math.toDegrees(p.latitude - bbox[1]) / _this2.uvUnit.y);
      });
      return uvs;
    }
  };
}

GeoPolygonMesh.DefaultUvGenerator = DefaultUvGenerator;

},{"h_234":2,"-_235":43,"3_236":60,"e_1":235,"s_2":236,"m_230":238,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],62:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _get2 = _interopRequireDefault(require("m_230"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _GeometryUtils = _interopRequireDefault(require("h_234"));

var _geojsonHelper = _interopRequireDefault(require("D_226"));

var _GeoPolylineGeometry = _interopRequireDefault(require("-_246"));

var _GeoMesh2 = _interopRequireDefault(require("3_236"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var GeoPolylineMesh = /*#__PURE__*/function (_GeoMesh) {
  (0, _inherits2["default"])(GeoPolylineMesh, _GeoMesh);

  var _super = _createSuper(GeoPolylineMesh);

  function GeoPolylineMesh(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, GeoPolylineMesh);
    var _THREE = THREE,
        MeshBasicMaterial = _THREE.MeshBasicMaterial;
    var _Cesium = Cesium,
        defaultValue = _Cesium.defaultValue;
    _this = _super.call(this, options);
    _this._lineWidth = options.lineWidth || 9; //单位：米

    _this._material = options.material || new MeshBasicMaterial({
      color: 'yellow',
      opacity: 0.5
    });
    _this._union = defaultValue(options.union, true);
    _this._unionEpsilon = defaultValue(options.unionEpsilon, 0.01); //单位：米

    _this._uvUnit = options.uvUnit;
    _this._needsUpdate = false;
    _this._clampToGround = defaultValue(options.clampToGround, false);
    _this.useRtcCenter = defaultValue(options.useRtcCenter, true);
    return _this;
  }

  (0, _createClass2["default"])(GeoPolylineMesh, [{
    key: "clampToGround",
    get: function get() {
      return this._clampToGround;
    },
    set: function set(val) {
      if (this._clampToGround != val) {
        this._clampToGround = val;
        this._needsUpdate = true;
      }
    }
  }, {
    key: "material",
    get: function get() {
      return this._material;
    },
    set: function set(val) {
      this._material = val;
      if (this.mesh) this.mesh.material = val;
    }
  }, {
    key: "lineWidth",
    get: function get() {
      return this._lineWidth;
    },
    set: function set(val) {
      if (this._lineWidth != val) {
        this._lineWidth = val;
        this._needsUpdate = true;
      }
    }
  }, {
    key: "uvUnit",
    get: function get() {
      return this._uvUnit;
    },
    set: function set(val) {
      if (this._uvUnit != val) {
        this._uvUnit = val;
        this._needsUpdate = true;
      }
    }
  }, {
    key: "union",
    get: function get() {
      return this._union;
    },
    set: function set(val) {
      if (this._union != val) {
        this._union = val;
        this._needsUpdate = true;
      }
    }
  }, {
    key: "unionEpsilon",
    get: function get() {
      return this._unionEpsilon;
    },
    set: function set(val) {
      if (this._unionEpsilon != val) {
        this._unionEpsilon = val;
        this._needsUpdate = true;
      }
    }
  }, {
    key: "createHighlightGeometry",
    value: function createHighlightGeometry(feature) {
      var uvUnit = this.uvUnit,
          clampToGround = this.clampToGround,
          lineWidth = this.lineWidth;

      var geometry = _GeoPolylineGeometry["default"].fromFeature(feature, lineWidth, uvUnit, clampToGround);

      return geometry;
    }
  }, {
    key: "createMesh",
    value: function createMesh(json) {
      var _Cesium2 = Cesium,
          Cartesian3 = _Cesium2.Cartesian3,
          BoundingSphere = _Cesium2.BoundingSphere;
      var _THREE2 = THREE,
          ShapeUtils = _THREE2.ShapeUtils,
          Mesh = _THREE2.Mesh,
          BufferGeometry = _THREE2.BufferGeometry,
          BufferAttribute = _THREE2.BufferAttribute;
      var features = [];

      _geojsonHelper["default"].featureEach(json, function (feature) {
        var geometry = feature.geometry;
        var geomType = geometry.type;

        if (geomType == 'MultiLineString') {
          geometry.coordinates.forEach(function (coordinates) {
            var newFeature = {
              type: "Feature",
              geometry: {
                type: 'LineString',
                coordinates: coordinates
              }
            };

            _geojsonHelper["default"].calcBBox(newFeature);

            features.push(newFeature);
          });
          return;
        }

        if (geomType != 'LineString') return;
        features.push(feature);
      });

      if (features.length == 0) return;
      var visualizer = this.visualizer,
          useRtcCenter = this.useRtcCenter,
          material = this.material,
          union = this.union,
          unionEpsilon = this.unionEpsilon,
          uvUnit = this.uvUnit,
          clampToGround = this.clampToGround,
          lineWidth = this.lineWidth;

      if (union) {
        features = _GeoPolylineGeometry["default"].union(features, unionEpsilon);
      }

      var needsCreatePickId = !!visualizer._frameState && !!visualizer._frameState.context;
      var geometries = [],
          geometry;

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];

        if (!feature.geometry) {
          continue;
        }

        var tempGeometry = _GeoPolylineGeometry["default"].fromFeature(feature, lineWidth, uvUnit, clampToGround);

        tempGeometry.computeBoundingSphere();
        needsCreatePickId && this.setPickId(feature, tempGeometry);
        geometries.push(tempGeometry);
      }

      geometry = _GeometryUtils["default"].mergeGeometries3js(geometries);
      geometry.computeBoundingSphere();
      BoundingSphere.clone(geometry.boundingSphere, this.boundingSphere);
      material.pickColorQualifier = 'varying';
      material.pickColorName = 'pickColor';
      var mesh = new Mesh(geometry, material);

      if (useRtcCenter) {
        this._rtcCenter = this.boundingSphere.center;
        mesh.up.set(0, 0, 1);
        mesh.modelMatrixNeedsUpdate = false;
        mesh.matrixAutoUpdate = false;
      } else {
        this._rtcCenter = null;
      }

      mesh.receiveShadow = true;
      this.transformGeometry(geometry, this._rtcCenter);
      return mesh;
    }
  }, {
    key: "render",
    value: function render(frameSate, renderList) {
      if (this._needsUpdate && this.mesh) {
        this.visualizer.remove(this.mesh, true);
        this.initMesh();
        this._needsUpdate = false;
      }

      (0, _get2["default"])((0, _getPrototypeOf2["default"])(GeoPolylineMesh.prototype), "render", this).call(this, frameSate, renderList);
    }
  }]);
  return GeoPolylineMesh;
}(_GeoMesh2["default"]);

exports["default"] = GeoPolylineMesh;

},{"h_234":2,"D_226":199,"-_246":44,"3_236":60,"e_1":235,"s_2":236,"m_230":238,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],63:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _GeometryUtils = _interopRequireDefault(require("h_234"));

var _GeoPolygonGeometry = _interopRequireDefault(require("-_235"));

var _GeoMesh2 = _interopRequireDefault(require("3_236"));

var _Water = require("-_257");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var GeoWaterMesh = /*#__PURE__*/function (_GeoMesh) {
  (0, _inherits2["default"])(GeoWaterMesh, _GeoMesh);

  var _super = _createSuper(GeoWaterMesh);

  function GeoWaterMesh(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, GeoWaterMesh);
    var _Cesium = Cesium,
        defaultValue = _Cesium.defaultValue;
    var _THREE = THREE,
        TextureLoader = _THREE.TextureLoader,
        Vector3 = _THREE.Vector3,
        RepeatWrapping = 1000;
    _this = _super.call(this, options);
    _this.skyBox = options.skyBox;
    _this.waterNormals = options.waterNormals;
    _this.alpha = defaultValue(options.alpha, 0.8);
    _this.clampToGround = defaultValue(options.clampToGround, true);
    _this._terrainProvider = null;
    _this.waterParams = {
      textureWidth: 1024,
      textureHeight: 1024,
      waterNormals: new TextureLoader().load(_this.waterNormals, function (texture) {
        texture.wrapS = texture.wrapT = RepeatWrapping;
      }),
      alpha: _this.alpha,
      sunDirection: new Vector3(),
      sunColor: 0xffffff,
      waterColor: 0x001e0f,
      distortionScale: 3.7,
      fog: false //localScene.fog != undefined

    };
    return _this;
  }

  (0, _createClass2["default"])(GeoWaterMesh, [{
    key: "createGeomerty",
    value: function createGeomerty(feature, boundingSpheres) {
      var _Cesium2 = Cesium,
          Cartesian3 = _Cesium2.Cartesian3,
          BoundingSphere = _Cesium2.BoundingSphere;
      var localScene = this.visualizer;
      var height;

      if (this.clampToGround && this._terrainProvider && feature.properties && feature.properties._terrainHeight) {
        height = feature.properties._terrainHeight;
      }

      var geometry = _GeoPolygonGeometry["default"].fromFeature(feature, height);

      boundingSpheres.push(BoundingSphere.clone(geometry.boundingSphere));
      var postions = geometry.attributes.position.values;

      for (var i = 0; i < postions.length; i += 3) {
        var x = postions[i],
            y = postions[i + 1],
            z = postions[i + 2];
        var cart3 = new Cartesian3(x, y, z);
        localScene.worldCoordinatesToLocal(cart3, cart3, Cartesian3.UNIT_Y); // cart3.y = 0;

        postions[i] = cart3.x;
        postions[i + 1] = cart3.y;
        postions[i + 2] = cart3.z;
      }

      geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
      geometry.computeBoundingSphere();
      geometry.computeVertexNormals();
      return geometry;
    }
  }, {
    key: "createMesh",
    value: function createMesh(json) {
      if (!this.visualizer) return;
      var _THREE2 = THREE,
          Object3D = _THREE2.Object3D;
      var boundingSpheres = [];
      var root = new Object3D();

      for (var index = 0; index < json.features.length; index++) {
        var feature = json.features[index];
        var waterGeometry = this.createGeomerty(feature, boundingSpheres);
        var water = new _Water.Water(waterGeometry, this.waterParams);
        root.add(water);
      }

      Cesium.BoundingSphere.fromBoundingSpheres(boundingSpheres, this.boundingSphere);
      return root;
    }
  }, {
    key: "render",
    value: function render(frameSate, renderList) {
      var _this2 = this;

      if (this.ready && !this.mesh) {
        this.initMesh();
      }

      if (!this.ready || !this.mesh || !this.show) return;
      this.pickId = this.mesh.pickId;
      renderList.push(this.mesh);
      /**
       * @type {Cesium.Scene}
       */

      var scene = this.visualizer.scene;
      var _Cesium3 = Cesium,
          EllipsoidTerrainProvider = _Cesium3.EllipsoidTerrainProvider,
          Cartographic = _Cesium3.Cartographic,
          sampleTerrainMostDetailed = _Cesium3.sampleTerrainMostDetailed;
      var terrainProvider;

      if (!this.clampToGround || scene.terrainProvider instanceof EllipsoidTerrainProvider) {
        terrainProvider = null;
      } else {
        terrainProvider = scene.terrainProvider;
      }

      if (terrainProvider != this._terrainProvider) {
        this._terrainProvider = terrainProvider;

        if (!terrainProvider) {
          this.initMesh();
        } else if (!this._isUpdatingTerrainProperties) {
          this._isUpdatingTerrainProperties = true;
          var features = [];
          this.source.features.forEach(function (feature) {
            if (!feature.geometry) return;
            features.push(feature);
          });
          var positions = features.map(function (feature) {
            var bbox = feature.geometry.bbox;
            var lon = (bbox[0] + bbox[2]) / 2,
                lat = (bbox[1] + bbox[3]) / 2;
            return Cartographic.fromDegrees(lon, lat);
          });
          sampleTerrainMostDetailed(terrainProvider, positions).then(function () {
            for (var i = 0; i < features.length; i++) {
              var feature = features[i];
              feature.properties = feature.properties || {};
              feature.properties._terrainHeight = positions[i].height;
            }

            positions.length = 0;

            _this2.initMesh();

            _this2._isUpdatingTerrainProperties = false;
          }).otherwise(function (err) {
            positions.length = 0;
            console.error(err);
          });
        }
      }

      var skyBox = this.skyBox;
      var sunPosition = skyBox ? skyBox.sunPosition : this.visualizer._sunPositionLC;
      this.mesh.children.forEach(function (water) {
        var waterMaterial = water.material;
        waterMaterial.uniforms.sunDirection.value.copy(sunPosition).normalize();
        waterMaterial.uniforms['time'].value += 1.0 / 60.0;
      });
    }
  }]);
  return GeoWaterMesh;
}(_GeoMesh2["default"]);

exports["default"] = GeoWaterMesh;

},{"h_234":2,"-_235":43,"3_236":60,"-_257":65,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],64:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _PagedLOD = _interopRequireDefault(require("M_264"));

var _Earth = _interopRequireDefault(require("C_217"));

var _ILayer2 = _interopRequireDefault(require("-_202"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var OsgbLayer = /*#__PURE__*/function (_ILayer) {
  (0, _inherits2["default"])(OsgbLayer, _ILayer);

  var _super = _createSuper(OsgbLayer);

  function OsgbLayer(params) {
    var _this;

    (0, _classCallCheck2["default"])(this, OsgbLayer);
    _this = _super.call(this, params);
    params.materialType = params.materialType || 'basic';
    _this.params = params;
    _this._root = new _PagedLOD["default"](params);
    return _this;
  }

  (0, _createClass2["default"])(OsgbLayer, [{
    key: "root",
    get: function get() {
      return this._root;
    }
  }, {
    key: "ready",
    get: function get() {
      return !!this._root && this._root.ready;
    }
  }, {
    key: "readyPromise",
    get: function get() {
      return this._root && this._root.readyPromise;
    }
  }, {
    key: "boundingSphere",
    get: function get() {
      return this._root && this._root.boundingSphere;
    }
  }, {
    key: "materialType",
    get: function get() {
      return this.params.materialType;
    },
    set: function set(val) {
      var params = this.params,
          _root = this._root;

      if (params.materialType != val) {
        params.materialType = val;
        if (_root) _root.materialType = val;
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;

      if (this.root) {
        this.root.show = val;
      }
    }
  }, {
    key: "reload",
    value: function reload(earth) {
      this.unload(earth);
      this._root = new _PagedLOD["default"](this.params);
      this.load(earth);
    }
    /**
     * 
     * @param {Earth|MeshVisualizer} earth 
     */

  }, {
    key: "load",
    value: function load(earth) {
      var localScene = earth.isMeshVisualizer ? earth : earth.globalScene;
      this.root.show = this.show;
      localScene.add(this.root);
    }
    /**
     * 
     * @param {Earth|MeshVisualizer} earth 
     */

  }, {
    key: "unload",
    value: function unload(earth) {
      var localScene = earth.isMeshVisualizer ? earth : earth.globalScene;
      var root = this.root;
      localScene.remove(root, true);
      this._root = root.destroy();
    }
  }]);
  return OsgbLayer;
}(_ILayer2["default"]);

exports["default"] = OsgbLayer;

},{"M_264":80,"C_217":40,"-_202":55,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Water = void 0;

/**
 * Work based on :
 * http://slayvin.net : Flat mirror for three.js
 * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror
 * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL
 */
var Water = function Water(geometry, options) {
  var _THREE = THREE,
      Color = _THREE.Color,
      FrontSide = 0,
      LinearEncoding = 3000,
      LinearFilter = 1006,
      MathUtils = _THREE.MathUtils,
      Matrix4 = _THREE.Matrix4,
      Mesh = _THREE.Mesh,
      NoToneMapping = 0,
      PerspectiveCamera = _THREE.PerspectiveCamera,
      Plane = _THREE.Plane,
      RGBFormat = 1022,
      ShaderMaterial = _THREE.ShaderMaterial,
      UniformsLib = _THREE.UniformsLib,
      UniformsUtils = _THREE.UniformsUtils,
      Vector3 = _THREE.Vector3,
      Vector4 = _THREE.Vector4,
      WebGLRenderTarget = _THREE.WebGLRenderTarget; // Mesh.call(this, geometry);

  var scope = new Mesh(geometry);
  options = options || {};
  var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;
  var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;
  var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;
  var alpha = options.alpha !== undefined ? options.alpha : 1.0;
  var time = options.time !== undefined ? options.time : 0.0;
  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;
  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);
  var sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);
  var waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7F7F7F);
  var eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);
  var eyeCesium = options.eyeCesium !== undefined ? options.eyeCesium : new Vector3(0, 0, 0);
  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;
  var side = options.side !== undefined ? options.side : FrontSide;
  var fog = options.fog !== undefined ? options.fog : false; //

  var mirrorPlane = new Plane();
  var normal = new Vector3();
  var mirrorWorldPosition = new Vector3();
  var cameraWorldPosition = new Vector3();
  var rotationMatrix = new Matrix4();
  var lookAtPosition = new Vector3(0, 0, -1);
  var clipPlane = new Vector4();
  var view = new Vector3();
  var target = new Vector3();
  var q = new Vector4();
  var textureMatrix = new Matrix4();
  var textureMatrixCesium = new Matrix4();
  var mirrorCamera = new PerspectiveCamera();
  var parameters = {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBFormat
  };
  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);

  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {
    renderTarget.texture.generateMipmaps = false;
  }

  var mirrorShader = {
    uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {
      "normalSampler": {
        value: null
      },
      "mirrorSampler": {
        value: null
      },
      "alpha": {
        value: 1.0
      },
      "time": {
        value: 0.0
      },
      "size": {
        value: 1.0
      },
      "distortionScale": {
        value: 20.0
      },
      "textureMatrix": {
        value: new Matrix4()
      },
      "textureMatrixCesium": {
        value: new Matrix4()
      },
      "sunColor": {
        value: new Color(0x7F7F7F)
      },
      "sunDirection": {
        value: new Vector3(0.70707, 0.70707, 0)
      },
      "eye": {
        value: new Vector3()
      },
      'eyeCesium': {
        value: new Vector3()
      },
      "waterColor": {
        value: new Color(0x555555)
      }
    }]),
    vertexShader: ['uniform mat4 textureMatrix;', 'uniform mat4 textureMatrixCesium;', 'uniform float time;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', '#include <common>', '#include <fog_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'void main() {', '	mirrorCoord = modelMatrix * vec4( position, 1.0 );', '	worldPosition = mirrorCoord.xyzw;', '#ifdef CESIUM_MESH_VISUALIZER', '	mirrorCoord = textureMatrixCesium * vec4( position, 1.0 );', '#else', '	mirrorCoord = textureMatrix * mirrorCoord;', '#endif', '	vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', '	gl_Position = projectionMatrix * mvPosition;', 'vec3 transformed = vec3( position );', '#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#include <logdepthbuf_vertex>', '#include <fog_vertex>', '#include <shadowmap_vertex>', '}'].join('\n'),
    fragmentShader: ['uniform sampler2D mirrorSampler;', 'uniform float alpha;', 'uniform float time;', 'uniform float size;', 'uniform float distortionScale;', 'uniform sampler2D normalSampler;', 'uniform vec3 sunColor;', 'uniform vec3 sunDirection;', 'uniform vec3 eye;', '#ifdef CESIUM_MESH_VISUALIZER', 'uniform vec3 eyeCesium;', '#endif', 'uniform vec3 waterColor;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', 'vec4 getNoise( vec2 uv ) {', '	vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);', '	vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );', '	vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );', '	vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );', '	vec4 noise = texture2D( normalSampler, uv0 ) +', '		texture2D( normalSampler, uv1 ) +', '		texture2D( normalSampler, uv2 ) +', '		texture2D( normalSampler, uv3 );', '	return noise * 0.5 - 1.0;', '}', 'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {', '	vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );', '	float direction = max( 0.0, dot( eyeDirection, reflection ) );', '	specularColor += pow( direction, shiny ) * sunColor * spec;', '	diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;', '}', '#include <common>', '#include <packing>', '#include <bsdfs>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <lights_pars_begin>', '#include <shadowmap_pars_fragment>', '#include <shadowmask_pars_fragment>', 'void main() {', '#include <logdepthbuf_fragment>', '#ifdef CESIUM_MESH_VISUALIZER', '	vec4 noise = getNoise((_CesiumModel2ThreeModel* worldPosition).xz * size );', '#else', '	vec4 noise = getNoise( worldPosition.xz * size );', '#endif ', '	vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );', '	vec3 diffuseLight = vec3(0.0);', '	vec3 specularLight = vec3(0.0);', '#ifdef CESIUM_MESH_VISUALIZER', '   vec3 worldToEye = eyeCesium-worldPosition.xyz;', '#else', '	vec3 worldToEye = eye-worldPosition.xyz;', '#endif ', '	vec3 eyeDirection = normalize( worldToEye );', '#ifdef CESIUM_MESH_VISUALIZER', '   eyeDirection=_CesiumNormal2ThreeNormal*eyeDirection;', '#endif ', '	sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );', '	float distance = length(worldToEye);', '	vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;', '	vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );', '	float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );', '	float rf0 = 0.3;', '	float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );', '	vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;', '	vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);', '	vec3 outgoingLight = albedo;', '	gl_FragColor = vec4( outgoingLight, alpha );', '#include <tonemapping_fragment>', '#include <fog_fragment>', '}'].join('\n')
  };
  var material = new ShaderMaterial({
    fragmentShader: mirrorShader.fragmentShader,
    vertexShader: mirrorShader.vertexShader,
    uniforms: UniformsUtils.clone(mirrorShader.uniforms),
    lights: true,
    side: side,
    fog: fog
  });
  material.uniforms["mirrorSampler"].value = renderTarget.texture;
  material.uniforms["textureMatrix"].value = textureMatrix;
  material.uniforms['textureMatrixCesium'].value = textureMatrixCesium;
  material.uniforms["alpha"].value = alpha;
  material.uniforms["time"].value = time;
  material.uniforms["normalSampler"].value = normalSampler;
  material.uniforms["sunColor"].value = sunColor;
  material.uniforms["waterColor"].value = waterColor;
  material.uniforms["sunDirection"].value = sunDirection;
  material.uniforms["distortionScale"].value = distortionScale;
  material.uniforms["eye"].value = eye;
  material.uniforms['eyeCesium'].value = eyeCesium;
  scope.material = material;

  scope.onBeforeRender = function (renderer, scene, camera) {
    if (renderer.isCesiumRenderer) {
      mirrorWorldPosition.setFromMatrixPosition(scope.modelMatrix);
      cameraWorldPosition.setFromMatrixPosition(camera.modelMatrix);
      rotationMatrix.extractRotation(scope.modelMatrix);
    } else {
      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix.extractRotation(scope.matrixWorld);
    }

    normal.set(0, 0, 1);
    normal.applyMatrix4(rotationMatrix);
    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away

    if (view.dot(normal) > 0) return;
    view.reflect(normal).negate();
    view.add(mirrorWorldPosition);
    if (renderer.isCesiumRenderer) rotationMatrix.extractRotation(camera.modelMatrix);else rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target.subVectors(mirrorWorldPosition, lookAtPosition);
    target.reflect(normal).negate();
    target.add(mirrorWorldPosition);
    mirrorCamera.position.copy(view);
    mirrorCamera.up.set(0, 1, 0);
    mirrorCamera.up.applyMatrix4(rotationMatrix);
    mirrorCamera.up.reflect(normal);
    mirrorCamera.lookAt(target);
    mirrorCamera.far = camera.far; // Used in WebGLBackground

    mirrorCamera.updateMatrixWorld();
    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix

    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    textureMatrix.multiply(mirrorCamera.projectionMatrix);
    textureMatrix.multiply(mirrorCamera.matrixWorldInverse);

    if (renderer.isCesiumRenderer) {
      textureMatrixCesium.copy(textureMatrix);
      textureMatrixCesium.multiply(scope.modelMatrix);
    } // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf


    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);
    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);
    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);
    var projectionMatrix = mirrorCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1.0;
    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector

    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix

    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    if (renderer.isCesiumRenderer) eyeCesium.setFromMatrixPosition(camera.modelMatrix);else eye.setFromMatrixPosition(camera.matrixWorld); // Render

    if (renderer.outputEncoding !== LinearEncoding) {
      console.warn('THREE.Water: WebGLRenderer must use LinearEncoding as outputEncoding.');

      scope.onBeforeRender = function () {};

      return;
    }

    if (renderer.toneMapping !== NoToneMapping) {
      console.warn('THREE.Water: WebGLRenderer must use NoToneMapping as toneMapping.');

      scope.onBeforeRender = function () {};

      return;
    }

    var currentRenderTarget = renderer.getRenderTarget();
    var currentXrEnabled = renderer.xr.enabled;
    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
    scope.visible = false;
    renderer.xr.enabled = false; // Avoid camera modification and recursion

    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

    renderer.setRenderTarget(renderTarget);
    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897

    if (renderer.autoClear === false) renderer.clear();
    renderer.render(scene, mirrorCamera);
    scope.visible = true;
    renderer.xr.enabled = currentXrEnabled;
    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
    renderer.setRenderTarget(currentRenderTarget); // Restore viewport

    var viewport = camera.viewport;

    if (viewport !== undefined) {
      renderer.state.viewport(viewport);
    }
  };

  return scope;
};

exports.Water = Water;

},{}],66:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.CountryVec2dLayer = exports.LabelVec2dLayer = exports.HighlightMarkerLayer = exports.HighlightPolygonLayer = exports.SealandVec2dLayer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _ImageTileLayer2 = _interopRequireDefault(require("o_273"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Vector2dLayer = /*#__PURE__*/function (_ImageTileLayer) {
  (0, _inherits2["default"])(Vector2dLayer, _ImageTileLayer);

  var _super = _createSuper(Vector2dLayer);

  function Vector2dLayer(params) {
    var _this;

    (0, _classCallCheck2["default"])(this, Vector2dLayer);
    _this = _super.call(this, params);
    _this.provider = new CesiumVectorTile.VectorTileImageryProvider(params);

    if (params.focusAdminNames) {
      _this.provider.focusAdminNames = params.focusAdminNames;
      _this.provider.focusPropertyName = params.focusPropertyName || 'NAME';
    }

    return _this;
  }

  (0, _createClass2["default"])(Vector2dLayer, [{
    key: "focusAdminNames",
    get: function get() {
      return this.provider && this.provider.focusAdminNames;
    },
    set: function set(val) {
      this.provider && (this.provider.focusAdminNames = val);
    }
  }, {
    key: "focusPropertyName",
    get: function get() {
      return this.provider && this.provider.focusPropertyName;
    },
    set: function set(val) {
      this.provider && (this.provider.focusPropertyName = val);
    }
  }]);
  return Vector2dLayer;
}(_ImageTileLayer2["default"]);

var DefaultParams = {
  Sealand: {
    zIndex: 0,
    removeDuplicate: false,
    minimumLevel: 0,
    defaultStyle: {
      fill: true,
      //是否填充海陆颜色
      outlineColor: 'rgba(138,138,138,1)',
      //边界颜色
      fillColor: 'rgba(235,235,235,1)',
      //陆地颜色
      backgroundColor: 'rgba(89,129,188,1)' //海区颜色

    }
  },
  SealandDark: {
    zIndex: 0,
    removeDuplicate: false,
    minimumLevel: 0,
    defaultStyle: {
      fill: true,
      //是否填充海陆颜色
      outlineColor: 'rgba(138,138,138,1)',
      //边界颜色
      fillColor: 'rgb(3,3,30)',
      //陆地颜色 
      backgroundColor: 'rgb(10,13,44)' //海区颜色

    }
  },
  ChinaBorder: {
    zIndex: 999,
    minimumLevel: 0,
    defaultStyle: {
      lineWidth: 1.25,
      outlineColor: 'rgba(88,88,88,1)'
    }
  },
  Province: {
    zIndex: 998,
    minimumLevel: 0,
    removeDuplicate: true,
    defaultStyle: {
      lineWidth: 1,
      //lineDash: [1, 4],
      fill: true,
      outline: true,
      shadowColor: 'white',
      outlineColor: 'rgba(118,118,118,1)',
      fillColor: 'rgba(225,225,225, .5)'
    },
    styleFilter: function styleFilter(feature, style) {
      var highlight = true;

      if (this.focusAdminNames && this.focusAdminNames.length) {
        for (var i = 0; i < this.focusAdminNames.length; i++) {
          highlight = feature.properties[this.focusPropertyName] && feature.properties[this.focusPropertyName].toString().indexOf(this.focusAdminNames[i]) >= 0;
          if (highlight) break;
        }
      }

      if (highlight) {
        style.fill = false;
        style.outlineColor = Cesium.Color.BLACK;
        style.fillColor = Cesium.Color.WHITE;
        style.lineWidth = 1.25;
        style.lineDash = null;
      }

      return style;
    }
  },
  PlaceName: {
    minimumLevel: 3,
    zIndex: 999,
    defaultStyle: {
      showLabel: true,
      labelPropertyName: "name",
      showMaker: true,
      labelOffsetY: -12,
      fontFamily: 'heiti',
      pointColor: 'rgba(118,118,118,1)',
      labelStrokeWidth: 4,
      fontSize: 12,
      labelStroke: true,
      fontColor: 'white',
      labelStrokeColor: 'rgba(118,118,118,1)' //Cesium.Color.BLACK

    },
    styleFilter: function styleFilter(fc, style, x, y, level) {
      var highlight = true;

      if (this.focusAdminNames && this.focusAdminNames.length && fc.properties.province) {
        for (var i = 0; i < this.focusAdminNames.length; i++) {
          highlight = fc.properties.province.indexOf(this.focusAdminNames[i]) >= 0;
          if (highlight) break;

          if (fc.properties.city) {
            highlight = fc.properties.city.indexOf(this.focusAdminNames[i]) >= 0;
            if (highlight) break;
          }

          if (style.labelPropertyName && typeof fc.properties[style.labelPropertyName] == 'string') {
            highlight = fc.properties[style.labelPropertyName].indexOf(this.focusAdminNames[i]) >= 0;
            if (highlight) break;
          }
        }
      }

      if (highlight) {
        style.pointColor = Cesium.Color.BLACK;
      }

      if (fc.properties.adminType == 'province') {
        if (level > 14) {
          style.show = false;
        }

        style.showMaker = false;
        style.labelOffsetY = 0;
        style.fontSize = 16;

        if (highlight) {
          style.labelStrokeColor = Cesium.Color.fromBytes(160, 99, 57);
        } else {
          style.labelStrokeColor = Cesium.Color.fromBytes(140, 89, 47);
        }
      } else {
        if (fc.properties.adminType == 'city') {
          if (!fc.properties.cityCode.endsWith("0100") && level < 6) {
            style.show = false;
          } else if (level < 5) {
            style.show = false;
          }
        }

        if (fc.properties.adminType == 'county' && level < 9) {
          style.show = false;
        }

        if (fc.properties.adminType == 'country') {
          style.show = false;
        }

        if (level > 14) {
          style.fontSize = 18;
        }

        if (highlight) {
          style.labelStrokeColor = Cesium.Color.BLACK;
        }
      }

      if (level < 6) {
        style.fontSize = 9;
      }

      if (level > 4) {
        style.labelPropertyName = "name";
      } else {
        style.labelPropertyName = "nameabbrevation";
      }

      return style;
    }
  }
};
Vector2dLayer.DefaultParams = DefaultParams;

var SealandVec2dLayer = /*#__PURE__*/function (_Vector2dLayer) {
  (0, _inherits2["default"])(SealandVec2dLayer, _Vector2dLayer);

  var _super2 = _createSuper(SealandVec2dLayer);

  /**
   * 
   * @param {{
   * source:string
   * theme?:'dark'|'light'
   * }} options 
   */
  function SealandVec2dLayer(options) {
    (0, _classCallCheck2["default"])(this, SealandVec2dLayer);
    var theme = options.theme || 'light';
    var styleOptions = theme == 'dark' ? DefaultParams.SealandDark : DefaultParams.Sealand;
    return _super2.call(this, Object.assign({
      source: options.source
    }, styleOptions));
  }

  return SealandVec2dLayer;
}(Vector2dLayer);

exports.SealandVec2dLayer = SealandVec2dLayer;

var HighlightPolygonLayer = /*#__PURE__*/function (_Vector2dLayer2) {
  (0, _inherits2["default"])(HighlightPolygonLayer, _Vector2dLayer2);

  var _super3 = _createSuper(HighlightPolygonLayer);

  /**
   * 
   * @param {{
   * source:string
   * focusAdminNames?:string[]
   * focusPropertyName?:string
   * theme?:'dark'|'light'
   * minimumLevel?:number
   * }} options 
   */
  function HighlightPolygonLayer(options) {
    (0, _classCallCheck2["default"])(this, HighlightPolygonLayer);
    return _super3.call(this, {
      source: options.source,
      focusAdminNames: options.focusAdminNames,
      focusPropertyName: options.focusPropertyName,
      minimumLevel: options.minimumLevel || 1,
      removeDuplicate: true,
      zIndex: typeof options.zIndex != 'undefined' ? options.zIndex : 998,
      defaultStyle: {
        lineWidth: 1,
        // lineDash: [1, 4],
        fill: options.theme !== 'dark',
        outline: true,
        shadowColor: 'white',
        outlineColor: 'rgba(118,118,118,1)',
        fillColor: 'rgba(225,225,225, .5)'
      },
      styleFilter: function styleFilter(feature, style) {
        var highlight = true;

        if (this.focusAdminNames && this.focusAdminNames.length) {
          for (var i = 0; i < this.focusAdminNames.length; i++) {
            highlight = feature.properties[this.focusPropertyName] && feature.properties[this.focusPropertyName].toString().indexOf(this.focusAdminNames[i]) >= 0;
            if (highlight) break;
          }
        }

        if (highlight) {
          style.fill = false;

          if (options.theme == 'dark') {
            style.outlineColor = 'rgb(245,245,245)';
          } else {
            style.outlineColor = Cesium.Color.BLACK;
          }

          style.fillColor = Cesium.Color.WHITE;
          style.lineWidth = 1.25;
          style.lineDash = null;
        }

        return style;
      }
    });
  }

  return HighlightPolygonLayer;
}(Vector2dLayer);

exports.HighlightPolygonLayer = HighlightPolygonLayer;

var HighlightMarkerLayer = /*#__PURE__*/function (_Vector2dLayer3) {
  (0, _inherits2["default"])(HighlightMarkerLayer, _Vector2dLayer3);

  var _super4 = _createSuper(HighlightMarkerLayer);

  /**
   * 
   * @param {{
   * source:string
   * focusAdminNames?:string[]
   * focusPropertyName?:string
   * theme?:'dark'|'light'
   * }} options 
   */
  function HighlightMarkerLayer(options) {
    (0, _classCallCheck2["default"])(this, HighlightMarkerLayer);
    return _super4.call(this, {
      source: options.source,
      focusAdminNames: options.focusAdminNames,
      focusPropertyName: options.focusPropertyName,
      minimumLevel: 3,
      zIndex: typeof options.zIndex != 'undefined' ? options.zIndex : 999,
      defaultStyle: {
        showLabel: true,
        labelPropertyName: "name",
        showMaker: true,
        labelOffsetY: -12,
        fontFamily: 'heiti',
        pointColor: 'rgba(118,118,118,1)',
        labelStrokeWidth: 4,
        fontSize: 12,
        labelStroke: true,
        fontColor: 'white',
        labelStrokeColor: 'rgba(118,118,118,1)' //Cesium.Color.BLACK

      },
      styleFilter: function styleFilter(fc, style, x, y, level) {
        var highlight = true;

        if (this.focusAdminNames && this.focusAdminNames.length && fc.properties.province) {
          for (var i = 0; i < this.focusAdminNames.length; i++) {
            highlight = fc.properties.province.indexOf(this.focusAdminNames[i]) >= 0;
            if (highlight) break;

            if (fc.properties.city) {
              highlight = fc.properties.city.indexOf(this.focusAdminNames[i]) >= 0;
              if (highlight) break;
            }

            if (style.labelPropertyName && typeof fc.properties[style.labelPropertyName] == 'string') {
              highlight = fc.properties[style.labelPropertyName].indexOf(this.focusAdminNames[i]) >= 0;
              if (highlight) break;
            }
          }
        }

        if (highlight) {
          if (options.theme == 'dark') {
            style.pointColor = Cesium.Color.WHITE;
          } else {
            style.pointColor = Cesium.Color.BLACK;
          }
        }

        if (fc.properties.adminType == 'province') {
          if (level > 14) {
            style.show = false;
          }

          style.showMaker = false;
          style.labelOffsetY = 0;
          style.fontSize = 16;

          if (highlight) {
            style.labelStrokeColor = Cesium.Color.fromBytes(160, 99, 57);
          } else {
            style.labelStrokeColor = Cesium.Color.fromBytes(140, 89, 47);
          }
        } else {
          if (fc.properties.adminType == 'city') {
            if (!fc.properties.cityCode.endsWith("0100") && level < 6) {
              style.show = false;
            } else if (level < 5) {
              style.show = false;
            }
          }

          if (fc.properties.adminType == 'county' && level < 9) {
            style.show = false;
          }

          if (fc.properties.adminType == 'country') {
            style.show = false;
          }

          if (level > 14) {
            style.fontSize = 18;
          }

          if (highlight) {
            if (options.theme == 'dark') {
              style.labelStrokeColor = 'rgb(10,13,44)';
            } else {
              style.labelStrokeColor = Cesium.Color.BLACK;
            }
          }
        }

        if (level < 6) {
          style.fontSize = 9;
        }

        if (level > 4) {
          style.labelPropertyName = "name";
        } else {
          style.labelPropertyName = "nameabbrevation";
        }

        return style;
      }
    });
  }

  return HighlightMarkerLayer;
}(Vector2dLayer);

exports.HighlightMarkerLayer = HighlightMarkerLayer;

var LabelVec2dLayer = /*#__PURE__*/function (_Vector2dLayer4) {
  (0, _inherits2["default"])(LabelVec2dLayer, _Vector2dLayer4);

  var _super5 = _createSuper(LabelVec2dLayer);

  /**
   * 
   * @param {{
   * source:string
   * minimumLevel?:number
   * maximumLevel?: number
   * }} options 
   */
  function LabelVec2dLayer(options) {
    (0, _classCallCheck2["default"])(this, LabelVec2dLayer);
    return _super5.call(this, {
      source: options.source,
      minimumLevel: options.minimumLevel || 12,
      maximumLevel: options.maximumLevel || 20,
      zIndex: typeof options.zIndex != 'undefined' ? options.zIndex : 9999,
      defaultStyle: {
        showLabel: true,
        labelPropertyName: "NAME",
        showMarker: false,
        labelOffsetY: -12,
        fontFamily: 'heiti',
        pointColor: 'rgba(118,118,118,1)',
        labelStrokeWidth: 4,
        fontSize: 12,
        labelStroke: true,
        fontColor: 'white',
        labelStrokeColor: 'rgba(118,118,118,1)'
      }
    });
  }

  return LabelVec2dLayer;
}(Vector2dLayer);

exports.LabelVec2dLayer = LabelVec2dLayer;

var CountryVec2dLayer = /*#__PURE__*/function (_Vector2dLayer5) {
  (0, _inherits2["default"])(CountryVec2dLayer, _Vector2dLayer5);

  var _super6 = _createSuper(CountryVec2dLayer);

  /**
   * 
   * @param {{
   * source:string
   * theme?:'dark'|'light'
   * }} options 
   */
  function CountryVec2dLayer(options) {
    (0, _classCallCheck2["default"])(this, CountryVec2dLayer);
    return _super6.call(this, {
      source: options.source,
      zIndex: typeof options.zIndex != 'undefined' ? options.zIndex : 999,
      minimumLevel: 0,
      defaultStyle: {
        lineWidth: 2,
        outlineColor: options.theme == 'dark' ? 'white' : 'rgba(88,88,88,1)'
      }
    });
  }

  return CountryVec2dLayer;
}(Vector2dLayer);

exports.CountryVec2dLayer = CountryVec2dLayer;
var _default = Vector2dLayer;
exports["default"] = _default;

},{"o_273":56,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],67:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _GeometryUtils = _interopRequireDefault(require("h_234"));

var _ExtrudedPolygonGeometry = _interopRequireDefault(require("h_278"));

var _GenericWorker = _interopRequireDefault(require("-_279"));

var _GeoPolygonGeometry = _interopRequireDefault(require("-_235"));

// import MeshVisualizer from "../../../core/MeshVisualizer.js";
function getPickId(feature, provider) {
  var pickIdMap = provider._pickIdMap;
  var pickId = pickIdMap.get(feature);

  if (!pickId) {
    var context = provider.localScene.frameState.context;
    pickId = context.createPickId({
      feature: feature,
      primitive: provider.root
    });
    pickIdMap.set(feature, pickId);
    provider.pickIds.push(pickId);
  }

  return pickId;
}

var Vector3DStandardProvider = /*#__PURE__*/function () {
  /**
   * 
   * @param {*} root 
   * @param {*} styleFilter 
   * @param {MeshVisualizer} localScene 
   * @param  {THREE.Vector2|Cesium.Cartesian2}uvUnit
   * @param  {boolean}[roundUv=false]
   * @param  {boolean}[useUvUnit=true]
   */
  function Vector3DStandardProvider(root, styleFilter, localScene, uvUnit, roundUv, useUvUnit) {
    (0, _classCallCheck2["default"])(this, Vector3DStandardProvider);
    var defaultValue = Cesium.defaultValue;
    this.root = root;
    this.styleFilter = styleFilter;
    this.localScene = localScene;
    this.uvUnit = uvUnit;
    this.roundUv = defaultValue(roundUv, false);
    this.useUvUnit = defaultValue(useUvUnit, true);
    this.pickIds = [];
    this._pickIdMap = new Map();
    this.terrainProvider = null;
    this.clampToGround = false;
    this.receiveShadow = true;
    this.castShadow = true;
  }

  (0, _createClass2["default"])(Vector3DStandardProvider, [{
    key: "destroy",
    value: function destroy() {
      this._pickIdMap.clear();

      this.pickIds.splice(0);
    }
  }, {
    key: "createMesh",
    value: function createMesh(feature, overrideUvUnit, createTopExtrudedUvNormal, createBottomExtrudedUvNormal, closeTop, uvGenerator, rtcCenter) {
      var styleFilter = this.styleFilter;
      var _THREE = THREE,
          Mesh = _THREE.Mesh;
      var _Cesium = Cesium,
          Cartesian3 = _Cesium.Cartesian3,
          Cartographic = _Cesium.Cartographic,
          defaultValue = _Cesium.defaultValue;
      var provider = this;
      /**
       * @type {MeshVisualizer}
       */

      var localScene = provider.localScene;
      var uvUnit = defaultValue(overrideUvUnit, provider.uvUnit);
      createTopExtrudedUvNormal = defaultValue(createTopExtrudedUvNormal, true);
      createBottomExtrudedUvNormal = defaultValue(createBottomExtrudedUvNormal, true);
      var roundUv = provider.roundUv;
      var useUvUnit = provider.useUvUnit;
      var clampToGround = provider.clampToGround;
      var terrainProvider = provider.terrainProvider;
      var style = {
        useUvUnit: useUvUnit,
        roundUv: roundUv,
        receiveShadow: this.receiveShadow,
        castShadow: this.castShadow
      };
      styleFilter(feature, style);
      var extrudedHeight = style.extrudedHeight; //|| 1

      var height = 0;

      if (clampToGround && feature.properties._terrianHeight && terrainProvider) {
        height = feature.properties._terrianHeight;
      }

      var geometry = _GeoPolygonGeometry["default"].fromFeature(feature, clampToGround ? height : null, height + extrudedHeight, uvGenerator, closeTop);

      if (extrudedHeight) {
        geometry = _ExtrudedPolygonGeometry["default"].createExtrudedUvNormal(geometry, height, style.useUvUnit ? style.uvUnit || uvUnit : null, style.roundUv, createTopExtrudedUvNormal, createBottomExtrudedUvNormal);
        geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
        geometry.attributes.uv = geometry.attributes.extrudedUv;
        geometry.deleteAttribute('extrudedUv');
        geometry.deleteAttribute('extrudedNormal');
      } else {
        geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
      }

      if (rtcCenter) {
        var positions = geometry.attributes.position.array;

        for (var i = 0; i < positions.length; i += 3) {
          positions[i] -= rtcCenter.x;
          positions[i + 1] -= rtcCenter.y;
          positions[i + 2] -= rtcCenter.z;
        }
      } else {
        var _positions = geometry.attributes.position.array;
        var cartesian3 = new Cartesian3();
        var cartographic = new Cartographic();
        var hs = [],
            maxY = 0;

        for (var _i = 0; _i < _positions.length; _i += 3) {
          cartesian3.x = _positions[_i];
          cartesian3.y = _positions[_i + 1];
          cartesian3.z = _positions[_i + 2];
          Cartographic.fromCartesian(cartesian3, null, cartographic);
          hs.push(cartographic.height - height);
          localScene.worldCoordinatesToLocal(cartesian3, cartesian3, {
            y: 1
          });
          _positions[_i] = cartesian3.x;
          _positions[_i + 1] = cartesian3.y;
          _positions[_i + 2] = cartesian3.z;
          maxY = Math.max(cartesian3.y, maxY);
        }

        if (extrudedHeight) {
          var eps = extrudedHeight * 0.1,
              id = 0;

          for (var _i2 = 0; _i2 < hs.length; _i2++) {
            var h = hs[_i2];

            if (h >= eps) {
              //top
              _positions[id + 1] = maxY;
            }

            id += 3;
          }
        }

        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();
      }

      var mesh = new Mesh(geometry, style.material);
      return mesh;
    }
  }, {
    key: "requestContent",
    value: function requestContent(contentSet, rtcCenter) {
      var groups = [],
          materialMap = new WeakMap();
      var root = this.root,
          styleFilter = this.styleFilter;
      var _THREE2 = THREE,
          Object3D = _THREE2.Object3D,
          Mesh = _THREE2.Mesh,
          BufferAttribute = _THREE2.BufferAttribute;
      var _Cesium2 = Cesium,
          Cartesian3 = _Cesium2.Cartesian3,
          Cartographic = _Cesium2.Cartographic,
          BoundingSphere = _Cesium2.BoundingSphere,
          sampleTerrainMostDetailed = _Cesium2.sampleTerrainMostDetailed;
      var provider = this;
      /**
       * @type {MeshVisualizer}
       */

      var localScene = provider.localScene; // const uvUnit = provider.uvUnit;
      // const roundUv = provider.roundUv;
      // const useUvUnit = provider.useUvUnit;
      // const clampToGround = provider.clampToGround;
      // const terrainProvider = provider.terrainProvider;

      var uvUnit = provider.uvUnit,
          roundUv = provider.roundUv,
          useUvUnit = provider.useUvUnit,
          clampToGround = provider.clampToGround,
          terrainProvider = provider.terrainProvider,
          receiveShadow = provider.receiveShadow,
          castShadow = provider.castShadow;

      function createContent(content) {
        var group,
            style = {
          useUvUnit: useUvUnit,
          roundUv: roundUv
        },
            feature = content.uri;
        var featureId = feature.properties.featureId;
        styleFilter(feature, style);
        var extrudedHeight = style.extrudedHeight; //|| 1

        var height = 0;

        if (provider.clampToGround && feature.properties._terrianHeight && provider.terrainProvider) {
          height = feature.properties._terrianHeight;
        }

        var geometry = _GeoPolygonGeometry["default"].fromFeature(feature, provider.clampToGround ? height : null, height + extrudedHeight);

        if (extrudedHeight) {
          geometry = _ExtrudedPolygonGeometry["default"].createExtrudedUvNormal(geometry, height, style.useUvUnit ? style.uvUnit || uvUnit : null, style.roundUv);
          geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
          geometry.attributes.uv = geometry.attributes.extrudedUv;
          geometry.deleteAttribute('extrudedUv');
          geometry.deleteAttribute('extrudedNormal');
        } else {
          geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
        }

        var ptCount = geometry.attributes.position.count;
        var batchIds = new Float32Array(ptCount);
        batchIds.fill(featureId);
        geometry.setAttribute('batchId', new BufferAttribute(batchIds, 1, false));
        var material = style.material; //pickColors

        material.pickColorQualifier = 'varying';
        material.pickColorName = 'pickColor';
        if (!geometry.boundingSphere) geometry.computeBoundingSphere();
        var pickId = getPickId(feature, provider);
        pickId.object.boundingSphere = BoundingSphere.clone(geometry.boundingSphere);
        var pickColors = [],
            _pickId$color = pickId.color,
            red = _pickId$color.red,
            green = _pickId$color.green,
            blue = _pickId$color.blue,
            alpha = _pickId$color.alpha;

        for (var i = 0; i < ptCount; i++) {
          pickColors.push(red, green, blue, alpha);
        }

        pickColors = new Float32Array(pickColors);
        geometry.setAttribute('pickColor', new BufferAttribute(pickColors, 4, false));

        if (rtcCenter) {
          var positions = geometry.attributes.position.array;

          for (var _i3 = 0; _i3 < positions.length; _i3 += 3) {
            positions[_i3] -= rtcCenter.x;
            positions[_i3 + 1] -= rtcCenter.y;
            positions[_i3 + 2] -= rtcCenter.z;
          }
        } else {
          var _positions2 = geometry.attributes.position.array;
          var cartesian3 = new Cartesian3();
          var cartographic = new Cartographic();
          var hs = [],
              maxY = 0;

          for (var _i4 = 0; _i4 < _positions2.length; _i4 += 3) {
            cartesian3.x = _positions2[_i4];
            cartesian3.y = _positions2[_i4 + 1];
            cartesian3.z = _positions2[_i4 + 2];
            Cartographic.fromCartesian(cartesian3, null, cartographic);
            hs.push(cartographic.height - height);
            localScene.worldCoordinatesToLocal(cartesian3, cartesian3, {
              y: 1
            });
            _positions2[_i4] = cartesian3.x;
            _positions2[_i4 + 1] = cartesian3.y;
            _positions2[_i4 + 2] = cartesian3.z;
            maxY = Math.max(cartesian3.y, maxY);
          }

          if (extrudedHeight) {
            var eps = extrudedHeight * 0.1,
                id = 0;

            for (var _i5 = 0; _i5 < hs.length; _i5++) {
              var h = hs[_i5];

              if (h >= eps) {
                //top
                _positions2[id + 1] = maxY;
              }

              id += 3;
            }
          }

          geometry.computeVertexNormals();
          geometry.computeBoundingSphere();
        }

        if (materialMap.has(material)) {
          group = materialMap.get(material);
        } else {
          group = {
            material: material,
            geometries: []
          };
          groups.push(group);
          materialMap.set(material, group);
        }

        group.geometries.push(geometry);
      }

      var batchList = [],
          batch = [],
          batchSize = 100,
          features = [];
      batchList.push(batch);
      contentSet.contain.forEach(function (content) {
        if (batch.length > batchSize) {
          batch = [];
          batchList.push(batch);
        }

        var feature = content.uri;

        if (feature.properties._terrianHeight == undefined) {
          features.push(feature);
        }

        batch.push(content);
      });
      contentSet.intersect.forEach(function (content) {
        if (batch.length > batchSize) {
          batch = [];
          batchList.push(batch);
        }

        var feature = content.uri;

        if (feature.properties._terrianHeight == undefined) {
          features.push(feature);
        }

        batch.push(content);
      }); //贴地情况下，检查各要素中心地形是否有值，如果没有则请求最高分辨率的地形

      var terrianPromise = null;

      if (clampToGround && terrainProvider && features.length) {
        terrianPromise = new Promise(function (resolve, reject) {
          var positions = features.map(function (feature) {
            var bbox = feature.geometry.bbox;
            var lon = (bbox[0] + bbox[2]) / 2.,
                lat = (bbox[1] + bbox[3]) / 2.;
            return Cartographic.fromDegrees(lon, lat);
          });
          sampleTerrainMostDetailed(terrainProvider, positions).then(function (positions) {
            for (var i = 0; i < positions.length; i++) {
              var feature = features[i];
              feature.properties._terrianHeight = positions[i].height || 0;
            }

            features.length = 0;
            resolve();
          }).otherwise(function (err) {
            features.length = 0;
            reject(err);
          });
        });
      }

      return Promise.all([terrianPromise]).then(function () {
        return new _GenericWorker["default"](batchList, function (batch) {
          for (var i = 0; i < batch.length; i++) {
            var el = batch[i];

            try {
              createContent(el);
            } catch (err) {
              console.error(err);
            }
          }
        }).run().then(function () {
          var object3d = new Object3D();
          groups.forEach(function (group) {
            var geometry = _GeometryUtils["default"].mergeGeometries3js(group.geometries);

            var material = group.material;
            var mesh = new Mesh(geometry, material);
            mesh.pickObject = {
              id: mesh,
              mesh: mesh,
              primitive: root
            };
            mesh.receiveShadow = receiveShadow;
            mesh.castShadow = castShadow;
            object3d.add(mesh);

            if (rtcCenter) {
              mesh.matrixAutoUpdate = false;
              mesh.modelMatrixNeedsUpdate = false;
            }

            mesh.frustumCulled = false;
            materialMap["delete"](material);
          });

          if (rtcCenter) {
            object3d.matrixAutoUpdate = false;
            object3d.modelMatrixNeedsUpdate = false;
          }

          object3d.frustumCulled = false;
          groups.splice(0); // contentSet.contain.splice(0)
          // contentSet.intersect.splice(0)

          return object3d;
        });
      });
    }
  }]);
  return Vector3DStandardProvider;
}();

exports["default"] = Vector3DStandardProvider;

},{"h_234":2,"-_279":189,"h_278":42,"-_235":43,"e_1":235,"s_2":236,"M_0":241}],68:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _GeometryUtils = _interopRequireDefault(require("h_234"));

var _SolidWireframeGeometry = _interopRequireDefault(require("m_285"));

var _BuildingVector3DLoader = _interopRequireDefault(require("M_286"));

var _GenericWorker = _interopRequireDefault(require("-_279"));

var Vector3DWireframeProvider = /*#__PURE__*/function () {
  function Vector3DWireframeProvider(root, styleFilter) {
    (0, _classCallCheck2["default"])(this, Vector3DWireframeProvider);
    this.root = root;
    this.styleFilter = styleFilter;
  }

  (0, _createClass2["default"])(Vector3DWireframeProvider, [{
    key: "requestContent",
    value: function requestContent(contentSet, rtcCenter) {
      var groups = [],
          materialMap = new WeakMap();
      var root = this.root,
          styleFilter = this.styleFilter;
      var _THREE = THREE,
          Object3D = _THREE.Object3D,
          Mesh = _THREE.Mesh;

      function createContent(content) {
        var group,
            style = {},
            feature = content.uri;
        var featureId = feature.properties.featureId;
        styleFilter(feature, style);

        var geometry = _BuildingVector3DLoader["default"].parseFeature(feature, featureId, style);

        var material = style.material;

        if (rtcCenter) {
          if (!(geometry instanceof Cesium.Geometry)) {
            geometry = geometry.constructor.createGeometry(geometry);
          }

          geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
          geometry = new _SolidWireframeGeometry["default"](geometry, true);
          var positions = geometry.attributes.position.array;

          for (var i = 0; i < positions.length; i += 3) {
            positions[i] -= rtcCenter.x;
            positions[i + 1] -= rtcCenter.y;
            positions[i + 2] -= rtcCenter.z;
          }
        } else {
          geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
          geometry = new _SolidWireframeGeometry["default"](geometry, true);
        }

        if (materialMap.has(material)) {
          group = materialMap.get(material);
        } else {
          group = {
            material: material,
            geometries: []
          };
          groups.push(group);
          materialMap.set(material, group);
        }

        group.geometries.push(geometry);
      }

      var batchList = [],
          batch = [],
          batchSize = 100;
      batchList.push(batch);
      contentSet.contain.forEach(function (content) {
        if (batch.length > batchSize) {
          batch = [];
          batchList.push(batch);
        }

        batch.push(content);
      });
      contentSet.intersect.forEach(function (content) {
        if (batch.length > batchSize) {
          batch = [];
          batchList.push(batch);
        }

        batch.push(content);
      });
      return new _GenericWorker["default"](batchList, function (batch) {
        batch.forEach(createContent);
      }).run().then(function () {
        var object3d = new Object3D();
        groups.forEach(function (group) {
          var geometry = _GeometryUtils["default"].mergeGeometries3js(group.geometries);

          var material = group.material;
          var mesh = new Mesh(geometry, material);
          mesh.pickObject = {
            id: mesh,
            mesh: mesh,
            primitive: root
          };
          object3d.add(mesh);
          mesh.matrixAutoUpdate = false;
          mesh.modelMatrixNeedsUpdate = false;
          mesh.frustumCulled = false;
          materialMap["delete"](material);
        });
        object3d.matrixAutoUpdate = false;
        object3d.modelMatrixNeedsUpdate = false;
        object3d.frustumCulled = false;
        groups.splice(0);
        contentSet.contain.splice(0);
        contentSet.intersect.splice(0);
        return object3d;
      });
    }
  }]);
  return Vector3DWireframeProvider;
}();

exports["default"] = Vector3DWireframeProvider;

},{"h_234":2,"M_286":75,"-_279":189,"m_285":45,"e_1":235,"s_2":236,"M_0":241}],69:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BuildingVector3DLoader = _interopRequireDefault(require("M_286"));

var _Vector3DWireframeProvider = _interopRequireDefault(require("o_295"));

var _Earth = _interopRequireDefault(require("C_217"));

var _ILayer2 = _interopRequireDefault(require("-_202"));

var _SolidWireframeMaterial = _interopRequireDefault(require("e_298"));

var _Vector3DStandardProvider = _interopRequireDefault(require("s_299"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Vector3dLayer = /*#__PURE__*/function (_ILayer) {
  (0, _inherits2["default"])(Vector3dLayer, _ILayer);

  var _super = _createSuper(Vector3dLayer);

  /**
   * 
   * @param {object} params 
   * @param {string} params.url 
   * @param {string} [params.property='Floor'] 用于计算拉伸高度的geojson属性名称
   * @param {string} [params.scale=4] 拉伸系数
   * @param {'gradient'|'standard'|'wireframe'} [params.style='gradient'] 
   * @param {THREE.Material} [params.material]
   * @param {THREE.Vec2|Cesium.Cartesian2} [params.uvUnit]
   * @param {number} [params.lodMinRange=8]
   * @param {boolean} [params.debugVolume]
   */
  function Vector3dLayer(params) {
    var _this;

    (0, _classCallCheck2["default"])(this, Vector3dLayer);
    var _Cesium = Cesium,
        Color = _Cesium.Color,
        defaultValue = _Cesium.defaultValue,
        Event = _Cesium.Event; // if (params.clampToGround && !params.terrainProvider) {
    //     throw new Error('Vector3dLayer#constructor:terrainProvider is required when clampToGround is true')
    // }

    params.style = params.style || 'standard';
    _this = _super.call(this, params);
    _this.url = params.url;
    _this.useRtcCenter = defaultValue(params.useRtcCenter, params.style != 'standard');
    _this._property = params.property || 'Floor';
    _this._scale = typeof params.scale == 'number' ? params.scale : 4;
    _this.lodMinRange = params.lodMinRange || 8;
    _this.bottomColor = params.bottomColor || Color.DARKBLUE.clone();
    _this.topColor = params.topColor || Color.CYAN.clone();
    _this.debugVolume = defaultValue(params.debugVolume, false);
    _this.style = params.style;
    _this._styleFilter = params.styleFilter;
    _this._uvUnit = params.uvUnit;
    _this._roundUv = defaultValue(params.roundUv, false);
    _this._lodContentProvider = null;
    _this._material = params.material;
    _this._terrainProvider = null; //params.terrainProvider

    _this._clampToGround = defaultValue(params.clampToGround, false);
    _this._receiveShadow = defaultValue(params.receiveShadow, true);
    _this._castShadow = defaultValue(params.castShadow, true);
    _this.root = null;
    _this.onBeforeLoad = new Event();
    _this.onLoading = new Event();
    _this.onLoaded = new Event();
    _this.onDataLoaded = new Event();
    return _this;
  }

  (0, _createClass2["default"])(Vector3dLayer, [{
    key: "property",
    get: function get() {
      return this._property;
    },
    set: function set(val) {
      if (this._property != val) {
        this._property = val;
        this.needsUpdate = true;
      }
    }
  }, {
    key: "scale",
    get: function get() {
      return this._scale;
    },
    set: function set(val) {
      if (this._scale != val) {
        this._scale = val;
        this.needsUpdate = true;
      }
    }
  }, {
    key: "receiveShadow",
    get: function get() {
      return this._receiveShadow;
    },
    set: function set(val) {
      if (this._receiveShadow != val) {
        this._receiveShadow = val;

        if (this._lodContentProvider) {
          this._lodContentProvider.receiveShadow = val;
        }

        this.needsUpdate = true;
      }
    }
  }, {
    key: "castShadow",
    get: function get() {
      return this._castShadow;
    },
    set: function set(val) {
      if (this._castShadow != val) {
        this._castShadow = val;

        if (this._lodContentProvider) {
          this._lodContentProvider.castShadow = val;
        }

        this.needsUpdate = true;
      }
    }
  }, {
    key: "material",
    get: function get() {
      return this._material;
    },
    set: function set(val) {
      if (this._material != val) {
        this._material = val;
        this.needsUpdate = true;
      }
    }
  }, {
    key: "contentProvider",
    get: function get() {
      return this._lodContentProvider;
    }
  }, {
    key: "clampToGround",
    get: function get() {
      return this._clampToGround;
    },
    set: function set(val) {
      if (this._clampToGround != val) {
        this._clampToGround = val;

        if (this._lodContentProvider) {
          this._lodContentProvider.clampToGround = val;
        }

        this.needsUpdate = true;
      }
    }
  }, {
    key: "terrainProvider",
    get: function get() {
      return this._terrainProvider;
    },
    set: function set(val) {
      if (this._terrainProvider != val) {
        this._terrainProvider = val;

        if (this._lodContentProvider) {
          this._lodContentProvider.terrainProvider = val;
        }

        this.needsUpdate = true;
      }
    }
  }, {
    key: "roundUv",
    get: function get() {
      return this._roundUv;
    },
    set: function set(val) {
      if (val != this._roundUv) {
        this._roundUv = val;

        if (this._lodContentProvider) {
          this._lodContentProvider.roundUv = this._roundUv;
        }

        this.needsUpdate = true;
      }
    }
  }, {
    key: "uvUnit",
    get: function get() {
      return this._uvUnit;
    },
    set: function set(val) {
      if (this._uvUnit != val) {
        this._uvUnit = val;

        if (this._lodContentProvider) {
          this._lodContentProvider.uvUnit = this.uvUnit;
        }

        this.needsUpdate = true;
      }
    }
  }, {
    key: "styleFilter",
    get: function get() {
      return this._styleFilter;
    },
    set: function set(val) {
      if (this.style != 'standard') return;

      if (typeof val == 'function' && val != this._styleFilter) {
        this._styleFilter = val;
        if (this._lodContentProvider) this._lodContentProvider.styleFilter = val;
        this.needsUpdate = true;
      }
    }
  }, {
    key: "needsUpdate",
    set: function set(val) {
      if (val && this.root) {
        this.root.needsUpdate = true;
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
      if (this.root) this.root.show = val;
    }
  }, {
    key: "boundingSphere",
    get: function get() {
      if (this.root) {
        return this.root.boundingSphereWC;
      }
    }
    /**
     * 
     * @param {Earth|MeshVisualizer} earth 
     */

  }, {
    key: "load",
    value: function load(earth) {
      var _this2 = this;

      this.onBeforeLoad.raiseEvent(this);
      var localScene = earth.isMeshVisualizer ? earth : earth.globalScene;
      var material = this.material,
          contentProviderClass = _Vector3DStandardProvider["default"];

      switch (this.style) {
        // case 'gradient':
        //     material = new ExtrudeGradientMaterial({
        //         useExtrudedUvNormal: true,
        //         uniforms: {
        //             bottomColor: this.bottomColor,
        //             topColor: this.topColor
        //         }
        //     })
        //     contentProviderClass = Vector3DGradientProvider
        //     break;
        case 'wireframe':
          material = new _SolidWireframeMaterial["default"]({
            lineColor: new THREE.Color('white'),
            faceColor: new THREE.Color(0x84fa),
            lineWidth: 1,
            faceOpacity: 0.5,
            transparent: true,
            depthTest: false
          });
          contentProviderClass = _Vector3DWireframeProvider["default"];
          break;
      }

      this.material = material;
      var styleFilter = this.style == 'standard' && typeof this.styleFilter == 'function' ? this.styleFilter : function (feature, style) {
        style.extrudedHeight = feature.properties[_this2.property] * _this2.scale;
        style.material = _this2.material;
      };
      var lodContentProvider = new contentProviderClass(null, styleFilter, localScene, this.uvUnit, this.roundUv);
      this._lodContentProvider = lodContentProvider;
      lodContentProvider.clampToGround = this.clampToGround;
      lodContentProvider.terrainProvider = this.terrainProvider;

      _BuildingVector3DLoader["default"].load(this.url, styleFilter, function (progress) {
        // console.log('Loading:' + progress.toFixed(1) + '%');
        _this2.onLoading.raiseEvent(_this2, progress);
      }, function (geojson) {
        _this2.onDataLoaded.raiseEvent(geojson);
      }, {
        minRange: this.lodMinRange,
        debugVolume: true,
        showDebugVolume: this.debugVolume,
        debugVolumeColor: Cesium.Color.BLACK,
        useRtcCenter: this.useRtcCenter,
        getLodContentProvider: function getLodContentProvider(root, styleFilter) {
          lodContentProvider.root = root;
          return lodContentProvider;
        }
      }).then(function (root) {
        _this2.root = root;
        root.show = _this2.show;
        localScene.add(root);

        _this2.onLoaded.raiseEvent(_this2);
      });
      /**
       * @type {Cesium.Scene}
       */


      var scene = localScene.scene;
      this._removeBeforeUpdateCb = localScene.beforeUpdate.addEventListener(function () {
        if (scene.terrainProvider instanceof Cesium.EllipsoidTerrainProvider) {
          _this2.terrainProvider = null;
        } else if (_this2._terrainProvider != scene.terrainProvider) {
          _this2.terrainProvider = scene.terrainProvider;
        }
      });
    }
    /**
     * 
     * @param {Earth|MeshVisualizer} earth 
     */

  }, {
    key: "unload",
    value: function unload(earth) {
      var _removeBeforeUpdateCb = this._removeBeforeUpdateCb,
          root = this.root,
          _lodContentProvider = this._lodContentProvider;
      if (_removeBeforeUpdateCb) _removeBeforeUpdateCb();
      if (!root) return;
      _lodContentProvider.destroy && _lodContentProvider.destroy();
      this.root = root.destroy();
    }
  }]);
  return Vector3dLayer;
}(_ILayer2["default"]);

var _default = Vector3dLayer;
exports["default"] = _default;

},{"M_286":75,"C_217":40,"e_298":70,"-_202":55,"s_299":67,"o_295":68,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * 
 * @param {object} parameters 
 * @param {THREE.Color} parameters.lineColor 
 * @param {number} parameters.lineOpacity
 * @param {THREE.Color} parameters.faceColor
 * @param {number} parameters.faceOpacity
 * @constructor
 * @extends THREE.ShaderMaterial
 */
function SolidWireframeMaterial() {
  var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _THREE = THREE,
      ShaderMaterial = _THREE.ShaderMaterial,
      Color = _THREE.Color;
  var shader = SolidWireframeMaterial.Shader;
  parameters = Object.assign({
    uniforms: {
      "lineWidth": {
        type: "f",
        value: typeof parameters.lineWidth == 'number' ? parameters.lineWidth : 4.0
      },
      "faceColor": {
        type: "c",
        value: parameters.faceColor || new Color(0x222222)
      },
      "faceOpacity": {
        type: "f",
        value: typeof parameters.faceOpacity == 'number' ? parameters.faceOpacity : 1.0
      },
      "lineColor": {
        type: "c",
        value: parameters.lineColor || new Color(0xffffff)
      },
      "lineOpacity": {
        type: "f",
        value: typeof parameters.lineOpacity == 'number' ? parameters.lineOpacity : 1.0
      }
    },
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  }, parameters);
  delete parameters.lineWidth;
  delete parameters.faceColor;
  delete parameters.faceOpacity;
  delete parameters.lineColor;
  delete parameters.lineOpacity;
  var material = new ShaderMaterial(parameters);
  var uniforms = material.uniforms;
  var defineProperty = Object.defineProperty;

  function defNumProp(name) {
    defineProperty(material, name, {
      get: function get() {
        return uniforms[name].value;
      },
      set: function set(val) {
        uniforms[name].value = val;
      }
    });
  }

  function defColorProp(name) {
    defineProperty(material, name, {
      get: function get() {
        return uniforms[name].value;
      },
      set: function set(val) {
        if (val != null && val != undefined) uniforms[name].value.set(val);
      }
    });
  }

  defColorProp('lineColor');
  defColorProp('faceColor');
  defNumProp('lineWidth');
  defNumProp('faceOpacity');
  defNumProp('lineOpacity');
  return material;
}

SolidWireframeMaterial.Shader = {
  vertexShader: ["attribute vec4 center;", "varying vec4 vCenter;", "void main() {", "   vCenter = center;", "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join('\n'),
  fragmentShader: ["#extension GL_OES_standard_derivatives : enable", "varying vec4 vCenter;", // control parameter
  "uniform float lineWidth;", "uniform float faceOpacity;", "uniform float lineOpacity;", "uniform vec3 faceColor;", "uniform vec3 lineColor;", "float _lineWidth;", "float edgeFactorTri() {", "   vec3 d = fwidth( vCenter.xyz );", "   vec3 a3 = smoothstep( vec3( 0.0 ), d * _lineWidth , vCenter.xyz );", "   return min( min( a3.x, a3.y ), a3.z );", "}", "float edgeFactorQuad1() {", "   vec2 d = fwidth( vCenter.xy );", "   vec2 a2 = smoothstep( vec2( 0.0 ), d * _lineWidth , vCenter.xy );", "   return min( a2.x, a2.y );", "}", "float edgeFactorQuad2() {", "   vec2 d = fwidth( 1.0 - vCenter.xy );", "   vec2 a2 = smoothstep( vec2( 0.0 ), d * _lineWidth , 1.0 - vCenter.xy );", "   return min( a2.x, a2.y );", "}", "void main() {", "   _lineWidth=lineWidth * czm_pixelRatio;", "   vec4 _lineColor=vec4( lineColor , lineOpacity );", "   vec4 _faceColor=vec4( faceColor , faceOpacity );", // "   if(length(vCenter)==0.)gl_FragColor =_faceColor;",
  // "else",
  "   if ( vCenter.w == 0.0 ) {", "       gl_FragColor = mix( _lineColor , _faceColor , edgeFactorTri() );", "   } else {", "       gl_FragColor = mix( _lineColor, _faceColor, min( edgeFactorQuad1(), edgeFactorQuad2() ) );", "   }", "}"].join('\n')
};
var _default = SolidWireframeMaterial;
exports["default"] = _default;

},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("h_300");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

},{"h_300":47}],72:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Batched3DModel3DTileContentEx = Batched3DModel3DTileContentEx;

var _MeshVisModel = _interopRequireDefault(require("3_302"));

var Cartesian3;
var Color;
var ComponentDatatype;
var defaultValue;
var defined;
var deprecationWarning;
var destroyObject;
var DeveloperError;
var getStringFromTypedArray;
var Matrix4;
var RuntimeError;
var Cesium3DTileBatchTable;
var Cesium3DTileFeature;
var Cesium3DTileFeatureTable;
var initDeps$B3DMTileContentDone = false;

function initDeps$B3DMTileContent() {
  if (initDeps$B3DMTileContentDone) return;
  initDeps$B3DMTileContentDone = true;
  var _Cesium = Cesium;
  Cartesian3 = _Cesium.Cartesian3;
  Color = _Cesium.Color;
  ComponentDatatype = _Cesium.ComponentDatatype;
  defaultValue = _Cesium.defaultValue;
  defined = _Cesium.defined;
  deprecationWarning = _Cesium.deprecationWarning;
  destroyObject = _Cesium.destroyObject;
  DeveloperError = _Cesium.DeveloperError;
  getStringFromTypedArray = _Cesium.getStringFromTypedArray;
  Matrix4 = _Cesium.Matrix4;
  RuntimeError = _Cesium.RuntimeError;
  Cesium3DTileBatchTable = _Cesium.Cesium3DTileBatchTable;
  Cesium3DTileFeature = _Cesium.Cesium3DTileFeature;
  Cesium3DTileFeatureTable = _Cesium.Cesium3DTileFeatureTable;
  Batched3DModel3DTileContentEx._deprecationWarning = deprecationWarning;
}
/**
 * Represents the contents of a
 * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Batched3DModel|Batched 3D Model}
 * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification|3D Tiles} tileset.
 * <p>
 * Implements the {@link Cesium3DTileContent} interface.
 * </p>
 *
 * @alias Batched3DModel3DTileContentEx
 * @constructor
 *
 * @private
 */


function Batched3DModel3DTileContentEx(tileset, tile, resource, arrayBuffer, byteOffset, visualizer) {
  initDeps$B3DMTileContent();
  this._tileset = tileset;
  this._tile = tile;
  this._resource = resource;
  this._model = undefined;
  this._batchTable = undefined;
  this._features = undefined; // Populate from gltf when available

  this._batchIdAttributeName = undefined;
  this._diffuseAttributeOrUniformName = {};
  this._rtcCenterTransform = undefined;
  this._contentModelMatrix = undefined;
  this.featurePropertiesDirty = false;
  this._visualizer = visualizer;
  initialize(this, arrayBuffer, byteOffset, visualizer);
} // This can be overridden for testing purposes


Batched3DModel3DTileContentEx._deprecationWarning = deprecationWarning;
Object.defineProperties(Batched3DModel3DTileContentEx.prototype, {
  featuresLength: {
    get: function get() {
      return this._batchTable.featuresLength;
    }
  },
  pointsLength: {
    get: function get() {
      return 0;
    }
  },
  trianglesLength: {
    get: function get() {
      return this._model.trianglesLength;
    }
  },
  geometryByteLength: {
    get: function get() {
      return this._model.geometryByteLength;
    }
  },
  texturesByteLength: {
    get: function get() {
      return this._model.texturesByteLength;
    }
  },
  batchTableByteLength: {
    get: function get() {
      return this._batchTable.memorySizeInBytes;
    }
  },
  innerContents: {
    get: function get() {
      return undefined;
    }
  },
  readyPromise: {
    get: function get() {
      return this._model.readyPromise;
    }
  },
  tileset: {
    get: function get() {
      return this._tileset;
    }
  },
  tile: {
    get: function get() {
      return this._tile;
    }
  },
  url: {
    get: function get() {
      return this._resource.getUrlComponent(true);
    }
  },
  batchTable: {
    get: function get() {
      return this._batchTable;
    }
  }
});
var sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;

function getBatchIdAttributeName(gltf) {
  var batchIdAttributeName = ModelUtility.getAttributeOrUniformBySemantic(gltf, "_BATCHID");

  if (!defined(batchIdAttributeName)) {
    batchIdAttributeName = ModelUtility.getAttributeOrUniformBySemantic(gltf, "BATCHID");

    if (defined(batchIdAttributeName)) {
      Batched3DModel3DTileContentEx._deprecationWarning("b3dm-legacy-batchid", "The glTF in this b3dm uses the semantic `BATCHID`. Application-specific semantics should be prefixed with an underscore: `_BATCHID`.");
    }
  }

  return batchIdAttributeName;
}

function getVertexShaderCallback(content) {
  return function (vs, programId) {
    var batchTable = content._batchTable;
    var handleTranslucent = !defined(content._tileset.classificationType);
    var gltf = content._model.gltf;

    if (defined(gltf)) {
      content._batchIdAttributeName = getBatchIdAttributeName(gltf);
      content._diffuseAttributeOrUniformName[programId] = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);
    }

    var callback = batchTable.getVertexShaderCallback(handleTranslucent, content._batchIdAttributeName, content._diffuseAttributeOrUniformName[programId]);
    return defined(callback) ? callback(vs) : vs;
  };
}

function getFragmentShaderCallback(content) {
  return function (fs, programId) {
    var batchTable = content._batchTable;
    var handleTranslucent = !defined(content._tileset.classificationType);
    var gltf = content._model.gltf;

    if (defined(gltf)) {
      content._diffuseAttributeOrUniformName[programId] = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);
    }

    var callback = batchTable.getFragmentShaderCallback(handleTranslucent, content._diffuseAttributeOrUniformName[programId]);
    return defined(callback) ? callback(fs) : fs;
  };
}

function getPickIdCallback(content) {
  return function () {
    return content._batchTable.getPickId();
  };
}

function getClassificationFragmentShaderCallback(content) {
  return function (fs) {
    var batchTable = content._batchTable;
    var callback = batchTable.getClassificationFragmentShaderCallback();
    return defined(callback) ? callback(fs) : fs;
  };
}

function createColorChangedCallback(content) {
  return function (batchId, color) {
    content._model.updateCommands(batchId, color);
  };
}

function initialize(content, arrayBuffer, byteOffset, visualizer) {
  var tileset = content._tileset;
  var tile = content._tile;
  var resource = content._resource;
  var byteStart = defaultValue(byteOffset, 0);
  byteOffset = byteStart;
  var uint8Array = new Uint8Array(arrayBuffer);
  var view = new DataView(arrayBuffer);
  byteOffset += sizeOfUint32; // Skip magic

  var version = view.getUint32(byteOffset, true);

  if (version !== 1) {
    throw new RuntimeError("Only Batched 3D Model version 1 is supported.  Version " + version + " is not.");
  }

  byteOffset += sizeOfUint32;
  var byteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var featureTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var batchTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var batchLength; // Legacy header #1: [batchLength] [batchTableByteLength]
  // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]
  // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]
  // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.
  // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table JSON will exceed this length.
  // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead

  if (batchTableJsonByteLength >= 570425344) {
    // First legacy check
    byteOffset -= sizeOfUint32 * 2;
    batchLength = featureTableJsonByteLength;
    batchTableJsonByteLength = featureTableBinaryByteLength;
    batchTableBinaryByteLength = 0;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;

    Batched3DModel3DTileContentEx._deprecationWarning("b3dm-legacy-header", "This b3dm header is using the legacy format [batchLength] [batchTableByteLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Batched3DModel.");
  } else if (batchTableBinaryByteLength >= 570425344) {
    // Second legacy check
    byteOffset -= sizeOfUint32;
    batchLength = batchTableJsonByteLength;
    batchTableJsonByteLength = featureTableJsonByteLength;
    batchTableBinaryByteLength = featureTableBinaryByteLength;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;

    Batched3DModel3DTileContentEx._deprecationWarning("b3dm-legacy-header", "This b3dm header is using the legacy format [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Batched3DModel.");
  }

  var featureTableJson;

  if (featureTableJsonByteLength === 0) {
    featureTableJson = {
      BATCH_LENGTH: defaultValue(batchLength, 0)
    };
  } else {
    var featureTableString = getStringFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);
    featureTableJson = JSON.parse(featureTableString);
    byteOffset += featureTableJsonByteLength;
  }

  var featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
  byteOffset += featureTableBinaryByteLength;
  var featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);
  batchLength = featureTable.getGlobalProperty("BATCH_LENGTH");
  featureTable.featuresLength = batchLength;
  var batchTableJson;
  var batchTableBinary;

  if (batchTableJsonByteLength > 0) {
    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the
    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.
    //
    // We could also make another request for it, but that would make the property set/get
    // API async, and would double the number of numbers in some cases.
    var batchTableString = getStringFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);
    batchTableJson = JSON.parse(batchTableString);
    byteOffset += batchTableJsonByteLength;

    if (batchTableBinaryByteLength > 0) {
      // Has a batch table binary
      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength); // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed

      batchTableBinary = new Uint8Array(batchTableBinary);
      byteOffset += batchTableBinaryByteLength;
    }
  }

  var colorChangedCallback;

  if (defined(tileset.classificationType)) {
    colorChangedCallback = createColorChangedCallback(content);
  }

  var batchTable = new Cesium3DTileBatchTable(content, batchLength, batchTableJson, batchTableBinary, colorChangedCallback);
  content._batchTable = batchTable;
  var gltfByteLength = byteStart + byteLength - byteOffset;

  if (gltfByteLength === 0) {
    throw new RuntimeError("glTF byte length must be greater than 0.");
  }

  var gltfView;

  if (byteOffset % 4 === 0) {
    gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);
  } else {
    // Create a copy of the glb so that it is 4-byte aligned
    Batched3DModel3DTileContentEx._deprecationWarning("b3dm-glb-unaligned", "The embedded glb is not aligned to a 4-byte boundary.");

    gltfView = new Uint8Array(uint8Array.subarray(byteOffset, byteOffset + gltfByteLength));
  }

  var pickObject = {
    content: content,
    primitive: tileset
  };
  content._rtcCenterTransform = Matrix4.IDENTITY;
  var rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", ComponentDatatype.FLOAT, 3);

  if (defined(rtcCenter)) {
    content._rtcCenterTransform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));
  }

  content._contentModelMatrix = Matrix4.multiply(tile.computedTransform, content._rtcCenterTransform, new Matrix4());

  try {
    var _Cesium = Cesium; // if (!defined(tileset.classificationType)) {
    // PERFORMANCE_IDEA: patch the shader on demand, e.g., the first time show/color changes.
    // The pick shader still needs to be patched.

    content._model = new _MeshVisModel["default"]({
      dracoDecoderPath: _MeshVisModel["default"].DefaultDracoDecoderPath,
      gltf: gltfView,
      visualizer: visualizer,
      cull: false,
      // The model is already culled by 3D Tiles
      releaseGltfJson: true,
      // Models are unique and will not benefit from caching so save memory
      opaquePass: 4,
      // Draw opaque portions of the model during the 3D Tiles pass
      basePath: resource,
      requestType: _Cesium.RequestType.TILES3D,
      modelMatrix: content._contentModelMatrix,
      upAxis: tileset._gltfUpAxis,
      forwardAxis: _Cesium.Axis.X,
      shadows: tileset.shadows,
      debugWireframe: tileset.debugWireframe,
      incrementallyLoadTextures: false,
      // vertexShaderLoaded: getVertexShaderCallback(content),
      // fragmentShaderLoaded: getFragmentShaderCallback(content),
      // uniformMapLoaded: batchTable.getUniformMapCallback(),
      // pickIdLoaded: getPickIdCallback(content),
      // addBatchIdToGeneratedShaders: batchLength > 0, // If the batch table has values in it, generated shaders will need a batchId attribute
      pickObject: pickObject,
      imageBasedLightingFactor: tileset.imageBasedLightingFactor,
      lightColor: tileset.lightColor,
      luminanceAtZenith: tileset.luminanceAtZenith,
      sphericalHarmonicCoefficients: tileset.sphericalHarmonicCoefficients,
      specularEnvironmentMaps: tileset.specularEnvironmentMaps
    }); // } else {
    //     // This transcodes glTF to an internal representation for geometry so we can take advantage of the re-batching of vector data.
    //     // For a list of limitations on the input glTF, see the documentation for classificationType of Cesium3DTileset.
    //     content._model = new ClassificationModel({
    //         gltf: gltfView,
    //         cull: false, // The model is already culled by 3D Tiles
    //         basePath: resource,
    //         requestType: RequestType.TILES3D,
    //         modelMatrix: content._contentModelMatrix,
    //         upAxis: tileset._gltfUpAxis,
    //         forwardAxis: Axis.X,
    //         debugWireframe: tileset.debugWireframe,
    //         vertexShaderLoaded: getVertexShaderCallback(content),
    //         classificationShaderLoaded: getClassificationFragmentShaderCallback(
    //             content
    //         ),
    //         uniformMapLoaded: batchTable.getUniformMapCallback(),
    //         pickIdLoaded: getPickIdCallback(content),
    //         classificationType: tileset._classificationType,
    //         batchTable: batchTable,
    //     });
    // }
  } catch (err) {
    console.error(err);
    throw err;
  }
}

function createFeatures(content) {
  var featuresLength = content.featuresLength;

  if (!defined(content._features) && featuresLength > 0) {
    var features = new Array(featuresLength);

    for (var i = 0; i < featuresLength; ++i) {
      features[i] = new Cesium3DTileFeature(content, i);
    }

    content._features = features;
  }
}

Batched3DModel3DTileContentEx.prototype.hasProperty = function (batchId, name) {
  return this._batchTable.hasProperty(batchId, name);
};

Batched3DModel3DTileContentEx.prototype.getFeature = function (batchId) {
  //>>includeStart('debug', pragmas.debug);
  var featuresLength = this.featuresLength;

  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {
    throw new DeveloperError("batchId is required and between zero and featuresLength - 1 (" + (featuresLength - 1) + ").");
  } //>>includeEnd('debug');


  createFeatures(this);
  return this._features[batchId];
};

Batched3DModel3DTileContentEx.prototype.applyDebugSettings = function (enabled, color) {
  color = enabled ? color : Color.WHITE;

  if (this.featuresLength === 0) {
    this._model.color = color;
  } else {
    this._batchTable.setAllColor(color);
  }
};

Batched3DModel3DTileContentEx.prototype.applyStyle = function (style) {
  if (this.featuresLength === 0) {
    var hasColorStyle = defined(style) && defined(style.color);
    var hasShowStyle = defined(style) && defined(style.show);
    var model = this._model;
    model.color = hasColorStyle ? style.color.evaluateColor(undefined, model.color) : Color.clone(Color.WHITE, model.color);
    model.show = hasShowStyle ? style.show.evaluate(undefined) : true;
  } else {
    this._batchTable.applyStyle(style);
  }
};

Batched3DModel3DTileContentEx.prototype.update = function (tileset, frameState) {
  // var commandStart = frameState.commandList.length;
  // In the PROCESSING state we may be calling update() to move forward
  // the content's resource loading.  In the READY state, it will
  // actually generate commands.
  this._batchTable.update(tileset, frameState);

  this._contentModelMatrix = Matrix4.multiply(this._tile.computedTransform, this._rtcCenterTransform, this._contentModelMatrix);
  var model = this._model,
      tileset = this._tileset;
  model.modelMatrix = this._contentModelMatrix;
  model.shadows = tileset.shadows;
  model.imageBasedLightingFactor = tileset.imageBasedLightingFactor;
  model.lightColor = tileset.lightColor;
  model.luminanceAtZenith = tileset.luminanceAtZenith;
  model.sphericalHarmonicCoefficients = tileset.sphericalHarmonicCoefficients;
  model.specularEnvironmentMaps = tileset.specularEnvironmentMaps;
  model.debugWireframe = tileset.debugWireframe; // // Update clipping planes
  // var tilesetClippingPlanes = this._tileset.clippingPlanes;
  // this._model.clippingPlanesOriginMatrix = this._tileset.clippingPlanesOriginMatrix;
  // if (defined(tilesetClippingPlanes) && this._tile.clippingPlanesDirty) {
  //     // Dereference the clipping planes from the model if they are irrelevant.
  //     // Link/Dereference directly to avoid ownership checks.
  //     // This will also trigger synchronous shader regeneration to remove or add the clipping plane and color blending code.
  //     this._model._clippingPlanes =
  //         tilesetClippingPlanes.enabled && this._tile._isClipped
  //             ? tilesetClippingPlanes
  //             : undefined;
  // }
  // // If the model references a different ClippingPlaneCollection due to the tileset's collection being replaced with a
  // // ClippingPlaneCollection that gives this tile the same clipping status, update the model to use the new ClippingPlaneCollection.
  // if (
  //     defined(tilesetClippingPlanes) &&
  //     defined(this._model._clippingPlanes) &&
  //     this._model._clippingPlanes !== tilesetClippingPlanes
  // ) {
  //     this._model._clippingPlanes = tilesetClippingPlanes;
  // }

  this._model.update(frameState); // // If any commands were pushed, add derived commands
  // var commandEnd = frameState.commandList.length;
  // if (
  //     commandStart < commandEnd &&
  //     (frameState.passes.render || frameState.passes.pick) &&
  //     !defined(tileset.classificationType)
  // ) {
  //     this._batchTable.addDerivedCommands(frameState, commandStart);
  // }

};

Batched3DModel3DTileContentEx.prototype.isDestroyed = function () {
  return false;
};

Batched3DModel3DTileContentEx.prototype.destroy = function () {
  this._model = this._model && this._model.destroy();
  this._batchTable = this._batchTable && this._batchTable.destroy();
  this._visualizer = null;
  return destroyObject(this);
};

},{"3_302":180,"M_0":241}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _Batched3DModel3DTileContentEx = require("D_303");

var _Instanced3DModel3DTileContentEx = require("._304");

var Cesium3DTileExtension = {
  init: function init() {
    if (this.__init__) return;
    this.__init__ = true;
    var _Cesium = Cesium,
        Cesium3DTileContentFactory = _Cesium.Cesium3DTileContentFactory,
        Cesium3DTileset = _Cesium.Cesium3DTileset;

    Cesium3DTileset.prototype.render = function (frameState, renderList) {
      if (this.__frameNumber != frameState.frameNumber) {
        this.update(frameState); //调用Cesium3DTileset的udpate方法，以更新_selectedTiles

        this.__frameNumber = frameState.frameNumber;
      } else {
        this.__frameNumber = frameState.frameNumber;
      }

      var tileModelCount = 0; //将可见的tile加入MeshVisualizer的渲染队列 

      for (var i = 0; i < this._selectedTiles.length; i++) {
        var tile = this._selectedTiles[i];
        var content = tile.content;

        if (content) {
          if (content._contents && Array.isArray(content._contents)) {
            var contents = content._contents;
            contents.forEach(function (subContent) {
              var model = subContent._model || subContent._modelInstanceCollection;

              if (model && model.isMeshVisModel) {
                renderList.push(model.root);
                tileModelCount++;
              }
            });
          } else {
            var model = content._model || content._modelInstanceCollection;

            if (model && model.isMeshVisModel) {
              renderList.push(model.root);
              tileModelCount++;
            }
          }
        }
      }
    }; //重写 Cesium3DTileContentFactory.b3dm content的创建方法


    Cesium3DTileContentFactory._b3dm = Cesium3DTileContentFactory.b3dm;

    Cesium3DTileContentFactory.b3dm = function (tileset, tile, resource, arrayBuffer, byteOffset) {
      var visualizer = tileset.visualizer;

      if (visualizer) {
        //使用CesiumMeshVisualizer
        return new _Batched3DModel3DTileContentEx.Batched3DModel3DTileContentEx(tileset, tile, resource, arrayBuffer, byteOffset, visualizer);
      } else {
        //使用Cesium.Model
        return Cesium3DTileContentFactory._b3dm(tileset, tile, resource, arrayBuffer, byteOffset);
      }
    };

    Cesium3DTileContentFactory._i3dm = Cesium3DTileContentFactory.i3dm;

    Cesium3DTileContentFactory.i3dm = function (tileset, tile, resource, arrayBuffer, byteOffset) {
      var visualizer = tileset.visualizer;

      if (visualizer) {
        //使用CesiumMeshVisualizer
        return new _Instanced3DModel3DTileContentEx.Instanced3DModel3DTileContentEx(tileset, tile, resource, arrayBuffer, byteOffset, visualizer);
      } else {
        //使用Cesium.Model
        return Cesium3DTileContentFactory._i3dm(tileset, tile, resource, arrayBuffer, byteOffset);
      }
    };
  }
};
var _default = Cesium3DTileExtension;
exports["default"] = _default;

},{"D_303":72,"._304":74}],74:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Instanced3DModel3DTileContentEx = Instanced3DModel3DTileContentEx;

var _MeshVisModel = _interopRequireDefault(require("3_302"));

var AttributeCompression;
var Cartesian3;
var Color;
var ComponentDatatype;
var defaultValue;
var defined;
var deprecationWarning;
var destroyObject;
var DeveloperError;
var Ellipsoid;
var getStringFromTypedArray;
var Matrix3;
var Matrix4;
var Quaternion;
var RequestType;
var RuntimeError;
var Transforms;
var TranslationRotationScale;
var Pass;
var Axis;
var Cesium3DTileBatchTable;
var Cesium3DTileFeature;
var Cesium3DTileFeatureTable;
var initDeps$Instanced3DModel3DTileContentExDone = false;

function initDeps$Instanced3DModel3DTileContentEx() {
  if (initDeps$Instanced3DModel3DTileContentExDone) return;
  initDeps$Instanced3DModel3DTileContentExDone = true;
  var _Cesium = Cesium;
  AttributeCompression = _Cesium.AttributeCompression;
  Cartesian3 = _Cesium.Cartesian3;
  Color = _Cesium.Color;
  ComponentDatatype = _Cesium.ComponentDatatype;
  defaultValue = _Cesium.defaultValue;
  defined = _Cesium.defined;
  deprecationWarning = _Cesium.deprecationWarning;
  destroyObject = _Cesium.destroyObject;
  DeveloperError = _Cesium.DeveloperError;
  Ellipsoid = _Cesium.Ellipsoid;
  getStringFromTypedArray = _Cesium.getStringFromTypedArray;
  Matrix3 = _Cesium.Matrix3;
  Matrix4 = _Cesium.Matrix4;
  Quaternion = _Cesium.Quaternion;
  RequestType = _Cesium.RequestType;
  RuntimeError = _Cesium.RuntimeError;
  Transforms = _Cesium.Transforms;
  TranslationRotationScale = _Cesium.TranslationRotationScale;
  Pass = _Cesium.Pass;
  Axis = _Cesium.Axis;
  Cesium3DTileBatchTable = _Cesium.Cesium3DTileBatchTable;
  Cesium3DTileFeature = _Cesium.Cesium3DTileFeature;
  Cesium3DTileFeatureTable = _Cesium.Cesium3DTileFeatureTable;
}
/**
 * Represents the contents of a
 * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Instanced3DModel|Instanced 3D Model}
 * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification|3D Tiles} tileset.
 * <p>
 * Implements the {@link Cesium3DTileContent} interface.
 * </p>
 *
 * @alias Instanced3DModel3DTileContentEx
 * @constructor
 *
 * @private
 */


function Instanced3DModel3DTileContentEx(tileset, tile, resource, arrayBuffer, byteOffset, visualizer) {
  initDeps$Instanced3DModel3DTileContentEx();
  this._tileset = tileset;
  this._tile = tile;
  this._resource = resource;
  this._modelInstanceCollection = undefined;
  this._batchTable = undefined;
  this._features = undefined;
  this.featurePropertiesDirty = false;
  this._visualizer = visualizer;
  initialize(this, arrayBuffer, byteOffset, visualizer);
} // This can be overridden for testing purposes


Instanced3DModel3DTileContentEx._deprecationWarning = deprecationWarning;
Object.defineProperties(Instanced3DModel3DTileContentEx.prototype, {
  featuresLength: {
    get: function get() {
      return this._batchTable.featuresLength;
    }
  },
  pointsLength: {
    get: function get() {
      return 0;
    }
  },
  trianglesLength: {
    get: function get() {
      var model = this._modelInstanceCollection._model;

      if (defined(model)) {
        return model.trianglesLength;
      }

      return 0;
    }
  },
  geometryByteLength: {
    get: function get() {
      var model = this._modelInstanceCollection._model;

      if (defined(model)) {
        return model.geometryByteLength;
      }

      return 0;
    }
  },
  texturesByteLength: {
    get: function get() {
      var model = this._modelInstanceCollection._model;

      if (defined(model)) {
        return model.texturesByteLength;
      }

      return 0;
    }
  },
  batchTableByteLength: {
    get: function get() {
      return this._batchTable.memorySizeInBytes;
    }
  },
  innerContents: {
    get: function get() {
      return undefined;
    }
  },
  readyPromise: {
    get: function get() {
      return this._modelInstanceCollection.readyPromise;
    }
  },
  tileset: {
    get: function get() {
      return this._tileset;
    }
  },
  tile: {
    get: function get() {
      return this._tile;
    }
  },
  url: {
    get: function get() {
      return this._resource.getUrlComponent(true);
    }
  },
  batchTable: {
    get: function get() {
      return this._batchTable;
    }
  }
});

function getPickIdCallback(content) {
  return function () {
    return content._batchTable.getPickId();
  };
}

var sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;
var propertyScratch1 = new Array(4);
var propertyScratch2 = new Array(4);

function initialize(content, arrayBuffer, byteOffset, visualizer) {
  var byteStart = defaultValue(byteOffset, 0);
  byteOffset = byteStart;
  var uint8Array = new Uint8Array(arrayBuffer);
  var view = new DataView(arrayBuffer);
  byteOffset += sizeOfUint32; // Skip magic

  var version = view.getUint32(byteOffset, true);

  if (version !== 1) {
    throw new RuntimeError("Only Instanced 3D Model version 1 is supported. Version " + version + " is not.");
  }

  byteOffset += sizeOfUint32;
  var byteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var featureTableJsonByteLength = view.getUint32(byteOffset, true);

  if (featureTableJsonByteLength === 0) {
    throw new RuntimeError("featureTableJsonByteLength is zero, the feature table must be defined.");
  }

  byteOffset += sizeOfUint32;
  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var batchTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += sizeOfUint32;
  var gltfFormat = view.getUint32(byteOffset, true);

  if (gltfFormat !== 1 && gltfFormat !== 0) {
    throw new RuntimeError("Only glTF format 0 (uri) or 1 (embedded) are supported. Format " + gltfFormat + " is not.");
  }

  byteOffset += sizeOfUint32;
  var featureTableString = getStringFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);
  var featureTableJson = JSON.parse(featureTableString);
  byteOffset += featureTableJsonByteLength;
  var featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
  byteOffset += featureTableBinaryByteLength;
  var featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);
  var instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
  featureTable.featuresLength = instancesLength;

  if (!defined(instancesLength)) {
    throw new RuntimeError("Feature table global property: INSTANCES_LENGTH must be defined");
  }

  var batchTableJson;
  var batchTableBinary;

  if (batchTableJsonByteLength > 0) {
    var batchTableString = getStringFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);
    batchTableJson = JSON.parse(batchTableString);
    byteOffset += batchTableJsonByteLength;

    if (batchTableBinaryByteLength > 0) {
      // Has a batch table binary
      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength); // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed

      batchTableBinary = new Uint8Array(batchTableBinary);
      byteOffset += batchTableBinaryByteLength;
    }
  }

  content._batchTable = new Cesium3DTileBatchTable(content, instancesLength, batchTableJson, batchTableBinary);
  var gltfByteLength = byteStart + byteLength - byteOffset;

  if (gltfByteLength === 0) {
    throw new RuntimeError("glTF byte length is zero, i3dm must have a glTF to instance.");
  }

  var gltfView;

  if (byteOffset % 4 === 0) {
    gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);
  } else {
    // Create a copy of the glb so that it is 4-byte aligned
    Instanced3DModel3DTileContentEx._deprecationWarning("i3dm-glb-unaligned", "The embedded glb is not aligned to a 4-byte boundary.");

    gltfView = new Uint8Array(uint8Array.subarray(byteOffset, byteOffset + gltfByteLength));
  }

  var tileset = content._tileset; // Create model instance collection

  var collectionOptions = {
    dracoDecoderPath: _MeshVisModel["default"].DefaultDracoDecoderPath,
    visualizer: visualizer,
    //MeshVisualizer
    instances: new Array(instancesLength),
    instancedAttributes: [{
      name: 'batchId',
      "default": 0
    }],
    batchTable: content._batchTable,
    cull: false,
    // Already culled by 3D Tiles
    url: undefined,
    requestType: RequestType.TILES3D,
    gltf: undefined,
    basePath: undefined,
    incrementallyLoadTextures: false,
    upAxis: tileset._gltfUpAxis,
    forwardAxis: Axis.X,
    opaquePass: 4,
    // Draw opaque portions during the 3D Tiles pass
    // pickIdLoaded: getPickIdCallback(content),
    imageBasedLightingFactor: tileset.imageBasedLightingFactor,
    lightColor: tileset.lightColor,
    luminanceAtZenith: tileset.luminanceAtZenith,
    sphericalHarmonicCoefficients: tileset.sphericalHarmonicCoefficients,
    specularEnvironmentMaps: tileset.specularEnvironmentMaps
  };

  if (gltfFormat === 0) {
    var gltfUrl = getStringFromTypedArray(gltfView); // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.
    // This removes all white space and null characters from the end of the string.

    gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
    collectionOptions.url = content._resource.getDerivedResource({
      url: gltfUrl
    });
  } else {
    collectionOptions.gltf = gltfView;
    collectionOptions.basePath = content._resource.clone();
  }

  var eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
  var rtcCenter;
  var rtcCenterArray = featureTable.getGlobalProperty("RTC_CENTER", ComponentDatatype.FLOAT, 3);

  if (defined(rtcCenterArray)) {
    rtcCenter = Cartesian3.unpack(rtcCenterArray);
  }

  var instances = collectionOptions.instances;
  var instancePosition = new Cartesian3();
  var instancePositionArray = new Array(3);
  var instanceNormalRight = new Cartesian3();
  var instanceNormalUp = new Cartesian3();
  var instanceNormalForward = new Cartesian3();
  var instanceRotation = new Matrix3();
  var instanceQuaternion = new Quaternion();
  var instanceScale = new Cartesian3();
  var instanceTranslationRotationScale = new TranslationRotationScale();
  var instanceTransform = new Matrix4();

  for (var i = 0; i < instancesLength; i++) {
    // Get the instance position
    var position = featureTable.getProperty("POSITION", ComponentDatatype.FLOAT, 3, i, propertyScratch1);

    if (!defined(position)) {
      position = instancePositionArray;
      var positionQuantized = featureTable.getProperty("POSITION_QUANTIZED", ComponentDatatype.UNSIGNED_SHORT, 3, i, propertyScratch1);

      if (!defined(positionQuantized)) {
        throw new RuntimeError("Either POSITION or POSITION_QUANTIZED must be defined for each instance.");
      }

      var quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", ComponentDatatype.FLOAT, 3);

      if (!defined(quantizedVolumeOffset)) {
        throw new RuntimeError("Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }

      var quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", ComponentDatatype.FLOAT, 3);

      if (!defined(quantizedVolumeScale)) {
        throw new RuntimeError("Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }

      for (var j = 0; j < 3; j++) {
        position[j] = positionQuantized[j] / 65535.0 * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
      }
    }

    Cartesian3.unpack(position, 0, instancePosition);

    if (defined(rtcCenter)) {
      Cartesian3.add(instancePosition, rtcCenter, instancePosition);
    }

    instanceTranslationRotationScale.translation = instancePosition; // Get the instance rotation

    var normalUp = featureTable.getProperty("NORMAL_UP", ComponentDatatype.FLOAT, 3, i, propertyScratch1);
    var normalRight = featureTable.getProperty("NORMAL_RIGHT", ComponentDatatype.FLOAT, 3, i, propertyScratch2);
    var hasCustomOrientation = false;

    if (defined(normalUp)) {
      if (!defined(normalRight)) {
        throw new RuntimeError("To define a custom orientation, both NORMAL_UP and NORMAL_RIGHT must be defined.");
      }

      Cartesian3.unpack(normalUp, 0, instanceNormalUp);
      Cartesian3.unpack(normalRight, 0, instanceNormalRight);
      hasCustomOrientation = true;
    } else {
      var octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", ComponentDatatype.UNSIGNED_SHORT, 2, i, propertyScratch1);
      var octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", ComponentDatatype.UNSIGNED_SHORT, 2, i, propertyScratch2);

      if (defined(octNormalUp)) {
        if (!defined(octNormalRight)) {
          throw new RuntimeError("To define a custom orientation with oct-encoded vectors, both NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P must be defined.");
        }

        AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);
        AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);
        hasCustomOrientation = true;
      } else if (eastNorthUp) {
        Transforms.eastNorthUpToFixedFrame(instancePosition, Ellipsoid.WGS84, instanceTransform);
        Matrix4.getMatrix3(instanceTransform, instanceRotation);
      } else {
        Matrix3.clone(Matrix3.IDENTITY, instanceRotation);
      }
    }

    if (hasCustomOrientation) {
      Cartesian3.cross(instanceNormalRight, instanceNormalUp, instanceNormalForward);
      Cartesian3.normalize(instanceNormalForward, instanceNormalForward);
      Matrix3.setColumn(instanceRotation, 0, instanceNormalRight, instanceRotation);
      Matrix3.setColumn(instanceRotation, 1, instanceNormalUp, instanceRotation);
      Matrix3.setColumn(instanceRotation, 2, instanceNormalForward, instanceRotation);
    }

    Quaternion.fromRotationMatrix(instanceRotation, instanceQuaternion);
    instanceTranslationRotationScale.rotation = instanceQuaternion; // Get the instance scale

    instanceScale = Cartesian3.fromElements(1.0, 1.0, 1.0, instanceScale);
    var scale = featureTable.getProperty("SCALE", ComponentDatatype.FLOAT, 1, i);

    if (defined(scale)) {
      Cartesian3.multiplyByScalar(instanceScale, scale, instanceScale);
    }

    var nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", ComponentDatatype.FLOAT, 3, i, propertyScratch1);

    if (defined(nonUniformScale)) {
      instanceScale.x *= nonUniformScale[0];
      instanceScale.y *= nonUniformScale[1];
      instanceScale.z *= nonUniformScale[2];
    }

    instanceTranslationRotationScale.scale = instanceScale; // Get the batchId

    var batchId = featureTable.getProperty("BATCH_ID", ComponentDatatype.UNSIGNED_SHORT, 1, i);

    if (!defined(batchId)) {
      // If BATCH_ID semantic is undefined, batchId is just the instance number
      batchId = i;
    } // Create the model matrix and the instance


    Matrix4.fromTranslationRotationScale(instanceTranslationRotationScale, instanceTransform);
    var modelMatrix = instanceTransform.clone();
    instances[i] = {
      modelMatrix: modelMatrix,
      batchId: batchId
    };
  } // ModelInstanceCollection


  content._modelInstanceCollection = new _MeshVisModel["default"](collectionOptions);
}

function createFeatures(content) {
  var featuresLength = content.featuresLength;

  if (!defined(content._features) && featuresLength > 0) {
    var features = new Array(featuresLength);

    for (var i = 0; i < featuresLength; ++i) {
      features[i] = new Cesium3DTileFeature(content, i);
    }

    content._features = features;
  }
}

Instanced3DModel3DTileContentEx.prototype.hasProperty = function (batchId, name) {
  return this._batchTable.hasProperty(batchId, name);
};

Instanced3DModel3DTileContentEx.prototype.getFeature = function (batchId) {
  var featuresLength = this.featuresLength; //>>includeStart('debug', pragmas.debug);

  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {
    throw new DeveloperError("batchId is required and between zero and featuresLength - 1 (" + (featuresLength - 1) + ").");
  } //>>includeEnd('debug');


  createFeatures(this);
  return this._features[batchId];
};

Instanced3DModel3DTileContentEx.prototype.applyDebugSettings = function (enabled, color) {
  color = enabled ? color : Color.WHITE;

  this._batchTable.setAllColor(color);
};

Instanced3DModel3DTileContentEx.prototype.applyStyle = function (style) {
  this._batchTable.applyStyle(style);
};

Instanced3DModel3DTileContentEx.prototype.update = function (tileset, frameState) {
  // var commandStart = frameState.commandList.length;
  // In the PROCESSING state we may be calling update() to move forward
  // the content's resource loading.  In the READY state, it will
  // actually generate commands.
  this._batchTable.update(tileset, frameState);

  var modelInstanceCollection = this._modelInstanceCollection,
      tileset = this._tileset;
  modelInstanceCollection.modelMatrix = this._tile.computedTransform;
  modelInstanceCollection.shadows = tileset.shadows;
  modelInstanceCollection.lightColor = tileset.lightColor;
  modelInstanceCollection.luminanceAtZenith = tileset.luminanceAtZenith;
  modelInstanceCollection.sphericalHarmonicCoefficients = tileset.sphericalHarmonicCoefficients;
  modelInstanceCollection.specularEnvironmentMaps = tileset.specularEnvironmentMaps;
  modelInstanceCollection.debugWireframe = tileset.debugWireframe; // var model = this._modelInstanceCollection._model;
  // if (defined(model)) {
  //   // Update for clipping planes
  //   var tilesetClippingPlanes = this._tileset.clippingPlanes;
  //   model.clippingPlanesOriginMatrix = this._tileset.clippingPlanesOriginMatrix;
  //   if (defined(tilesetClippingPlanes) && this._tile.clippingPlanesDirty) {
  //     // Dereference the clipping planes from the model if they are irrelevant - saves on shading
  //     // Link/Dereference directly to avoid ownership checks.
  //     model._clippingPlanes =
  //       tilesetClippingPlanes.enabled && this._tile._isClipped
  //         ? tilesetClippingPlanes
  //         : undefined;
  //   }
  //   // If the model references a different ClippingPlaneCollection due to the tileset's collection being replaced with a
  //   // ClippingPlaneCollection that gives this tile the same clipping status, update the model to use the new ClippingPlaneCollection.
  //   if (
  //     defined(tilesetClippingPlanes) &&
  //     defined(model._clippingPlanes) &&
  //     model._clippingPlanes !== tilesetClippingPlanes
  //   ) {
  //     model._clippingPlanes = tilesetClippingPlanes;
  //   }
  // }
  // this._modelInstanceCollection.update(frameState);
  // // If any commands were pushed, add derived commands
  // var commandEnd = frameState.commandList.length;
  // if (
  //   commandStart < commandEnd &&
  //   (frameState.passes.render || frameState.passes.pick)
  // ) {
  //   this._batchTable.addDerivedCommands(frameState, commandStart, false);
  // }
};

Instanced3DModel3DTileContentEx.prototype.isDestroyed = function () {
  return false;
};

Instanced3DModel3DTileContentEx.prototype.destroy = function () {
  this._modelInstanceCollection = this._modelInstanceCollection && this._modelInstanceCollection.destroy();
  this._batchTable = this._batchTable && this._batchTable.destroy();
  this._visualizer = null;
  return destroyObject(this);
};

},{"3_302":180,"M_0":241}],75:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _GeometryUtils = _interopRequireDefault(require("s_310"));

var _geojsonHelper = _interopRequireDefault(require("h_311"));

var _GenericWorker = _interopRequireDefault(require("-_312"));

var _traverse = _interopRequireDefault(require("3_313"));

var _QuadtreeLODUtil = _interopRequireDefault(require("D_314"));

var _QuadtreeLOD = _interopRequireDefault(require("._315"));

// import { geojsonHelper, GenericWorker, traverse } from "@mesh-3d/utils";
function _getLodContentProvider(root, styleFilter) {
  return {
    requestContent: function requestContent(contentSet, rtcCenter) {
      var groups = [],
          materialMap = new WeakMap();

      function createContent(content) {
        var group,
            style = {},
            feature = content.uri;
        var featureId = feature.properties.featureId;
        styleFilter(feature, style);
        var geometry = BuildingVector3DLoader.parseFeature(feature, featureId, style);
        var material = style.material;

        if (rtcCenter) {
          if (!(geometry instanceof Cesium.Geometry)) {
            geometry = geometry.constructor.createGeometry(geometry);
          }

          var positions = geometry.attributes.position.values;

          for (var i = 0; i < positions.length; i += 3) {
            positions[i] -= rtcCenter.x;
            positions[i + 1] -= rtcCenter.y;
            positions[i + 2] -= rtcCenter.z;
          }
        }

        if (materialMap.has(material)) {
          group = materialMap.get(material);
        } else {
          group = {
            material: material,
            geometries: []
          };
          groups.push(group);
          materialMap.set(material, group);
        }

        group.geometries.push(geometry);
      }

      var batchList = [],
          batch = [],
          batchSize = 100;
      batchList.push(batch);
      contentSet.contain.forEach(function (content) {
        if (batch.length > batchSize) {
          batch = [];
          batchList.push(batch);
        }

        batch.push(content);
      });
      contentSet.intersect.forEach(function (content) {
        if (batch.length > batchSize) {
          batch = [];
          batchList.push(batch);
        }

        batch.push(content);
      });
      return new _GenericWorker["default"](batchList, function (batch) {
        batch.forEach(createContent);
      }).run().then(function () {
        var object3d = new THREE.Object3D();
        groups.forEach(function (group) {
          var geometry = _GeometryUtils["default"].mergeGeometries(group.geometries);

          geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
          var material = group.material;
          var mesh = new THREE.Mesh(geometry, material);
          mesh.pickObject = {
            id: mesh,
            mesh: mesh,
            primitive: root
          };
          object3d.add(mesh);
          mesh.matrixAutoUpdate = false;
          mesh.modelMatrixNeedsUpdate = false;
          mesh.frustumCulled = false;
          materialMap["delete"](material);
        });
        object3d.matrixAutoUpdate = false;
        object3d.modelMatrixNeedsUpdate = false;
        object3d.frustumCulled = false;
        groups.splice(0);
        contentSet.contain.splice(0);
        contentSet.intersect.splice(0);
        return object3d;
      });
    }
  };
}

var BuildingVector3DLoader = /*#__PURE__*/function () {
  function BuildingVector3DLoader() {
    (0, _classCallCheck2["default"])(this, BuildingVector3DLoader);
  }

  (0, _createClass2["default"])(BuildingVector3DLoader, null, [{
    key: "loadGeojson",
    value:
    /**
     * 
     * @param {string} url 
     * @returns {Promise<geojson.PolygonFeatureCollection>}
     */
    function loadGeojson(url) {
      return Cesium.Resource.fetchJson(url);
    }
    /**
     * 
     * @param {string} url 
     * @param {(feature:geojson.Feature<geojson.Polygon|geojson.MultiPolygon>,style:{
            height?: number;
            extrudedHeight?: number;
            vertexFormat?: VertexFormat;
            stRotation?: number;
            ellipsoid?: Ellipsoid;
            granularity?: number;
            perPositionHeight?: boolean;
            closeTop?: boolean;
            closeBottom?: boolean;
            arcType?: ArcType;
            material?:MeshMaterial
     })=>void}styleFilter
     * @param {(progress:number)=>void}onProgress
     * @param {(geojson:geojson.FeatureCollection<geojson.Polygon|geojson.MultiPolygon>)=>void}[onDataLoad]
     * @param {object}[options]
     * @param {number}[options.minRange=2]
     * @param {number}[options.maxLevel=5]
     * @param {number}[options.zSliceLevel=6]
     * @returns {Promise<QuadtreeLOD>}
     */

  }, {
    key: "load",
    value: function load(url, styleFilter, onProgress, onDataLoad, options) {
      var _this = this;

      if (typeof onDataLoad != 'function') {
        options = onDataLoad;
        onDataLoad = null;
      }

      return this.loadGeojson(url).then(function (geojson) {
        console.time('calcBBox');

        _geojsonHelper["default"].calcBBox(geojson);

        console.timeEnd('calcBBox'); // console.log(geojson);

        if (typeof onDataLoad == 'function') {
          onDataLoad(geojson);
        }

        return _this.parse(geojson, styleFilter, onProgress, options);
      });
    }
  }, {
    key: "parse",
    value: function parse(geojson, styleFilter, onProgress, options) {
      if (onProgress && typeof onProgress != 'function') {
        options = onProgress, onProgress = null;
      }

      if (!onProgress) onProgress = function onProgress(progress) {};
      options = options || {};
      options.useRtcCenter = typeof options.useRtcCenter == 'boolean' ? options.useRtcCenter : true;
      console.time('process contentSet');
      var getLodContentProvider = options.getLodContentProvider || _getLodContentProvider;
      var contentSet = [],
          rootRectangle,
          rootMaximumHeight = 0.0,
          minimumHeight = 0.1;
      ;
      var invalidCount = 0;
      var batchList = [],
          batch = [],
          batchSize = geojson.features && geojson.features.length > 100 ? geojson.features.length / 100 : 100;
      batchList.push(batch);

      _geojsonHelper["default"].featureEach(geojson, function (feature, featureId) {
        if (!feature.geometry || !feature.geometry.coordinates.length) {
          invalidCount++;
          return;
        }

        if (batch.length > batchSize) {
          batch = [];
          batchList.push(batch);
        }

        batch.push({
          feature: feature,
          id: featureId
        });
      });

      var _Cesium2 = Cesium,
          Rectangle = _Cesium2.Rectangle,
          TileBoundingRegion = _Cesium2.TileBoundingRegion,
          Color = _Cesium2.Color;
      var processWorker = new _GenericWorker["default"](batchList, function (batch) {
        for (var i = 0; i < batch.length; i++) {
          var taskData = batch[i];
          var feature = taskData.feature,
              featureId = taskData.id;

          try {
            var bbox = feature.geometry.bbox;
            var maximumHeight = feature.properties.Floor * 10;
            var rectangle = Rectangle.fromDegrees(bbox[0], bbox[1], bbox[2], bbox[3]);
            var region = new TileBoundingRegion({
              rectangle: rectangle,
              minimumHeight: minimumHeight,
              maximumHeight: maximumHeight
            });
            feature.properties = feature.properties || {};
            feature.properties.featureId = featureId;
            var content = {
              uri: feature,
              boundingVolume: {
                region: region,
                sphere: region.boundingSphere
              },
              showDebugVolume: false
            };
            contentSet.push(content);
            rootMaximumHeight = Math.max(rootMaximumHeight, maximumHeight);

            if (!rootRectangle) {
              rootRectangle = rectangle.clone();
            } else {
              Rectangle.union(rootRectangle, rectangle, rootRectangle);
            }
          } catch (err) {
            console.error(err);
            throw err;
          }
        }
      });
      var totalProgress = 0;
      return processWorker.run(function (progress) {
        totalProgress = progress * 0.4;
        onProgress(totalProgress);
      }).then(function () {
        totalProgress = 40;
        onProgress(totalProgress); // console.timeEnd('process contentSet');

        try {
          var rootRegion = new TileBoundingRegion({
            rectangle: rootRectangle,
            minimumHeight: minimumHeight,
            maximumHeight: rootMaximumHeight
          }); // console.time('QuadtreeLODUtil.create');

          var scale = rootRectangle.width / rootRectangle.height;
          var xSize = 4,
              ySize = 4,
              zSize = 2;

          if (scale > 1) {
            xSize = parseInt(Math.ceil(ySize * scale));
          } else {
            ySize = parseInt(Math.ceil(xSize / scale));
          }

          var root = _QuadtreeLODUtil["default"].create({
            rootBoundingVolume: {
              region: rootRegion
            },
            maxLevel: options.maxLevel || 5,
            zSliceLevel: options.zSliceLevel || 6,
            xSize: xSize,
            ySize: ySize,
            zSize: zSize,
            minRange: options.minRange || 2,
            debugVolume: options.debugVolume,
            showDebugVolume: options.showDebugVolume,
            debugVolumeColor: options.debugVolumeColor || Color.CYAN.clone(),
            rtcCenter: options.useRtcCenter && rootRegion.boundingSphere.center,
            recursive: false
          });

          var rootTiles = root.children.slice();
          var createWorker = new _GenericWorker["default"](rootTiles, function (rootTile) {
            rootTile._createLODTreeDelay(true);
          });
          return createWorker.run(function (progress) {
            onProgress(progress * 0.2 + totalProgress);
          }).then(function () {
            totalProgress = 60;
            onProgress(totalProgress); // console.timeEnd('QuadtreeLODUtil.create')
            // console.time('QuadtreeLODUtil.filterContents');
            //L1

            rootTiles = root.children.slice();
            var filterL1Worker = new _GenericWorker["default"](rootTiles, function (rootTile) {
              _QuadtreeLODUtil["default"].filterContents(contentSet, rootTile, false);
            });
            return filterL1Worker.run(function (progress) {
              onProgress(progress * 0.1 + totalProgress);
            }).then(function () {
              //L2~LN
              totalProgress = 70;
              onProgress(totalProgress);
              var tileList = [];
              root.children.forEach(function (rootTile) {
                (0, _traverse["default"])(rootTile.children, function (tile) {
                  tile.refine = 'ADD';
                  if (tile.level > 0) tileList.push(tile);
                });
              });
              tileList.sort(function (a, b) {
                return a.level - b.level;
              });
              batchList = [];
              batch = [];
              batchList.push(batch);
              batchSize = 100; //tileList.length > 20 ? tileList.length / 100 : 20;

              tileList.forEach(function (tile) {
                if (batch.length > batchSize) {
                  batch = [];
                  batchList.push(batch);
                }

                batch.push(tile);
              });
              var filterWorker = new _GenericWorker["default"](batchList, function (batch) {
                for (var i = 0; i < batch.length; i++) {
                  var tile = batch[i];

                  var currentContentSet = //tile.parent && tile.parent._getContentSetBeforeFilter ? 
                  tile.parent._getContentSetBeforeFilter(); //: contentSet


                  _QuadtreeLODUtil["default"].filterContents(currentContentSet, tile, false);
                }
              });
              return filterWorker.run(function (progress) {
                onProgress(progress * 0.3 + totalProgress);
              }).then(function () {
                totalProgress = 100; // console.timeEnd('QuadtreeLODUtil.filterContents');

                var lodContentProvider = getLodContentProvider(root, styleFilter);
                root.children.forEach(function (child) {
                  (0, _traverse["default"])(child, function (node) {
                    node.contentProvider = lodContentProvider;
                  });
                });
                onProgress(totalProgress);
                return root;
              });
            });
          });
        } catch (e) {
          console.error(e);
          throw e;
        }
      });
    }
    /**
     * 
     * @param {geojson.Feature<geojson.Polygon|geojson.MultiPolygon>} feature
     * @param {number}featureId
     * @param {{
            height?: number;
            extrudedHeight?: number;
            vertexFormat?: VertexFormat;
            stRotation?: number;
            ellipsoid?: Ellipsoid;
            granularity?: number;
            perPositionHeight?: boolean;
            closeTop?: boolean;
            closeBottom?: boolean;
            arcType?: ArcType;
     }}style
     * @returns {Cesium.Geometry} result 
     */

  }, {
    key: "parseFeature",
    value: function parseFeature(feature, featureId, style) {
      if (!feature.geometry) return;
      var geometry = this.parseGeometry(feature.geometry, style);
      var ptCount = geometry.attributes.position.values.length;
      var batchIds = new Float32Array(ptCount);
      batchIds.fill(featureId);
      var _Cesium = Cesium;
      var batchId = new _Cesium.GeometryAttribute({
        componentDatatype: _Cesium.ComponentDatatype.FLOAT,
        componentsPerAttribute: 1,
        values: batchIds
      });
      geometry.attributes.batchId = batchId;
      return geometry;
    }
    /**
     * 
     * @param {geojson.Polygon|geojson.MultiPolygon|geojson.MultiGeometry<geojson.Polygon|geojson.MultiPolygon>} geometry 
     */

  }, {
    key: "parseGeometry",
    value: function parseGeometry(geometry, options) {
      var _this2 = this;

      var type = geometry.type;

      if (type == 'Polygon') {
        geometry = this.parsePolygon(geometry.coordinates, options);
      } else if (type == 'MultiPolygon') {
        var geometries = geometry.coordinates.map(function (polygon) {
          return _this2.parsePolygon(polygon, options);
        });
        geometry = _GeometryUtils["default"].mergeGeometries(geometries);
      } else if (type == 'MultiGeometry') {
        var _geometries = geometry.geometry.map(function (geometry) {
          return _this2.parseGeometry(geometry, options);
        });

        geometry = _GeometryUtils["default"].mergeGeometries(_geometries);
      }

      return geometry;
    }
    /**
     * 
     * @param {geojson.Polygon} coordinates 
     * @param {{
        height?: number;
        extrudedHeight?: number;
        vertexFormat?: VertexFormat;
        stRotation?: number;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        perPositionHeight?: boolean;
        closeTop?: boolean;
        closeBottom?: boolean;
        arcType?: ArcType;
     * }}options
     * @returns {Cesium.Geometry} result 
     */

  }, {
    key: "parsePolygon",
    value: function parsePolygon(coordinates, options) {
      var _Cesium3 = Cesium,
          PolygonHierarchy = _Cesium3.PolygonHierarchy,
          PolygonGeometry = _Cesium3.PolygonGeometry;
      var positions = this.transformCoordinates(coordinates[0]),
          holes = [];

      for (var i = 1; i < coordinates.length; i++) {
        var contour = coordinates[i];
        contour = new PolygonHierarchy(this.transformCoordinates(contour));
        holes.push(contour);
      }

      var geometryCls = PolygonGeometry; //ExtrudedPolygonGeometry;

      var geometry = new geometryCls(Object.assign({
        polygonHierarchy: new PolygonHierarchy(positions, holes),
        generateExtrudedUvNormal: true
      }, options));
      geometry = geometryCls.createGeometry(geometry);
      return geometry;
    }
  }, {
    key: "transformCoordinates",
    value: function transformCoordinates(contour) {
      var cw = _geojsonHelper["default"].isClockWise(contour);

      contour = contour.map(function (pt) {
        return Cesium.Cartesian3.fromDegrees(pt[0], pt[1], pt[2] || 0);
      });

      if (!cw) {
        contour.reverse();
      }

      return contour;
    }
  }]);
  return BuildingVector3DLoader;
}();

exports["default"] = BuildingVector3DLoader;

},{"s_310":2,"-_312":189,"h_311":199,"3_313":207,"._315":83,"D_314":84,"e_1":235,"s_2":236,"M_0":241}],76:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _index = require("3_170");

var _MeshVisualizer = _interopRequireDefault(require("s_123"));

var _CesiumRTCHelper = _interopRequireDefault(require("s_321"));

var quat;
var position;
var mat3;
var dir;
var mat4;
var dirInverse = {
  x: 0,
  y: 0,
  z: -1
};
var quat2;
var axis = {
  x: 0,
  y: 1,
  z: 0
};

var CameraHelper = /*#__PURE__*/function () {
  function CameraHelper() {
    (0, _classCallCheck2["default"])(this, CameraHelper);
    this.visualizer = new _MeshVisualizer["default"]();
    /**
     * @type {WeakMap<Cesium.Camera,Mesh>}
     */

    this.cameraMeshes = new WeakMap();
    this.cameras = [];
    this.show = true;
  }

  (0, _createClass2["default"])(CameraHelper, [{
    key: "update",
    value: function update(frameState) {
      if (!this.show) return;
      this.visualizer.update(frameState);
    }
  }, {
    key: "removeCamera",
    value: function removeCamera(camera) {
      if (this.cameraMeshes.has(camera)) {
        var mesh = this.cameraMeshes.get(camera);
        if (this.visualizer.children.indexOf(mesh.frustum) != -1) this.visualizer.remove(mesh.frustum);
        if (this.visualizer.children.indexOf(mesh.direction) != -1) this.visualizer.remove(mesh.direction);
        this.cameraMeshes["delete"](camera);
      }
    }
    /**
     * 
     * @param {Cesium.Camera} camera 
     */

  }, {
    key: "addCamera",
    value: function addCamera(camera, color, dirColor, matrix) {
      if (this.cameraMeshes.has(camera)) {
        var mesh = this.cameraMeshes.get(camera);
        if (this.visualizer.children.indexOf(mesh.frustum) == -1) this.visualizer.add(mesh.frustum);
        if (this.visualizer.children.indexOf(mesh.direction) == -1) this.visualizer.add(mesh.direction);
        return;
      }

      var geometry = this.createGeometry(camera, matrix);
      var outlineMaterial = new THREE.LineBasicMaterial({
        color: (color || Cesium.Color.YELLOW).toCssColorString(),
        side: 2
      });
      var dirMaterial = new THREE.LineBasicMaterial({
        color: (dirColor || Cesium.Color.RED).toCssColorString(),
        side: 2
      });
      var frustumOutline = new THREE.LineSegments(geometry.frustumOutline, outlineMaterial);
      var directionLine = new THREE.LineSegments(geometry.direction, dirMaterial);
      directionLine.frustumCulled = false;
      frustumOutline.frustumCulled = false;
      directionLine.up.set(0, 0, 1);
      frustumOutline.up.set(0, 0, 1);
      this.visualizer.add(frustumOutline);
      this.visualizer.add(directionLine);
      this.cameraMeshes.set(camera, {
        frustum: frustumOutline,
        direction: directionLine
      }); // camera.changed.addEventListener(()=>{
      //     this.updateCamera(camera)
      // })

      this.cameras.push(camera);
    }
  }, {
    key: "createGeometry",
    value: function createGeometry(camera, matrix) {
      var _Cesium = Cesium,
          Matrix4 = _Cesium.Matrix4,
          Cartesian3 = _Cesium.Cartesian3,
          Quaternion = _Cesium.Quaternion,
          Matrix3 = _Cesium.Matrix3,
          FrustumOutlineGeometry = _Cesium.FrustumOutlineGeometry;
      matrix = matrix || camera.inverseViewMatrix;
      if (matrix.elements) matrix = matrix.elements;
      mat3 = Matrix4.getMatrix3(matrix, mat3 || new Matrix3());
      quat = Quaternion.fromRotationMatrix(mat3, quat || new Quaternion());
      quat2 = Quaternion.fromAxisAngle(axis, Math.PI, quat2);
      Quaternion.multiply(quat, quat2, quat);
      position = Matrix4.getTranslation(camera.inverseViewMatrix, position || new Cartesian3());
      var frustumOutlineGeometry = new FrustumOutlineGeometry({
        frustum: camera.frustum,
        origin: position,
        orientation: quat
      }); //增加观察方向辅助线

      return {
        direction: _index.GeometryUtils.toBufferGeometry3js(this.createDirGeometry(position, mat3, camera.frustum.far)),
        frustumOutline: _index.GeometryUtils.toBufferGeometry3js(FrustumOutlineGeometry.createGeometry(frustumOutlineGeometry))
      };
    }
  }, {
    key: "createDirGeometry",
    value: function createDirGeometry(position, rotationMatrix, far) {
      var _Cesium2 = Cesium,
          Matrix4 = _Cesium2.Matrix4,
          Cartesian3 = _Cesium2.Cartesian3,
          Geometry = _Cesium2.Geometry,
          ComponentDatatype = _Cesium2.ComponentDatatype;
      mat4 = Matrix4.IDENTITY.clone(mat4);
      Matrix4.multiplyByMatrix3(mat4, rotationMatrix, mat4);
      if (!dir) dir = new Cartesian3();
      Matrix4.multiplyByPoint(mat4, dirInverse, dir);
      Cartesian3.multiplyByScalar(dir, far || 50000000000, dir);
      var target = Cartesian3.add(position, dir, dir);
      var positions = new Float32Array(2 * 3);
      Cartesian3.pack(position, positions, 0);
      Cartesian3.pack(target, positions, 3);
      var indices = new Uint8Array([0, 1]);
      var geometry = new Geometry({
        attributes: {
          position: {
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: positions
          }
        },
        indices: indices
      });
      return geometry;
    }
  }, {
    key: "updateCamera",
    value: function updateCamera(camera, matrix) {
      var mesh = this.cameraMeshes.get(camera);
      var geometry = this.createGeometry(camera, matrix);
      mesh.frustum.geometry = geometry.frustum;
      mesh.frustum.geometry.needsUpdate = true;
      mesh.direction.geometry = geometry.direction;
      mesh.direction.geometry.needsUpdate = true;
    }
  }]);
  return CameraHelper;
}();

var _default = CameraHelper;
exports["default"] = _default;

},{"s_123":5,"3_170":39,"s_321":77,"e_1":235,"s_2":236,"M_0":241}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = CesiumRTCHelper;
var scratchTranslationRtc;

var CESIUM_RTC_MODELVIEW = function CESIUM_RTC_MODELVIEW(uniformState, model) {
  // CESIUM_RTC extension
  var _Cesium = Cesium,
      Matrix4 = _Cesium.Matrix4,
      defined = _Cesium.defined,
      Cartesian3 = _Cesium.Cartesian3;
  var mvRtc = new Matrix4();
  if (!scratchTranslationRtc) scratchTranslationRtc = new Matrix4();
  return function () {
    if (defined(model._rtcCenter)) {
      Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);
      Cartesian3.add(scratchTranslationRtc, model._rtcCenter, scratchTranslationRtc);
      Matrix4.multiplyByPoint(uniformState.view, scratchTranslationRtc, scratchTranslationRtc);
      return Matrix4.setTranslation(uniformState.modelView, scratchTranslationRtc, mvRtc);
    }

    return uniformState.modelView;
  };
};

function CesiumRTCHelper(object) {
  var _rtcCenter = object._rtcCenter;

  if (!_rtcCenter) {
    var getBoundingSphere = function getBoundingSphere(obj) {
      var geometry = obj.geometry;
      if (!geometry) return;
      var boundingSphere = geometry.boundingSphere;

      if (!boundingSphere) {
        geometry.computeBoundingSphere();
        boundingSphere = geometry.boundingSphere;
      }

      spheres.push(Cesium.BoundingSphere.clone(boundingSphere));
    };

    var spheres = [];
    object.traverse(getBoundingSphere);

    if (spheres.length) {
      var allSphere = Cesium.BoundingSphere.fromBoundingSpheres(spheres);
      object._rtcCenter = _rtcCenter = allSphere.center;
    }
  }

  if (!_rtcCenter) return object;

  function userCenter(obj) {
    var geometry = obj.geometry;
    if (!geometry) return;
    var positionAttr = geometry.attributes.position;
    if (!positionAttr) return;
    var positions = positionAttr.array;

    for (var i = 0; i < positions.length; i += 3) {
      positions[i] -= _rtcCenter.x;
      positions[i + 1] -= _rtcCenter.y;
      positions[i + 2] -= _rtcCenter.z;
    }
  }

  object.traverse(userCenter);

  var uniformMapLoadedCallback = function uniformMapLoadedCallback(uniformMap, frameState) {
    var cesiumRtcModelViewUniform = CESIUM_RTC_MODELVIEW(frameState.context.uniformState, object);
    uniformMap.modelView = cesiumRtcModelViewUniform;
    uniformMap.u_modelView = cesiumRtcModelViewUniform;
    uniformMap.modelViewMatrix = cesiumRtcModelViewUniform;
    uniformMap.u_modelViewMatrix = cesiumRtcModelViewUniform;
  };

  object.traverse(function (child) {
    if (!child.geometry) return;
    child.uniformMapLoadedCallback = uniformMapLoadedCallback;
  });

  if (object.geometry) {
    object.uniformMapLoadedCallback = uniformMapLoadedCallback;
  }

  return object;
}

},{}],78:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _QuadtreeNode = _interopRequireDefault(require("D_325"));

// import { Object3D } from "../core/Object3D.js";
var IContentProvider = /*#__PURE__*/function () {
  function IContentProvider() {
    (0, _classCallCheck2["default"])(this, IContentProvider);
  }

  (0, _createClass2["default"])(IContentProvider, [{
    key: "requestContent",
    value:
    /**
     * 
     * @param {string|geojson.Feature|geojson.FeatureCollection|QuadtreeNode[]} uri 
     * @param {Cesium.Cartesian3} [rtcCenter] 
     * @returns {THREE.Object3D}
     */
    function requestContent(uri, rtcCenter) {
      throw new Error('IContentProvider.requestContent not implemented');
    }
  }]);
  return IContentProvider;
}();

exports["default"] = IContentProvider;

},{"D_325":85,"e_1":235,"s_2":236,"M_0":241}],79:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.memeoryOf = memeoryOf;
exports.boundingBoxToRegion = boundingBoxToRegion;
exports.getSurfacePosition = getSurfacePosition;
exports.tileContains = tileContains;
exports.selectTileLoaded = selectTileLoaded;
exports.updatePositionClamped = updatePositionClamped;
exports.packBoundingRegion = packBoundingRegion;
exports.unpackBoundingRegion = unpackBoundingRegion;
exports.packBoundingBox = packBoundingBox;
exports.unpackBoundingBox = unpackBoundingBox;
exports.packBoundingSphere = packBoundingSphere;
exports.unpackBoundingSphere = unpackBoundingSphere;
exports.computeBoundingVolume = computeBoundingVolume;

var _WebGLGeometries = _interopRequireDefault(require("C_327"));

var _materialMapParameters = ['map', 'lightMap', 'bumpMap', 'aoMap', 'specularMap', 'alphaMap', 'envMap', 'normalMap', 'emissiveMap', 'displacementMap', 'metalnessMap', 'roughnessMap', 'transmissionMap', 'clearcoatNormalMap', 'clearcoatMap'];
/**
 * 
 * @param {THREE.Texture|THREE.BufferGeometry|THREE.Mesh|THREE.MeshPhysicalMaterial} obj 
 * @returns {number} in bytes
 */

function memeoryOf(obj) {
  var mem = 0;

  if (obj.isTexture) {
    var image = obj.image,
        pixelSize = 4; //obj.format == 1023 ? 4 : 3;

    mem = image.width * image.height * pixelSize;
  } else if (obj.isGeometry) {
    var geometry = _WebGLGeometries["default"].get(obj);

    var attributes = geometry.attributes;

    for (var key in attributes) {
      if (attributes[key]) {
        var arrayView = attributes[key].array;
        mem += arrayView.buffer.byteLength;
      }
    }

    if (obj.index) {
      mem += obj.index.array.buffer.byteLength;
    }
  } else if (obj.isMesh) {
    var geometryMem = memeoryOf(obj.geometry);
    var materials = obj.material;
    if (!Array.isArray(materials)) materials = [materials];
    var meterialMem = 0;
    materials.forEach(function (material) {
      meterialMem += memeoryOf(material);
    });
    mem = meterialMem + geometryMem;
  } else if (obj.isMaterial) {
    _materialMapParameters.forEach(function (name) {
      var map = obj[name];
      if (map) mem += memeoryOf(map);
    });
  } else if (obj.isObject3D) {
    obj.children.forEach(function (child) {
      mem += memeoryOf(child);
    });
  }

  return mem;
}
/**
 * 
 * @param {Cesium.AxisAlignedBoundingBox} boundingBox 
 * @param {Cesium.Matrix4} modelMatrix 
 * @returns {Cesium.TileBoundingRegion}
 */


function boundingBoxToRegion(boundingBox, modelMatrix) {
  var _Cesium2 = Cesium,
      Rectangle = _Cesium2.Rectangle,
      Cartographic = _Cesium2.Cartographic,
      Matrix4 = _Cesium2.Matrix4,
      Cartesian3 = _Cesium2.Cartesian3,
      Ellipsoid = _Cesium2.Ellipsoid,
      TileBoundingRegion = _Cesium2.TileBoundingRegion;
  var min = boundingBox.minimum,
      max = boundingBox.maximum;
  var xs = [min.x, max.x],
      ys = [min.y, max.y],
      zs = [min.z, max.z],
      p = new Cartesian3(0, 0, 0),
      pWC = new Cartesian3(),
      pnCart = new Cartographic();
  var minLon = Math.PI * 2,
      maxLon = -minLon,
      minLat = Math.PI,
      maxLat = -minLat,
      minimumHeight = Number.MAX_VALUE,
      maximumHeight = -minimumHeight;

  for (var i = 0; i < xs.length; i++) {
    p.x = xs[i];

    for (var j = 0; j < ys.length; j++) {
      p.y = ys[j];

      for (var k = 0; k < zs.length; k++) {
        p.z = zs[k];
        Matrix4.multiplyByPoint(modelMatrix, p, pWC);
        Cartographic.fromCartesian(pWC, Ellipsoid.WGS84, pnCart);
        minLon = Math.min(pnCart.longitude, minLon);
        maxLon = Math.max(pnCart.longitude, maxLon);
        minLat = Math.min(pnCart.latitude, minLat);
        maxLat = Math.max(pnCart.latitude, maxLat);
        minimumHeight = Math.min(pnCart.height, minimumHeight);
        maximumHeight = Math.max(pnCart.height, maximumHeight);
      }
    }
  }

  var rectangle = Rectangle.fromRadians(minLon, minLat, maxLon, maxLat);
  return new TileBoundingRegion({
    rectangle: rectangle,
    minimumHeight: minimumHeight,
    maximumHeight: maximumHeight,
    ellipsoid: Ellipsoid.WGS84
  });
}

function getSurfacePosition(positionWC) {
  var _Cesium = Cesium;

  var positionCartographic = _Cesium.Cartographic.fromCartesian(positionWC);

  var positionSurface = _Cesium.Cartesian3.fromRadians(positionCartographic.longitude, positionCartographic.latitude, 0);

  return positionSurface;
}

var _scratchTileContainsRay;
/**
 * 
 * @param {{
 * region?:Cesium.TileBoundingRegion
 * boundingSphere?:Cesium.BoundingSphere
 * boundingSphereWC?:Cesium.BoundingSphere
 * }} tile 
 * @param {Cesium.Cartesian3} positionSurface 
 * @returns {boolean}
 */


function tileContains(tile, positionSurface) {
  var _Cesium3 = Cesium,
      Rectangle = _Cesium3.Rectangle,
      Cartographic = _Cesium3.Cartographic,
      Cartesian3 = _Cesium3.Cartesian3,
      IntersectionTests = _Cesium3.IntersectionTests,
      Ray = _Cesium3.Ray;

  if (tile.region) {
    var positionCartographic = Cartographic.fromCartesian(positionSurface);
    var rectangle = tile.region.rectangle;
    return Rectangle.contains(rectangle, positionCartographic);
  } else {
    if (!_scratchTileContainsRay) _scratchTileContainsRay = new Ray();
    Cartesian3.clone(positionSurface, _scratchTileContainsRay.position);
    Cartesian3.normalize(positionSurface, _scratchTileContainsRay.direction);
    var boundingSphereWC = tile.boundingSphereWC || tile.boundingSphere;

    if (!boundingSphereWC) {
      return false;
    }

    return IntersectionTests.raySphere(_scratchTileContainsRay, boundingSphereWC);
  }
}

function selectTileLoaded(tile, position, isPositionSurface) {
  var positionSurface = isPositionSurface ? position : getSurfacePosition(position);
  var l = tile.children.length;

  if (tileContains(tile, positionSurface)) {
    var result;

    for (var i = 0; i < l; i++) {
      result = selectTileLoaded(tile.children[i], positionSurface, true);
      if (result) break;
    }

    if (!result && tile.isCommandsReady()) {
      result = tile;
    }

    return result;
  }
}
/**
 * 
 * @param {QuadtreeLOD} lodSet 
 * @param {Cesium.Entity[]} entities 
 * @param {Cesium.Viewer}viewer
 * @param {boolean}[foreUpdate=false]
 */


function updatePositionClamped(lodSet, entities, viewer, foreUpdate) {
  // var maxLevel = lodSet.maxLevel || 5
  entities.forEach(function (entity) {
    if (entity.positionClamped && !foreUpdate) return;
    var positionProperty = entity.position;
    var position = positionProperty.getValue(viewer.clock.currentTime);
    var tile = selectTileLoaded(lodSet, position);

    if (tile) {
      var positionClamped = viewer.scene.clampToHeight(position, entities);

      if (positionClamped) {
        // var positionClampedCartographic = Cesium.Cartographic.fromCartesian(positionClamped)
        // if (positionClampedCartographic.height > 0 || tile.level == maxLevel) {
        entity.position = positionClamped;
        entity.positionClamped = positionClamped; // }
      }
    }
  });
}
/**
 * 
 * @param {Cesium.TileBoundingRegion} region 
 * @param {number[]} [array]  
 * @param {number} [startIndex]
 */


function packBoundingRegion(region, array, startIndex) {
  startIndex = startIndex || 0;
  array = array || [];
  Cesium.Rectangle.pack(region.rectangle, startIndex);
  array[startIndex + 4] = region.minimumHeight;
  array[startIndex + 5] = region.maximumHeight;
  return array;
}
/**
 *  
 * @param {number[]} [array]  
 * @param {number} [startIndex]
 * @returns {Cesium.TileBoundingRegion}
 */


function unpackBoundingRegion(array, startIndex) {
  var _Cesium4 = Cesium,
      Rectangle = _Cesium4.Rectangle,
      TileBoundingRegion = _Cesium4.TileBoundingRegion;
  startIndex = startIndex || 0;
  var rectangle = Rectangle.unpack(array, startIndex);
  var minimumHeight = array[startIndex + 4];
  var maximumHeight = array[startIndex + 5];
  var region = new TileBoundingRegion({
    rectangle: rectangle,
    minimumHeight: minimumHeight,
    maximumHeight: maximumHeight
  });
  return region;
}
/**
 * 
 * @param {Cesium.AxisAlignedBoundingBox} box 
 * @param {number[]} [array]  
 * @param {number} [startIndex]
 */


function packBoundingBox(box, array, startIndex) {
  startIndex = startIndex || 0;
  array = array || [];
  var Cartesian3 = Cesium.Cartesian3;
  Cartesian3.pack(box.center, array, startIndex);
  Cartesian3.pack(box.minimum, array, startIndex + 3);
  Cartesian3.pack(box.maximum, array, startIndex + 6);
  return array;
}
/**
 * 
 * @param {number[]} array 
 * @param {number} [startIndex=0] 
 * @param {Cesium.AxisAlignedBoundingBox}[result]
 * @returns {Cesium.AxisAlignedBoundingBox}
 */


function unpackBoundingBox(array, startIndex, result) {
  startIndex = startIndex || 0;
  var _Cesium5 = Cesium,
      Cartesian3 = _Cesium5.Cartesian3,
      AxisAlignedBoundingBox = _Cesium5.AxisAlignedBoundingBox;
  if (!result) result = new AxisAlignedBoundingBox();
  Cartesian3.unpack(array, startIndex, result.center);
  Cartesian3.unpack(array, startIndex + 3, result.minimum);
  Cartesian3.unpack(array, startIndex + 6, result.maximum);
  return result;
}
/**
 * 
 * @param {Cesium.BoundingSphere} sphere 
 * @param {number[]} [array] 
 * @param {number} [startIndex]
 * @returns {number} array
 */


function packBoundingSphere(sphere, array, startIndex) {
  startIndex = startIndex || 0;
  if (!array) array = [];
  Cesium.Cartesian3.pack(sphere.center, array, startIndex);
  array[startIndex + 3] = sphere.radius;
  return array;
}
/**
 * 
 * @param {number[]} array 
 * @param {number} [startIndex=0] 
 * @param {Cesium.BoundingSphere}[result]
 * @returns {Cesium.BoundingSphere}
 */


function unpackBoundingSphere(array, startIndex, result) {
  startIndex = startIndex || 0;
  var _Cesium6 = Cesium,
      Cartesian3 = _Cesium6.Cartesian3,
      BoundingSphere = _Cesium6.BoundingSphere;
  if (!result) result = new BoundingSphere();
  Cartesian3.unpack(array, startIndex, result.center);
  result.radius = array[startIndex + 3];
  return result;
}
/**
 * 
 * @param {THREE.Group} model 
 * @returns {{
 * box:number[]
 * sphere:number[]
 * }}
 */


function computeBoundingVolume(model) {
  var _Cesium7 = Cesium,
      BoundingSphere = _Cesium7.BoundingSphere,
      AxisAlignedBoundingBox = _Cesium7.AxisAlignedBoundingBox,
      Cartesian3 = _Cesium7.Cartesian3,
      Matrix4 = _Cesium7.Matrix4;
  model.updateMatrixWorld(true);
  var vertices = [];
  model.updateMatrixWorld();
  model.traverse(function (object) {
    if (object.isMesh) {
      var geometry = object.geometry;
      var positions = geometry.getAttribute('position');

      if (!positions || positions.count < 3) {
        debugger;
      }

      positions = positions.array;

      try {
        positions = Cartesian3.unpackArray(positions);
        positions.forEach(function (position) {
          Matrix4.multiplyByPoint(object.matrixWorld.elements, position, position);
          vertices.push(position);
        });
      } catch (err) {
        console.error(err);
      }
    }
  });
  var box = AxisAlignedBoundingBox.fromPoints(vertices);
  var bs = BoundingSphere.fromPoints(vertices);
  var boxCenter = box.center;
  var boxArr = [];
  Cartesian3.pack(boxCenter, boxArr, 0);
  Cartesian3.pack(box.minimum, boxArr, 3);
  Cartesian3.pack(box.maximum, boxArr, 6);
  var sphere = [bs.center.x, bs.center.y, bs.center.z, bs.radius];
  return {
    sphere: sphere,
    box: boxArr
  };
}

},{"C_327":22,"M_0":241}],80:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Path = _interopRequireDefault(require("D_336"));

var _StringUtil = _interopRequireDefault(require("._337"));

var _GenericWorker = _interopRequireDefault(require("-_312"));

var _traverse = _interopRequireDefault(require("3_313"));

var Osg = _interopRequireWildcard(require("m_340"));

var _parseOsg = require("M_341");

var _OSGLoader = _interopRequireDefault(require("e_342"));

var _IRenderable2 = _interopRequireDefault(require("s_343"));

var _releaseResources = _interopRequireDefault(require("h_344"));

var _RendererUtils = _interopRequireDefault(require("-_345"));

var _LODUtils = require("3_346");

var _PagedLODQueue = require("D_347");

var _PagedLODState = _interopRequireDefault(require("._348"));

var _GeometryUtils = _interopRequireDefault(require("s_310"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function checkShouldCancel(previousLod, lod) {
  var shouldCancel = previousLod.root && !previousLod.root._visible;

  if (!shouldCancel) {
    shouldCancel = previousLod.parent && !previousLod.parent._visible;
  }

  if (!shouldCancel) {
    shouldCancel = !previousLod._visible;
  }

  if (!shouldCancel) {
    shouldCancel = (0, _PagedLODQueue.pendingSort)(previousLod, lod) > 0;
  }

  return shouldCancel;
}
/**
 * 
 * @param {PagedLOD} lod 
 * @param {string} rootPath
 * @private
 */


function toJSON(lod, rootPath) {
  var json = {
    uri: lod.uri.replace(rootPath, '.')
  };

  if (lod.localBoundingSphere) {
    json.sphere = (0, _LODUtils.packBoundingSphere)(lod.localBoundingSphere);
  }

  if (lod.aabbLocal) {
    json.box = (0, _LODUtils.packBoundingBox)(lod.aabbLocal);
  }

  return json;
}

var scratchMatrix3;

function updateContentModelMatrix(lod) {
  if (!lod.boundingSphere) return;
  var _Cesium2 = Cesium,
      Matrix3 = _Cesium2.Matrix3,
      Matrix4 = _Cesium2.Matrix4,
      BoundingSphere = _Cesium2.BoundingSphere;
  var tileset = lod.tileset;
  var modelMatrix = tileset ? tileset.modelMatrix : lod.modelMatrix; //boundingSphere

  var uniformScale = Matrix4.getMaximumScale(modelMatrix);
  var boundingSphere = lod.boundingSphere,
      localBoundingSphere = lod.localBoundingSphere;
  boundingSphere.radius *= uniformScale;
  Matrix4.multiplyByPoint(modelMatrix, localBoundingSphere.center, boundingSphere.center);
  lod.boundingSphere2d = BoundingSphere.projectTo2D(boundingSphere, null, lod.boundingSphere2d); //boudingBox

  var obb = lod.obb,
      aabbLocal = lod.aabbLocal;

  if (obb) {
    Matrix4.multiplyByPoint(modelMatrix, obb.center, obb.center);
    if (!scratchMatrix3) scratchMatrix3 = new Matrix3();
    var rotationScale = Matrix4.getMatrix3(modelMatrix, scratchMatrix3);
    Matrix3.multiply(rotationScale, obb.halfAxes, obb.halfAxes);
  }

  if (lod.aabbLocal) {
    Matrix4.multiplyByPoint(modelMatrix, aabbLocal.center, lod.aabb.center);
    lod.region = (0, _LODUtils.boundingBoxToRegion)(aabbLocal, modelMatrix);
  } //content


  if (!lod.content) return;
  lod.content.traverse(function (node) {
    if (node.isMesh) {
      node.frustumCulled = false;
      Matrix4.multiply(modelMatrix, node.matrixWorld.elements, node.modelMatrix);
    }

    node.matrixAutoUpdate = false;
    node.modelMatrixNeedsUpdate = false;
  });

  if (lod.debugVolume && lod.debugVolume.isObject3D) {
    lod.debugVolume._modelMatrix = modelMatrix;
  }
} //parse
//2


function parseOsgb(lod) {
  var osgRoot = lod.osgRoot,
      promise;

  if (lod._osgBuffer) {
    osgRoot = Osg.readBuffer(lod._osgBuffer);

    if (!osgRoot) {
      //osg
      var osg = new Uint8Array(lod._osgBuffer);
      osg = THREE.LoaderUtils.decodeText(osg);
      osgRoot = (0, _parseOsg.readOsg)(osg);
      lod.content = (0, _parseOsg.parseOsg)(osgRoot, false);
      (0, _traverse["default"])(lod.content, function (obj) {
        obj.castShadow = lod.castShadow;
        obj.receiveShadow = lod.receiveShadow;
      });
    }

    lod.osgRoot = osgRoot;
    lod._osgBuffer = null;
  }

  if (osgRoot) {
    // lod.rangeMode = osgRoot.RangeMode;
    lod.rangeDataList = osgRoot.RangeDataList;
    lod.rangeList = osgRoot.RangeList; // lod.centerMode = osgRoot.CenterMode;

    var minHeight = lod.tileset.minHeight;

    if (typeof lod.tileset.minHeight == 'number') {
      Osg.traverse(osgRoot, function (osgNode) {
        if (osgNode.Type !== 'Osg::Geometry') return;
        var vertices = osgNode.VertexArray.Value;

        for (var i = 0; i < vertices.length; i += 3) {
          if (vertices[i + 2] < minHeight) {
            vertices[i + 2] = minHeight;
          }
        }
      });
    }

    if (!lod._isExpired) {
      computeBoundingVolume(lod);
    } //empty lod


    if (lod._isEmptyLOD) {
      promise = Cesium.when.defer();
      promise.resolve(lod);
    } else if (osgRoot.Type == 'Osg::PagedLOD' || osgRoot.Type == 'Osg::Geometry') {
      if (!lod.children[0]) {
        //first load
        createRangeDataChild(lod);
      }

      promise = parseContent(lod);
    } else {
      lod.hasEmbedLOD = true;
      lod._contentMemorySize = 0;
      promise = createOrUpdateEmbedLodChildren(lod);
    }
  } else {
    promise = Cesium.when.defer();
    promise.resolve(lod);
  }

  return promise;
}
/**
 * 
 * @param {PagedLOD} lod 
 * @returns 
 */


function parseContent(lod) {
  var tileset = lod.tileset;
  var df = Cesium.when.defer();

  if (lod.content) {
    debugger;
    var mem = (0, _LODUtils.memeoryOf)(lod.content);
    tileset._memorySize += mem;
    lod._contentMemorySize = mem;
    df.resolve(lod);
  } else {
    var loader = lod.loader,
        _tileset = lod.tileset;
    loader.parse(lod.osgRoot, lod.path, function (model) {
      model.traverse(function (node) {
        if (node.isMesh) {
          node.frustumCulled = false;
          node.pickObject = {
            id: lod,
            mesh: node,
            primitive: _tileset
          };
          node.material.autoRefresh = false;
          node.modelMatrix = Cesium.Matrix4.multiply(_tileset.modelMatrix, node.matrixWorld.elements, node.modelMatrix);
        }

        node.matrixAutoUpdate = false;
        node.modelMatrixNeedsUpdate = false;
      });
      var mem = (0, _LODUtils.memeoryOf)(model);
      _tileset._memorySize += mem;
      lod._contentMemorySize = mem;
      lod.content = model;
      lod.content.osgRoot = null;
      lod.osgRoot = null;
      updateContentModelMatrix(lod);
      df.resolve(lod);
    }, function (e) {
      console.error(e);
      df.reject(e);
    }, {
      loadTexture: _tileset.loadTexture,
      materialType: _tileset.materialType
    });
  }

  return df;
} //2-1

/**
 * 
 * @param {PagedLOD} lod 
 */


function computeBoundingSphere(lod) {
  var _Cesium3 = Cesium,
      BoundingSphere = _Cesium3.BoundingSphere,
      Cartesian3 = _Cesium3.Cartesian3,
      Matrix4 = _Cesium3.Matrix4;
  lod._isEmptyLOD = false;

  if (!lod.tileset) {
    var boundingSpheres = [];
    lod.children.forEach(function (child) {
      if (child._isEmptyLOD) return;
      boundingSpheres.push(child.localBoundingSphere);
    });
    lod.localBoundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);
    lod.boundingSphere = lod.localBoundingSphere.clone();
    return;
  }

  var osgRoot = lod.osgRoot;

  if (osgRoot) {
    var children = osgRoot.Children;
    var userCenter = osgRoot.UserCenter;

    if (osgRoot.Type == 'Osg::PagedLOD') {
      lod.localBoundingSphere = new BoundingSphere(Cartesian3.fromArray(userCenter.center), userCenter.radius);
    } else if (children && children[0].Type == 'Osg::PagedLOD') {
      var _boundingSpheres = [];
      osgRoot.Children.forEach(function (osgChild) {
        userCenter = osgChild.UserCenter;

        if (!userCenter) {
          return;
        }

        _boundingSpheres.push(new BoundingSphere(Cartesian3.fromArray(userCenter.center), userCenter.radius));
      });

      if (_boundingSpheres.length) {
        lod.localBoundingSphere = BoundingSphere.fromBoundingSpheres(_boundingSpheres);
      }
    } else {
      var _boundingSpheres2 = [];
      Osg.traverse(osgRoot, function (osgNode) {
        if (osgNode.Type == 'Osg::Geometry') {
          var vertices = osgNode.VertexArray.Value;

          _boundingSpheres2.push(BoundingSphere.fromVertices(vertices));
        }
      });

      if (_boundingSpheres2.length == 0) {
        lod._isEmptyLOD = true; // throw new Error('cannot compute boundingSphere for node ' + osgRoot);
      } else {
        lod.localBoundingSphere = BoundingSphere.fromBoundingSpheres(_boundingSpheres2);
      }
    }
  }

  if (!lod._isEmptyLOD) {
    lod.boundingSphere = lod.localBoundingSphere.clone();
    var uniformScale = Matrix4.getMaximumScale(lod.tileset.modelMatrix);
    lod.boundingSphere.radius *= uniformScale;
    Matrix4.multiplyByPoint(lod.tileset.modelMatrix, lod.localBoundingSphere.center, lod.boundingSphere.center);
    lod.boundingSphere2d = BoundingSphere.projectTo2D(lod.boundingSphere);
  }
}

function computeBoundingVolume(lod) {
  var _Cesium4 = Cesium,
      Color = _Cesium4.Color,
      AxisAlignedBoundingBox = _Cesium4.AxisAlignedBoundingBox,
      OrientedBoundingBox = _Cesium4.OrientedBoundingBox,
      Matrix3 = _Cesium4.Matrix3,
      Cartesian3 = _Cesium4.Cartesian3,
      BoxOutlineGeometry = _Cesium4.BoxOutlineGeometry,
      Transforms = _Cesium4.Transforms,
      Matrix4 = _Cesium4.Matrix4;

  try {
    computeBoundingSphere(lod);
    if (lod._isEmptyLOD) return;
    var osgRoot = lod.osgRoot,
        transform = lod.tileset.modelMatrix;

    if (osgRoot) {
      var vertices = [];
      Osg.traverse(osgRoot, function (node) {
        if (node.Type == 'Osg::Geometry') {
          var pts = Cartesian3.unpackArray(node.VertexArray.Value);
          vertices = vertices.concat(pts);
        }
      });
      if (!vertices.length) return;
      lod.obbLocal = OrientedBoundingBox.fromPoints(vertices);
      lod.aabbLocal = AxisAlignedBoundingBox.fromPoints(vertices);
    } else if (!lod.aabbLocal && !lod.obbLocal) {
      return;
    }

    if (lod.aabbLocal) {
      lod.aabb = lod.aabbLocal.clone();
      Matrix4.multiplyByPoint(transform, lod.aabbLocal.center, lod.aabb.center);
      lod.region = (0, _LODUtils.boundingBoxToRegion)(lod.aabbLocal, transform);

      if (lod.debugVolume) {
        var boxGeometry = BoxOutlineGeometry.fromAxisAlignedBoundingBox(lod.aabbLocal);
        boxGeometry = BoxOutlineGeometry.createGeometry(boxGeometry);
        boxGeometry = _GeometryUtils["default"].toBufferGeometry3js(boxGeometry);
        var aabBoxMaterial = new THREE.LineBasicMaterial({
          color: 'cyan'
        });
        aabBoxMaterial.allowPick = false;
        lod.debugVolume = new THREE.LineSegments(boxGeometry, aabBoxMaterial);
        lod.debugVolume.modelMatrixNeedsUpdate = false;
        lod.debugVolume._modelMatrix = lod.tileset.modelMatrix;
      }
    }

    if (lod.obbLocal) {
      lod.obb = lod.obbLocal.clone();
      Matrix4.multiplyByPoint(transform, lod.obb.center, lod.obb.center);
      if (!scratchMatrix3) scratchMatrix3 = new Matrix3();
      var rotationScale = Matrix4.getMatrix3(transform, scratchMatrix3);
      Matrix3.multiply(rotationScale, lod.obb.halfAxes, lod.obb.halfAxes);
    }
  } catch (err) {
    debugger;
    throw err;
  }
} //2-2

/**
 * 
 * @param {PagedLOD} lod 
 */


function createRangeDataChild(lod) {
  var rangeDataList = lod.rangeDataList;

  if (rangeDataList && rangeDataList.length > 0) {
    //prepare next level 
    var childFileName = rangeDataList[1];
    var parent = lod;
    var childTile = new PagedLOD({
      tileset: parent.tileset,
      tileId: childFileName,
      manager: parent.manager,
      loader: parent.loader,
      parent: parent,
      root: parent.root || parent,
      uri: parent.path + '/' + childFileName,
      debugVolume: parent.debugVolume,
      showDebugVolume: parent.showDebugVolume,
      minRange: parent.minRange,
      receiveShadow: parent.receiveShadow,
      castShadow: parent.castShadow
    });
    lod.children.push(childTile);
  }
} //2-3 

/**
 *
 * @param {PagedLOD}lod
 * @returns {boolean}
 * @private
 */


function createOrUpdateEmbedLodChildren(lod) {
  var childReadyPromises = [];
  var osgRoot = lod.osgRoot;
  osgRoot.Children.forEach(function (osgChild, index) {
    var childTile = lod.children[index];
    var promise;

    if (childTile) {
      //reload 
      childTile.osgRoot = osgChild;
      childTile.state = _PagedLODState["default"].LOADING;
      promise = parseContent(childTile);
    } else {
      //first load
      var tileId = lod.tileId + "." + index;
      var parent = lod;
      childTile = new PagedLOD({
        uri: parent.uri + index,
        tileId: tileId,
        parent: parent,
        manager: parent.manager,
        loader: parent.loader,
        tileset: parent.tileset,
        root: parent.root || parent,
        debugVolume: parent.debugVolume,
        showDebugVolume: parent.showDebugVolume,
        minRange: parent.minRange,
        isEmbedLOD: true,
        receiveShadow: parent.receiveShadow,
        castShadow: parent.castShadow
      });
      childTile.state = _PagedLODState["default"].LOADING;
      childTile.osgRoot = osgChild;
      promise = parseOsgb(childTile);
      lod.children.push(childTile);
    }

    promise = promise.then(function () {
      childTile.state = _PagedLODState["default"].LOADED;
      childTile.osgRoot = null;
      childTile.ready = true;
      childTile._isExpired = false;
      childTile.readyPromise.resolve(childTile);
      return childTile;
    });
    childReadyPromises.push(promise);
  });
  return Cesium.when.all(childReadyPromises, function () {
    lod.osgRoot = null;
    return lod;
  });
}

function initializePagedLODSet(tileset, frameState, renderer, currentWebglRenderState, camera3jsLocal) {
  tileset.children.forEach(function (lod) {
    var content = lod.content;

    if (!content) {
      lod._isEmptyLOD = true;
      return;
    }

    content.traverse(function (obj) {
      var material = obj.material;

      if (material) {
        var map = material.map;
        if (map) renderer._textures.get(map, frameState);

        renderer._webglRenderItems.getAndUpdate(obj, frameState, false, currentWebglRenderState, camera3jsLocal);
      }
    });
    lod.state = _PagedLODState["default"].READY;
  });
  tileset._initialized = true;
}

function processPagedLODState(lod, frameState, renderer, camera3jsLocal, currentWebglRenderState) {
  var state = lod.state,
      tileset = lod.tileset;
  var webglTextures = renderer._textures,
      webglRenderItems = renderer._webglRenderItems;

  if (tileset._lodInitializing) {
    return;
  }

  if (state == _PagedLODState["default"].UNLOADED || state == _PagedLODState["default"].EXPIRED) {
    var previousLod = tileset._lodLoading;

    if (previousLod) {
      if (previousLod == lod) return;

      if (tileset.optimizeType != 'SpeedFirst') {
        if (!checkShouldCancel(previousLod, lod)) return;
        previousLod.cancelRequest();
      }
    }

    tileset._lodLoading = lod;
    lod.requestTile().then(function () {
      if (tileset.optimizeType == 'SpeedFirst') {
        lod.state = _PagedLODState["default"].READY;
        tileset._shouldRaiseTileLoaded = true;
      }

      tileset._lodLoading = null;
    }).otherwise(function (err) {
      console.warn('Failed to load tile:' + tileToLoad.uri);
      console.error(err);
      tileset._lodLoading = null;
    });
  } else {
    var previousLod = tileset._lodInitializing;

    if (previousLod) {
      return;
    }

    var content = lod.content;

    if (!content) {
      return;
    } else if (tileset.optimizeType == 'SpeedFirst') {
      lod.state = _PagedLODState["default"].READY;
      tileset._shouldRaiseTileLoaded = true;
      tileset._lodInitializing = null;
      return;
    }

    tileset._lodInitializing = lod;

    if (state == _PagedLODState["default"].LOADED) {
      lod.state = _PagedLODState["default"].TEXTRURE_INITIALIZING;
      content.traverse(function (obj) {
        var material = obj.material;

        if (material && material.map) {
          var map = material.map;
          webglTextures.get(map, frameState);
        }
      });
      Cesium.requestAnimationFrame(function () {
        lod.state = _PagedLODState["default"].TEXTRURE_INITIALIZED;
        tileset._lodInitializing = null;
      });
    } else if (state == _PagedLODState["default"].TEXTRURE_INITIALIZED) {
      lod.state = _PagedLODState["default"].RENDER_ITEM_INITIALIZING;
      content.traverse(function (obj) {
        var geometry = obj.geometry,
            material = obj.material;
        if (!geometry || !material) return;
        webglRenderItems.getAndUpdate(obj, frameState, false, currentWebglRenderState, camera3jsLocal); //删除顶点数组

        if (lod.tileset.releaseGeometry) {
          var attrs = geometry.attributes;

          for (var name in attrs) {
            if (Object.hasOwnProperty.call(attrs, name)) {
              var attr = attrs[name];
              attr.array = new attr.array.constructor(0);
            }
          }
        }
      });
      Cesium.requestAnimationFrame(function () {
        lod.state = _PagedLODState["default"].READY;
        tileset._shouldRaiseTileLoaded = true;
        tileset._lodInitializing = null;
      });
    }
  }
}
/**
 * 
 */


var PagedLOD = /*#__PURE__*/function (_IRenderable) {
  (0, _inherits2["default"])(PagedLOD, _IRenderable);

  var _super = _createSuper(PagedLOD);

  function PagedLOD(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, PagedLOD);
    _this = _super.call(this, options);
    _this.isPagedLOD = true;
    _this.isEmbedLOD = !!options.isEmbedLOD;
    _this.hasEmbedLOD = !!options.hasEmbedLOD;
    _this.uri = options.uri;
    _this.path = _Path["default"].GetDirectoryName(_this.uri);
    _this.debugVolume = options.debugVolume;
    _this.showDebugVolume = options.showDebugVolume;
    _this.rangeDataList = options.rangeDataList || [];
    _this.rangeList = options.rangeList || [];
    _this.minRange = options.minRange || 8;
    _this.boundingSphere = null;
    _this.localBoundingSphere = null;
    _this.aabb = null;
    _this.aabbLocal = null;
    _this.obb = null;
    _this.obbLocal = null;
    /**
     * @type {Cesium.TileBoundingRegion}
     */

    _this.region = null;
    _this.state = _PagedLODState["default"].UNLOADED;
    /**
     * @type  {THREE.LoadingManager}
     */

    _this.manager = options.manager;
    var _Cesium = Cesium,
        when = _Cesium.when,
        defaultValue = _Cesium.defaultValue,
        Matrix4 = _Cesium.Matrix4,
        Event = _Cesium.Event;

    var uriLower = _this.uri.toLowerCase();

    if (uriLower.endsWith('.xml') || uriLower.endsWith('.json')) {
      _this.onInitProgress = options.onInitProgress;
      _this.debugVolumeOnly = defaultValue(options.debugVolumeOnly, false);
      _this.ext = options.ext || 'osgb';
      _this.dataDir = options.dataDir || '/Data';
      _this.tilePattern = options.tilePattern || 'Tile_{x}_{y}';
      _this.metadata = {};
      _this.minX = options.minX || 0;
      _this.maxX = options.maxX || 8;
      _this.minY = options.minY || 0;
      _this.maxY = options.maxY || 8;
      _this._transform = options.transform || Matrix4.IDENTITY.clone();
      _this._srsTransform = Matrix4.IDENTITY.clone();
      _this._srsMatrix = Matrix4.IDENTITY.clone();
      _this._computedTransform = Matrix4.IDENTITY.clone();
      _this.modelMatrix = Matrix4.IDENTITY.clone();
      _this.modelMatrixNeedsUpdate = true;
      _this._memorySize = 0;
      _this.geometryErrorScale = options.geometryErrorScale || 0.75;
      _this.maximumMemorySize = options.maximumMemorySize || 1024 * 1024 * 500;
      _this.tileLoaded = new Event();
      _this._shouldRaiseTileLoaded = false;
      _this.queue = new _PagedLODQueue.PagedLODQueue((0, _assertThisInitialized2["default"])(_this));
      _this.show = defaultValue(options.show, true);
      _this.castShadow = defaultValue(options.castShadow, false);
      _this.receiveShadow = defaultValue(options.receiveShadow, false);
      _this.loadTexture = defaultValue(options.loadTexture, true);
      _this.materialType = defaultValue(options.materialType, 'basic');
      _this.minHeight = options.minHeight;
      _this.releaseGeometry = defaultValue(options.releaseGeometry, true);
      _this.sortType = defaultValue(options.sortType, 'RangeFirst');
      _this.optimizeType = defaultValue(options.optimizeType, 'PerformanceFirst');
      _this._level = -1;
      _this.debugSuspendVisit = false;

      _this.loadMetaData();
    } else {
      var parent = options.parent,
          root = options.root,
          tileset = options.tileset,
          tileId = options.tileId;
      _this._level = (parent || root || tileset)._level + 1;
      _this.parent = parent;
      _this.root = root;
      _this.tileId = tileId;
      _this.tileset = tileset;
      _this._timeStamp = Date.now();
      _this._contentMemorySize = 0;
      _this.castShadow = options.castShadow;
      _this.receiveShadow = options.receiveShadow;
    }
    /**
     * @type {OSGLoader}
     */


    _this.loader = options.loader || new _OSGLoader["default"](_this.manager); // this.fileLoader = new THREE.FileLoader(this.manager);

    /**
     * @type {PagedLOD[]}
     */

    _this.children = options.children || [];
    _this.ready = false;
    _this.readyPromise = when.defer();
    return _this;
  }

  (0, _createClass2["default"])(PagedLOD, [{
    key: "transform",
    get: function get() {
      return this._transform;
    },
    set: function set(transform) {
      if (this.center && !Cesium.Matrix4.equals(transform, this._transform)) {
        this._transform = transform;
        this.modelMatrixNeedsUpdate = true;
      }
    } //initialize

  }, {
    key: "loadMetaData",
    value: function loadMetaData() {
      var _this2 = this;

      var url = this.uri;
      if (this.manager) url = this.manager.resolveURL(this.uri);
      var _Cesium5 = Cesium,
          Resource = _Cesium5.Resource,
          Cartesian3 = _Cesium5.Cartesian3,
          Cartographic = _Cesium5.Cartographic,
          Transforms = _Cesium5.Transforms,
          Matrix4 = _Cesium5.Matrix4;
      var tileset = this;

      function onMetadataLoad() {
        var metadata = tileset.metadata;
        tileset.center = Cartesian3.fromDegrees(metadata.srs[0], metadata.srs[1], metadata.srs[2] || 0);
        tileset.centerCartographic = Cartographic.fromDegrees(metadata.srs[0], metadata.srs[1], metadata.srs[2] || 0);
        tileset._srsModelMatrix = Transforms.eastNorthUpToFixedFrame(tileset.center, Cesium.Ellipsoid.WGS84, tileset._srsMatrix);

        if (metadata.srsOrigin) {
          var translation = Cartesian3.fromArray(metadata.srsOrigin);
          tileset._srsTransform = Matrix4.fromTranslation(translation);
        }

        Matrix4.multiply(tileset._transform, tileset._srsTransform, tileset._computedTransform);
        Matrix4.multiply(tileset._srsMatrix, tileset._computedTransform, tileset.modelMatrix);
      }

      var promise,
          metaUri = this.uri.toLowerCase();

      if (metaUri.endsWith('.xml')) {
        promise = Resource.fetchXML(url).then(function (metaDoc) {
          var modelMetadatas = metaDoc.getElementsByTagName('ModelMetadata');

          if (modelMetadatas && modelMetadatas.length > 0) {
            var modelMetadata = modelMetadatas[0]; // 

            var srsEls = modelMetadata.getElementsByTagName('SRS');

            if (srsEls && srsEls.length) {
              var srsEl = srsEls[0];
              var srsText = srsEl.textContent;
              var start = srsText.indexOf(':');
              var parts = srsText.split(':'),
                  name = parts[0];

              if (name == 'ENU') {
                var lonlat = srsText.substr(start + 1);
                _this2.metadata.srs = JSON.parse('[' + lonlat + ']');

                _this2.metadata.srs.reverse();
              } else // if (name == 'EPSG') {
                // } else 
                {
                  throw new Error('Unsupport SRS:' + srsText);
                }
            } //


            var srsOriginEls = modelMetadata.getElementsByTagName('SRSOrigin');

            if (srsOriginEls && srsOriginEls.length) {
              var srsOriginEl = srsOriginEls[0];
              var srsOriginText = srsOriginEl.textContent;

              if (srsOriginText) {
                _this2.metadata.srsOrigin = JSON.parse('[' + srsOriginText + ']');
              }
            }
          } else {
            console.warn('metadata  ' + _this2.url + ' is empty.');
          }

          onMetadataLoad();
          return _this2.loadRootTiles();
        }).otherwise(function (e) {
          console.trace(e);
          console.warn('metadata ' + url + ' load failed.', e);
          return _this2.loadRootTiles();
        });
      } else {
        promise = Resource.fetchJson(url).then(function (tilesetJson) {
          _this2.metadata = tilesetJson.metadata;
          _this2.localBoundingSphere = (0, _LODUtils.unpackBoundingSphere)(tilesetJson.sphere);
          _this2.boundingSphere = _this2.localBoundingSphere.clone();

          if (tilesetJson.box) {
            _this2.aabbLocal = (0, _LODUtils.unpackBoundingBox)(tilesetJson.box);
            _this2.aabb = _this2.aabbLocal.clone();
          }

          if (tilesetJson.transform) {
            _this2.transform = Matrix4.fromArray(tilesetJson.transform, 0, _this2.transform);
          }

          onMetadataLoad();
          updateContentModelMatrix(_this2);
          _this2.minX = tilesetJson.minX;
          _this2.minY = tilesetJson.minY;
          _this2.maxX = tilesetJson.maxX;
          _this2.maxY = tilesetJson.maxY;
          return _this2.createRootTiles(tilesetJson);
        }).otherwise(function (e) {
          console.warn('metadata ' + url + ' load failed.', e);
          console.error(e);
        });
      }

      return promise;
    }
    /**
     * 从索引文件中创建根节点
     * @param {*} tilesetJson 
     * @private
     */

  }, {
    key: "createRootTiles",
    value: function createRootTiles(tilesetJson) {
      var _this3 = this;

      var tileset = this;
      var parent = tileset,
          batch = [],
          batches = [batch];
      tilesetJson.children.forEach(function (rootTileJson) {
        var tileId = rootTileJson.uri.split(/\//).pop();
        tileId = tileId.split('.');
        tileId.pop();
        tileId = tileId.join('.');
        var uri = rootTileJson.uri;

        if (uri.startsWith('.')) {
          uri = uri.slice(1);
        }

        ;
        var rootTile = new PagedLOD({
          uri: _this3.path + uri,
          tileId: tileId,
          tileset: parent,
          loader: parent.loader,
          manager: parent.manager,
          debugVolume: parent.debugVolume,
          showDebugVolume: parent.showDebugVolume,
          minRange: parent.minRange,
          receiveShadow: parent.receiveShadow,
          castShadow: parent.castShadow
        });
        rootTile.state = _PagedLODState["default"].UNLOADED;
        rootTile.localBoundingSphere = (0, _LODUtils.unpackBoundingSphere)(rootTileJson.sphere);
        rootTile.aabbLocal = (0, _LODUtils.unpackBoundingBox)(rootTileJson.box);

        if (batch.length > 10) {
          batch = [];
          batches.push(batch);
        }

        batch.push(rootTile);
        parent.children.push(rootTile);
      });
      var worker = new _GenericWorker["default"](batches, function (batch) {
        for (var i = 0; i < batch.length; i++) {
          var rootTile = batch[i];
          computeBoundingVolume(rootTile);
          updateContentModelMatrix(rootTile);
        }
      });
      return worker.run(this.onInitProgress).then(function () {
        console.time('first rendering');
        _this3._initialized = true;
        _this3.state = _PagedLODState["default"].READY;
        _this3.ready = true;

        _this3.readyPromise.resolve(_this3);

        return _this3;
      });
    }
    /**
     * 根据minX,minY,maxX,maxY创建根节点
     * @private
     */

  }, {
    key: "loadRootTiles",
    value: function loadRootTiles() {
      var _this4 = this;

      var children = this.children;
      var allTiles = [];

      for (var x = this.minX; x <= this.maxX; x++) {
        var xNo = _StringUtil["default"].paddingStart(x, 3);

        for (var y = this.minY; y <= this.maxY; y++) {
          var yNo = _StringUtil["default"].paddingStart(y, 3);

          var tileId = this.tilePattern.replace('{x}', xNo).replace('{y}', yNo);
          var filePath = this.dataDir + '/' + tileId + '/' + tileId + '.' + this.ext;
          var url = this.path + filePath;
          var parent = this;
          var tile = new PagedLOD({
            uri: url,
            tileId: tileId,
            tileset: parent,
            loader: parent.loader,
            manager: parent.manager,
            debugVolume: parent.debugVolume,
            showDebugVolume: parent.showDebugVolume,
            minRange: parent.minRange,
            receiveShadow: parent.receiveShadow,
            castShadow: parent.castShadow
          });
          allTiles.push(tile);
        }
      }

      var worker = new _GenericWorker["default"](allTiles, function (tile) {
        return new Promise(function (resolve, reject) {
          tile.requestTile().then(function (tile) {
            if (tile && !tile._isEmptyLOD) {
              children.push(tile);
            }

            resolve();
          }).otherwise(function (e) {
            console.warn('tile ' + tile.tileId + ' load failed.', e);
            resolve();
          });
        });
      });
      return worker.run(this.onInitProgress).then(function () {
        computeBoundingSphere(_this4);
        updateContentModelMatrix(_this4);
        _this4.state = _PagedLODState["default"].READY;
        _this4.ready = true;

        _this4.readyPromise.resolve(_this4);

        return _this4;
      });
    } //1

  }, {
    key: "requestTile",
    value: function requestTile() {
      var _Cesium6 = Cesium,
          when = _Cesium6.when,
          Resource = _Cesium6.Resource;
      var lod = this;

      if (lod.osgRoot) {
        debugger;
        var df = when.defer();
        df.resolve(lod);
        return df;
      }

      var request = new Cesium.Request();
      lod._request = request;

      lod.cancelRequest = function () {
        // if (request.cancelFunction) {
        //     request.cancelFunction()
        //     lod.state = PagedLODState.UNLOADED;
        // } else {
        lod.state = _PagedLODState["default"].CANCELLED; // }
      };

      var url = lod.uri;
      if (lod.manager) url = lod.manager.resolveURL(lod.uri);
      lod.state = _PagedLODState["default"].LOADING;

      function doRequest() {
        if (lod._osgBuffer) {
          return Cesium.when(lod._osgBuffer, function () {
            return parseOsgb(lod).then(function () {
              lod.state = _PagedLODState["default"].LOADED;
              return lod;
            });
          });
        }

        return Resource.fetchArrayBuffer({
          url: url,
          request: request
        }).then(function (buffer) {
          lod._osgBuffer = buffer;
          lod._osgBufferSize = buffer.byteLength;

          if (lod.state == _PagedLODState["default"].CANCELLED) {
            lod.state = _PagedLODState["default"].UNLOADED;
            return lod;
          }

          return parseOsgb(lod);
        });
      }

      return doRequest().then(function () {
        if (lod.state == _PagedLODState["default"].CANCELLED) {
          lod.unload();
          return lod;
        }

        if (lod.state == _PagedLODState["default"].UNLOADED) return lod;

        if (lod.hasEmbedLOD) {
          lod.state = _PagedLODState["default"].READY;
        } else {
          lod.state = _PagedLODState["default"].LOADED;
        }

        lod.ready = true;
        lod.readyPromise.resolve(lod);
        return lod;
      }).otherwise(function (e) {
        if (lod.state == _PagedLODState["default"].UNLOADED) return lod;
        console.error(e);
        lod.state = _PagedLODState["default"].ERROR;
        lod.ready = false;
        lod.readyPromise.reject(e); // throw e;
      });
    } //render

  }, {
    key: "computeDistanceToCamera",
    value: function computeDistanceToCamera(frameState) {
      var region = this.region,
          boundingSphere = this.boundingSphere;
      var camera = frameState.camera;
      var distanceToCamera;

      if (region) {
        distanceToCamera = region.distanceToCamera(frameState);
      } else if (boundingSphere) {
        distanceToCamera = camera.distanceToBoundingSphere(boundingSphere);
      } else {
        return;
      }

      if (distanceToCamera == 0) {
        distanceToCamera = Cesium.Cartesian3.distance(boundingSphere.center, camera.positionWC);
      }

      this._distanceToCamera = distanceToCamera;
    }
  }, {
    key: "computeOrderParams",
    value: function computeOrderParams(frameState) {
      var _Cesium7 = Cesium,
          Cartesian3 = _Cesium7.Cartesian3;
      /**
       * @type {Cesium.Camera}
       */

      var camera = frameState.camera;
      var scene = camera._scene;
      var region = this.region,
          boundingSphere = this.boundingSphere,
          tileset = this.tileset;
      tileset = tileset || this;
      var centerWC;

      if (region) {
        centerWC = Cartesian3.add(region.southwestCornerCartesian, region.northeastCornerCartesian, {});
        Cartesian3.divideByScalar(centerWC, 2, centerWC);
      } else if (boundingSphere) {
        centerWC = boundingSphere.center;
      } else {
        return;
      }

      if (tileset._cameraHeight < 50 || tileset._cameraPitch > -0.1) {
        this._radiusPixel = undefined;
        return;
      }

      var centerPixel = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, centerWC, {});

      if (centerPixel) {
        var x = centerPixel.x,
            y = centerPixel.y;
        var w = scene.canvas.width / frameState.pixelRatio;
        var h = scene.canvas.height / frameState.pixelRatio;
        x = x - w / 2;
        y = y - h / 2;
        if (y < 0) y = -y;
        this._radiusPixel = x * x + y * y;
      }
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState  
     * @returns {boolean}
     * @protected
     */

  }, {
    key: "computeVisibility",
    value: function computeVisibility(frameState) {
      var _Cesium8 = Cesium,
          Intersect = _Cesium8.Intersect;
      var parent = this.parent,
          cullingVolume = frameState.cullingVolume;
      var visibility;

      if (parent) {
        if (parent._visibility == 1) {
          visibility = parent._visibility;
        } else {
          visibility = cullingVolume.computeVisibility(this.region ? this.region : this.boundingSphere); // this.boundingSphere);
        }
      } else {
        visibility = cullingVolume.computeVisibility(this.boundingSphere);
      }

      this._visibility = visibility;
      this._visible = visibility > -1;

      if (this._visible) {
        var geometryErrorScale = (this.tileset || this).geometryErrorScale;
        this.range = _RendererUtils["default"].computeRange(this._distanceToCamera, this.boundingSphere.radius, frameState, geometryErrorScale);
        this._visible = this.range > this.minRange;
      }

      return this._visible;
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @param {PagedLODQueue}renderQueue
     * @private
     */

  }, {
    key: "visit",
    value: function visit(frameState, renderQueue) {
      if (this._isEmptyLOD) return;
      var tileset = this.tileset;

      if (tileset) {
        this.minRange = tileset.minRange;
        this.showDebugVolume = tileset.showDebugVolume;
      }

      if (this.frameNumber != frameState.frameNumber) {
        this.computeDistanceToCamera(frameState);
        this.computeVisibility(frameState);
      }

      if (this._visible) {
        this.computeOrderParams(frameState);
        var _tileset2 = this.tileset;
        this._timeStamp = _tileset2._currentTimeStamp;
        var needLoadChild = this.rangeList && this.rangeList.length > 0;

        if (needLoadChild) {
          var nextRange = this.rangeList[1];
          needLoadChild = this.range > nextRange[0] && this.range <= nextRange[1];

          if (!needLoadChild) {
            if (this.state == _PagedLODState["default"].READY) {
              return renderQueue.pushRendering(this);
            } else {
              return renderQueue.pushPending(this);
            }
          }
        }

        var childrenReady = this.children.length > 0;
        this.children.forEach(function (child) {
          child._timeStamp = _tileset2._currentTimeStamp;

          if (child.state !== _PagedLODState["default"].READY) {
            childrenReady = false;
            child.computeDistanceToCamera(frameState);
            child.computeOrderParams(frameState);
            return renderQueue.pushPending(child);
          }

          var contentReady = true;

          if (child.hasEmbedLOD) {
            child.children.forEach(function (embedLOD) {
              if (embedLOD.state !== _PagedLODState["default"].READY) {
                contentReady = false;
                embedLOD.computeDistanceToCamera(frameState);
                embedLOD.computeOrderParams(frameState);
                renderQueue.pushPending(embedLOD);
              }
            });
          }

          if (contentReady) {
            child.visit(frameState, renderQueue);
          } else {
            childrenReady = false;
          }
        });

        if (!childrenReady) {
          if (this.state == _PagedLODState["default"].READY) {
            renderQueue.pushRendering(this);
          } else {
            renderQueue.pushPending(this);
          }
        }
      }

      this.frameNumber = frameState.frameNumber;
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @param {THREE.Object3D[]} renderList 
     * @param {Mesh3D.WebGLRenderer}renderer
     * @param {THREE.Camera} camera3jsLocal 
     * @param {Mesh3D.WebGLRenderState} currentWebglRenderState
     */

  }, {
    key: "render",
    value: function render(frameState, renderList, renderer, camera3jsLocal, currentWebglRenderState) {
      var _this5 = this;

      if (!this.ready || !this.show) return;
      var renderQueue = this.queue,
          debugSuspendVisit = this.debugSuspendVisit;

      if (!debugSuspendVisit) {
        this._currentTimeStamp = Date.now();

        if (frameState.frameNumber != this.frameNumber) {
          if (this.modelMatrixNeedsUpdate) {
            Cesium.Matrix4.multiply(this._transform, this._srsTransform, this._computedTransform);
            Cesium.Matrix4.multiply(this._srsMatrix, this._computedTransform, this.modelMatrix);
            (0, _traverse["default"])(this, function (lod) {
              updateContentModelMatrix(lod);
            });
            this.modelMatrixNeedsUpdate = false;
          }

          this.computeDistanceToCamera(frameState);
          this.computeVisibility(frameState);
          this.computeOrderParams(frameState);
          if (!this._visible) return;

          if (this._shouldRaiseTileLoaded) {
            Cesium.requestAnimationFrame(function () {
              _this5.tileLoaded.raiseEvent(_this5);

              _this5._shouldRaiseTileLoaded = false;
            });
          }

          if (!this._initialized) {
            initializePagedLODSet(this, frameState, renderer, currentWebglRenderState, camera3jsLocal);
          }

          renderQueue.init(); //visit

          this._cameraHeight = frameState.camera.positionCartographic.height;
          this._cameraPitch = frameState.camera.pitch;
          this.children.forEach(function (root) {
            root.visit(frameState, renderQueue);
          }); //

          renderQueue.sortPendings();
          var nextPending = renderQueue.shiftPending();

          if (nextPending) {
            processPagedLODState(nextPending, frameState, renderer, camera3jsLocal, currentWebglRenderState);
          }
        } //unload


        this._memorySize0 = this._memorySize0 || 0;
        var maximumMemorySize = this.maximumMemorySize;
        var memIncreased = this._memorySize - this._memorySize0;

        if (this._memorySize > maximumMemorySize && memIncreased > maximumMemorySize * 0.25) {
          this.unload();
          this._memorySize0 = this._memorySize;
        }
      }

      renderQueue.getRenderList(renderList);

      if (renderList.length && !this._rendering) {
        this._rendering = true;
        console.timeEnd('first rendering');
      } // console.log('renderlist', renderQueue.renerList.length);


      this.frameNumber = frameState.frameNumber; // if (!debugSuspendVisit) renderQueue.reset();
    }
  }, {
    key: "unload",
    value: function unload() {
      var _this6 = this;

      var tileset = this.tileset;

      if (!tileset) {
        var expiredTiles = this.queue.getExpiredList();
        var stack = expiredTiles.splice(0);

        while (stack.length > 0) {
          var expiredTile = stack.pop();
          expiredTile.unload();
        }

        ;
        return;
      }

      if (this._request) {
        this._request.cancelFunction && this._request.cancelFunction();
      } //


      if (this.hasEmbedLOD) {
        var needsUnloadChildren = true;
        this.children.forEach(function (child) {
          if (child._timeStamp == _this6.tileset._currentTimeStamp) {
            needsUnloadChildren = false;
          }
        });

        if (needsUnloadChildren) {
          this.children.forEach(function (child) {
            child.unload();
          });
          this._isExpired = true;
          this._loading = false;
          this.state = _PagedLODState["default"].EXPIRED;
        }
      } //


      var content = this.content;
      if (!content) return;
      tileset.visualizer.remove(content, true);
      (0, _releaseResources["default"])(content);

      if (content.osgRoot) {
        Osg.traverse(content.osgRoot, function (node) {
          if (node.Type == 'Osg::Geometry') {
            destroyObject(node);
          }
        });
        delete content.osgRoot;
      }

      this.content = null;
      this._osgBuffer = null;
      this._isExpired = true;
      this._loading = false;
      this.state = _PagedLODState["default"].EXPIRED; //

      if (tileset._memorySize > 0) {
        tileset._memorySize -= this._contentMemorySize;
      }

      this._contentMemorySize = 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var visualizer = this.visualizer;
      var destroyObject = Cesium.destroyObject;
      (0, _traverse["default"])(this.children, function (node) {
        node.unload();

        if (node.debugVolume) {
          node.debugVolume = visualizer.remove(node.debugVolume, true);
        }

        if (node.osgRoot) {
          Osg.traverse(node.osgRoot, function (node) {
            if (node.Type == 'Osg::Geometry') {
              destroyObject(node);
            }
          });
        }
      });
      this._renderList && this._renderList.splice(0);
      this.boundingSphere = null;
      this.localBoundingSphere = null;
      this.aabb = null;
      this.aabbLocal = null;
      this.obb = null;
      this.obbLocal = null;
      this.region = null;
      visualizer.remove(this, true);
      this.visualizer = null;
      return destroyObject(this);
    }
    /**
     * @protected
     */

  }, {
    key: "isCommandsReady",
    value: function isCommandsReady() {
      if (!this.tileset) return false;
      if (this.state !== _PagedLODState["default"].READY) return false;
      var content = this.content;
      var ready = undefined;
      (0, _traverse["default"])(content, function (obj) {
        if (ready == false) return;

        if (obj.isMesh && obj.visible) {
          if (ready == undefined) ready = true;
          var renderItems = obj.renderItems;
          if (!renderItems) ready = false;else {
            renderItems.forEach(function (renderItem) {
              if (!renderItem.loaded) ready = false;
            });
          }
        }
      });
      return ready;
    }
  }, {
    key: "toIndexJSON",
    value: function toIndexJSON() {
      var _this7 = this;

      if (this.root) {
        console.warn('Mesh3D.PagedLOD：只能从根节点导出索引');
        return;
      }

      var jsonRoot = toJSON(this, this.path);
      jsonRoot.metadata = Object.assign({
        exporter: 'Mesh3D.PagedLOD',
        datetime: new Date().toLocaleDateString()
      }, this.metadata);
      jsonRoot.children = [];
      delete jsonRoot.uri;
      jsonRoot.ext = this.ext;
      jsonRoot.dataDir = this.dataDir;
      jsonRoot.tilePattern = this.tilePattern;
      jsonRoot.minX = this.minX;
      jsonRoot.minY = this.minY;
      jsonRoot.maxX = this.maxX;
      jsonRoot.maxY = this.maxY;
      jsonRoot.transform = Cesium.Matrix4.toArray(this.transform);
      this.children.forEach(function (level0) {
        if (level0._isEmptyLOD) return;
        level0 = toJSON(level0, _this7.path);
        jsonRoot.children.push(level0);
      });
      return jsonRoot;
    }
  }, {
    key: "selectTileLoaded",
    value: function selectTileLoaded(position) {
      return (0, _LODUtils.selectTileLoaded)(this, position);
    }
  }], [{
    key: "updatePositionClamped",
    value: function updatePositionClamped(lodSet, entities, viewer, foreUpdate) {
      return (0, _LODUtils.updatePositionClamped)(lodSet, entities, viewer, foreUpdate);
    }
  }]);
  return PagedLOD;
}(_IRenderable2["default"]);

exports["default"] = PagedLOD;

},{"s_310":2,"s_343":4,"-_345":6,"-_312":189,"D_336":193,"._337":194,"3_313":207,"3_346":79,"D_347":81,"._348":82,"m_340":179,"e_342":182,"M_341":185,"h_344":186,"s_332":233,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242,"M_110":245}],81:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pendingSort = pendingSort;
exports.PagedLODQueue = PagedLODQueue;

var _traverse = _interopRequireDefault(require("3_313"));

var _PagedLODState = _interopRequireDefault(require("._348"));

function pendingSort(a, b) {
  //根节点优先
  if (a._level != b._level) {
    if (a._level == 0) return -1;
    if (b._level == 0) return 1;

    if (a.tileset.sortType == 'LevelFirst') {
      return a._level - b._level;
    }
  } //根节点距相机近者优先


  if (a.root && b.root && a.root != b.root) {
    if (a.root._radiusPixel != b.root._radiusPixel) {
      return a.root._radiusPixel - b.root._radiusPixel;
    }

    if (a.root._level != b.root._level) {
      return a.parent._level - b.parent._level;
    }

    return a.root._distanceToCamera - b.root._distanceToCamera;
  } //父级距相机近者优先


  if (a.parent && b.parent && a.parent != b.parent) {
    if (a.parent._radiusPixel != b.parent._radiusPixel) {
      return a.parent._radiusPixel - b.parent._radiusPixel;
    } // if (a.parent._level != b.parent._level) {
    //     return a.parent._level - b.parent._level;
    // }


    return a.parent._distanceToCamera - b.parent._distanceToCamera;
  }

  if (a._radiusPixel != b._radiusPixel) {
    return a._radiusPixel - b._radiusPixel;
  }

  if (a._distanceToCamera != undefined && b._distanceToCamera != undefined) {
    return a._distanceToCamera - b._distanceToCamera;
  }

  var da = a.parent ? a.parent._distanceToCamera : a._distanceToCamera;
  var db = b.parent ? b.parent._distanceToCamera : b._distanceToCamera;
  return da - db;
}
/**
 * 
 * @param {PagedLOD} tileset 
 * @constructor
 */


function PagedLODQueue(tileset) {
  /**
   * @type  {PagedLOD[]}
   * @private
   */
  var renderList = [];
  /**
   * @type  {PagedLOD[]}
   * @private
   */

  var pendingList = [];
  /**
   * @type  {PagedLOD[]}
   * @private
   */

  var expiredList = [];
  /**
   * @type  {PagedLOD[]}
   * @private
   */

  var debuggingList = [];
  var memeryRendering = 0;

  this.init = function init() {
    expiredList.length = 0;
    pendingList.length = 0;
    renderList.length = 0;
    memeryRendering = 0;
    debuggingList.length = 0;
  };

  this.reset = this.init;

  this.getExpiredList = function getExpiredList() {
    tileset.children.forEach(function (root) {
      (0, _traverse["default"])(root.children, function (lod) {
        if (lod._loading && !lod.content || !lod.uri.endsWith(tileset.ext) || lod._timeStamp == tileset._currentTimeStamp) {
          return;
        }

        expiredList.push(lod);
      });
    });
    return expiredList;
  };

  this.sortPendings = function sortPendings() {
    pendingList.sort(pendingSort);
  };
  /**
   * @returns {PagedLOD}
   */


  this.shiftPending = function shiftPending() {
    return pendingList.shift();
  };

  this.pushDebugging = function pushDebugging(lodDebugging) {
    debuggingList.push(lodDebugging);
  };
  /**
   * 
   * @param {PagedLOD} lodPending 
   */


  this.pushPending = function pushPending(lodPending) {
    var state = lodPending.state;
    lodPending._timeStamp = tileset._currentTimeStamp;
    if (lodPending.isEmbedLOD && (state == _PagedLODState["default"].UNLOADED || state == _PagedLODState["default"].EXPIRED)) return;
    if (state == _PagedLODState["default"].LOADING || state == _PagedLODState["default"].RENDER_ITEM_INITIALIZING || state == _PagedLODState["default"].TEXTRURE_INITIALIZING) return;
    pendingList.push(lodPending);
  };
  /**
   * 
   * @param {PagedLOD} lodPending 
   */


  this.pushRendering = function pushRendering(lodRendering) {
    lodRendering._timeStamp = tileset._currentTimeStamp;
    renderList.push(lodRendering);
    memeryRendering += lodRendering._contentMemorySize;
  };
  /**
   * 
   * @param {(Object3D|THREE.Object3D)[]} dstRenderList 
   */


  this.getRenderList = function getRenderList(dstRenderList) {
    renderList.forEach(function (lod) {
      var content = lod.content;
      var tileset = lod.tileset;
      var debugVolume = lod.debugVolume;
      var showDebugVolume = lod.showDebugVolume;
      var debugVolumeOnly = tileset.debugVolumeOnly;

      if (content && !debugVolumeOnly) {
        //同步阴影开关
        var castShadow = tileset.castShadow,
            receiveShadow = tileset.receiveShadow;

        if (castShadow != lod.castShadow || receiveShadow != lod.receiveShadow) {
          lod.receiveShadow = receiveShadow;
          lod.castShadow = castShadow;
          (0, _traverse["default"])(content, function (obj) {
            obj.castShadow = castShadow;
            obj.receiveShadow = receiveShadow;
          });
        }

        dstRenderList.push(content);
      }

      if (showDebugVolume && debugVolume && debugVolume.isObject3D) {
        debugVolume.frustumCulled = false;
        dstRenderList.push(debugVolume);
      }
    });
  };

  Object.defineProperties(this, {
    memeryRendering: {
      get: function get() {
        return memeryRendering;
      }
    },
    debuggingList: {
      get: function get() {
        return debuggingList;
      }
    },
    renderList: {
      get: function get() {
        return renderList;
      }
    },
    pendingList: {
      get: function get() {
        return pendingList;
      }
    },
    expiredList: {
      get: function get() {
        return getExpiredList();
      }
    }
  });
}

},{"3_313":207,"._348":82,"M_0":241}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var PagedLODState = {
  CANCELLED: -1,
  UNLOADED: 0,
  LOADING: 1,
  LOADED: 2,
  TEXTRURE_INITIALIZING: 3,
  TEXTRURE_INITIALIZED: 4,
  RENDER_ITEM_INITIALIZING: 5,
  READY: 7,
  EXPIRED: 8,
  ERROR: 9
};
var _default = PagedLODState;
exports["default"] = _default;

},{}],83:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _QuadtreeNode2 = _interopRequireDefault(require("D_325"));

var _releaseResources = _interopRequireDefault(require("h_344"));

var _VISMLoader = _interopRequireDefault(require("o_361"));

var _TextureUtils = _interopRequireDefault(require("m_362"));

var _LODUtils = require("3_346");

var _traverse = _interopRequireDefault(require("3_313"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _checkIfNeedRequest(lod, requestList) {
  var content = lod.content;

  if (content && lod.loader && !content._model) {
    if (!lod._loading) {
      //load from  uri
      // lod._timeStamp = Date.now();
      if (requestList.indexOf(lod) == -1) requestList.push(lod);
    }

    return true;
  }

  return false;
}

var QuadtreeLOD = /*#__PURE__*/function (_QuadtreeNode) {
  (0, _inherits2["default"])(QuadtreeLOD, _QuadtreeNode);

  var _super = _createSuper(QuadtreeLOD);

  /**
   * 
   * @param {object} options 
   * @param {{
   * box:Cesium.AxisAlignedBoundingBox|number[],
   * sphere:Cesium.BoundingSphere|number[]
   * }} options.boundingVolume 
   */
  function QuadtreeLOD(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, QuadtreeLOD);
    _this = _super.call(this, options);
    var _Cesium = Cesium,
        defaultValue = _Cesium.defaultValue,
        when = _Cesium.when,
        Event = _Cesium.Event;
    _this.ready = true;
    _this.show = defaultValue(options.show, true);
    _this.readyPromise = when.defer();
    _this.maximumTextureSize = options.maximumTextureSize;
    _this.maxMipmapSize = defaultValue(options.maxMipmapSize, 1024);
    _this.geometryErrorScale = defaultValue(options.geometryErrorScale, 1);
    _this.isQuadtreeLOD = true;
    _this.tileLoaded = new Event();
    /**
     * @type {QuadtreeLOD[]}
     */

    _this.children = [];
    /**
     * @type {number}
     */

    _this.level = options.level || 0;
    /**
     * @type {number}
     */

    _this.maxLevel = options.maxLevel;
    /**
     * @type {{
         contain:QuadtreeNode[],
         intersect:QuadtreeNode[],
         length:number
       }}
     */

    _this._contentSet = {
      contain: [],
      intersect: [],
      length: 0
    };

    if (options.contentSet) {
      _this.contentSet = options.contentSet;
    }
    /**
     * @type {'ADD'|'REPLACE'}
     */


    _this.refine = options.refine || 'ADD';
    /**
     * @type {'PIXEL_SIZE_ON_SCREEN'|'DISTANCE_TO_CAMERA'}
     */

    _this.rangeMode = options.rangeMode || 'PIXEL_SIZE_ON_SCREEN';
    /**
     * @type {QuadtreeLOD}
     */

    _this.parent = options.parent;
    /**
     * @type {QuadtreeLOD}
     */

    _this.root = options.root;
    _this.translucent = defaultValue(options.translucent, false);
    _this.alphaTest = 0;

    if (typeof options.alphaTest == 'number') {
      _this.alphaTest = options.alphaTest;
    }

    _this._memorySize = 0;
    _this.maximumMemorySize = options.maximumMemorySize || 200 * 1024 * 1024;
    return _this;
  }

  (0, _createClass2["default"])(QuadtreeLOD, [{
    key: "contentSet",
    get: function get() {
      return this._contentSet;
    },
    set: function set(contentSet) {
      this.setContentSet(contentSet);
    } //

  }, {
    key: "selectTileLoaded",
    value: function selectTileLoaded(position) {
      return (0, _LODUtils.selectTileLoaded)(this, position);
    } //

    /**
     * @private
     */

  }, {
    key: "isCommandsReady",
    value: function isCommandsReady() {
      var content = this.content,
          model;
      if (!content && !this.contentSet.length) return false;

      if (this.content) {
        model = this.content.isObject3D ? this.content : this.content._model;
      } else if (this.contentSet.length) {
        return true;
      }

      if (model) {
        var ready = undefined;
        (0, _traverse["default"])(model, function (obj) {
          if (ready == false) return;

          if (obj.isMesh && obj.visible) {
            if (ready == undefined) ready = true;
            var renderItems = obj.renderItems;
            if (!renderItems) ready = false;else {
              renderItems.forEach(function (renderItem) {
                if (!renderItem.loaded) ready = false;
              });
            }
          }
        });
        return ready;
      }

      return false;
    }
    /**
     * 
     * @param {
        {
            contain:QuadtreeNode[],
            intersect:QuadtreeNode[],
            length:number
        }
     * } contentSet 
     * @private
     */

  }, {
    key: "setContentSet",
    value: function setContentSet(contentSet) {
      var _this2 = this;

      var getContent = function getContent(node) {
        if (!(node instanceof _QuadtreeNode2["default"])) {
          node.modelMatrix = node.modelMatrix || _this2.modelMatrix;
          node.rtcCenter = node.rtcCenter || _this2.rtcCenter;
          node.debugVolume = _this2.debugVolume;
          node.showDebugVolume = _this2.showDebugVolume;
          node = new _QuadtreeNode2["default"](node);
        }

        return node;
      };

      for (var i = 0; i < contentSet.contain.length; i++) {
        var node = contentSet.contain[i];
        contentSet.contain[i] = getContent(node);
      }

      for (var _i = 0; _i < contentSet.intersect.length; _i++) {
        var _node = contentSet.intersect[_i];
        contentSet.intersect[_i] = getContent(_node);
      }

      this._contentSet = contentSet;
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @param {QuadtreeLOD[]} renderList 
     * @param {QuadtreeLOD[]} requestList 
     * @param {QuadtreeLOD[]} textureInitList 
     * @private
     */

  }, {
    key: "visit",
    value: function visit(frameState, renderList, requestList, textureInitList) {
      var _this3 = this;

      if (this.frameNumber != frameState.frameNumber) {
        this.computeVisibility(frameState);
      }

      if (this._visible) {
        renderList.maxLevel = Math.max(this.level, renderList.maxLevel);
        renderList.visitTimes++;

        if (_checkIfNeedRequest(this, requestList)) {
          this.frameNumber = frameState.frameNumber;
          return;
        } //v3


        var needLoadChildren = this.children.length > 0,
            childrenReady = false;

        if (needLoadChildren) {
          var nextRange = this.children[0].minRange;
          needLoadChildren = this.range >= nextRange;
        }

        if (needLoadChildren) {
          childrenReady = true;
          this.children.forEach(function (child) {
            var visibility = frameState.cullingVolume.computeVisibility(child.boundingSphereWC);

            if (visibility == -1) {
              return;
            }

            child.visibility = visibility;
            child._visible = true;
            child.computeRange(frameState, _this3.geometryErrorScale);
            child.frameNumber = frameState.frameNumber;
            child.visit(frameState, renderList, requestList, textureInitList);
            var content = child.content,
                contentSet = child.contentSet;

            if (content && !content.isObject3D) {
              if (!content._model) {
                //子节点可见，但是模型未加载完成，使用父级暂时代替
                childrenReady = false; // child.isCommandsReady();
              } else if (!content._model._ready) {
                //子节点可见，但是模型未加载完成，使用父级暂时代替
                childrenReady = false;
                textureInitList.push(child);
              } else if (!child.isCommandsReady()) {
                childrenReady = false;
              }
            } else if (contentSet && contentSet.length) {
              if (!contentSet.ready) childrenReady = false;
            }
          });
        }

        if (!childrenReady || this.refine == 'ADD') {
          if (this.content && this.content._model && !this.content._model._ready) {
            textureInitList.push(this);
          } else {
            if (this.content && !this._commandsReady) {
              this._commandsReady = true;
              if (this.root) this.root._needsRaiseTileLoaded = true;
            }

            renderList.push(this);
          }
        }
      }

      this.frameNumber = frameState.frameNumber;
    }
    /**
     * Called by MeshViusalizer
     * @param {Cesium.FrameState} frameState 
     * @param {THREE.Object3D[]} renderList 
     * @private
     * @override QuadtreeNode.prototype.render
     */

  }, {
    key: "render",
    value: function render(frameState, renderList) {
      var _this4 = this;

      if (!this.ready || !this.show) return;
      var _Cesium2 = Cesium,
          when = _Cesium2.when,
          requestAnimationFrame = _Cesium2.requestAnimationFrame,
          Color = _Cesium2.Color;
      this._needsRaiseTileLoaded = false;
      var cacheRenderList = this._cacheRenderList || [];

      if (frameState.frameNumber != this.frameNumber) {
        cacheRenderList.splice(0);
        this.computeVisibility(frameState);
        this.frameNumber = frameState.frameNumber;
        if (!this._visible) return;
        this._currentTimeStamp = Date.now();
        /**
         * @type {QuadtreeLOD[]}
         * @private
         */

        var lodRenderList = [],
            requestList = [],
            textureInitList = [];
        lodRenderList.maxLevel = this.level;
        lodRenderList.visitTimes = 0;
        this.children.forEach(function (root) {
          root._timeStamp = _this4._currentTimeStamp;
          root.visit(frameState, lodRenderList, requestList, textureInitList);
        });
        lodRenderList.sort(function (a, b) {
          return a._distanceToCamera - b._distanceToCamera;
        }); //get renderable tile's contents

        var debugVolumeColor = this.debugVolumeColor;
        lodRenderList.forEach(function (lod) {
          if (lod.show == false) return;

          if (lod.debugVolume && _this4.showDebugVolume) {
            lod.debugVolume.frustumCulled = false;

            if (debugVolumeColor) {
              var debugMaterial = lod.debugVolume.material;

              if (debugMaterial._debugVolumeColor != debugVolumeColor) {
                debugMaterial._debugVolumeColor = debugVolumeColor;
                debugMaterial.color.set(debugVolumeColor.toCssColorString());
              }
            }

            cacheRenderList.push(lod.debugVolume);
          }

          if (!lod.content && lod.contentSet.length == 0) {
            return;
          }

          lod._timeStamp = _this4._currentTimeStamp;

          if (lod.contentProvider) {
            if (!lod._contentRequested || _this4._version != lod._version) {
              if (!_this4._contentRequesting) {
                _this4._contentRequesting = true;
                var object3d = lod.contentProvider.requestContent(lod.contentSet, _this4.rtcCenter);
                when(object3d, function (object3d) {
                  (0, _traverse["default"])(object3d, function (mesh) {
                    mesh.frustumCulled = false;
                    if (mesh.isMesh && _this4.rtcCenter) mesh.uniformMapLoadedCallback = _this4.uniformMapLoadedCallback;
                  });

                  if (lod.content && _this4.visualizer) {
                    _this4.visualizer.remove(lod.content);
                  }

                  lod.content = object3d;
                  _this4._contentRequesting = false;
                  lod._version = _this4._version;
                });
                lod._contentRequested = true;
              }

              if (lod.content) {
                cacheRenderList.push(lod.content);
              }
            } else if (lod.content) {
              cacheRenderList.push(lod.content);
            }
          } else if (lod.content) {
            var content = lod.content;

            if (content.isObject3D) {
              cacheRenderList.push(content);
            } else if (content._model) {
              if (!content._model._ready) {
                if (textureInitList.indexOf(lod) == -1) textureInitList.push(lod);
              } else cacheRenderList.push(content._model);
            } else {
              _checkIfNeedRequest(lod, requestList);
            }
          }

          var contentSet = lod.contentSet;

          if (_this4.generateLOD == false && contentSet && contentSet.length > 0) {
            contentSet.ready = true;
            contentSet.contain.forEach(function (contentNode) {
              if (contentNode.content && !contentNode.content._ready) {
                contentNode._distanceToCamera = frameState.camera.distanceToBoundingSphere(_this4.boundingSphereWC);
                contentSet.ready = false;
                textureInitList.push(contentNode);
              }
            });
            contentSet.intersect.forEach(function (contentNode) {
              if (contentNode.debugVolume) contentNode.debugVolume.material.defaultColor = Color.RED;

              if (contentNode.content && !contentNode.content._ready) {
                contentNode._distanceToCamera = frameState.camera.distanceToBoundingSphere(contentNode.boundingSphereWC);
                contentSet.ready = false;
                textureInitList.push(contentNode);
              }
            });

            if (contentSet.ready) {
              contentSet.contain.forEach(function (contentNode) {
                if (contentNode.debugVolume) contentNode.debugVolume.material.defaultColor = Color.CYAN;

                if (contentNode.content) {
                  contentNode.render(frameState, cacheRenderList);
                }
              });
              contentSet.intersect.forEach(function (contentNode) {
                if (contentNode.debugVolume) contentNode.debugVolume.material.defaultColor = Color.RED;

                if (contentNode.content) {
                  contentNode.render(frameState, cacheRenderList);
                }
              });
            }
          }
        }); //load one tile

        if (requestList && requestList.length > 0 && !this._loading) {
          this._loading = true;
          requestList.sort(function (a, b) {
            return a._distanceToCamera - b._distanceToCamera;
          });
          var lodToLoad = requestList.shift();
          lodToLoad._timeStamp = this._currentTimeStamp;
          this.imageCache = this.imageCache || {};
          this.texturesByUrl = this.texturesByUrl || {};
          var imageCache = this.imageCache[lodToLoad.level];
          var texturesByUrl = this.texturesByUrl[lodToLoad.level];

          if (!imageCache) {
            imageCache = {};
            this.imageCache[lodToLoad.level] = imageCache;
          }

          lodToLoad._loadContent(imageCache, texturesByUrl).then(function () {
            _this4._memorySize += lodToLoad._contentMemorySize;
            lodToLoad._timeStamp = _this4._currentTimeStamp;
            requestAnimationFrame(function () {
              _this4._loading = false;
            });
          });
        } //初始化可渲染瓦片的纹理


        if (textureInitList.length > 0 && !this._texureCreating) {
          if (this.generateLOD != false) {
            textureInitList.sort(function (a, b) {
              a = a.parent ? a.parent._distanceToCamera : a._distanceToCamera;
              b = b.parent ? b.parent._distanceToCamera : b._distanceToCamera;
              return a - b;
            });
          }

          var tileToInitTexture = textureInitList.shift(),
              content = tileToInitTexture.content._model || tileToInitTexture.content,
              textureCache = this.visualizer._textureCache;
          tileToInitTexture._timeStamp = this._currentTimeStamp;
          this._cacheTextureIds = this._cacheTextureIds || [];
          var uuidPrefix = this.generateLOD == false ? '' : 'L' + tileToInitTexture.level + '_';
          content._ready = _TextureUtils["default"].initTexture(frameState, content.mesh || content, textureCache, this._cacheTextureIds, uuidPrefix, this.maximumTextureSize, this.maxMipmapSize);
          this._texureCreating = true;
          requestAnimationFrame(function () {
            // if (content._ready) {
            //     this.tileLoaded.raiseEvent(this, tileToInitTexture);
            // }
            // content._ready = true;
            _this4._texureCreating = false;
          });
        }

        if (this._memorySize > this.maximumMemorySize) {
          // debugger
          this.unload();
        }
      }

      cacheRenderList.forEach(function (item) {
        renderList.push(item);
      });
      this._cacheRenderList = cacheRenderList;

      if (this._needsRaiseTileLoaded) {
        requestAnimationFrame(function () {
          _this4.tileLoaded.raiseEvent(_this4);
        });
      }
    }
  }, {
    key: "_loadContent",
    value: function _loadContent(imageCache, texturesByUrl) {
      var _this5 = this;

      this._loading = true;
      return new Promise(function (resolve, reject) {
        var loader = _this5.loader,
            content = _this5.content;
        _this5.uri = content.uri;
        loader.load(content.uri, function (model) {
          content._model = model;
          _this5._contentMemorySize = model._memorySize;
          model.traverse(function (obj) {
            if (obj.isMesh) {
              /**
               * @type {THREE.Material[]}
               * @private
               */
              var materials = Array.isArray(obj.material) ? obj.material : [obj.material];
              materials.forEach(function (material) {
                material.autoRefresh = false;

                if (material.transparent) {
                  if (_this5.alphaTest && _this5.alphaTest > 0) {
                    material.alphaTest = _this5.alphaTest;
                  } else if (_this5.translucent || _this5.root.translucent) {
                    material.translucent = true; // material.opacity = 0.5;
                    // material.depthWrite = false
                    // material.depthFunc = 2
                  }
                }
              });
              obj.pickObject = {
                id: _this5,
                mesh: obj,
                primitive: _this5
              }; //GeometryUtils.clampToIndices(obj.geometry);
            }

            obj.frustumCulled = false;
            obj.matrixAutoUpdate = false;
            obj.modelMatrixNeedsUpdate = false;
            obj.modelMatrix = _this5.modelMatrix;
          });
          _this5._loading = false;
          resolve(model);
        }, undefined, function (err) {
          _this5._loading = false;
          console.error(err);
          reject(err);
        }, {
          loadTexture: true,
          imageCache: imageCache,
          textureCache: texturesByUrl
        });
      });
    }
  }, {
    key: "unload",
    value: function unload() {
      var _this6 = this;

      if (this.level == 0) {
        var expiredTiles = [];
        this.children.forEach(function (root) {
          (0, _traverse["default"])(root.children, function (node) {
            if (node._loading || !node.content || !node.content._model) return;

            if (node._timeStamp != _this6._currentTimeStamp) {
              expiredTiles.push(node);
            }
          });
        });
        expiredTiles.sort(function (a, b) {
          return b._timeStamp / b._distanceToCamera - a._timeStamp / b._distanceToCamera;
        });
        var stack = expiredTiles.splice(0);

        do {
          var expiredTile = stack.pop();
          expiredTile.unload();
          if (this._memorySize > 0) this._memorySize -= expiredTile._contentMemorySize;else break;
        } while (stack.length > 0);

        return;
      }

      if (this.content && this.content._model) {
        var visualizer = this.root.visualizer;
        var model = this.content._model;
        debugger;
        visualizer.remove(model, true);
        (0, _releaseResources["default"])(model);
        delete this.content._model;
      }

      this._isExpired = true;
      this._loading = false;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var destroyObject = Cesium.destroyObject;
      var visualizer = this.visualizer;
      this._cacheRenderList && this._cacheRenderList.splice(0);
      (0, _traverse["default"])(this.children, function (node) {
        node._contentSet && node._contentSet.contain.splice(0) && node._contentSet.intersect;
        node._contentSet = null;

        if (node.debugVolume) {
          node.debugVolume = visualizer.remove(node.debugVolume);
        }

        if (node.content) {
          var content = node.content._model ? node.content._model : node.content;
          if (visualizer) visualizer.remove(content, true);
          (0, _releaseResources["default"])(content);
          node.content = content.destroy && content.destroy();
        }

        delete node.contentProvider;
        delete node.boundingVolume;
        delete node.visualizer;
        delete node.uniformMapLoadedCallback;
        destroyObject(node);
      });
      visualizer && visualizer.remove(this, true);

      if (this._cacheTextureIds && visualizer) {
        this._cacheTextureIds.forEach(function (uuid) {
          var tex = visualizer._textureCache[uuid];

          if (tex) {
            (!tex.isDestroyed || !tex.isDestroyed()) && tex.destroy();
            delete visualizer._textureCache[uuid];
          }
        });

        this._cacheTextureIds = null;
      }

      this.children.splice(0);
      this._contentSet && this._contentSet.contain.splice(0) && this._contentSet.intersect;
      this._contentSet = null;
      this.visualizer = null;
      this.imageCache = null;
      return destroyObject(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        boundingVolume: {
          box: (0, _LODUtils.packBoundingBox)(this.boundingBox),
          sphere: (0, _LODUtils.packBoundingSphere)(this.boundingSphere)
        },
        children: [],
        level: this.level,
        content: this.content,
        contentSet: this.contentSet,
        minRange: this.minRange,
        refine: this.refine
      };
      this.children.forEach(function (child) {
        child = child.toJSON();
        child.parent = json;
        json.children.push(child);
      });
      return json;
    }
    /**
     * 
     * @param {QuadtreeLOD} lodSet 
     * @param {Cesium.Entity[]} entities 
     * @param {Cesium.Viewer}viewer
     * @param {boolean}[foreUpdate=false]
     */

  }], [{
    key: "updatePositionClamped",
    value: function updatePositionClamped(lodSet, entities, viewer, foreUpdate) {
      return (0, _LODUtils.updatePositionClamped)(lodSet, entities, viewer, foreUpdate);
    }
    /**
     * 
     * @param {object} options 
     * @param {string} options.url 
     * @param {Cesium.Matrix4} options.modelMatrix
     * @param {THREE.LoadingManager} [options.manager]
     * @param {string} [options.dracoDecoderPath]
     * @param {number} [options.alphaTest]
     * @param {number} [options.maximumMemorySize] 
     * @param {THREE.Loader} [options.loader]
     * @param {boolean} [options.debugVolume]
     * @param {boolean} [options.showDebugVolume]
     * @param {'ADD'|'REPLACE'} [options.refine]
     * @param {number} [options.minRange]
     * @param {number} [options.rangePower=4]
     * @param {number} [options.maxMipmapSize=1024]
     * @param {number}[options.maximumTextureSize]
     * @param {boolean}[options.translucent]
     * @returns  {QuadtreeLOD}
     */

  }, {
    key: "load",
    value: function load(options) {
      var _this7 = this;

      var url = options.url,
          manager = options.manager;
      options.rangePower = options.rangePower || 4;
      var rootPath = THREE.LoaderUtils.extractUrlBase(url);

      if (rootPath && rootPath.length > 0 && !rootPath.endsWith('/')) {
        rootPath += '/';
      }

      var root = new QuadtreeLOD({
        modelMatrix: options.modelMatrix,
        maximumMemorySize: options.maximumMemorySize,
        alphaTest: options.alphaTest,
        level: 0,
        maxMipmapSize: options.maxMipmapSize,
        maximumTextureSize: options.maximumTextureSize,
        translucent: options.translucent,
        geometryErrorScale: options.geometryErrorScale
      });
      root.ready = false;
      var fileLoader = new THREE.FileLoader(manager);
      fileLoader.load(url, function (data) {
        var json = JSON.parse(data);

        _this7.fromJSON(json, options, root);

        root.uri = url;
        (0, _traverse["default"])(root, function (node) {
          if (node.content && node.content.uri) {
            node.content.uri = rootPath + node.content.uri;
          }

          if (options.minRange) {
            node.minRange = options.minRange * Math.pow(options.rangePower, node.level);
          }
        });
        root.ready = true;
        root.readyPromise.resolve(root);
      }, undefined, function (err) {
        root.readyPromise.reject(err);
      });
      return root;
    }
    /**
     * 
     * @param {object} json 
     * @param {object} options 
     * @param {Cesium.Matrix4} options.modelMatrix
     * @param {THREE.LoadingManager} [options.manager]
     * @param {string} [options.dracoDecoderPath]
     * @param {number} [options.alphaTest]
     * @param {THREE.Loader} [options.loader]
     * @param {boolean} [options.debugVolume]
     * @param {boolean} [options.showDebugVolume]
     * @param {'ADD'|'REPLACE'} [options.refine]
     * @param {QuadtreeLOD} root
     * @returns {QuadtreeLOD} root
     */

  }, {
    key: "fromJSON",
    value: function fromJSON(json, options, root) {
      var loader = options.loader;

      if (!loader) {
        loader = new _VISMLoader["default"](options.manager);

        if (options.dracoDecoderPath) {
          loader.setDracoDecoderPath(options.dracoDecoderPath);
        }

        options.loader = loader;
      } // 


      var rootOptions = {
        modelMatrix: options.modelMatrix,
        boundingVolume: json.boundingVolume,
        content: json.content,
        level: json.level,
        minRange: json.minRange,
        refine: json.refine || options.refine,
        debugVolume: !!options.debugVolume,
        showDebugVolume: !!options.showDebugVolume,
        alphaTest: options.alphaTest,
        maximumMemorySize: options.maximumMemorySize
      };

      if (!root) {
        root = new QuadtreeLOD(rootOptions);
      } else {
        root.init(rootOptions);
      }

      root.loader = options.loader;
      this.createChildren(root, json.children, root, options);
      return root;
    }
    /**
     * 
     * @param {QuadtreeLOD} lodNode 
     * @param {object[]} childrenJSON  
     * @param {QuadtreeLOD} root 
     * @param {object} options 
     * @param {Cesium.Matrix4} options.modelMatrix
     * @param {THREE.Loader} [options.loader]
     * @param {boolean} [options.debugVolume]
     * @param {boolean} [options.showDebugVolume]
     * @param {'ADD'|'REPLACE'} [options.refine]
     */

  }, {
    key: "createChildren",
    value: function createChildren(lodNode, childrenJSON, root, options) {
      var _this8 = this;

      lodNode.children = childrenJSON.map(function (childJSON) {
        var child = new QuadtreeLOD({
          modelMatrix: options.modelMatrix,
          boundingVolume: childJSON.boundingVolume,
          content: childJSON.content,
          level: childJSON.level,
          debugVolume: !!options.debugVolume,
          showDebugVolume: !!options.showDebugVolume,
          refine: childJSON.refine || options.refine,
          minRange: childJSON.minRange,
          alphaTest: options.alphaTest
        });
        child.loader = options.loader;
        child.root = root;
        child.parent = lodNode;

        if (childJSON.children && childJSON.children.length) {
          _this8.createChildren(child, childJSON.children, root, options);
        }

        return child;
      });
    }
  }]);
  return QuadtreeLOD;
}(_QuadtreeNode2["default"]);

exports["default"] = QuadtreeLOD;

},{"m_362":17,"3_313":207,"3_346":79,"D_325":85,"o_361":184,"h_344":186,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _GeometryUtils = _interopRequireDefault(require("s_310"));

var _computeArea = _interopRequireDefault(require("D_369"));

var _QuadtreeLOD = _interopRequireDefault(require("._315"));

var _QuadtreeNode = _interopRequireDefault(require("D_325"));

var _quadtreeLODBox1, _quadtreeLODBox2;

function setBoxCache(a, b) {
  if (!_quadtreeLODBox1) _quadtreeLODBox1 = new THREE.Box3();
  if (!_quadtreeLODBox2) _quadtreeLODBox2 = new THREE.Box3();

  _quadtreeLODBox1.min.copy(a.minimum || a.min);

  _quadtreeLODBox1.max.copy(a.maximum || a.max);

  _quadtreeLODBox2.min.copy(b.minimum || b.min);

  _quadtreeLODBox2.max.copy(b.maximum || b.max);
}
/**
 * @example
    var root = QuadtreeLODUtil.create({
        rootBoundingBox: model.aabb,
        maxLevel: 6,
        zSliceLevel: 5,
        minRange: 64,
        debugVolume: true,
        showDebugVolume: true,
        debugVolumeColor: Cesium.Color.CYAN,
        modelMatrix: meshVisualizer.modelMatrix
    })
    console.log('QuadtreeLOD', root);
    let rootJson = root.toJSON()
    console.log('QuadtreeLOD json', rootJson);

    root = QuadtreeLODUtil.fromJSON(rootJson, {
        debugVolume: true,
        showDebugVolume: true,
        debugVolumeColor: Cesium.Color.CYAN,
        modelMatrix: meshVisualizer.modelMatrix
    })
    console.log('fromJSON LOD', root);
    meshVisualizer.add(root);
 */


var QuadtreeLODUtil = /*#__PURE__*/function () {
  function QuadtreeLODUtil() {
    (0, _classCallCheck2["default"])(this, QuadtreeLODUtil);
  }

  (0, _createClass2["default"])(QuadtreeLODUtil, null, [{
    key: "computeLODPower",
    value:
    /**
     * 
     * @param {THREE.Mesh} mesh 
     */
    function computeLODPower(mesh) {
      var Cartesian3 = Cesium.Cartesian3;
      var geometry = mesh.geometry;
      var positions = geometry.attributes.position;
      positions = positions.array || positions.values;
      if (!geometry.boundingBox) geometry.computeBoundingBox();
      var box = geometry.boundingBox;
      var x0 = box.min.x,
          y0 = box.min.y,
          x1 = box.max.x,
          y1 = box.max.y;
      var a = new Cartesian3(x0, y1, 0),
          b = new Cartesian3(x0, y0, 0),
          c = new Cartesian3(x1, y0, 0),
          d = new Cartesian3(x1, y1, 0);
      var boxArea = 0;
      boxArea += (0, _computeArea["default"])(a, b, c);
      boxArea += (0, _computeArea["default"])(a, c, d);

      var area = _GeometryUtils["default"].computeSurfaceArea(geometry);

      var power = area * (area / boxArea); // let vCount = positions.length / 3, faceCount = geometry.index ? geometry.index.count / 3 : vCount / 3;
      // let msg = '面积a:' + area + ';\n顶点数:' + vCount + ";\n三角面数:" + faceCount + ";\n包围盒底面积A:" + boxArea + ";\n占比(a/A):" + (area / boxArea).toFixed(2) + ";\n权重:" + power;
      // console.log(msg);

      return power;
    }
    /**
     *  
     * @example
     *  ·————·————·
     *  |         |
     *  |         |
     *  |         |
     *  ·————·————·
     * 
     *       |
     *       |                ·------·------·
     *       v               /      /      /|
     *                      ·------·------· |
     *  ·————·————·        /      /      /|/|
     *  | 01 | 02 |       ·------·------· / |
     *  ·————·————·  or   ｜     ｜     ｜/|/
     *  | 03 | 04 |       ·------·------· / 
     *  ·————·————·       ｜     ｜     ｜/ 
                          ·------·------·   
     *  sliceZ=false        sliceZ=true
     *                      
     * @param {
      {
        box: Cesium.AxisAlignedBoundingBox,
        region:Cesium.TileBoundingRegion
      }
    } boundingVolume    
     * @param {number} [xSize=2] 
     * @param {number} [ySize=2] 
     * @param {number} [zSize=1] 
     * @return {
      {
        box: Cesium.AxisAlignedBoundingBox,
        region:Cesium.TileBoundingRegion
      }[]
    }
     */

  }, {
    key: "splitBoundingVolume",
    value: function splitBoundingVolume(boundingVolume, xSize, ySize, zSize) {
      var boundingVolumeList = [],
          boxList,
          regionList;

      if (boundingVolume.box) {
        boxList = this.splitBoundingBox(boundingVolume.box, xSize, ySize, zSize);
      }

      if (boundingVolume.region) {
        regionList = this.splitBoundingRegion(boundingVolume.region, xSize, ySize, zSize);
      }

      if (boxList || regionList) {
        var length = regionList ? regionList.length : boxList.length;

        for (var i = 0; i < length; i++) {
          var newBoundingVolume = {};
          if (regionList) newBoundingVolume.region = regionList[i];
          if (boxList) newBoundingVolume.box = boxList[i];
          boundingVolumeList.push(newBoundingVolume);
        }
      }

      return boundingVolumeList;
    }
    /**
     * 
     * @param {Cesium.AxisAlignedBoundingBox} aabb  
     * @param {number} [xSize=2] 
     * @param {number} [ySize=2] 
     * @param {number} [zSize=1] 
     * @return {Cesium.AxisAlignedBoundingBox[]}
     * @private
     */

  }, {
    key: "splitBoundingBox",
    value: function splitBoundingBox(aabb, xSize, ySize, zSize) {
      var _Cesium = Cesium,
          Cartesian3 = _Cesium.Cartesian3,
          AxisAlignedBoundingBox = _Cesium.AxisAlignedBoundingBox;
      var boxList = [];
      var size = Cartesian3.subtract(aabb.maximum, aabb.minimum, new Cartesian3());
      var minimum = new Cartesian3(0, 0, 0);
      var maximum = new Cartesian3(0, 0, 0);
      var vertices = [minimum, maximum];
      xSize = xSize || 2;
      ySize = ySize || 2;
      zSize = zSize || 1;
      var xStep = 1 / xSize;
      var yStep = 1 / ySize;
      var zStep = 1 / zSize;

      for (var i = 0; i < xSize; i++) {
        var x = i * xStep,
            x1 = (i + 1) * xStep;

        for (var j = 0; j < ySize; j++) {
          var y = j * yStep,
              y1 = (j + 1) * yStep;

          for (var k = 0; k < zSize; k++) {
            var z = k * zStep,
                z1 = (k + 1) * zStep;
            minimum = Cartesian3.fromElements(x, y, z, minimum);
            minimum = Cartesian3.multiplyComponents(size, minimum, minimum);
            minimum = Cartesian3.add(aabb.minimum, minimum, minimum);
            maximum = Cartesian3.fromElements(x1, y1, z1, maximum);
            maximum = Cartesian3.multiplyComponents(size, maximum, maximum);
            maximum = Cartesian3.add(aabb.minimum, maximum, maximum);
            var box = AxisAlignedBoundingBox.fromPoints(vertices);
            boxList.push(box);
          }
        }
      }

      return boxList;
    }
    /**
     * 
     * @param {Cesium.TileBoundingRegion} region 
     * @param {number} [xSize=2] 
     * @param {number} [ySize=2] 
     * @param {number} [zSize=1] 
     * @return {Cesium.TileBoundingRegion[]}
     * @private
     */

  }, {
    key: "splitBoundingRegion",
    value: function splitBoundingRegion(region, xSize, ySize, zSize) {
      var _Cesium2 = Cesium,
          Rectangle = _Cesium2.Rectangle,
          TileBoundingRegion = _Cesium2.TileBoundingRegion;
      var _region$rectangle = region.rectangle,
          west = _region$rectangle.west,
          south = _region$rectangle.south,
          width = _region$rectangle.width,
          height = _region$rectangle.height;
      var maximumHeight = region.maximumHeight,
          minimumHeight = region.minimumHeight;
      var deltH = maximumHeight - minimumHeight;
      var regionList = [];
      xSize = xSize || 2;
      ySize = ySize || 2;
      zSize = zSize || 1;
      var xStep = 1 / xSize;
      var yStep = 1 / ySize;
      var zStep = 1 / zSize;

      for (var i = 0; i < xSize; i++) {
        var x = i * xStep * width,
            x1 = (i + 1) * xStep * width;

        for (var j = 0; j < ySize; j++) {
          var y = j * yStep * height,
              y1 = (j + 1) * yStep * height;

          for (var k = 0; k < zSize; k++) {
            var z = k * zStep * deltH,
                z1 = (k + 1) * zStep * deltH;
            var rectangle = new Rectangle(west + x, south + y, west + x1, south + y1);
            var newReginon = new TileBoundingRegion({
              rectangle: rectangle,
              minimumHeight: minimumHeight + z,
              maximumHeight: minimumHeight + z1
            });
            regionList.push(newReginon);
          }
        }
      }

      return regionList;
    }
    /**
     * if a contains b,then return true,otherwise return false.
     * @param {Cesium.AxisAlignedBoundingBox|THREE.Box3} a 
     * @param {Cesium.AxisAlignedBoundingBox|THREE.Box3} b 
     * @returns {boolean}
     */

  }, {
    key: "boxContains",
    value: function boxContains(a, b) {
      setBoxCache(a, b);
      return _quadtreeLODBox1.containsBox(_quadtreeLODBox2);
    }
    /**
     * 
     * @param {Cesium.AxisAlignedBoundingBox|THREE.Box3} a 
     * @param {Cesium.AxisAlignedBoundingBox|THREE.Box3} b 
     * @returns {boolean}
     */

  }, {
    key: "boxIntersect",
    value: function boxIntersect(a, b) {
      setBoxCache(a, b);

      var intersection = _quadtreeLODBox1.intersect(_quadtreeLODBox2);

      intersection = !intersection.isEmpty();
      return intersection;
    }
    /**
     * if a contains b,then return true,otherwise return false.
     * @param {Cesium.TileBoundingRegion} a 
     * @param {Cesium.TileBoundingRegion} b 
     * @returns {boolean}
     */

  }, {
    key: "regionContains",
    value: function regionContains(a, b) {
      var rectA = a.rectangle;
      var rectB = b.rectangle;
      var deltMinHeight = a.minimumHeight - b.minimumHeight;
      var deltMaxHeight = a.maximumHeight - b.maximumHeight;
      var contains = rectA.west - rectB.west <= 0 && rectA.east - rectB.east >= 0 && rectA.south - rectB.south <= 0 && rectA.north - rectB.north >= 0;

      if (contains) {
        contains = deltMinHeight <= 0 && deltMaxHeight >= 0;
      }

      return contains;
    }
    /**
     *  
     * @param {Cesium.TileBoundingRegion} a 
     * @param {Cesium.TileBoundingRegion} b 
     * @returns {boolean}
     */

  }, {
    key: "regionIntersect",
    value: function regionIntersect(a, b) {
      var rectA = a.rectangle;
      var rectB = b.rectangle;
      var deltH1 = a.maximumHeight - b.minimumHeight;
      var deltH2 = b.maximumHeight - a.minimumHeight;
      var intersect = deltH1 > 0 && deltH2 > 0;

      if (intersect) {
        intersect = !!Cesium.Rectangle.intersection(rectA, rectB);
      }

      return intersect;
    }
    /**
     * 
     * @param {
        {
            uri:string,
            boundingVolume: {
                sphere: Cesium.BoundingSphere,
                box?: Cesium.AxisAlignedBoundingBox,
                region?:Cesium.TileBoundingRegion
            } 
        }[]
     *} contentSet 
     * @param {number}[power=2]
     * @param {boolean}[recursive=true]
     * @param {number}[maxRaius]
     * @param {QuadtreeLOD} lod 
     * @param {(node:QuadtreeLOD,content:QuadtreeNode)=>boolean} [filter] 
     */

  }, {
    key: "filterContents",
    value: function filterContents(contentSet, lod, recursive, power, maxRaius, filter) {
      var _this = this;

      power = power || 2;
      recursive = typeof recursive == 'undefined' ? true : recursive;

      if (lod.level == 0) {
        //tree
        lod.children.forEach(function (child) {
          _this.filterContents(contentSet, child, power, recursive, maxRaius, filter);
        });
        return;
      }

      var lodContentSet = {
        contain: new Array(),
        intersect: new Array(),
        length: 0
      };
      var minRadius = lod.minRadius;

      if (!minRadius) {
        if (!maxRaius) {
          maxRaius = contentSet.maxRaius || 0;

          if (!maxRaius) {
            contentSet.forEach(function (content) {
              maxRaius = Math.max(content.boundingVolume.sphere.radius, maxRaius);
            });
            contentSet.maxRaius = maxRaius;
          }

          maxRaius = Math.min(maxRaius, lod.boundingVolume.sphere.radius);
          contentSet.maxRaius = maxRaius;
        }

        var radiusStep = maxRaius / Math.pow(power, lod.maxLevel);
        minRadius = radiusStep * Math.pow(power, lod.maxLevel - lod.level); // minRadius = maxRaius * (1.0 - lod.level / lod.maxLevel);

        lod.minRadius = lod.level == lod.maxLevel ? 0 : minRadius;
      }

      contentSet.forEach(function (content) {
        if (lod.region && content.boundingVolume.region) {
          var contentRegion = content.boundingVolume.region;
          var lodRegion = lod.region;

          if (_this.regionContains(lodRegion, contentRegion)) {
            lodContentSet.contain.push(content);
            lodContentSet.length++;
          } else if (_this.regionIntersect(lodRegion, contentRegion)) {
            lodContentSet.intersect.push(content);
            lodContentSet.length++;
          }
        } else {
          var contentBox = content.boundingVolume.box;
          var lodBox = lod.boundingBox;

          if (_this.boxContains(lodBox, contentBox)) {
            lodContentSet.contain.push(content);
            lodContentSet.length++;
          } else if (_this.boxIntersect(lodBox, contentBox)) {
            lodContentSet.intersect.push(content);
            lodContentSet.length++;
          }
        }
      });
      lod.contentSet = lodContentSet;
      var currentContentSet = lodContentSet.contain.concat(lodContentSet.intersect);

      if (recursive) {
        lod.children.forEach(function (child) {
          _this.filterContents(currentContentSet, child, power, recursive, maxRaius || contentSet.maxRaius, filter);
        });
      } else {
        currentContentSet.maxRaius = maxRaius;

        lod._getContentSetBeforeFilter = function () {
          return currentContentSet;
        };
      }

      function filterByRadius(lodNode, content) {
        var contentRadius = content.boundingVolume.sphere.radius;
        if (contentRadius <= lod.minRadius) return false;
        if (lod.parent && contentRadius >= lod.parent.minRadius) return false;
        return true;
      }

      if (lod.parent && lod.parent.refine == 'ADD') {
        filter = filter || filterByRadius;
        var finalLodContentSet = {
          contain: [],
          intersect: [],
          length: 0
        };
        lodContentSet.contain.forEach(function (content) {
          if (filter(lod, content)) {
            finalLodContentSet.contain.push(content);
            finalLodContentSet.length++;
          }
        });
        lodContentSet.intersect.forEach(function (content) {
          if (filter(lod, content)) {
            finalLodContentSet.intersect.push(content);
            finalLodContentSet.length++;
          }
        });
        lod.contentSet = finalLodContentSet;
      }
    }
    /**
     * 
     * @param {QuadtreeLOD} parent 
     * @param {number} maxLevel 
     * @param {number} minRange 
     * @param {boolean}[recursive=true]
     */

  }, {
    key: "createLODTree",
    value: function createLODTree(parent, maxLevel, minRange, recursive, zSliceLevel, xSize, ySize, zSize, debugVolume, debugVolumeColor, showDebugVolume) {
      var _this2 = this;

      var level = parent.level + 1;
      if (level > maxLevel) return;
      zSliceLevel = zSliceLevel || Infinity;
      var boundingVolumeList = this.splitBoundingVolume(parent.boundingVolume, level == 1 ? xSize : 2, level == 1 ? ySize : 2, zSize && level == 1 ? zSize : 1);
      boundingVolumeList.forEach(function (boundingVolume) {
        var child = new _QuadtreeLOD["default"]({
          parent: parent,
          boundingVolume: boundingVolume,
          level: level,
          minRange: minRange * Math.pow(4, level - 1),
          debugVolumeColor: debugVolumeColor,
          debugVolume: debugVolume,
          showDebugVolume: showDebugVolume,
          modelMatrix: parent.modelMatrix,
          rtcCenter: parent.rtcCenter,
          maxLevel: maxLevel
        });

        if (recursive) {
          _this2.createLODTree(child, maxLevel, minRange, recursive, zSliceLevel, xSize, ySize, zSize, debugVolume, debugVolumeColor, showDebugVolume);
        } else {
          child._createLODTreeDelay = function (pRecursive) {
            pRecursive = typeof pRecursive == 'undefined' ? false : pRecursive;

            _this2.createLODTree(child, maxLevel, minRange, pRecursive, zSliceLevel, xSize, ySize, zSize, debugVolume, debugVolumeColor, showDebugVolume);
          };
        }

        parent.children.push(child);
      });
    }
    /**
     * 
     * @param {{
     *   rootBoundingVolume:{box?:Cesium.AxisAlignedBoundingBox,region?:Cesium.TileBoundingRegion},
     *   maxLevel:number,
     *   xSize?:number,
     *   ySize?:number,
     *   zSize?:number,
     *   zSliceLevel:number,
     *   minRange:number,
     *   debugVolumeColor?:Cesium.Color
     *   debugVolume?: boolean,
     *   showDebugVolume?: boolean,
     *   modelMatrix?:Cesium.Matrix4,
     *   rtcCenter?:Cesium.Cartesian3,
     *   recursive?:boolean,
     *   maximumTextureSize?:number
     * }} options 
     * @returns {QuadtreeLOD}
     */

  }, {
    key: "create",
    value: function create(options) {
      var rootBoundingVolume = options.rootBoundingVolume,
          maxLevel = options.maxLevel,
          zSliceLevel = options.zSliceLevel,
          minRange = options.minRange,
          debugVolume = options.debugVolume,
          showDebugVolume = options.showDebugVolume,
          debugVolumeColor = options.debugVolumeColor || Cesium.Color.YELLOW,
          modelMatrix = options.modelMatrix,
          rtcCenter = options.rtcCenter,
          recursive = typeof options.recursive == 'undefined' ? true : options.recursive;
      var root = new _QuadtreeLOD["default"]({
        boundingVolume: rootBoundingVolume,
        level: 0,
        debugVolumeColor: debugVolumeColor,
        debugVolume: debugVolume,
        showDebugVolume: showDebugVolume,
        minRange: minRange,
        modelMatrix: modelMatrix,
        rtcCenter: rtcCenter,
        maxLevel: maxLevel,
        maximumTextureSize: options.maximumTextureSize
      });
      this.createLODTree(root, maxLevel, minRange, recursive, zSliceLevel, options.xSize, options.ySize, options.zSize || 2, debugVolume, debugVolumeColor, showDebugVolume);
      return root;
    }
    /**
     * 
     * @param {Object} json 
     * @param {{
     *   debugVolumeColor?:Cesium.Color
     *   debugVolume?: boolean,
     *   showDebugVolume?: boolean,
     *   modelMatrix?:Cesium.Matrix4
     * }} options
     * @returns {QuadtreeLOD} root
     */

  }, {
    key: "fromJSON",
    value: function fromJSON(json, options) {
      options = options || {};

      function parse(parent, json) {
        json.children.forEach(function (childJson) {
          var childLod = new _QuadtreeLOD["default"](Object.assign(options, childJson));
          childLod.parent = parent;
          parse(childLod, childJson);
          parent.children.push(childLod);
        });
      }

      var root = new _QuadtreeLOD["default"](Object.assign(options, json));
      parse(root, json);
      return root;
    }
  }]);
  return QuadtreeLODUtil;
}();

exports["default"] = QuadtreeLODUtil;

},{"s_310":2,"D_369":195,"._315":83,"D_325":85,"e_1":235,"s_2":236,"M_0":241}],85:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _IRenderable2 = _interopRequireDefault(require("s_343"));

var _IContentProvider = _interopRequireDefault(require("3_379"));

var _LODUtils = require("3_346");

var _GeometryUtils = _interopRequireDefault(require("s_310"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var scratchTranslationRtc;

var getRtcModelViewCallback = function getRtcModelViewCallback(uniformState, model) {
  // CESIUM_RTC extension
  var _Cesium2 = Cesium,
      Matrix4 = _Cesium2.Matrix4,
      defined = _Cesium2.defined,
      Cartesian3 = _Cesium2.Cartesian3;
  var mvRtc = new Matrix4();
  if (!scratchTranslationRtc) scratchTranslationRtc = new Matrix4();
  return function () {
    if (defined(model.rtcCenter)) {
      Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);
      Cartesian3.add(scratchTranslationRtc, model.rtcCenter, scratchTranslationRtc);
      Matrix4.multiplyByPoint(uniformState.view, scratchTranslationRtc, scratchTranslationRtc);
      return Matrix4.setTranslation(uniformState.modelView, scratchTranslationRtc, mvRtc);
    }

    return uniformState.modelView;
  };
};

var QuadtreeNode = /*#__PURE__*/function (_IRenderable) {
  (0, _inherits2["default"])(QuadtreeNode, _IRenderable);

  var _super = _createSuper(QuadtreeNode);

  function QuadtreeNode(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, QuadtreeNode);
    _this = _super.call(this);
    /**
     * @type {number}
     */

    _this.minRange = null;
    /**
    * @type {{box:Cesium.AxisAlignedBoundingBox,region:Cesium.TileBoundingRegion}}
    */

    _this.boundingVolume = null;
    /**
     * @type {string}
     */

    _this.uri = null;
    /**
     * @type {IContentProvider}
     */

    _this.contentProvider = null;
    _this.frustumCulled = null; // Cesium.defaultValue(options.frustumCulled, true);

    _this.debugVolume = null; // Cesium.defaultValue(options.debugVolume, true);

    _this.showDebugVolume = null; //Cesium.defaultValue(options.showDebugVolume, true);

    _this.debugVolumeOnly = false;
    _this.debugVolumeColor = null;
    _this.modelMatrixNeedsUpdate = true;
    _this._modelMatrix = null;
    _this.rtcCenter = null; //options.rtcCenter;

    /**
     * @type {THREE.Group}
     */

    _this.content = options.content || null;
    _this._version = 0;

    if (options.boundingVolume) {
      _this.init(options);
    }

    return _this;
  } //properties


  (0, _createClass2["default"])(QuadtreeNode, [{
    key: "needsUpdate",
    set: function set(val) {
      if (val) {
        this._version++;
      }
    }
    /**
     * @type {Cesium.BoundingSphere}
     */

  }, {
    key: "boundingSphere",
    get: function get() {
      return this.boundingVolume.sphere;
    }
    /**
     * @type {Cesium.AxisAlignedBoundingBox}
     */

  }, {
    key: "boundingBox",
    get: function get() {
      return this.boundingVolume.box;
    }
    /**
     * @type {Cesium.BoundingSphere}
     */

  }, {
    key: "boundingSphereWC",
    get: function get() {
      return this.boundingVolume.sphereWC;
    }
    /**
     * @type {Cesium.AxisAlignedBoundingBox}
     */

  }, {
    key: "boundingBoxWC",
    get: function get() {
      return this.boundingVolume.boxWC;
    }
    /**
     * @type {Cesium.TileBoundingRegion}
     */

  }, {
    key: "region",
    get: function get() {
      return this.boundingVolume.region;
    }
  }, {
    key: "modelMatrix",
    get: function get() {
      return this._modelMatrix;
    } // methods

    /**
     * 
     * @param {object} options 
     * @private
     */
    ,
    set: function set(val) {
      if (!val) return;
      var _Cesium3 = Cesium,
          Matrix4 = _Cesium3.Matrix4,
          BoundingSphere = _Cesium3.BoundingSphere;
      val = val.elements || val;

      if (!Matrix4.equals(val, this._modelMatrix)) {
        this._modelMatrix = Matrix4.clone(val, this._modelMatrix);

        if (this.boundingBoxWC) {
          Matrix4.multiplyByPoint(this.modelMatrix, this.boundingBox.center, this.boundingBoxWC.center);
        }

        if (!this.region || !BoundingSphere.equals(this.boundingSphereWC, this.region.boundingSphere)) {
          Matrix4.multiplyByPoint(this.modelMatrix, this.boundingSphere.center, this.boundingSphereWC.center);
        }

        this.modelMatrixNeedsUpdate = true;
      }
    }
  }, {
    key: "init",
    value: function init(options) {
      var _Cesium4 = Cesium,
          defaultValue = _Cesium4.defaultValue,
          Matrix4 = _Cesium4.Matrix4,
          AxisAlignedBoundingBox = _Cesium4.AxisAlignedBoundingBox,
          BoundingSphere = _Cesium4.BoundingSphere;
      this.minRange = options.minRange || 4;
      this.boundingVolume = options.boundingVolume;
      this.uri = options.uri;
      this.contentProvider = options.contentProvider;
      this.frustumCulled = defaultValue(options.frustumCulled, true);
      this.debugVolume = defaultValue(options.debugVolume, false);
      this.showDebugVolume = defaultValue(options.showDebugVolume, false);
      this.debugVolumeOnly = defaultValue(options.debugVolumeOnly, false);
      this.debugVolumeColor = options.debugVolumeColor;
      this.modelMatrixNeedsUpdate = true;
      this._modelMatrix = null;
      this.rtcCenter = options.rtcCenter;
      this.content = options.content || null;
      var boundingVolume = this.boundingVolume;

      if (boundingVolume.box && Array.isArray(this.boundingVolume.box)) {
        var box = boundingVolume.box;
        boundingVolume.box = (0, _LODUtils.unpackBoundingBox)(box);
      }

      if (boundingVolume.region && Array.isArray(boundingVolume.region)) {
        var region = boundingVolume.region;
        boundingVolume.region = (0, _LODUtils.unpackBoundingRegion)(region);
      }

      if (boundingVolume.sphere && Array.isArray(boundingVolume.sphere)) {
        var sphere = boundingVolume.sphere;
        boundingVolume.sphere = (0, _LODUtils.unpackBoundingSphere)(sphere);
        boundingVolume.sphereWC = BoundingSphere.clone(boundingVolume.sphere);
      }

      if (boundingVolume.box && !boundingVolume.region && options.modelMatrix) {
        boundingVolume.region = (0, _LODUtils.boundingBoxToRegion)(boundingVolume.box, options.modelMatrix);
      }

      if (!boundingVolume.sphere) {
        if (boundingVolume.box) {
          var _box = boundingVolume.box;
          var vertices = [_box.minimum, _box.maximum];
          boundingVolume.sphere = BoundingSphere.fromPoints(vertices);
          boundingVolume.sphereWC = BoundingSphere.clone(boundingVolume.sphere);
        } else if (boundingVolume.region) {
          boundingVolume.sphere = boundingVolume.region.boundingSphere;
          boundingVolume.sphereWC = boundingVolume.region.boundingSphere;
        }
      } else {
        boundingVolume.sphereWC = BoundingSphere.clone(boundingVolume.sphere);
      }

      boundingVolume.boxWC = AxisAlignedBoundingBox.clone(this.boundingVolume.box);
      this.modelMatrix = options.modelMatrix || Matrix4.IDENTITY.clone();
      this.geometricError = boundingVolume.sphere.radius;

      if (this.rtcCenter) {
        var node = this,
            cesiumRtcModelViewUniform;

        this.uniformMapLoadedCallback = function (uniformMap, frameState, mesh) {
          if (!cesiumRtcModelViewUniform) {
            cesiumRtcModelViewUniform = getRtcModelViewCallback(frameState.context.uniformState, node);
          }

          uniformMap.modelView = cesiumRtcModelViewUniform;
          uniformMap.u_modelView = cesiumRtcModelViewUniform;
          uniformMap.modelViewMatrix = cesiumRtcModelViewUniform;
          uniformMap.u_modelViewMatrix = cesiumRtcModelViewUniform;
        };
      }

      if (this.debugVolume) {
        this.createDebugVolume(options.debugVolumeColor);
      }
    }
    /**
     * 
     * @param {Cesium.Color|THREE.Color|string} [debugVolumeColor] 
     * @private
     */

  }, {
    key: "createDebugVolume",
    value: function createDebugVolume(debugVolumeColor) {
      var _Cesium5 = Cesium,
          RectangleOutlineGeometry = _Cesium5.RectangleOutlineGeometry,
          Ellipsoid = _Cesium5.Ellipsoid,
          BoxOutlineGeometry = _Cesium5.BoxOutlineGeometry,
          Color = _Cesium5.Color;
      var _THREE = THREE,
          LineSegments = _THREE.LineSegments,
          LineBasicMaterial = _THREE.LineBasicMaterial;
      var geometry;

      if (this.region) {
        //&& this.rtcCenter) {
        geometry = new RectangleOutlineGeometry({
          rectangle: this.region.rectangle,
          height: this.region.minimumHeight,
          extrudedHeight: this.region.maximumHeight,
          ellipsoid: Ellipsoid.WGS84
        });
      } else {
        geometry = BoxOutlineGeometry.fromAxisAlignedBoundingBox(this.boundingBox);
      }

      geometry = geometry.constructor.createGeometry(geometry);

      if (this.rtcCenter) {
        var rtcCenter = this.rtcCenter;
        var positions = geometry.attributes.position.values;

        for (var i = 0; i < positions.length; i += 3) {
          positions[i] -= rtcCenter.x;
          positions[i + 1] -= rtcCenter.y;
          positions[i + 2] -= rtcCenter.z;
        }
      }

      geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);

      if (debugVolumeColor && debugVolumeColor instanceof Cesium.Color) {
        debugVolumeColor = debugVolumeColor.toCssColorString();
      }

      var material = new LineBasicMaterial({
        color: debugVolumeColor || 'cyan'
      });
      material._debugVolumeColor = debugVolumeColor;
      var mesh = new LineSegments(geometry, material);
      mesh.pickObject = {
        id: this,
        mesh: this,
        primitive: this.root || this
      };
      mesh.frustumCulled = false;

      if (this.region && this.rtcCenter) {
        mesh.modelMatrixNeedsUpdate = false;
      }

      mesh.uniformMapLoadedCallback = this.uniformMapLoadedCallback;
      this.debugVolume = mesh;
    }
    /**
     *  
     * @param {Cesium.FrameState} frameState  
     * @returns {Number} The range, in pixel
     * @protected
     */

  }, {
    key: "computeRange",
    value: function computeRange(frameState, progressiveResolutionHeightFraction) {
      var _Cesium = Cesium;

      var heightFraction = _Cesium.defaultValue(progressiveResolutionHeightFraction, 1.0);

      var camera = frameState.camera;
      var context = frameState.context;
      var height = context.drawingBufferHeight * heightFraction;
      this._distanceToCamera = camera.distanceToBoundingSphere(this.boundingSphereWC);
      var distance = Math.max(this._distanceToCamera, _Cesium.Math.EPSILON7);
      var sseDenominator = camera.frustum.sseDenominator;
      var geometricError = this.geometricError;
      var range = geometricError * height / (distance * sseDenominator);
      range /= frameState.pixelRatio;
      this.range = range;
      return range;
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState  
     * @returns {boolean}
     * @protected
     */

  }, {
    key: "computeVisibility",
    value: function computeVisibility(frameState) {
      var Intersect = Cesium.Intersect;
      this._visible = true;

      if (this.frustumCulled) {
        var parent = this.parent;
        var visibility = parent && parent.visibility;

        if (visibility != 1) {
          visibility = frameState.cullingVolume.computeVisibility(this.boundingSphereWC);
        }

        this.visibility = visibility;
        this._visible = visibility != -1;
      }

      if (this._visible) {
        this.range = this.computeRange(frameState);
        this._visible = this.range >= this.minRange;
      }

      return this._visible;
    }
    /**
    * 
    * @param {Cesium.FrameState} frameState 
    * @param {THREE.Object3D[]} renderList 
    * @protected
    */

  }, {
    key: "render",
    value: function render(frameState, renderList) {
      var _this2 = this;

      if (this.frameNumber == frameState.frameNumber) {
        return;
      }

      if (!this.computeVisibility(frameState)) return;

      if (this.debugVolume && (this.showDebugVolume || this.debugVolumeOnly)) {
        this.debugVolume.frustumCulled = false;
        renderList.push(this.debugVolume);
      }

      if (!this.debugVolumeOnly) {
        if (this.uri && this.contentProvider && !this._contentRequested) {
          var contentProvider = this.contentProvider;
          var object3d = contentProvider.requestContent(this.uri, this.rtcCenter);
          Cesium.when(object3d, function (object3d) {
            if (_this2.rtcCenter && !object3d.uniformMapLoadedCallback) {
              object3d.uniformMapLoadedCallback = _this2.uniformMapLoadedCallback;
            }

            object3d.frustumCulled = false;
            _this2.content = object3d;
          });
          this._contentRequested = true;
        } else if (this.content) {
          if (this.content.isObject3D) {
            if (this.content.matrixAutoUpdate) {
              this.content.updateMatrixWorld();
            }

            renderList.push(this.content);
          } else if (this.content.mesh) {
            renderList.push(this.content.mesh);
          }
        }
      }

      this.modelMatrixNeedsUpdate = false;
      this.frameNumber = frameState.frameNumber;
    }
  }]);
  return QuadtreeNode;
}(_IRenderable2["default"]);

exports["default"] = QuadtreeNode;

},{"s_310":2,"s_343":4,"3_379":78,"3_346":79,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],86:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _IRenderable2 = _interopRequireDefault(require("s_343"));

var _QuadtreeLODUtil = _interopRequireDefault(require("D_314"));

var _QuadtreeNode = _interopRequireDefault(require("D_325"));

var _QuadtreeLOD = _interopRequireDefault(require("._315"));

var _OSGLoader = _interopRequireDefault(require("e_342"));

var _VISMLoader = _interopRequireDefault(require("o_361"));

var _releaseResources = _interopRequireDefault(require("h_344"));

var _index = require("._172");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function processContentObject3d(contentNode, content, useLightMap, translucent) {
  delete content.osgRoot;
  contentNode.content = content;

  if (!content.userData) {
    content.userData = {
      uri: contentNode.uri
    };
  }

  content.traverse(function (obj) {
    obj.matrixAutoUpdate = false;
    obj.frustumCulled = false;
    obj.up.set(0, 0, 1);

    if (obj.isMesh) {
      obj.pickObject = {
        id: obj,
        mesh: obj,
        primitive: content
      };
      var objMaterial = obj.material;
      /**
       * @type {THREE.Material[]}
       */

      var materials = Array.isArray(objMaterial) ? objMaterial : [objMaterial];
      materials.forEach(function (material) {
        material.autoRefresh = false;

        if (material.transparent) {
          if (translucent) {
            // material.depthWrite = false;
            // material.opacity = 0.5;
            // material.depthTest = false
            // material.depthFunc = 2
            // material.premultipliedAlpha = true;
            material.translucent = translucent;
          } //  material.transparent = transparent;

        }

        if (!useLightMap) material.lightMap = null;
      });
    }
  });
}

function reClassContentSet(contentSet, maxLevel) {
  maxLevel = maxLevel || 5;
  var newContentSet = [],
      maxPower = 0,
      minPower = Number.MAX_VALUE,
      powers = [];
  contentSet.forEach(function (contentNode) {
    if (!contentNode.content) return;
    var content = contentNode.content;
    content.updateMatrixWorld();
    content.traverse(function (obj) {
      if (obj.isMesh) {
        var matrixWorld = obj.matrixWorld;
        var geometry = obj.geometry.clone();
        geometry.applyMatrix4(matrixWorld);
        geometry.computeBoundingBox();
        geometry.computeBoundingSphere();

        if (!obj._power) {
          var power = _QuadtreeLODUtil["default"].computeLODPower(obj);

          obj._power = power;

          if (!isNaN(power) && power !== Infinity) {
            maxPower = Math.max(maxPower, power);
            minPower = Math.min(minPower, power);
          }

          powers.push(power);
        } else {
          debugger;
        }

        var box = geometry.boundingBox,
            sphere = geometry.boundingSphere;
        var points = [box.min, box.max];
        geometry = null;
        var _Cesium = Cesium;
        newContentSet.push({
          boundingVolume: {
            box: new _Cesium.AxisAlignedBoundingBox.fromPoints(points),
            sphere: _Cesium.BoundingSphere.clone(sphere)
          },
          content: {
            uuid: obj.uuid,
            mesh: obj,
            root: content
          },
          power: obj._power
        });
      }
    });
  });
  newContentSet.sort(function (a, b) {
    return b.power - a.power;
  });
  powers.sort(function (a, b) {
    return b - a;
  });
  var newChildren = [],
      lastPower,
      levels = [],
      level = 1,
      factor = Math.sqrt(maxPower / 3);
  levels.push(newChildren);
  newContentSet.forEach(function (contentNode) {
    var a = maxPower / contentNode.power,
        b = lastPower / contentNode.power,
        c = factor / (level * 2),
        d = factor * Math.pow(2, level - 1);
    var b1 = a < d,
        b2 = b < c;

    if (!lastPower || b1 && b2 || newChildren.length < 3 || level >= maxLevel) {
      contentNode.level = level;
      newChildren.push(contentNode);
    } else {
      level++;
      newChildren = [];
      levels.push(newChildren);
      contentNode.level = level;
      newChildren.push(contentNode);
    }

    lastPower = contentNode.power;
  });
  newChildren = [];
  newContentSet.maxPower = maxPower;
  newContentSet.minPower = minPower;
  newContentSet.levels = levels;
  return newContentSet;
}

var QuatreeContentSet = /*#__PURE__*/function (_IRenderable) {
  (0, _inherits2["default"])(QuatreeContentSet, _IRenderable);

  var _super = _createSuper(QuatreeContentSet);

  /**
   * 
   * @param {object} options 
   * @param {Cesium.Matrix4} options.modelMatrix
   * @param {string} [options.url]
   * @param {QuadtreeNode[]|{uri:string,content:THREE.Group|THREE.Scene}[]} [options.contentSet]
   * @param {number} [options.minRange=32]
   * @param {number} [options.radiusPower=4] 
   * @param {{minRadius:number}[]} [options.lods] 
   * @param {boolean} [options.show=true]
   * @param {boolean} [options.useLightMap=true]
   * @param {boolean} [options.preloadTexture=false]
   * @param {boolean} [options.translucent=true]
   * @param {boolean} [options.contentCull=true]
   * @param {boolean} [options.debugVolume=true]
   * @param {boolean} [options.showDebugVolume=true]
   * @param {string} [options.dracoDecoderPath] 
   * @param {number} [options.maximumTextureSize] 
   */
  function QuatreeContentSet(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, QuatreeContentSet);
    _this = _super.call(this, options);
    var _Cesium2 = Cesium,
        defaultValue = _Cesium2.defaultValue,
        when = _Cesium2.when,
        Event = _Cesium2.Event;
    _this.maximumTextureSize = options.maximumTextureSize;
    _this.isQuatreeContentSet = true;
    _this.url = options.url;
    _this.contentSet = options.contentSet;
    _this.show = defaultValue(options.show, true);
    _this.modelMatrix = options.modelMatrix;
    _this.debugVolume = options.debugVolume;
    _this.showDebugVolume = options.showDebugVolume;
    _this.minRange = options.minRange || 32;
    _this.radiusPower = options.radiusPower || 4;
    _this.lods = options.lods || [];
    _this.maxLevel = options.maxLevel || 5;
    _this.refine = options.refine || 'ADD';
    _this.useLightMap = defaultValue(options.useLightMap, true);
    _this.preloadTexture = defaultValue(options.preloadTexture, false);
    _this.translucent = defaultValue(options.translucent, false);
    _this.format = options.format || 'osg';
    _this.dracoDecoderPath = options.dracoDecoderPath;
    _this.contentCull = defaultValue(options.contentCull, true);
    /**
     * @type {QuadtreeLOD}
     */

    _this.lodRoot = null;
    /**
     * @type {THREE.Loader}
     */

    _this.loader = options.loader;
    /**
     * @type {QuadtreeNode[]}
     */

    _this.children = [];
    /**
     * @type {THREE.Scene}
     * @private
     */

    _this.scene = new THREE.Scene();
    _this.onLoadProgress = new Event();
    _this.ready = false;
    _this.readyPromise = when.defer();
    return _this;
  }

  (0, _createClass2["default"])(QuatreeContentSet, [{
    key: "boundingSphere",
    get: function get() {
      if (!this.lodRoot) return;
      return this.lodRoot.boundingSphere;
    }
  }, {
    key: "boundingSphereWC",
    get: function get() {
      if (!this.lodRoot) return;
      return this.lodRoot.boundingSphereWC;
    }
  }, {
    key: "boundingBoxWC",
    get: function get() {
      if (!this.lodRoot) return;
      return this.lodRoot.boundingBoxWC;
    }
  }, {
    key: "region",
    get: function get() {
      if (!this.lodRoot) return;
      return this.lodRoot.region;
    }
    /**
     * @public
     */

  }, {
    key: "init",
    value: function init() {
      var _this2 = this;

      var useLightMap = this.useLightMap;
      var preloadTexture = this.preloadTexture;
      var translucent = this.translucent;

      if (this.contentSet) {
        this.contentSet.forEach(function (contentNode) {
          processContentObject3d(contentNode, contentNode.content, useLightMap, translucent);
        });
        this.onload(this.contentSet);
        return;
      }

      if (!this.url) {
        throw new Error('url is required');
      }

      this.onLoadProgress.raiseEvent({
        currentPercent: 0,
        totalPercent: 0,
        currentFile: _index.Path.GetFileName(this.url)
      });
      var _Cesium = Cesium;
      var path = THREE.LoaderUtils.extractUrlBase(this.url);
      return _Cesium.Resource.fetchJson(this.url).then(function (contentSet) {
        var df = _Cesium.when.defer();

        var stack = contentSet.slice();
        var loader = _this2.loader;
        var imageCache = {};
        var total = 0;

        var loadNext = function loadNext(done) {
          if (stack.length == 0) {
            done();
            return;
          }

          var contentNode = stack.pop();

          var box = _QuadtreeLODUtil["default"].unpackBoundingBox(contentNode.boundingVolume.box);

          var sphere = _QuadtreeLODUtil["default"].unpackBoundingSphere(contentNode.boundingVolume.sphere);

          contentNode.boundingVolume.box = box;
          contentNode.boundingVolume.sphere = sphere;

          var fileName = _index.Path.GetFileName(contentNode.uri);

          contentNode.uri = path + contentNode.uri;

          if (!loader) {
            var format = _index.Path.GetExtension(contentNode.uri).toLowerCase();

            if (format == '.vism') {
              loader = new _VISMLoader["default"]();
            } else {
              loader = new _OSGLoader["default"]();
            }
          }

          if (loader.setDracoDecoderPath && !loader.dracoLoader && _this2.dracoDecoderPath) {
            loader.setDracoDecoderPath(_this2.dracoDecoderPath);
          }

          _this2.onLoadProgress.raiseEvent({
            currentPercent: 0,
            totalPercent: total,
            currentFile: fileName
          });

          loader.load(contentNode.uri, function (content) {
            processContentObject3d(contentNode, content, useLightMap, translucent);
            total = 100 * (contentSet.length - stack.length) / contentSet.length;

            _this2.onLoadProgress.raiseEvent({
              currentPercent: 100,
              totalPercent: total,
              currentFile: fileName
            });

            loadNext(done);
          }, function (evt) {
            var current = 100 * evt.loaded / evt.total;

            _this2.onLoadProgress.raiseEvent({
              currentPercent: current,
              totalPercent: total,
              currentFile: fileName
            });
          }, function (err) {
            stack = null;
            imageCache = {};
            throw err;
          }, {
            loadTexture: preloadTexture,
            imageCache: imageCache
          });
        };

        loadNext(function () {
          _this2.onLoadProgress.raiseEvent({
            currentPercent: 100,
            totalPercent: 100,
            currentFile: '全部加载完成'
          });

          imageCache = {};

          _this2.onload(contentSet);

          df.resolve(_this2);
        });
        return df;
      });
    }
  }, {
    key: "onload",
    value: function onload(contentSet) {
      var _this3 = this;

      var oldContentSet = contentSet;
      contentSet = reClassContentSet(contentSet, this.max);
      var boxVertices = [];
      contentSet = contentSet.map(function (content) {
        var box = content.boundingVolume.box; // let sphere = content.boundingVolume.sphere;

        boxVertices.push(box.minimum, box.maximum);
        content.modelMatrix = _this3.modelMatrix;
        content.debugVolume = _this3.debugVolume;
        content.showDebugVolume = _this3.showDebugVolume;
        content.minRange = _this3.minRange;
        content.frustumCulled = _this3.contentCull;
        var power = content.power,
            level = content.level;
        content = new _QuadtreeNode["default"](content);
        content.power = power;
        content.level = level;
        return content;
      });
      this.boundingBox = Cesium.AxisAlignedBoundingBox.fromPoints(boxVertices);
      this.children.push.apply(this.children, contentSet);
      oldContentSet.forEach(function (oldContentNode) {
        var contentRoot = oldContentNode.content;

        _this3.scene.add(contentRoot); // oldContentNode.content = null;

      });
      this.createLOD();
      this.ready = true;
      this.readyPromise.resolve(this);
    }
  }, {
    key: "createLOD",
    value: function createLOD() {
      var _this4 = this;

      var radiusArr;

      if (this.lods.length > 0) {
        radiusArr = this.lods.map(function (lod) {
          return lod.minRadius;
        });
        radiusArr.sort(function (a, b) {
          return b - a;
        });
        console.log(radiusArr);
        var radiusStatics = [],
            radiusMap = new Map();
        this.children.forEach(function (content) {
          var sphere = content.boundingVolume.sphere;
          var r = parseInt(sphere.radius);

          if (!radiusMap.has(r)) {
            var item = {
              radius: r,
              count: 1
            };
            radiusMap.set(r, item);
            radiusStatics.push(item);
          } else {
            var _item = radiusMap.get(r);

            _item.count++;
          }
        });
        radiusStatics.sort(function (a, b) {
          return a.radius - b.radius;
        });
        console.log(radiusStatics);
        var sums = new Array(radiusArr.length).fill(0);
        var radiusArr2 = radiusArr.slice().sort(function (a, b) {
          return a - b;
        });
        radiusArr2.push(Infinity);
        radiusStatics.forEach(function (item) {
          for (var i = 1; i < radiusArr2.length; i++) {
            if (item.radius >= radiusArr2[i - 1] && item.radius <= radiusArr2[i]) {
              sums[i - 1] += item.count;
            }
          }
        });
        sums.reverse();
        console.log(sums);
      } //


      var rootBoundingBox = this.boundingBox;
      console.time('QuadtreeLODUtil.create');
      var _Cesium3 = Cesium,
          Cartesian3 = _Cesium3.Cartesian3,
          Color = _Cesium3.Color;
      var dimension = Cartesian3.subtract(rootBoundingBox.maximum, rootBoundingBox.minimum, new Cartesian3());
      var scale = dimension.x / dimension.y,
          xSize = 4,
          ySize = 4;

      if (scale > 1) {
        xSize = parseInt(Math.ceil(ySize * scale));
      } else {
        ySize = parseInt(Math.ceil(xSize / scale));
      }

      var root = _QuadtreeLODUtil["default"].create({
        rootBoundingVolume: {
          box: rootBoundingBox
        },
        maxLevel: this.lods.length || this.maxLevel,
        xSize: xSize,
        ySize: ySize,
        zSize: this.zSize || 1,
        minRange: this.minRange,
        debugVolume: this.debugVolume,
        showDebugVolume: this.showDebugVolume,
        debugVolumeColor: Color.CYAN,
        modelMatrix: this.modelMatrix,
        maximumTextureSize: this.maximumTextureSize
      });

      console.timeEnd('QuadtreeLODUtil.create');
      console.time('QuadtreeLODUtil.filterContents');
      (0, _index.traverse)(root, function (node) {
        // node.refine = this.refine || 'ADD';
        if (radiusArr) node.minRadius = radiusArr[node.level - 1];
      });

      var filterFunc = function filterFunc(lodNode, contentNode) {
        // let levels = contentNode.level;
        return lodNode.level == contentNode.level;
      };

      (0, _index.traverse)(root, function (node) {
        _QuadtreeLODUtil["default"].filterContents(_this4.children, node, _this4.radiusPower, null, filterFunc);
      });
      console.timeEnd('QuadtreeLODUtil.filterContents');
      root.generateLOD = false;
      console.log(root);
      this.lodRoot = root;
    }
  }, {
    key: "render",
    value: function render(frameState, renderList) {
      if (!this.ready || !this.show) return; // this.scene.updateMatrixWorld(true);

      this.lodRoot.visualizer = this.visualizer;
      this.lodRoot.render(frameState, renderList);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.visualizer) {
        this.visualizer.remove(this.scene, true);
        this.visualizer.remove(this);
      }

      (0, _releaseResources["default"])(this.scene);
      this.children.splice(0);
      this.ready = false;
      this.contentSet.forEach(function (contentNode) {
        contentNode.content = null;
      });
      this.contentSet.splice(0);
      this.lodRoot.destroy();
      this.lodRoot = null;
      this.loader = null;
      if (!this.scene.isScene && scene.dispose) this.scene.dispose();
      this.scene = null;
      this.visualizer = null;
    }
  }]);
  return QuatreeContentSet;
}(_IRenderable2["default"]);

exports["default"] = QuatreeContentSet;

},{"s_343":4,"._172":209,"._315":83,"D_314":84,"D_325":85,"e_342":182,"o_361":184,"h_344":186,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],87:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskList = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var TaskList = /*#__PURE__*/function () {
  function TaskList(maxLoadingCount, workFuncName) {
    (0, _classCallCheck2["default"])(this, TaskList);
    this._queue = [];
    this._loadingTiles = new Map();
    this._loadingCount = 0;
    this.maxLoadingCount = maxLoadingCount || 1;
    this.workFuncName = workFuncName || 'requestTile';
    this.deferredList = [];
    this.immediateList = [];
  }

  (0, _createClass2["default"])(TaskList, [{
    key: "add",
    value: function add(tile) {
      if (this.has(tile)) return;

      this._queue.push(tile);
    }
  }, {
    key: "has",
    value: function has(tile) {
      return this._loadingTiles.has(tile.tileId) || this._queue.indexOf(tile) != -1;
    }
  }, {
    key: "remove",
    value: function remove(tile) {
      if (this._loadingTiles.has(tile.tileId)) {
        this._loadingTiles["delete"](tile.tileId);
      }

      if (this._queue.indexOf(tile) == -1) return;

      for (var i = 0; i < this.length; i++) {
        if (this._queue[i] == tile) {
          return this._queue.splice(i, 1);
        }
      }
    }
  }, {
    key: "update",
    value: function update(isCameraMoving) {
      var _this = this;

      if (this.length > 0 && this._loadingCount < this.maxLoadingCount) {
        var deferredList = [],
            immediateList = [];

        this._queue.forEach(function (tile) {
          if (tile.visibility == false) deferredList.push(tile);else immediateList.push(tile);
        });

        var workdList = immediateList.length > 0 ? immediateList : deferredList;

        if (immediateList.length == 0) {
          if (isCameraMoving) return;
        }

        workdList.sort(function (a, b) {
          if (a._distanceToCamera && b._distanceToCamera) {
            return a._distanceToCamera - b._distanceToCamera;
          }

          if (a.visibility == true && b.visibility == false) {
            return -1;
          }

          if (a.visibility == false && b.visibility == true) {
            return 1;
          }

          if (a.parent && b.parent) {
            return a._distanceToCamera - b.parent._distanceToCamera;
          } else {
            return b.priority - a.priority;
          }
        });
        this.deferredList = deferredList;
        this.immediateList = immediateList;
        if (workdList.length == 0) return;
        var tile = workdList.shift();

        this._loadingTiles.set(tile.tileId, tile);

        Cesium.when(tile[this.workFuncName](), function () {
          if (isCameraMoving) {
            Cesium.requestAnimationFrame(function () {
              _this._loadingCount--;
            });
          } else {
            _this._loadingCount--;
          }

          _this._loadingTiles["delete"](tile.tileId);
        }, function (e) {
          console.warn('tile ' + tile.tileId + '  load failed.');
          _this._loadingCount--;

          _this._loadingTiles["delete"](tile.tileId);
        });
        this._loadingCount++;
        this._queue = immediateList.concat(deferredList);
        console.log(this.workFuncName, this._queue.length);
        return true;
      }
    }
  }, {
    key: "length",
    get: function get() {
      return this._queue.length + this.immediateList.length + this.deferredList.length;
    }
  }]);
  return TaskList;
}();

exports.TaskList = TaskList;

},{"e_1":235,"s_2":236,"M_0":241}],88:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BmpDecoder = BmpDecoder;

/**
 * @author shaozilee
 *
 * Bmp format decoder,support 1bit 4bit 8bit 24bit bmp
 *
 */
function BmpDecoder(buffer, is_with_alpha) {
  if (buffer instanceof Uint8Array) {
    buffer = buffer.buffer;
  } else if (typeof Buffer != 'undefined' && buffer instanceof Buffer) {
    buffer = new Uint8Array(buffer).buffer;
  }

  this.pos = 0;
  this.buffer = new DataView(buffer);
  var uin8arr = new Uint8Array(buffer);

  this.buffer.toString = function (encoding, start, end) {
    var bytes = uin8arr.subarray(start, end);
    var str = String.fromCharCode.apply(null, bytes);
    return str;
  };

  this.is_with_alpha = !!is_with_alpha;
  this.bottom_up = true;
  this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
  if (this.flag != "BM") throw new Error("Invalid BMP File");
  this.parseHeader();
  this.parseRGBA();
}

BmpDecoder.prototype.parseHeader = function () {
  this.fileSize = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.reserved = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.offset = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.headerSize = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.width = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.height = this.buffer.getInt32(this.pos);
  this.pos += 4;
  this.planes = this.buffer.getUint16(this.pos);
  this.pos += 2;
  this.bitPP = this.buffer.getUint16(this.pos);
  this.pos += 2;
  this.compress = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.rawSize = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.hr = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.vr = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.colors = this.buffer.getUint32(this.pos);
  this.pos += 4;
  this.importantColors = this.buffer.getUint32(this.pos);
  this.pos += 4;

  if (this.bitPP === 16 && this.is_with_alpha) {
    this.bitPP = 15;
  }

  if (this.bitPP < 15) {
    var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(len);

    for (var i = 0; i < len; i++) {
      var blue = this.buffer.getUint8(this.pos++);
      var green = this.buffer.getUint8(this.pos++);
      var red = this.buffer.getUint8(this.pos++);
      var quad = this.buffer.getUint8(this.pos++);
      this.palette[i] = {
        red: red,
        green: green,
        blue: blue,
        quad: quad
      };
    }
  }

  if (this.height < 0) {
    this.height *= -1;
    this.bottom_up = false;
  }
};

BmpDecoder.prototype.parseRGBA = function () {
  var bitn = "bit" + this.bitPP;
  var len = this.width * this.height * 4;
  this.data = new Uint8Array(len);
  this[bitn]();
};

BmpDecoder.prototype.bit1 = function () {
  var xlen = Math.ceil(this.width / 8);
  var mode = xlen % 4;
  var y = this.height >= 0 ? this.height - 1 : -this.height;

  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y;

    for (var x = 0; x < xlen; x++) {
      var b = this.buffer.getUint8(this.pos++);
      var location = line * this.width * 4 + x * 8 * 4;

      for (var i = 0; i < 8; i++) {
        if (x * 8 + i < this.width) {
          var rgb = this.palette[b >> 7 - i & 0x1];
          this.data[location + i * 4] = 0;
          this.data[location + i * 4 + 1] = rgb.blue;
          this.data[location + i * 4 + 2] = rgb.green;
          this.data[location + i * 4 + 3] = rgb.red;
        } else {
          break;
        }
      }
    }

    if (mode != 0) {
      this.pos += 4 - mode;
    }
  }
};

BmpDecoder.prototype.bit4 = function () {
  //RLE-4
  if (this.compress == 2) {
    var setPixelData = function setPixelData(rgbIndex) {
      var rgb = this.palette[rgbIndex];
      this.data[location] = 0;
      this.data[location + 1] = rgb.blue;
      this.data[location + 2] = rgb.green;
      this.data[location + 3] = rgb.red;
      location += 4;
    };

    this.data.fill(0xff);
    var location = 0;
    var lines = this.bottom_up ? this.height - 1 : 0;
    var low_nibble = false; //for all count of pixel

    while (location < this.data.length) {
      var a = this.buffer.getUint8(this.pos++);
      var b = this.buffer.getUint8(this.pos++); //absolute mode

      if (a == 0) {
        if (b == 0) {
          //line end
          if (this.bottom_up) {
            lines--;
          } else {
            lines++;
          }

          location = lines * this.width * 4;
          low_nibble = false;
          continue;
        } else if (b == 1) {
          //image end
          break;
        } else if (b == 2) {
          //offset x,y
          var x = this.buffer.getUint8(this.pos++);
          var y = this.buffer.getUint8(this.pos++);

          if (this.bottom_up) {
            lines -= y;
          } else {
            lines += y;
          }

          location += y * this.width * 4 + x * 4;
        } else {
          var c = this.buffer.getUint8(this.pos++);

          for (var i = 0; i < b; i++) {
            if (low_nibble) {
              setPixelData.call(this, c & 0x0f);
            } else {
              setPixelData.call(this, (c & 0xf0) >> 4);
            }

            if (i & 1 && i + 1 < b) {
              c = this.buffer.getUint8(this.pos++);
            }

            low_nibble = !low_nibble;
          }

          if ((b + 1 >> 1 & 1) == 1) {
            this.pos++;
          }
        }
      } else {
        //encoded mode
        for (var i = 0; i < a; i++) {
          if (low_nibble) {
            setPixelData.call(this, b & 0x0f);
          } else {
            setPixelData.call(this, (b & 0xf0) >> 4);
          }

          low_nibble = !low_nibble;
        }
      }
    }
  } else {
    var xlen = Math.ceil(this.width / 2);
    var mode = xlen % 4;

    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;

      for (var x = 0; x < xlen; x++) {
        var b = this.buffer.getUint8(this.pos++);
        var location = line * this.width * 4 + x * 2 * 4;
        var before = b >> 4;
        var after = b & 0x0F;
        var rgb = this.palette[before];
        this.data[location] = 0;
        this.data[location + 1] = rgb.blue;
        this.data[location + 2] = rgb.green;
        this.data[location + 3] = rgb.red;
        if (x * 2 + 1 >= this.width) break;
        rgb = this.palette[after];
        this.data[location + 4] = 0;
        this.data[location + 4 + 1] = rgb.blue;
        this.data[location + 4 + 2] = rgb.green;
        this.data[location + 4 + 3] = rgb.red;
      }

      if (mode != 0) {
        this.pos += 4 - mode;
      }
    }
  }
};

BmpDecoder.prototype.bit8 = function () {
  //RLE-8
  if (this.compress == 1) {
    var setPixelData = function setPixelData(rgbIndex) {
      var rgb = this.palette[rgbIndex];
      this.data[location] = 0;
      this.data[location + 1] = rgb.blue;
      this.data[location + 2] = rgb.green;
      this.data[location + 3] = rgb.red;
      location += 4;
    };

    this.data.fill(0xff);
    var location = 0;
    var lines = this.bottom_up ? this.height - 1 : 0;

    while (location < this.data.length) {
      var a = this.buffer.getUint8(this.pos++);
      var b = this.buffer.getUint8(this.pos++); //absolute mode

      if (a == 0) {
        if (b == 0) {
          //line end
          if (this.bottom_up) {
            lines--;
          } else {
            lines++;
          }

          location = lines * this.width * 4;
          continue;
        } else if (b == 1) {
          //image end
          break;
        } else if (b == 2) {
          //offset x,y
          var x = this.buffer.getUint8(this.pos++);
          var y = this.buffer.getUint8(this.pos++);

          if (this.bottom_up) {
            lines -= y;
          } else {
            lines += y;
          }

          location += y * this.width * 4 + x * 4;
        } else {
          for (var i = 0; i < b; i++) {
            var c = this.buffer.getUint8(this.pos++);
            setPixelData.call(this, c);
          }

          if (b & 1 == 1) {
            this.pos++;
          }
        }
      } else {
        //encoded mode
        for (var i = 0; i < a; i++) {
          setPixelData.call(this, b);
        }
      }
    }
  } else {
    var mode = this.width % 4;

    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;

      for (var x = 0; x < this.width; x++) {
        var b = this.buffer.getUint8(this.pos++);
        var location = line * this.width * 4 + x * 4;

        if (b < this.palette.length) {
          var rgb = this.palette[b];
          this.data[location] = 0;
          this.data[location + 1] = rgb.blue;
          this.data[location + 2] = rgb.green;
          this.data[location + 3] = rgb.red;
        } else {
          this.data[location] = 0;
          this.data[location + 1] = 0xFF;
          this.data[location + 2] = 0xFF;
          this.data[location + 3] = 0xFF;
        }
      }

      if (mode != 0) {
        this.pos += 4 - mode;
      }
    }
  }
};

BmpDecoder.prototype.bit15 = function () {
  var dif_w = this.width % 3;

  var _11111 = parseInt("11111", 2),
      _1_5 = _11111;

  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y;

    for (var x = 0; x < this.width; x++) {
      var B = this.buffer.getUint16(this.pos);
      this.pos += 2;
      var blue = (B & _1_5) / _1_5 * 255 | 0;
      var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;
      var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
      var alpha = B >> 15 ? 0xFF : 0x00;
      var location = line * this.width * 4 + x * 4;
      this.data[location] = alpha;
      this.data[location + 1] = blue;
      this.data[location + 2] = green;
      this.data[location + 3] = red;
    } //skip extra bytes


    this.pos += dif_w;
  }
};

BmpDecoder.prototype.bit16 = function () {
  var dif_w = this.width % 2 * 2; //default xrgb555

  this.maskRed = 0x7C00;
  this.maskGreen = 0x3E0;
  this.maskBlue = 0x1F;
  this.mask0 = 0;

  if (this.compress == 3) {
    this.maskRed = this.buffer.getUint32(this.pos);
    this.pos += 4;
    this.maskGreen = this.buffer.getUint32(this.pos);
    this.pos += 4;
    this.maskBlue = this.buffer.getUint32(this.pos);
    this.pos += 4;
    this.mask0 = this.buffer.getUint32(this.pos);
    this.pos += 4;
  }

  var ns = [0, 0, 0];

  for (var i = 0; i < 16; i++) {
    if (this.maskRed >> i & 0x01) ns[0]++;
    if (this.maskGreen >> i & 0x01) ns[1]++;
    if (this.maskBlue >> i & 0x01) ns[2]++;
  }

  ns[1] += ns[0];
  ns[2] += ns[1];
  ns[0] = 8 - ns[0];
  ns[1] -= 8;
  ns[2] -= 8;

  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y;

    for (var x = 0; x < this.width; x++) {
      var B = this.buffer.getUint16(this.pos);
      this.pos += 2;
      var blue = (B & this.maskBlue) << ns[0];
      var green = (B & this.maskGreen) >> ns[1];
      var red = (B & this.maskRed) >> ns[2];
      var location = line * this.width * 4 + x * 4;
      this.data[location] = 0;
      this.data[location + 1] = blue;
      this.data[location + 2] = green;
      this.data[location + 3] = red;
    } //skip extra bytes


    this.pos += dif_w;
  }
};

BmpDecoder.prototype.bit24 = function () {
  for (var y = this.height - 1; y >= 0; y--) {
    var line = this.bottom_up ? y : this.height - 1 - y;

    for (var x = 0; x < this.width; x++) {
      //Little Endian rgb
      var blue = this.buffer.getUint8(this.pos++);
      var green = this.buffer.getUint8(this.pos++);
      var red = this.buffer.getUint8(this.pos++);
      var location = line * this.width * 4 + x * 4;
      this.data[location] = 0;
      this.data[location + 1] = blue;
      this.data[location + 2] = green;
      this.data[location + 3] = red;
    } //skip extra bytes


    this.pos += this.width % 4;
  }
};
/**
 * add 32bit decode func
 * @author soubok
 */


BmpDecoder.prototype.bit32 = function () {
  //BI_BITFIELDS
  if (this.compress == 3) {
    this.maskRed = this.buffer.getUint32(this.pos);
    this.pos += 4;
    this.maskGreen = this.buffer.getUint32(this.pos);
    this.pos += 4;
    this.maskBlue = this.buffer.getUint32(this.pos);
    this.pos += 4;
    this.mask0 = this.buffer.getUint32(this.pos);
    this.pos += 4;

    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;

      for (var x = 0; x < this.width; x++) {
        //Little Endian rgba
        var alpha = this.buffer.getUint8(this.pos++);
        var blue = this.buffer.getUint8(this.pos++);
        var green = this.buffer.getUint8(this.pos++);
        var red = this.buffer.getUint8(this.pos++);
        var location = line * this.width * 4 + x * 4;
        this.data[location] = alpha;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
    }
  } else {
    for (var y = this.height - 1; y >= 0; y--) {
      var line = this.bottom_up ? y : this.height - 1 - y;

      for (var x = 0; x < this.width; x++) {
        //Little Endian argb
        var blue = this.buffer.getUint8(this.pos++);
        var green = this.buffer.getUint8(this.pos++);
        var red = this.buffer.getUint8(this.pos++);
        var alpha = this.buffer.getUint8(this.pos++);
        var location = line * this.width * 4 + x * 4;
        this.data[location] = alpha;
        this.data[location + 1] = blue;
        this.data[location + 2] = green;
        this.data[location + 3] = red;
      }
    }
  }
};

BmpDecoder.prototype.getData = function () {
  return this.data;
}; // export function decode(bmpData) {
//     var decoder = new BmpDecoder(bmpData);
//     return decoder;
// };

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":248}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DRACOExporter = void 0;

// import {
// var	BufferGeometry;
// } from "../three/three.module.js";

/**
 * Export draco compressed files from threejs geometry objects.
 *
 * Draco files are compressed and usually are smaller than conventional 3D file formats.
 *
 * The exporter receives a options object containing
 *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)
 *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)
 *  - encoderMethod
 *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)
 *  - exportUvs
 *  - exportNormals
 */

/* global DracoEncoderModule */
var DRACOExporter = function DRACOExporter() {};

exports.DRACOExporter = DRACOExporter;
DRACOExporter.prototype = {
  constructor: DRACOExporter,
  parse: function parse(geometry, options) {
    if (DracoEncoderModule === undefined) {
      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');
    }

    if (options === undefined) {
      options = {
        decodeSpeed: 5,
        encodeSpeed: 5,
        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,
        quantization: [16, 8, 8, 8, 8],
        //POSITION, NORMAL, COLOR, TEX_COORD,GENERIC
        exportUvs: true,
        exportNormals: true,
        exportColor: false
      };
    }

    var dracoEncoder = DracoEncoderModule();
    var encoder = new dracoEncoder.Encoder();
    var builder = new dracoEncoder.MeshBuilder();
    var mesh = new dracoEncoder.Mesh();

    if (geometry.isGeometry === true) {
      var bufferGeometry = new THREE.BufferGeometry();
      bufferGeometry.fromGeometry(geometry);
      geometry = bufferGeometry;
    }

    if (geometry.isBufferGeometry !== true) {
      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or BufferGeometry instance.');
    }

    var vertices = geometry.getAttribute('position');
    builder.AddFloatAttributeToMesh(mesh, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
    var faces = geometry.getIndex();

    if (faces !== null) {
      builder.AddFacesToMesh(mesh, faces.count / 3, faces.array);
    } else {
      var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);

      for (var i = 0; i < faces.length; i++) {
        faces[i] = i;
      }

      builder.AddFacesToMesh(mesh, vertices.count, faces);
    }

    if (options.exportNormals === true) {
      var normals = geometry.getAttribute('normal');

      if (normals !== undefined) {
        builder.AddFloatAttributeToMesh(mesh, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);
      }
    }

    if (options.exportUvs === true) {
      var uvs = geometry.getAttribute('uv');

      if (uvs !== undefined) {
        builder.AddFloatAttributeToMesh(mesh, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);
      }

      uvs = geometry.getAttribute('uv2');

      if (uvs !== undefined) {
        builder.AddFloatAttributeToMesh(mesh, dracoEncoder.GENERIC, uvs.count, uvs.itemSize, uvs.array);
      }
    }

    if (options.exportColor === true) {
      var colors = geometry.getAttribute('color');

      if (colors !== undefined) {
        builder.AddFloatAttributeToMesh(mesh, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
      }
    } //Compress using draco encoder


    var encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).

    encoder.SetSpeedOptions(options.encodeSpeed || 5, options.decodeSpeed || 5); // Sets the desired encoding method for a given geometry.

    if (options.encoderMethod !== undefined) {
      encoder.SetEncodingMethod(options.encoderMethod);
    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.
    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.


    if (options.quantization !== undefined) {
      for (var i = 0; i < 5; i++) {
        if (options.quantization[i] !== undefined) {
          encoder.SetAttributeQuantization(i, options.quantization[i]);
        }
      }
    }

    var length = encoder.EncodeMeshToDracoBuffer(mesh, encodedData);
    dracoEncoder.destroy(mesh);

    if (length === 0) {
      throw new Error('THREE.DRACOExporter: Draco encoding failed.');
    } //Copy encoded data to buffer.


    var outputData = new Int8Array(new ArrayBuffer(length));

    for (var i = 0; i < length; i++) {
      outputData[i] = encodedData.GetValue(i);
    }

    dracoEncoder.destroy(encodedData);
    dracoEncoder.destroy(encoder);
    dracoEncoder.destroy(builder);
    return outputData;
  }
}; // Encoder methods

DRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;
DRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type

DRACOExporter.POINT_CLOUD = 0;
DRACOExporter.TRIANGULAR_MESH = 1; // Attribute type

DRACOExporter.INVALID = -1;
DRACOExporter.POSITION = 0;
DRACOExporter.NORMAL = 1;
DRACOExporter.COLOR = 2;
DRACOExporter.TEX_COORD = 3;
DRACOExporter.GENERIC = 4;

},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLTFExporter = void 0;

var _index = require("h_399");

/**
 * @author fernandojsg / http://fernandojsg.com
 * @author Don McCurdy / https://www.donmccurdy.com
 * @author Takahiro / https://github.com/takahirox
 */
var isNodeEnv = typeof Blob == 'undefined' || typeof Image == 'undefined' || typeof Document == 'undefined' || typeof window == 'undefined';
var BufferAttribute, BufferGeometry, ClampToEdgeWrapping, DoubleSide, InterpolateDiscrete, InterpolateLinear, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MathUtils, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, PropertyBinding, RGBAFormat, RepeatWrapping, Scene, Vector3; //------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

var WebGLConstants = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006,
  UNSIGNED_BYTE: 0x1401,
  UNSIGNED_SHORT: 0x1403,
  FLOAT: 0x1406,
  UNSIGNED_INT: 0x1405,
  ARRAY_BUFFER: 0x8892,
  ELEMENT_ARRAY_BUFFER: 0x8893,
  NEAREST: 0x2600,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
var THREE_TO_WEBGL = {};
var PATH_PROPERTIES = {
  scale: 'scale',
  position: 'translation',
  quaternion: 'rotation',
  morphTargetInfluences: 'weights'
};
var initDeps$GLTFExporterDone = false;

function initDeps$GLTFExporter() {
  if (initDeps$GLTFExporterDone) return;
  initDeps$GLTFExporterDone = true;
  var _THREE = THREE;
  BufferAttribute = _THREE.BufferAttribute, BufferGeometry = _THREE.BufferGeometry, ClampToEdgeWrapping = 1001, DoubleSide = 2, InterpolateDiscrete = 2300, InterpolateLinear = 2301, LinearFilter = 1006, LinearMipmapLinearFilter = 1008, LinearMipmapNearestFilter = 1007, MathUtils = _THREE.MathUtils, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapLinearFilter = 1005, NearestMipmapNearestFilter = 1004, PropertyBinding = _THREE.PropertyBinding, RGBAFormat = 1023, RepeatWrapping = 1000, Scene = _THREE.Scene, Vector3 = _THREE.Vector3;
  THREE_TO_WEBGL[NearestFilter] = 9728;
  THREE_TO_WEBGL[NearestMipmapNearestFilter] = 9984;
  THREE_TO_WEBGL[NearestMipmapLinearFilter] = 9986;
  THREE_TO_WEBGL[LinearFilter] = 9729;
  THREE_TO_WEBGL[LinearMipmapNearestFilter] = 9985;
  THREE_TO_WEBGL[LinearMipmapLinearFilter] = 9987;
  THREE_TO_WEBGL[ClampToEdgeWrapping] = 33071;
  THREE_TO_WEBGL[RepeatWrapping] = 10497;
  THREE_TO_WEBGL[MirroredRepeatWrapping] = 33648;
} //------------------------------------------------------------------------------
// GLTF Exporter
//------------------------------------------------------------------------------


var GLTFExporter = function GLTFExporter() {
  initDeps$GLTFExporter();
};

exports.GLTFExporter = GLTFExporter;
GLTFExporter.prototype = {
  constructor: GLTFExporter,

  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  parse: function parse(input, onDone, options) {
    var DEFAULT_OPTIONS = {
      binary: false,
      trs: false,
      onlyVisible: true,
      truncateDrawRange: true,
      embedImages: true,
      maxTextureSize: Infinity,
      animations: [],
      forceIndices: false,
      forcePowerOfTwoTextures: false,
      includeCustomExtensions: false
    };
    options = Object.assign({}, DEFAULT_OPTIONS, options);

    if (options.animations.length > 0) {
      // Only TRS properties, and not matrices, may be targeted by animation.
      options.trs = true;
    }

    var outputJSON = {
      asset: {
        version: "2.0",
        generator: "GLTFExporter"
      }
    };
    var byteOffset = 0;
    var buffers = [];
    var pending = [];
    var nodeMap = new Map();
    var skins = [];
    var extensionsUsed = {};
    var cachedData = {
      meshes: new Map(),
      attributes: new Map(),
      attributesNormalized: new Map(),
      materials: new Map(),
      textures: new Map(),
      images: new Map(),
      assetSrcs: options.assetSrcs || {}
    };
    var cachedCanvas;
    var uids = new Map();
    var uid = 0;
    /**
     * Assign and return a temporal unique id for an object
     * especially which doesn't have .uuid
     * @param  {Object} object
     * @return {Integer}
     */

    function getUID(object) {
      if (!uids.has(object)) uids.set(object, uid++);
      return uids.get(object);
    }
    /**
     * Compare two arrays
     * @param  {Array} array1 Array 1 to compare
     * @param  {Array} array2 Array 2 to compare
     * @return {Boolean}        Returns true if both arrays are equal
     */


    function equalArray(array1, array2) {
      return array1.length === array2.length && array1.every(function (element, index) {
        return element === array2[index];
      });
    }
    /**
     * Converts a string to an ArrayBuffer.
     * @param  {string} text
     * @return {ArrayBuffer}
     */


    function stringToArrayBuffer(text) {
      if (typeof TextEncoder !== 'undefined') {
        return new TextEncoder().encode(text).buffer;
      }

      var array = new Uint8Array(new ArrayBuffer(text.length));

      for (var i = 0, il = text.length; i < il; i++) {
        var value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).

        array[i] = value > 0xFF ? 0x20 : value;
      }

      return array.buffer;
    }
    /**
     * Get the min and max vectors from the given attribute
     * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
     * @param  {Integer} start
     * @param  {Integer} count
     * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
     */


    function getMinMax(attribute, start, count) {
      var output = {
        min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
        max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
      };

      for (var i = start; i < start + count; i++) {
        for (var a = 0; a < attribute.itemSize; a++) {
          var value = attribute.array[i * attribute.itemSize + a];
          output.min[a] = Math.min(output.min[a], value);
          output.max[a] = Math.max(output.max[a], value);
        }
      }

      return output;
    }
    /**
     * Checks if image size is POT.
     *
     * @param {Image} image The image to be checked.
     * @returns {Boolean} Returns true if image size is POT.
     *
     */


    function isPowerOfTwo(image) {
      return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
    }
    /**
     * Checks if normal attribute values are normalized.
     *
     * @param {BufferAttribute} normal
     * @returns {Boolean}
     *
     */


    function isNormalizedNormalAttribute(normal) {
      if (cachedData.attributesNormalized.has(normal)) {
        return false;
      }

      var v = new Vector3();

      for (var i = 0, il = normal.count; i < il; i++) {
        // 0.0005 is from glTF-validator
        if (Math.abs(v.fromArray(normal.array, i * 3).length() - 1.0) > 0.0005) return false;
      }

      return true;
    }
    /**
     * Creates normalized normal buffer attribute.
     *
     * @param {BufferAttribute} normal
     * @returns {BufferAttribute}
     *
     */


    function createNormalizedNormalAttribute(normal) {
      if (cachedData.attributesNormalized.has(normal)) {
        return cachedData.attributesNormalized.get(normal);
      }

      var attribute = normal.clone();
      var v = new Vector3();

      for (var i = 0, il = attribute.count; i < il; i++) {
        v.fromArray(attribute.array, i * 3);

        if (v.x === 0 && v.y === 0 && v.z === 0) {
          // if values can't be normalized set (1, 0, 0)
          v.setX(1.0);
        } else {
          v.normalize();
        }

        v.toArray(attribute.array, i * 3);
      }

      cachedData.attributesNormalized.set(normal, attribute);
      return attribute;
    }
    /**
     * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
     *
     * @param {Integer} bufferSize The size the original buffer.
     * @returns {Integer} new buffer size with required padding.
     *
     */


    function getPaddedBufferSize(bufferSize) {
      return Math.ceil(bufferSize / 4) * 4;
    }
    /**
     * Returns a buffer aligned to 4-byte boundary.
     *
     * @param {ArrayBuffer} arrayBuffer Buffer to pad
     * @param {Integer} paddingByte (Optional)
     * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
     */


    function getPaddedArrayBuffer(arrayBuffer, paddingByte) {
      paddingByte = paddingByte || 0;
      var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);

      if (paddedLength !== arrayBuffer.byteLength) {
        var array = new Uint8Array(paddedLength);
        array.set(new Uint8Array(arrayBuffer));

        if (paddingByte !== 0) {
          for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {
            array[i] = paddingByte;
          }
        }

        return array.buffer;
      }

      return arrayBuffer;
    }
    /**
     * Serializes a userData.
     *
     * @param {THREE.Object3D|THREE.Material} object
     * @param {Object} gltfProperty
     */


    function serializeUserData(object, gltfProperty) {
      if (Object.keys(object.userData).length === 0) {
        return;
      }

      try {
        var json = JSON.parse(JSON.stringify(object.userData));

        if (options.includeCustomExtensions && json.gltfExtensions) {
          if (gltfProperty.extensions === undefined) {
            gltfProperty.extensions = {};
          }

          for (var extensionName in json.gltfExtensions) {
            gltfProperty.extensions[extensionName] = json.gltfExtensions[extensionName];
            extensionsUsed[extensionName] = true;
          }

          delete json.gltfExtensions;
        }

        if (Object.keys(json).length > 0) {
          gltfProperty.extras = json;
        }
      } catch (error) {
        console.warn('THREE.GLTFExporter: userData of \'' + object.name + '\' ' + 'won\'t be serialized because of JSON.stringify error - ' + error.message);
      }
    }
    /**
     * Applies a texture transform, if present, to the map definition. Requires
     * the KHR_texture_transform extension.
     */


    function applyTextureTransform(mapDef, texture) {
      var didTransform = false;
      var transformDef = {};

      if (texture.offset.x !== 0 || texture.offset.y !== 0) {
        transformDef.offset = texture.offset.toArray();
        didTransform = true;
      }

      if (texture.rotation !== 0) {
        transformDef.rotation = texture.rotation;
        didTransform = true;
      }

      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {
        transformDef.scale = texture.repeat.toArray();
        didTransform = true;
      }

      if (didTransform) {
        mapDef.extensions = mapDef.extensions || {};
        mapDef.extensions['KHR_texture_transform'] = transformDef;
        extensionsUsed['KHR_texture_transform'] = true;
      }
    }
    /**
     * Process a buffer to append to the default one.
     * @param  {ArrayBuffer} buffer
     * @return {Integer}
     */


    function processBuffer(buffer) {
      if (!outputJSON.buffers) {
        outputJSON.buffers = [{
          byteLength: 0
        }];
      } // All buffers are merged before export.


      buffers.push(buffer);
      return 0;
    }
    /**
     * Process and generate a BufferView
     * @param  {BufferAttribute} attribute
     * @param  {number} componentType
     * @param  {number} start
     * @param  {number} count
     * @param  {number} target (Optional) Target usage of the BufferView
     * @return {Object}
     */


    function processBufferView(attribute, componentType, start, count, target) {
      if (!outputJSON.bufferViews) {
        outputJSON.bufferViews = [];
      } // Create a new dataview and dump the attribute's array into it


      var componentSize;

      if (componentType === 5121) {
        componentSize = 1;
      } else if (componentType === 5123) {
        componentSize = 2;
      } else {
        componentSize = 4;
      }

      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);
      var dataView = new DataView(new ArrayBuffer(byteLength));
      var offset = 0;

      for (var i = start; i < start + count; i++) {
        for (var a = 0; a < attribute.itemSize; a++) {
          // @TODO Fails on InterleavedBufferAttribute, and could probably be
          // optimized for normal BufferAttribute.
          var value = attribute.array[i * attribute.itemSize + a];

          if (componentType === 5126) {
            dataView.setFloat32(offset, value, true);
          } else if (componentType === 5125) {
            dataView.setUint32(offset, value, true);
          } else if (componentType === 5123) {
            dataView.setUint16(offset, value, true);
          } else if (componentType === 5121) {
            dataView.setUint8(offset, value);
          }

          offset += componentSize;
        }
      }

      var gltfBufferView = {
        buffer: processBuffer(dataView.buffer),
        byteOffset: byteOffset,
        byteLength: byteLength
      };
      if (target !== undefined) gltfBufferView.target = target;

      if (target === 34962) {
        // Only define byteStride for vertex attributes.
        gltfBufferView.byteStride = attribute.itemSize * componentSize;
      }

      byteOffset += byteLength;
      outputJSON.bufferViews.push(gltfBufferView); // @TODO Merge bufferViews where possible.

      var output = {
        id: outputJSON.bufferViews.length - 1,
        byteLength: 0
      };
      return output;
    }
    /**
     * Process and generate a BufferView from an image Blob.
     * @param {Blob} blob
     * @return {Promise<Integer>}
     */


    function processBufferViewImage(blob) {
      if (!outputJSON.bufferViews) {
        outputJSON.bufferViews = [];
      }

      return new Promise(function (resolve) {
        var reader = new window.FileReader();
        reader.readAsArrayBuffer(blob);

        reader.onloadend = function () {
          var buffer = getPaddedArrayBuffer(reader.result);
          var bufferView = {
            buffer: processBuffer(buffer),
            byteOffset: byteOffset,
            byteLength: buffer.byteLength
          };
          byteOffset += buffer.byteLength;
          outputJSON.bufferViews.push(bufferView);
          resolve(outputJSON.bufferViews.length - 1);
        };
      });
    }
    /**
     * Process attribute to generate an accessor
     * @param  {BufferAttribute} attribute Attribute to process
     * @param  {BufferGeometry} geometry (Optional) Geometry used for truncated draw range
     * @param  {Integer} start (Optional)
     * @param  {Integer} count (Optional)
     * @return {Integer}           Index of the processed accessor on the "accessors" array
     */


    function processAccessor(attribute, geometry, start, count) {
      var types = {
        1: 'SCALAR',
        2: 'VEC2',
        3: 'VEC3',
        4: 'VEC4',
        16: 'MAT4'
      };
      var componentType; // Detect the component type of the attribute array (float, uint or ushort)

      if (attribute.array.constructor === Float32Array) {
        componentType = 5126;
      } else if (attribute.array.constructor === Uint32Array) {
        componentType = 5125;
      } else if (attribute.array.constructor === Uint16Array) {
        componentType = 5123;
      } else if (attribute.array.constructor === Uint8Array) {
        componentType = 5121;
      } else {
        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');
      }

      if (start === undefined) start = 0;
      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet

      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {
        var end = start + count;
        var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;
        start = Math.max(start, geometry.drawRange.start);
        count = Math.min(end, end2) - start;
        if (count < 0) count = 0;
      } // Skip creating an accessor if the attribute doesn't have data to export


      if (count === 0) {
        return null;
      }

      var minMax = getMinMax(attribute, start, count);
      var bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For
      // animation samplers, target must not be set.

      if (geometry !== undefined) {
        bufferViewTarget = attribute === geometry.index ? 34963 : 34962;
      }

      var bufferView = processBufferView(attribute, componentType, start, count, bufferViewTarget);
      var gltfAccessor = {
        bufferView: bufferView.id,
        byteOffset: bufferView.byteOffset,
        componentType: componentType,
        count: count,
        max: minMax.max,
        min: minMax.min,
        type: types[attribute.itemSize]
      };

      if (!outputJSON.accessors) {
        outputJSON.accessors = [];
      }

      outputJSON.accessors.push(gltfAccessor);
      return outputJSON.accessors.length - 1;
    }
    /**
     * Process image
     * @param  {Image} image to process
     * @param  {Integer} format of the image (e.g. 1022, RGBAFormat etc)
     * @param  {Boolean} flipY before writing out the image
     * @return {Integer}     Index of the processed texture in the "images" array
     */


    function processImage(image, format, flipY) {
      if (!image) return;

      if (!cachedData.images.has(image.src)) {
        cachedData.images.set(image.src, {});
      }

      var cachedImages = cachedData.images.get(image.src);
      var mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';
      var key = mimeType + ":flipY/" + flipY.toString();

      if (cachedImages[key] !== undefined) {
        return cachedImages[key];
      }

      if (!outputJSON.images) {
        outputJSON.images = [];
      }

      var gltfImage = {
        mimeType: mimeType
      };
      var uri = cachedData.assetSrcs[image.src] || image.src || image;

      if (typeof HTMLCanvasElement != 'undefined' && (typeof uri != 'string' || uri.startsWith('blob:') || options.embedImages)) {
        if (!image) {
          image = document.createElement('canvas');
          image.width = 2;
          image.height = 2;
        }

        var canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');
        canvas.width = Math.min(image.width, options.maxTextureSize);
        canvas.height = Math.min(image.height, options.maxTextureSize);

        if (options.forcePowerOfTwoTextures && !isPowerOfTwo(canvas)) {
          console.warn('GLTFExporter: Resized non-power-of-two image.', image);
          canvas.width = MathUtils.floorPowerOfTwo(canvas.width);
          canvas.height = MathUtils.floorPowerOfTwo(canvas.height);
        }

        var ctx = canvas.getContext('2d');

        if (flipY === true) {
          ctx.translate(0, canvas.height);
          ctx.scale(1, -1);
        }

        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

        if (options.binary === true) {
          pending.push(new Promise(function (resolve) {
            canvas.toBlob(function (blob) {
              processBufferViewImage(blob).then(function (bufferViewIndex) {
                gltfImage.bufferView = bufferViewIndex;
                resolve();
              });
            }, mimeType);
          }));
        } else {
          gltfImage.uri = canvas.toDataURL(mimeType);
        }
      } else {
        if (typeof uri != 'string') {
          debugger;
        }

        gltfImage.uri = uri;
      }

      outputJSON.images.push(gltfImage);
      var index = outputJSON.images.length - 1;
      cachedImages[key] = index;
      return index;
    }
    /**
     * Process sampler
     * @param  {Texture} map Texture to process
     * @return {Integer}     Index of the processed texture in the "samplers" array
     */


    function processSampler(map) {
      if (!outputJSON.samplers) {
        outputJSON.samplers = [];
      }

      var gltfSampler = {
        magFilter: THREE_TO_WEBGL[map.magFilter],
        minFilter: THREE_TO_WEBGL[map.minFilter],
        wrapS: THREE_TO_WEBGL[map.wrapS],
        wrapT: THREE_TO_WEBGL[map.wrapT]
      };
      outputJSON.samplers.push(gltfSampler);
      return outputJSON.samplers.length - 1;
    }
    /**
     * Process texture
     * @param  {Texture} map Map to process
     * @return {Integer}     Index of the processed texture in the "textures" array
     */


    function processTexture(map) {
      if (cachedData.textures.has(map)) {
        return cachedData.textures.get(map);
      }

      if (!outputJSON.textures) {
        outputJSON.textures = [];
      }

      var gltfTexture = {
        sampler: processSampler(map),
        source: processImage(map.image, map.format, map.flipY)
      };

      if (map.name) {
        gltfTexture.name = map.name;
      }

      outputJSON.textures.push(gltfTexture);
      var index = outputJSON.textures.length - 1;
      cachedData.textures.set(map, index);
      return index;
    }
    /**
     * Process material
     * @param  {THREE.Material} material Material to process
     * @return {Integer}      Index of the processed material in the "materials" array
     */


    function processMaterial(material) {
      if (cachedData.materials.has(material)) {
        return cachedData.materials.get(material);
      }

      if (material.isShaderMaterial) {
        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');
        return null;
      }

      if (!outputJSON.materials) {
        outputJSON.materials = [];
      } // @QUESTION Should we avoid including any attribute that has the default value?


      var gltfMaterial = {
        pbrMetallicRoughness: {}
      };

      if (material.isMeshBasicMaterial) {
        gltfMaterial.extensions = {
          KHR_materials_unlit: {}
        };
        extensionsUsed['KHR_materials_unlit'] = true;
      } else if (material.isGLTFSpecularGlossinessMaterial) {
        gltfMaterial.extensions = {
          KHR_materials_pbrSpecularGlossiness: {}
        };
        extensionsUsed['KHR_materials_pbrSpecularGlossiness'] = true;
      } else if (!material.isMeshStandardMaterial) {
        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');
      } // pbrMetallicRoughness.baseColorFactor


      var color = material.color.toArray().concat([material.opacity]);

      if (!equalArray(color, [1, 1, 1, 1])) {
        gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;
      }

      if (material.isMeshStandardMaterial) {
        gltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;
        gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;
      } else if (material.isMeshBasicMaterial) {
        gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;
        gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;
      } else {
        gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;
        gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;
      } // pbrSpecularGlossiness diffuse, specular and glossiness factor


      if (material.isGLTFSpecularGlossinessMaterial) {
        if (gltfMaterial.pbrMetallicRoughness.baseColorFactor) {
          gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;
        }

        var specularFactor = [1, 1, 1];
        material.specular.toArray(specularFactor, 0);
        gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = specularFactor;
        gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = material.glossiness;
      } // pbrMetallicRoughness.metallicRoughnessTexture


      if (material.metalnessMap || material.roughnessMap) {
        if (material.metalnessMap === material.roughnessMap) {
          var metalRoughMapDef = {
            index: processTexture(material.metalnessMap)
          };
          applyTextureTransform(metalRoughMapDef, material.metalnessMap);
          gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
        } else {
          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');
        }
      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture


      if (material.map) {
        var baseColorMapDef = {
          index: processTexture(material.map)
        };
        applyTextureTransform(baseColorMapDef, material.map);

        if (material.isGLTFSpecularGlossinessMaterial) {
          gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = baseColorMapDef;
        }

        gltfMaterial.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
      } // pbrSpecularGlossiness specular map


      if (material.isGLTFSpecularGlossinessMaterial && material.specularMap) {
        var specularMapDef = {
          index: processTexture(material.specularMap)
        };
        applyTextureTransform(specularMapDef, material.specularMap);
        gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = specularMapDef;
      }

      if (material.emissive) {
        // emissiveFactor
        var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();

        if (!equalArray(emissive, [0, 0, 0])) {
          gltfMaterial.emissiveFactor = emissive;
        } // emissiveTexture


        if (material.emissiveMap) {
          var emissiveMapDef = {
            index: processTexture(material.emissiveMap)
          };
          applyTextureTransform(emissiveMapDef, material.emissiveMap);
          gltfMaterial.emissiveTexture = emissiveMapDef;
        }
      } // normalTexture


      if (material.normalMap) {
        var normalMapDef = {
          index: processTexture(material.normalMap)
        };

        if (material.normalScale && material.normalScale.x !== -1) {
          if (material.normalScale.x !== material.normalScale.y) {
            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');
          }

          normalMapDef.scale = material.normalScale.x;
        }

        applyTextureTransform(normalMapDef, material.normalMap);
        gltfMaterial.normalTexture = normalMapDef;
      } // occlusionTexture


      if (material.aoMap) {
        var occlusionMapDef = {
          index: processTexture(material.aoMap),
          texCoord: 1
        };

        if (material.aoMapIntensity !== 1.0) {
          occlusionMapDef.strength = material.aoMapIntensity;
        }

        applyTextureTransform(occlusionMapDef, material.aoMap);
        gltfMaterial.occlusionTexture = occlusionMapDef;
      } // alphaMode


      if (material.transparent) {
        gltfMaterial.alphaMode = 'BLEND';
      } else {
        if (material.alphaTest > 0.0) {
          gltfMaterial.alphaMode = 'MASK';
          gltfMaterial.alphaCutoff = material.alphaTest;
        }
      } // doubleSided


      if (material.side === DoubleSide) {
        gltfMaterial.doubleSided = true;
      }

      if (material.name !== '') {
        gltfMaterial.name = material.name;
      }

      serializeUserData(material, gltfMaterial);
      outputJSON.materials.push(gltfMaterial);
      var index = outputJSON.materials.length - 1;
      cachedData.materials.set(material, index);
      return index;
    }
    /**
     * Process mesh
     * @param  {THREE.Mesh} mesh Mesh to process
     * @return {Integer}      Index of the processed mesh in the "meshes" array
     */


    function processMesh(mesh) {
      var meshCacheKeyParts = [mesh.geometry.uuid];

      if (Array.isArray(mesh.material)) {
        for (var i = 0, l = mesh.material.length; i < l; i++) {
          meshCacheKeyParts.push(mesh.material[i].uuid);
        }
      } else {
        meshCacheKeyParts.push(mesh.material.uuid);
      }

      var meshCacheKey = meshCacheKeyParts.join(':');

      if (cachedData.meshes.has(meshCacheKey)) {
        return cachedData.meshes.get(meshCacheKey);
      }

      var geometry = mesh.geometry;
      var mode; // Use the correct mode

      if (mesh.isLineSegments) {
        mode = 1;
      } else if (mesh.isLineLoop) {
        mode = 2;
      } else if (mesh.isLine) {
        mode = 3;
      } else if (mesh.isPoints) {
        mode = 0;
      } else {
        mode = mesh.material.wireframe ? 1 : 4;
      }

      if (!geometry.isBufferGeometry) {
        console.warn('GLTFExporter: Exporting THREE.Geometry will increase file size. Use BufferGeometry instead.');
        geometry = new BufferGeometry().setFromObject(mesh);
      }

      var gltfMesh = {};
      var attributes = {};
      var primitives = [];
      var targets = []; // Conversion between attributes names in threejs and gltf spec

      var nameConversion = {
        uv: 'TEXCOORD_0',
        uv2: 'TEXCOORD_1',
        color: 'COLOR_0',
        skinWeight: 'WEIGHTS_0',
        skinIndex: 'JOINTS_0'
      };
      var originalNormal = geometry.getAttribute('normal');

      if (originalNormal !== undefined && !isNormalizedNormalAttribute(originalNormal)) {
        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');
        geometry.setAttribute('normal', createNormalizedNormalAttribute(originalNormal));
      } // @QUESTION Detect if .vertexColors = true?
      // For every attribute create an accessor


      var modifiedAttribute = null;

      for (var attributeName in geometry.attributes) {
        // Ignore morph target attributes, which are exported later.
        if (attributeName.substr(0, 5) === 'morph') continue;
        var attribute = geometry.attributes[attributeName];
        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically
        // listed in the spec; non-spec attributes are considered custom.

        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;

        if (!validVertexAttributes.test(attributeName)) {
          attributeName = '_' + attributeName;
        }

        if (cachedData.attributes.has(getUID(attribute))) {
          attributes[attributeName] = cachedData.attributes.get(getUID(attribute));
          continue;
        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.


        modifiedAttribute = null;
        var array = attribute.array;

        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
          console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);
        }

        var accessor = processAccessor(modifiedAttribute || attribute, geometry);

        if (accessor !== null) {
          attributes[attributeName] = accessor;
          cachedData.attributes.set(getUID(attribute), accessor);
        }
      }

      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found

      if (Object.keys(attributes).length === 0) {
        return null;
      } // Morph targets


      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {
        var weights = [];
        var targetNames = [];
        var reverseDictionary = {};

        if (mesh.morphTargetDictionary !== undefined) {
          for (var key in mesh.morphTargetDictionary) {
            reverseDictionary[mesh.morphTargetDictionary[key]] = key;
          }
        }

        for (var i = 0; i < mesh.morphTargetInfluences.length; ++i) {
          var target = {};
          var warned = false;

          for (var attributeName in geometry.morphAttributes) {
            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
            // Three.js doesn't support TANGENT yet.
            if (attributeName !== 'position' && attributeName !== 'normal') {
              if (!warned) {
                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');
                warned = true;
              }

              continue;
            }

            var attribute = geometry.morphAttributes[attributeName][i];
            var gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.
            //
            // glTF 2.0 Specification:
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

            var baseAttribute = geometry.attributes[attributeName];

            if (cachedData.attributes.has(getUID(attribute))) {
              target[gltfAttributeName] = cachedData.attributes.get(getUID(attribute));
              continue;
            } // Clones attribute not to override


            var relativeAttribute = attribute.clone();

            if (!geometry.morphTargetsRelative) {
              for (var j = 0, jl = attribute.count; j < jl; j++) {
                relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));
              }
            }

            target[gltfAttributeName] = processAccessor(relativeAttribute, geometry);
            cachedData.attributes.set(getUID(baseAttribute), target[gltfAttributeName]);
          }

          targets.push(target);
          weights.push(mesh.morphTargetInfluences[i]);
          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);
        }

        gltfMesh.weights = weights;

        if (targetNames.length > 0) {
          gltfMesh.extras = {};
          gltfMesh.extras.targetNames = targetNames;
        }
      }

      var forceIndices = options.forceIndices;
      var isMultiMaterial = Array.isArray(mesh.material);
      if (isMultiMaterial && geometry.groups.length === 0) return null;

      if (!forceIndices && geometry.index === null && isMultiMaterial) {
        // temporal workaround.
        console.warn('THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.');
        forceIndices = true;
      }

      var didForceIndices = false;

      if (geometry.index === null && forceIndices) {
        var indices = [];

        for (var i = 0, il = geometry.attributes.position.count; i < il; i++) {
          indices[i] = i;
        }

        geometry.setIndex(indices);
        didForceIndices = true;
      }

      var materials = isMultiMaterial ? mesh.material : [mesh.material];
      var groups = isMultiMaterial ? geometry.groups : [{
        materialIndex: 0,
        start: undefined,
        count: undefined
      }];

      for (var i = 0, il = groups.length; i < il; i++) {
        var primitive = {
          mode: mode,
          attributes: attributes
        };
        serializeUserData(geometry, primitive);
        if (targets.length > 0) primitive.targets = targets;

        if (geometry.index !== null) {
          var cacheKey = getUID(geometry.index);

          if (groups[i].start !== undefined || groups[i].count !== undefined) {
            cacheKey += ':' + groups[i].start + ':' + groups[i].count;
          }

          if (cachedData.attributes.has(cacheKey)) {
            primitive.indices = cachedData.attributes.get(cacheKey);
          } else {
            primitive.indices = processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);
            cachedData.attributes.set(cacheKey, primitive.indices);
          }

          if (primitive.indices === null) delete primitive.indices;
        }

        var material = processMaterial(materials[groups[i].materialIndex]);

        if (material !== null) {
          primitive.material = material;
        }

        primitives.push(primitive);
      }

      if (didForceIndices) {
        geometry.setIndex(null);
      }

      gltfMesh.primitives = primitives;

      if (!outputJSON.meshes) {
        outputJSON.meshes = [];
      }

      outputJSON.meshes.push(gltfMesh);
      var index = outputJSON.meshes.length - 1;
      cachedData.meshes.set(meshCacheKey, index);
      return index;
    }
    /**
     * Process camera
     * @param  {THREE.Camera} camera Camera to process
     * @return {Integer}      Index of the processed mesh in the "camera" array
     */


    function processCamera(camera) {
      if (!outputJSON.cameras) {
        outputJSON.cameras = [];
      }

      var isOrtho = camera.isOrthographicCamera;
      var gltfCamera = {
        type: isOrtho ? 'orthographic' : 'perspective'
      };

      if (isOrtho) {
        gltfCamera.orthographic = {
          xmag: camera.right * 2,
          ymag: camera.top * 2,
          zfar: camera.far <= 0 ? 0.001 : camera.far,
          znear: camera.near < 0 ? 0 : camera.near
        };
      } else {
        gltfCamera.perspective = {
          aspectRatio: camera.aspect,
          yfov: MathUtils.degToRad(camera.fov),
          zfar: camera.far <= 0 ? 0.001 : camera.far,
          znear: camera.near < 0 ? 0 : camera.near
        };
      }

      if (camera.name !== '') {
        gltfCamera.name = camera.type;
      }

      outputJSON.cameras.push(gltfCamera);
      return outputJSON.cameras.length - 1;
    }
    /**
     * Creates glTF animation entry from AnimationClip object.
     *
     * Status:
     * - Only properties listed in PATH_PROPERTIES may be animated.
     *
     * @param {THREE.AnimationClip} clip
     * @param {THREE.Object3D} root
     * @return {number}
     */


    function processAnimation(clip, root) {
      if (!outputJSON.animations) {
        outputJSON.animations = [];
      }

      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
      var tracks = clip.tracks;
      var channels = [];
      var samplers = [];

      for (var i = 0; i < tracks.length; ++i) {
        var track = tracks[i];
        var trackBinding = PropertyBinding.parseTrackName(track.name);
        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);
        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];

        if (trackBinding.objectName === 'bones') {
          if (trackNode.isSkinnedMesh === true) {
            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
          } else {
            trackNode = undefined;
          }
        }

        if (!trackNode || !trackProperty) {
          console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
          return null;
        }

        var inputItemSize = 1;
        var outputItemSize = track.values.length / track.times.length;

        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {
          outputItemSize /= trackNode.morphTargetInfluences.length;
        }

        var interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE
        // Detecting glTF cubic spline interpolant by checking factory method's special property
        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
        // valid value from .getInterpolation().

        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {
          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9
          // (VEC3 * 3: inTangent, splineVertex, and outTangent)
          // but needs to be stored as VEC3 so dividing by 3 here.

          outputItemSize /= 3;
        } else if (track.getInterpolation() === InterpolateDiscrete) {
          interpolation = 'STEP';
        } else {
          interpolation = 'LINEAR';
        }

        samplers.push({
          input: processAccessor(new BufferAttribute(track.times, inputItemSize)),
          output: processAccessor(new BufferAttribute(track.values, outputItemSize)),
          interpolation: interpolation
        });
        channels.push({
          sampler: samplers.length - 1,
          target: {
            node: nodeMap.get(trackNode),
            path: trackProperty
          }
        });
      }

      outputJSON.animations.push({
        name: clip.name || 'clip_' + outputJSON.animations.length,
        samplers: samplers,
        channels: channels
      });
      return outputJSON.animations.length - 1;
    }

    function processSkin(object) {
      var node = outputJSON.nodes[nodeMap.get(object)];
      var skeleton = object.skeleton;
      if (skeleton === undefined) return null;
      var rootJoint = object.skeleton.bones[0];
      if (rootJoint === undefined) return null;
      var joints = [];
      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);

      for (var i = 0; i < skeleton.bones.length; ++i) {
        joints.push(nodeMap.get(skeleton.bones[i]));
        skeleton.boneInverses[i].toArray(inverseBindMatrices, i * 16);
      }

      if (outputJSON.skins === undefined) {
        outputJSON.skins = [];
      }

      outputJSON.skins.push({
        inverseBindMatrices: processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
        joints: joints,
        skeleton: nodeMap.get(rootJoint)
      });
      var skinIndex = node.skin = outputJSON.skins.length - 1;
      return skinIndex;
    }

    function processLight(light) {
      var lightDef = {};
      if (light.name) lightDef.name = light.name;
      lightDef.color = light.color.toArray();
      lightDef.intensity = light.intensity;

      if (light.isDirectionalLight) {
        lightDef.type = 'directional';
      } else if (light.isPointLight) {
        lightDef.type = 'point';
        if (light.distance > 0) lightDef.range = light.distance;
      } else if (light.isSpotLight) {
        lightDef.type = 'spot';
        if (light.distance > 0) lightDef.range = light.distance;
        lightDef.spot = {};
        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;
        lightDef.spot.outerConeAngle = light.angle;
      }

      if (light.decay !== undefined && light.decay !== 2) {
        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');
      }

      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');
      }

      var lights = outputJSON.extensions['KHR_lights_punctual'].lights;
      lights.push(lightDef);
      return lights.length - 1;
    }
    /**
     * Process Object3D node
     * @param  {THREE.Object3D} node Object3D to processNode
     * @return {Integer}      Index of the node in the nodes list
     */


    function processNode(object) {
      if (!outputJSON.nodes) {
        outputJSON.nodes = [];
      }

      var gltfNode = {};

      if (options.trs) {
        var rotation = object.quaternion.toArray();
        var position = object.position.toArray();
        var scale = object.scale.toArray();

        if (!equalArray(rotation, [0, 0, 0, 1])) {
          gltfNode.rotation = rotation;
        }

        if (!equalArray(position, [0, 0, 0])) {
          gltfNode.translation = position;
        }

        if (!equalArray(scale, [1, 1, 1])) {
          gltfNode.scale = scale;
        }
      } else {
        if (object.matrixAutoUpdate) {
          object.updateMatrix();
        }

        if (!equalArray(object.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])) {
          gltfNode.matrix = object.matrix.elements;
        }
      } // We don't export empty strings name because it represents no-name in Three.js.


      if (object.name !== '') {
        gltfNode.name = String(object.name);
      }

      serializeUserData(object, gltfNode);

      if (object.isMesh || object.isLine || object.isPoints) {
        var mesh = processMesh(object);

        if (mesh !== null) {
          gltfNode.mesh = mesh;
        }
      } else if (object.isCamera) {
        gltfNode.camera = processCamera(object);
      } else if (object.isDirectionalLight || object.isPointLight || object.isSpotLight) {
        if (!extensionsUsed['KHR_lights_punctual']) {
          outputJSON.extensions = outputJSON.extensions || {};
          outputJSON.extensions['KHR_lights_punctual'] = {
            lights: []
          };
          extensionsUsed['KHR_lights_punctual'] = true;
        }

        gltfNode.extensions = gltfNode.extensions || {};
        gltfNode.extensions['KHR_lights_punctual'] = {
          light: processLight(object)
        };
      } else if (object.isLight) {
        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', object);
        return null;
      }

      if (object.isSkinnedMesh) {
        skins.push(object);
      }

      if (object.children.length > 0) {
        var children = [];

        for (var i = 0, l = object.children.length; i < l; i++) {
          var child = object.children[i];

          if (child.visible || options.onlyVisible === false) {
            var node = processNode(child);

            if (node !== null) {
              children.push(node);
            }
          }
        }

        if (children.length > 0) {
          gltfNode.children = children;
        }
      }

      outputJSON.nodes.push(gltfNode);
      var nodeIndex = outputJSON.nodes.length - 1;
      nodeMap.set(object, nodeIndex);
      return nodeIndex;
    }
    /**
     * Process Scene
     * @param  {Scene} node Scene to process
     */


    function processScene(scene) {
      if (!outputJSON.scenes) {
        outputJSON.scenes = [];
        outputJSON.scene = 0;
      }

      var gltfScene = {};

      if (scene.name !== '') {
        gltfScene.name = scene.name;
      }

      outputJSON.scenes.push(gltfScene);
      var nodes = [];

      for (var i = 0, l = scene.children.length; i < l; i++) {
        var child = scene.children[i];

        if (child.visible || options.onlyVisible === false) {
          var node = processNode(child);

          if (node !== null) {
            nodes.push(node);
          }
        }
      }

      if (nodes.length > 0) {
        gltfScene.nodes = nodes;
      }

      serializeUserData(scene, gltfScene);
    }
    /**
     * Creates a Scene to hold a list of objects and parse it
     * @param  {Array} objects List of objects to process
     */


    function processObjects(objects) {
      var scene = new Scene();
      scene.name = 'AuxScene';

      for (var i = 0; i < objects.length; i++) {
        // We push directly to children instead of calling `add` to prevent
        // modify the .parent and break its original scene and hierarchy
        scene.children.push(objects[i]);
      }

      processScene(scene);
    }

    function processInput(input) {
      input = input instanceof Array ? input : [input];
      var objectsWithoutScene = [];

      for (var i = 0; i < input.length; i++) {
        if (input[i] instanceof Scene) {
          processScene(input[i]);
        } else {
          objectsWithoutScene.push(input[i]);
        }
      }

      if (objectsWithoutScene.length > 0) {
        processObjects(objectsWithoutScene);
      }

      for (var i = 0; i < skins.length; ++i) {
        processSkin(skins[i]);
      }

      for (var i = 0; i < options.animations.length; ++i) {
        processAnimation(options.animations[i], input[0]);
      }
    }

    try {
      processInput(input);
    } catch (error) {
      console.error(error);
      throw error;
    }

    function mergeBuffers(buffers) {
      buffers = buffers.map(function (buffer) {
        if (buffer instanceof DataView || buffer instanceof Uint8Array) {
          return buffer.buffer;
        }

        return buffer;
      });
      var totalByteLength = 0;
      buffers.forEach(function (buffer) {
        return totalByteLength += buffer.byteLength;
      });
      var mergedBuffer = new Uint8Array(totalByteLength);
      var byteOffset = 0;
      buffers.forEach(function (buffer) {
        mergedBuffer.set(new Uint8Array(buffer), byteOffset);
        byteOffset += buffer.byteLength;
      });
      return mergedBuffer.buffer;
    }

    Promise.all(pending).then(function () {
      if (isNodeEnv) {
        // Merge buffers.
        var mergedBuffer = mergeBuffers(buffers); // var blob = new Blob(buffers, { type: 'application/octet-stream' });
        // Declare extensions.

        var extensionsUsedList = Object.keys(extensionsUsed);
        if (extensionsUsedList.length > 0) outputJSON.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.

        if (outputJSON.buffers && outputJSON.buffers.length > 0) outputJSON.buffers[0].byteLength = mergedBuffer.byteLength; //blob.size;

        if (options.binary === true) {
          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification
          var GLB_HEADER_BYTES = 12;
          var GLB_HEADER_MAGIC = 0x46546C67;
          var GLB_VERSION = 2;
          var GLB_CHUNK_PREFIX_BYTES = 8;
          var GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
          var GLB_CHUNK_TYPE_BIN = 0x004E4942; // var reader = new window.FileReader();
          // reader.readAsArrayBuffer(blob);
          // reader.onloadend = function () {
          // Binary chunk.

          var binaryChunk = getPaddedArrayBuffer(mergedBuffer); //reader.result);

          var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
          binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
          binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.

          var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(outputJSON)), 0x20);
          var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
          jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
          jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.

          var header = new ArrayBuffer(GLB_HEADER_BYTES);
          var headerView = new DataView(header);
          headerView.setUint32(0, GLB_HEADER_MAGIC, true);
          headerView.setUint32(4, GLB_VERSION, true);
          var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
          headerView.setUint32(8, totalByteLength, true); // var glbBlob 

          var glbBuffer = mergeBuffers( //new Blob(
          [header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk]); //, { type: 'application/octet-stream' });
          // var glbReader = new window.FileReader();
          // glbReader.readAsArrayBuffer(glbBlob);
          // glbReader.onloadend = function () {

          onDone(glbBuffer); //glbReader.result);
          // };
          // };
        } else {
          if (outputJSON.buffers && outputJSON.buffers.length > 0) {
            // var reader = new window.FileReader();
            // reader.readAsDataURL(blob);
            // reader.onloadend = function () {
            var base64data = 'data:application/octet-stream;base64,' + (0, _index.fromByteArray)(new Uint8Array(mergedBuffer)); //reader.result;

            outputJSON.buffers[0].uri = base64data;
            onDone(outputJSON); // };
          } else {
            onDone(outputJSON);
          }
        }
      } else {
        // Merge buffers.
        var blob = new Blob(buffers, {
          type: 'application/octet-stream'
        }); // Declare extensions.

        var extensionsUsedList = Object.keys(extensionsUsed);
        if (extensionsUsedList.length > 0) outputJSON.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.

        if (outputJSON.buffers && outputJSON.buffers.length > 0) outputJSON.buffers[0].byteLength = blob.size;

        if (options.binary === true) {
          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification
          var GLB_HEADER_BYTES = 12;
          var GLB_HEADER_MAGIC = 0x46546C67;
          var GLB_VERSION = 2;
          var GLB_CHUNK_PREFIX_BYTES = 8;
          var GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
          var GLB_CHUNK_TYPE_BIN = 0x004E4942;
          var reader = new window.FileReader();
          reader.readAsArrayBuffer(blob);

          reader.onloadend = function () {
            // Binary chunk.
            var binaryChunk = getPaddedArrayBuffer(reader.result);
            var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.

            var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(outputJSON)), 0x20);
            var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.

            var header = new ArrayBuffer(GLB_HEADER_BYTES);
            var headerView = new DataView(header);
            headerView.setUint32(0, GLB_HEADER_MAGIC, true);
            headerView.setUint32(4, GLB_VERSION, true);
            var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
            headerView.setUint32(8, totalByteLength, true);
            var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {
              type: 'application/octet-stream'
            });
            var glbReader = new window.FileReader();
            glbReader.readAsArrayBuffer(glbBlob);

            glbReader.onloadend = function () {
              onDone(glbReader.result);
            };
          };
        } else {
          if (outputJSON.buffers && outputJSON.buffers.length > 0) {
            var reader = new window.FileReader();
            reader.readAsDataURL(blob);

            reader.onloadend = function () {
              var base64data = reader.result;
              outputJSON.buffers[0].uri = base64data;
              onDone(outputJSON);
            };
          } else {
            onDone(outputJSON);
          }
        }
      }
    });
  }
};
GLTFExporter.Utils = {
  insertKeyframe: function insertKeyframe(track, time) {
    var tolerance = 0.001; // 1ms

    var valueSize = track.getValueSize();
    var times = new track.TimeBufferType(track.times.length + 1);
    var values = new track.ValueBufferType(track.values.length + valueSize);
    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    var index;

    if (track.times.length === 0) {
      times[0] = time;

      for (var i = 0; i < valueSize; i++) {
        values[i] = 0;
      }

      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance) return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }

      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (var i = 0; i < track.times.length; i++) {
        if (Math.abs(track.times[i] - time) < tolerance) return i;

        if (track.times[i] < time && track.times[i + 1] > time) {
          times.set(track.times.slice(0, i + 1), 0);
          times[i + 1] = time;
          times.set(track.times.slice(i + 1), i + 2);
          values.set(track.values.slice(0, (i + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i + 1) * valueSize);
          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);
          index = i + 1;
          break;
        }
      }
    }

    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {
    var tracks = [];
    var mergedTracks = {};
    var sourceTracks = clip.tracks;

    for (var i = 0; i < sourceTracks.length; ++i) {
      var sourceTrack = sourceTracks[i];
      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);

      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {
        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
        tracks.push(sourceTrack);
        continue;
      }

      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          // This should never happen, because glTF morph target animations
          // affect all targets already.
          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');
        }

        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }

      var targetCount = sourceTrackNode.morphTargetInfluences.length;
      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];

      if (targetIndex === undefined) {
        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);
      }

      var mergedTrack; // If this is the first time we've seen this object, create a new
      // track to store merged keyframe data for each morph target.

      if (mergedTracks[sourceTrackNode.uuid] === undefined) {
        mergedTrack = sourceTrack.clone();
        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);

        for (var j = 0; j < mergedTrack.times.length; j++) {
          values[j * targetCount + targetIndex] = mergedTrack.values[j];
        }

        mergedTrack.name = '.morphTargetInfluences';
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }

      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly
      // interpolated) value from the source track.

      for (var j = 0; j < mergedTrack.times.length; j++) {
        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);
      } // For every existing keyframe of the source track, write a (possibly
      // new) keyframe to the merged track. Values from the previous loop may
      // be written again, but keyframes are de-duplicated.


      for (var j = 0; j < sourceTrack.times.length; j++) {
        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];
      }
    }

    clip.tracks = tracks;
    return clip;
  }
};

},{"h_399":218}],91:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BMPLoader = BMPLoader;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _decoder = require("m_406");

var _esExtends = _interopRequireDefault(require("M_407"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _BMPLoader;

function BMPLoader(manager) {
  if (!_BMPLoader) {
    var _THREE = THREE,
        FileLoader = _THREE.FileLoader,
        Loader = _THREE.Loader,
        Texture = _THREE.Texture;
    var _BMPLoaderPrototype = {
      // constructor: BMPLoader,
      load: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new Texture();

        if (typeof url == 'string') {
          var loader = new THREE.FileLoader(this.manager);
          loader.setResponseType('arraybuffer');
          loader.setPath(this.path);
          loader.load(url, function (buffer) {
            texture.image = scope.parse(buffer);
            texture.needsUpdate = true;

            if (onLoad !== undefined) {
              onLoad(texture);
            }
          }, onProgress, onError);
        } else {
          texture.image = scope.parse(url);
          texture.needsUpdate = true;

          if (onLoad !== undefined) {
            onLoad(texture);
          }
        }

        return texture;
      },
      parse: function parse(buffer) {
        var decoder = new _decoder.BmpDecoder(buffer);
        var cv = document.createElement('canvas');
        cv.width = decoder.width;
        cv.height = decoder.height;
        var ctx = cv.getContext('2d');
        var imgData = ctx.getImageData(0, 0, cv.width, cv.height);
        imgData.data.set(decoder.data);
        return cv;
      }
    };
    _BMPLoader = (0, _esExtends["default"])(Loader, {
      prototype: _BMPLoaderPrototype,
      esConstructor: function esConstructor() {
        var _esCtor = /*#__PURE__*/function (_Loader) {
          (0, _inherits2["default"])(_esCtor, _Loader);

          var _super = _createSuper(_esCtor);

          function _esCtor(manager) {
            var _this;

            (0, _classCallCheck2["default"])(this, _esCtor);
            _this = _super.call(this, manager);
            constructor.call((0, _assertThisInitialized2["default"])(_this), manager);
            return _this;
          }

          return _esCtor;
        }(Loader);

        return _esCtor;
      },
      constructor: function constructor(manager) {}
    });
    _BMPLoader.prototype.constructor.name = 'BMPLoader';
  }

  return new _BMPLoader(manager);
}

},{"M_407":198,"m_406":88,"s_332":233,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],92:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DDSLoader = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _esExtends = _interopRequireDefault(require("M_407"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var CompressedTextureLoader, RGBAFormat, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_S3TC_DXT1_Format;
var initDeps$DDSLoaderDone = false;

function initDeps$DDSLoader() {
  if (initDeps$DDSLoaderDone) return;
  initDeps$DDSLoaderDone = true;
  var _THREE = THREE;
  CompressedTextureLoader = _THREE.CompressedTextureLoader, RGBAFormat = 1023, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_ETC1_Format = 36196, RGB_S3TC_DXT1_Format = 33776;
}

var _DDSLoader;

var DDSLoader = function DDSLoader(manager) {
  initDeps$DDSLoader();

  if (!_DDSLoader) {
    var _prototype_ = {
      parse: function parse(buffer, loadMipmaps) {
        var dds = {
          mipmaps: [],
          width: 0,
          height: 0,
          format: null,
          mipmapCount: 1
        }; // Adapted from @toji's DDS utils
        // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js
        // All values and structures referenced from:
        // http://msdn.microsoft.com/en-us/library/bb943991.aspx/

        var DDS_MAGIC = 0x20534444;
        var DDSD_CAPS = 0x1,
            DDSD_HEIGHT = 0x2,
            DDSD_WIDTH = 0x4,
            DDSD_PITCH = 0x8,
            DDSD_PIXELFORMAT = 0x1000,
            DDSD_MIPMAPCOUNT = 0x20000,
            DDSD_LINEARSIZE = 0x80000,
            DDSD_DEPTH = 0x800000;
        var DDSCAPS_COMPLEX = 0x8,
            DDSCAPS_MIPMAP = 0x400000,
            DDSCAPS_TEXTURE = 0x1000;
        var DDSCAPS2_CUBEMAP = 0x200,
            DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
            DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
            DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
            DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
            DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
            DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
            DDSCAPS2_VOLUME = 0x200000;
        var DDPF_ALPHAPIXELS = 0x1,
            DDPF_ALPHA = 0x2,
            DDPF_FOURCC = 0x4,
            DDPF_RGB = 0x40,
            DDPF_YUV = 0x200,
            DDPF_LUMINANCE = 0x20000;

        function fourCCToInt32(value) {
          return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
        }

        function int32ToFourCC(value) {
          return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);
        }

        function loadARGBMip(buffer, dataOffset, width, height) {
          var dataLength = width * height * 4;
          var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
          var byteArray = new Uint8Array(dataLength);
          var dst = 0;
          var src = 0;

          for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
              var b = srcBuffer[src];
              src++;
              var g = srcBuffer[src];
              src++;
              var r = srcBuffer[src];
              src++;
              var a = srcBuffer[src];
              src++;
              byteArray[dst] = r;
              dst++; //r

              byteArray[dst] = g;
              dst++; //g

              byteArray[dst] = b;
              dst++; //b

              byteArray[dst] = a;
              dst++; //a
            }
          }

          return byteArray;
        }

        var FOURCC_DXT1 = fourCCToInt32("DXT1");
        var FOURCC_DXT3 = fourCCToInt32("DXT3");
        var FOURCC_DXT5 = fourCCToInt32("DXT5");
        var FOURCC_ETC1 = fourCCToInt32("ETC1");
        var headerLengthInt = 31; // The header length in 32 bit ints
        // Offsets into the header array

        var off_magic = 0;
        var off_size = 1;
        var off_flags = 2;
        var off_height = 3;
        var off_width = 4;
        var off_mipmapCount = 7;
        var off_pfFlags = 20;
        var off_pfFourCC = 21;
        var off_RGBBitCount = 22;
        var off_RBitMask = 23;
        var off_GBitMask = 24;
        var off_BBitMask = 25;
        var off_ABitMask = 26;
        var off_caps = 27;
        var off_caps2 = 28;
        var off_caps3 = 29;
        var off_caps4 = 30; // Parse header

        var header = new Int32Array(buffer, 0, headerLengthInt);

        if (header[off_magic] !== DDS_MAGIC) {
          console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');
          return dds;
        }

        if (!header[off_pfFlags] & DDPF_FOURCC) {
          console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');
          return dds;
        }

        var blockBytes;
        var fourCC = header[off_pfFourCC];
        var isRGBAUncompressed = false;

        switch (fourCC) {
          case FOURCC_DXT1:
            blockBytes = 8;
            dds.format = RGB_S3TC_DXT1_Format;
            break;

          case FOURCC_DXT3:
            blockBytes = 16;
            dds.format = RGBA_S3TC_DXT3_Format;
            break;

          case FOURCC_DXT5:
            blockBytes = 16;
            dds.format = RGBA_S3TC_DXT5_Format;
            break;

          case FOURCC_ETC1:
            blockBytes = 8;
            dds.format = RGB_ETC1_Format;
            break;

          default:
            if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {
              isRGBAUncompressed = true;
              blockBytes = 64;
              dds.format = RGBAFormat;
            } else {
              console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));
              return dds;
            }

        }

        dds.mipmapCount = 1;

        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
          dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
        }

        var caps2 = header[off_caps2];
        dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;

        if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {
          console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');
          return dds;
        }

        dds.width = header[off_width];
        dds.height = header[off_height];
        var dataOffset = header[off_size] + 4; // Extract mipmaps buffers

        var faces = dds.isCubemap ? 6 : 1;

        for (var face = 0; face < faces; face++) {
          var width = dds.width;
          var height = dds.height;

          for (var i = 0; i < dds.mipmapCount; i++) {
            if (isRGBAUncompressed) {
              var byteArray = loadARGBMip(buffer, dataOffset, width, height);
              var dataLength = byteArray.length;
            } else {
              var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
              var byteArray = new Uint8Array(buffer, dataOffset, dataLength);
            }

            var mipmap = {
              "data": byteArray,
              "width": width,
              "height": height
            };
            dds.mipmaps.push(mipmap);
            dataOffset += dataLength;
            width = Math.max(width >> 1, 1);
            height = Math.max(height >> 1, 1);
          }
        }

        return dds;
      }
    };
    _DDSLoader = (0, _esExtends["default"])(CompressedTextureLoader, {
      esConstructor: function esConstructor(constructor) {
        var _esCtor = /*#__PURE__*/function (_CompressedTextureLoa) {
          (0, _inherits2["default"])(_esCtor, _CompressedTextureLoa);

          var _super = _createSuper(_esCtor);

          function _esCtor(manager) {
            var _this;

            (0, _classCallCheck2["default"])(this, _esCtor);
            _this = _super.call(this, manager);
            constructor.call((0, _assertThisInitialized2["default"])(_this), manager);
            return _this;
          }

          return _esCtor;
        }(CompressedTextureLoader);

        return _esCtor;
      },
      constructor: function constructor(manager) {},
      prototype: _prototype_
    });
  }

  return new _DDSLoader(manager);
};

exports.DDSLoader = DDSLoader;

},{"M_407":198,"s_332":233,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],93:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DRACOLoader = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _typeof2 = _interopRequireDefault(require("M_110"));

var _esExtends = _interopRequireDefault(require("M_407"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BufferAttribute, BufferGeometry, FileLoader, Loader;
var initDeps$DRACOLoaderDone = false;

function initDeps$DRACOLoader() {
  if (initDeps$DRACOLoaderDone) return;
  initDeps$DRACOLoaderDone = true;
  var _THREE = THREE;
  BufferAttribute = _THREE.BufferAttribute, BufferGeometry = _THREE.BufferGeometry, FileLoader = _THREE.FileLoader, Loader = _THREE.Loader;
}

var _DRACOLoader;

var DRACOLoader = function DRACOLoader(manager) {
  initDeps$DRACOLoader();

  if (!_DRACOLoader) {
    var _prototype_ = {
      setDecoderPath: function setDecoderPath(path) {
        this.decoderPath = path;
        return this;
      },
      setDecoderConfig: function setDecoderConfig(config) {
        this.decoderConfig = config;
        return this;
      },
      setWorkerLimit: function setWorkerLimit(workerLimit) {
        this.workerLimit = workerLimit;
        return this;
      },

      /** @deprecated */
      setVerbosity: function setVerbosity() {
        console.warn('THREE.DRACOLoader: The .setVerbosity() method has been removed.');
      },

      /** @deprecated */
      setDrawMode: function setDrawMode() {
        console.warn('THREE.DRACOLoader: The .setDrawMode() method has been removed.');
      },

      /** @deprecated */
      setSkipDequantization: function setSkipDequantization() {
        console.warn('THREE.DRACOLoader: The .setSkipDequantization() method has been removed.');
      },
      load: function load(url, onLoad, onProgress, onError) {
        var _this = this;

        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');

        if (this.crossOrigin === 'use-credentials') {
          loader.setWithCredentials(true);
        }

        loader.load(url, function (buffer) {
          var taskConfig = {
            attributeIDs: _this.defaultAttributeIDs,
            attributeTypes: _this.defaultAttributeTypes,
            useUniqueIDs: false
          };

          _this.decodeGeometry(buffer, taskConfig).then(onLoad)["catch"](onError);
        }, onProgress, onError);
      },

      /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
      decodeDracoFile: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
        var taskConfig = {
          attributeIDs: attributeIDs || this.defaultAttributeIDs,
          attributeTypes: attributeTypes || this.defaultAttributeTypes,
          useUniqueIDs: !!attributeIDs
        };
        this.decodeGeometry(buffer, taskConfig).then(callback);
      },
      decodeGeometry: function decodeGeometry(buffer, taskConfig) {
        var _this2 = this;

        // TODO: For backward-compatibility, support 'attributeTypes' objects containing
        // references (rather than names) to typed array constructors. These must be
        // serialized before sending them to the worker.
        for (var attribute in taskConfig.attributeTypes) {
          var type = taskConfig.attributeTypes[attribute];

          if (type.BYTES_PER_ELEMENT !== undefined) {
            taskConfig.attributeTypes[attribute] = type.name;
          }
        } //


        var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred
        // again from this thread.

        if (_DRACOLoader.taskCache.has(buffer)) {
          var cachedTask = _DRACOLoader.taskCache.get(buffer);

          if (cachedTask.key === taskKey) {
            return cachedTask.promise;
          } else if (buffer.byteLength === 0) {
            // Technically, it would be possible to wait for the previous task to complete,
            // transfer the buffer back, and decode again with the second configuration. That
            // is complex, and I don't know of any reason to decode a Draco buffer twice in
            // different ways, so this is left unimplemented.
            throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');
          }
        } //


        var worker;
        var taskID = this.workerNextTaskID++;
        var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance
        // when the task completes.

        var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {
          worker = _worker;
          return new Promise(function (resolve, reject) {
            worker._callbacks[taskID] = {
              resolve: resolve,
              reject: reject
            };
            worker.postMessage({
              type: 'decode',
              id: taskID,
              taskConfig: taskConfig,
              buffer: buffer
            }, [buffer]); // this.debug();
          });
        }).then(function (message) {
          return _this2._createGeometry(message.geometry);
        }); // Remove task from the task list.


        geometryPending["finally"](function () {
          if (worker && taskID) {
            _this2._releaseTask(worker, taskID); // this.debug();

          }
        }); // Cache the task result.

        _DRACOLoader.taskCache.set(buffer, {
          key: taskKey,
          promise: geometryPending
        });

        return geometryPending;
      },
      _createGeometry: function _createGeometry(geometryData) {
        var geometry = new BufferGeometry();

        if (geometryData.index) {
          geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
        }

        for (var i = 0; i < geometryData.attributes.length; i++) {
          var attribute = geometryData.attributes[i];
          var name = attribute.name;
          var array = attribute.array;
          var itemSize = attribute.itemSize;
          geometry.setAttribute(name, new BufferAttribute(array, itemSize));
        }

        return geometry;
      },
      _loadLibrary: function _loadLibrary(url, responseType) {
        var loader = new FileLoader(this.manager);
        loader.setPath(this.decoderPath);
        loader.setResponseType(responseType);
        return new Promise(function (resolve, reject) {
          loader.load(url, resolve, undefined, reject);
        });
      },
      preload: function preload() {
        this._initDecoder();

        return this;
      },
      _initDecoder: function _initDecoder() {
        var _this3 = this;

        if (this.decoderPending) return this.decoderPending;
        var useJS = (typeof WebAssembly === "undefined" ? "undefined" : (0, _typeof2["default"])(WebAssembly)) !== 'object' || this.decoderConfig.type === 'js';
        var librariesPending = [];

        if (useJS) {
          librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));
        } else {
          librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));
          librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));
        }

        this.decoderPending = Promise.all(librariesPending).then(function (libraries) {
          var jsContent = libraries[0];

          if (!useJS) {
            _this3.decoderConfig.wasmBinary = libraries[1];
          }

          var fn = _DRACOLoader.DRACOWorker.toString();

          var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\n');
          _this3.workerSourceURL = URL.createObjectURL(new Blob([body]));
        });
        return this.decoderPending;
      },
      _getWorker: function _getWorker(taskID, taskCost) {
        var _this4 = this;

        return this._initDecoder().then(function () {
          if (_this4.workerPool.length < _this4.workerLimit) {
            var worker = new Worker(_this4.workerSourceURL);
            worker._callbacks = {};
            worker._taskCosts = {};
            worker._taskLoad = 0;
            worker.postMessage({
              type: 'init',
              decoderConfig: _this4.decoderConfig
            });

            worker.onmessage = function (e) {
              var message = e.data;

              switch (message.type) {
                case 'decode':
                  worker._callbacks[message.id].resolve(message);

                  break;

                case 'error':
                  worker._callbacks[message.id].reject(message);

                  break;

                default:
                  console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
              }
            };

            _this4.workerPool.push(worker);
          } else {
            _this4.workerPool.sort(function (a, b) {
              return a._taskLoad > b._taskLoad ? -1 : 1;
            });
          }

          var worker = _this4.workerPool[_this4.workerPool.length - 1];
          worker._taskCosts[taskID] = taskCost;
          worker._taskLoad += taskCost;
          return worker;
        });
      },
      _releaseTask: function _releaseTask(worker, taskID) {
        worker._taskLoad -= worker._taskCosts[taskID];
        delete worker._callbacks[taskID];
        delete worker._taskCosts[taskID];
      },
      debug: function debug() {
        console.log('Task load: ', this.workerPool.map(function (worker) {
          return worker._taskLoad;
        }));
      },
      dispose: function dispose() {
        for (var i = 0; i < this.workerPool.length; ++i) {
          this.workerPool[i].terminate();
        }

        this.workerPool.length = 0;
        return this;
      }
    };
    _DRACOLoader = (0, _esExtends["default"])(Loader, {
      esConstructor: function esConstructor(constructor) {
        var _esCtor = /*#__PURE__*/function (_Loader) {
          (0, _inherits2["default"])(_esCtor, _Loader);

          var _super = _createSuper(_esCtor);

          function _esCtor(manager) {
            var _this5;

            (0, _classCallCheck2["default"])(this, _esCtor);
            _this5 = _super.call(this, manager);
            constructor.call((0, _assertThisInitialized2["default"])(_this5), manager);
            return _this5;
          }

          return _esCtor;
        }(Loader);

        return _esCtor;
      },
      constructor: function constructor() {
        this.decoderPath = '';
        this.decoderConfig = {};
        this.decoderBinary = null;
        this.decoderPending = null;
        this.workerLimit = 4;

        if (navigator && navigator.hardwareConcurrency) {
          var hardwareConcurrency = navigator.hardwareConcurrency / 2;
          this.workerLimit = Math.max(4, hardwareConcurrency);
          this.workerLimit = Math.min(hardwareConcurrency, 8);
        }

        this.workerPool = [];
        this.workerNextTaskID = 1;
        this.workerSourceURL = '';
        this.defaultAttributeIDs = {
          position: 'POSITION',
          normal: 'NORMAL',
          color: 'COLOR',
          uv: 'TEX_COORD',
          uv2: 'GENERIC'
        };
        this.defaultAttributeTypes = {
          position: 'Float32Array',
          normal: 'Float32Array',
          color: 'Float32Array',
          uv: 'Float32Array',
          uv2: 'Float32Array'
        };
      },
      prototype: _prototype_
    });
    /* WEB WORKER */

    _DRACOLoader.DRACOWorker = function () {
      var decoderConfig;
      var decoderPending;

      onmessage = function onmessage(e) {
        var message = e.data;

        switch (message.type) {
          case 'init':
            decoderConfig = message.decoderConfig;
            decoderPending = new Promise(function (resolve
            /*, reject*/
            ) {
              decoderConfig.onModuleLoaded = function (draco) {
                // Module is Promise-like. Wrap before resolving to avoid loop.
                resolve({
                  draco: draco
                });
              };

              DracoDecoderModule(decoderConfig);
            });
            break;

          case 'decode':
            var buffer = message.buffer;
            var taskConfig = message.taskConfig;
            decoderPending.then(function (module) {
              var draco = module.draco;
              var decoder = new draco.Decoder();
              var decoderBuffer = new draco.DecoderBuffer();
              decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);

              try {
                var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
                var buffers = geometry.attributes.map(function (attr) {
                  return attr.array.buffer;
                });
                if (geometry.index) buffers.push(geometry.index.array.buffer);
                self.postMessage({
                  type: 'decode',
                  id: message.id,
                  geometry: geometry
                }, buffers);
              } catch (error) {
                console.error(error);
                self.postMessage({
                  type: 'error',
                  id: message.id,
                  error: error.message
                });
              } finally {
                draco.destroy(decoderBuffer);
                draco.destroy(decoder);
              }
            });
            break;
        }
      };

      function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
        var attributeIDs = taskConfig.attributeIDs;
        var attributeTypes = taskConfig.attributeTypes;
        var dracoGeometry;
        var decodingStatus;
        var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);

        if (geometryType === draco.TRIANGULAR_MESH) {
          dracoGeometry = new draco.Mesh();
          decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
        } else if (geometryType === draco.POINT_CLOUD) {
          dracoGeometry = new draco.PointCloud();
          decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
        } else {
          throw new Error('THREE.DRACOLoader: Unexpected geometry type.');
        }

        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
          throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());
        }

        var geometry = {
          index: null,
          attributes: []
        }; // Gather all vertex attributes.

        for (var attributeName in attributeIDs) {
          var attributeType = self[attributeTypes[attributeName]];
          var attribute;
          var attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs
          // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
          // a Draco file may contain a custom set of attributes, identified by known unique
          // IDs. glTF files always do the latter, and `.drc` files typically do the former.

          if (taskConfig.useUniqueIDs) {
            attributeID = attributeIDs[attributeName];
            attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
          } else {
            attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
            if (attributeID === -1) continue;
            attribute = decoder.GetAttribute(dracoGeometry, attributeID);
          }

          geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
        } // Add index.


        if (geometryType === draco.TRIANGULAR_MESH) {
          // Generate mesh faces.
          var numFaces = dracoGeometry.num_faces();
          var numIndices = numFaces * 3;
          var index = new Uint32Array(numIndices);
          var indexArray = new draco.DracoInt32Array();

          for (var i = 0; i < numFaces; ++i) {
            decoder.GetFaceFromMesh(dracoGeometry, i, indexArray);

            for (var j = 0; j < 3; ++j) {
              index[i * 3 + j] = indexArray.GetValue(j);
            }
          }

          geometry.index = {
            array: index,
            itemSize: 1
          };
          draco.destroy(indexArray);
        }

        draco.destroy(dracoGeometry);
        return geometry;
      }

      function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
        var numComponents = attribute.num_components();
        var numPoints = dracoGeometry.num_points();
        var numValues = numPoints * numComponents;
        var dracoArray;
        var array;

        switch (attributeType) {
          case Float32Array:
            dracoArray = new draco.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Float32Array(numValues);
            break;

          case Int8Array:
            dracoArray = new draco.DracoInt8Array();
            decoder.GetAttributeInt8ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Int8Array(numValues);
            break;

          case Int16Array:
            dracoArray = new draco.DracoInt16Array();
            decoder.GetAttributeInt16ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Int16Array(numValues);
            break;

          case Int32Array:
            dracoArray = new draco.DracoInt32Array();
            decoder.GetAttributeInt32ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Int32Array(numValues);
            break;

          case Uint8Array:
            dracoArray = new draco.DracoUInt8Array();
            decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Uint8Array(numValues);
            break;

          case Uint16Array:
            dracoArray = new draco.DracoUInt16Array();
            decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Uint16Array(numValues);
            break;

          case Uint32Array:
            dracoArray = new draco.DracoUInt32Array();
            decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, attribute, dracoArray);
            array = new Uint32Array(numValues);
            break;

          default:
            throw new Error('THREE.DRACOLoader: Unexpected attribute type.');
        }

        for (var i = 0; i < numValues; i++) {
          array[i] = dracoArray.GetValue(i);
        }

        draco.destroy(dracoArray);
        return {
          name: attributeName,
          array: array,
          itemSize: numComponents
        };
      }
    };

    _DRACOLoader.taskCache = new WeakMap();
    /** Deprecated static methods */

    /** @deprecated */

    _DRACOLoader.setDecoderPath = function () {
      console.warn('THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.');
    };
    /** @deprecated */


    _DRACOLoader.setDecoderConfig = function () {
      console.warn('THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.');
    };
    /** @deprecated */


    _DRACOLoader.releaseDecoderModule = function () {
      console.warn('THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.');
    };
    /** @deprecated */


    _DRACOLoader.getDecoderModule = function () {
      console.warn('THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.');
    };
  }

  return new _DRACOLoader(manager);
};

exports.DRACOLoader = DRACOLoader;

},{"M_407":198,"s_332":233,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242,"M_110":245}],94:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLTFLoader = void 0;

var _typeof2 = _interopRequireDefault(require("M_110"));

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _esExtends = _interopRequireDefault(require("M_407"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AnimationClip, Bone, Box3, BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, DirectionalLight, DoubleSide, FileLoader, FrontSide, Group, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, Line, LineBasicMaterial, LineLoop, LineSegments, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, Loader, LoaderUtils, Material, // Math as _Math,
_Math, Matrix4, Matrix3, Mesh, MeshBasicMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NumberKeyframeTrack, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, Points, PointsMaterial, PropertyBinding, QuaternionKeyframeTrack, RGBAFormat, RGBFormat, RepeatWrapping, Skeleton, SkinnedMesh, Sphere, SpotLight, TangentSpaceNormalMap, TextureLoader, TriangleFanDrawMode, TriangleStripDrawMode, Vector2, Vector3, VectorKeyframeTrack, sRGBEncoding, Texture, ShaderMaterial;

var initDeps$GLTFLoaderDone = false;

function initDeps$GLTFLoader() {
  if (initDeps$GLTFLoaderDone) return;
  initDeps$GLTFLoaderDone = true;
  var _THREE = THREE;
  AnimationClip = _THREE.AnimationClip, Bone = _THREE.Bone, Box3 = _THREE.Box3, BufferAttribute = _THREE.BufferAttribute, BufferGeometry = _THREE.BufferGeometry, ClampToEdgeWrapping = 1001, Color = _THREE.Color, DirectionalLight = _THREE.DirectionalLight, DoubleSide = 2, FileLoader = _THREE.FileLoader, FrontSide = 0, Group = _THREE.Group, InterleavedBuffer = _THREE.InterleavedBuffer, InterleavedBufferAttribute = _THREE.InterleavedBufferAttribute, Interpolant = _THREE.Interpolant, InterpolateDiscrete = 2300, InterpolateLinear = 2301, Line = _THREE.Line, LineBasicMaterial = _THREE.LineBasicMaterial, LineLoop = _THREE.LineLoop, LineSegments = _THREE.LineSegments, LinearFilter = 1006, LinearMipmapLinearFilter = 1008, LinearMipmapNearestFilter = 1007, Loader = _THREE.Loader, LoaderUtils = _THREE.LoaderUtils, Material = _THREE.Material, // Math as _Math,
  _Math = _THREE.Math, Matrix4 = _THREE.Matrix4, Matrix3 = _THREE.Matrix3, Mesh = _THREE.Mesh, MeshBasicMaterial = _THREE.MeshBasicMaterial, MeshPhysicalMaterial = _THREE.MeshPhysicalMaterial, MeshStandardMaterial = _THREE.MeshStandardMaterial, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapLinearFilter = 1005, NearestMipmapNearestFilter = 1004, NumberKeyframeTrack = _THREE.NumberKeyframeTrack, Object3D = _THREE.Object3D, OrthographicCamera = _THREE.OrthographicCamera, PerspectiveCamera = _THREE.PerspectiveCamera, PointLight = _THREE.PointLight, Points = _THREE.Points, PointsMaterial = _THREE.PointsMaterial, PropertyBinding = _THREE.PropertyBinding, QuaternionKeyframeTrack = _THREE.QuaternionKeyframeTrack, RGBAFormat = 1023, RGBFormat = 1022, RepeatWrapping = 1000, Skeleton = _THREE.Skeleton, SkinnedMesh = _THREE.SkinnedMesh, Sphere = _THREE.Sphere, SpotLight = _THREE.SpotLight, TangentSpaceNormalMap = 0, TextureLoader = _THREE.TextureLoader, TriangleFanDrawMode = 2, TriangleStripDrawMode = 1, Vector2 = _THREE.Vector2, Vector3 = _THREE.Vector3, VectorKeyframeTrack = _THREE.VectorKeyframeTrack, sRGBEncoding = 3001, Texture = _THREE.Texture, ShaderMaterial = _THREE.ShaderMaterial;
}

var _GLTFLoader;

var GLTFLoader = function GLTFLoader(manager) {
  initDeps$GLTFLoader();

  if (!_GLTFLoader) {
    /* GLTFREGISTRY */
    var GLTFRegistry = function GLTFRegistry() {
      var objects = {};
      return {
        get: function get(key) {
          return objects[key];
        },
        add: function add(key, object) {
          objects[key] = object;
        },
        remove: function remove(key) {
          delete objects[key];
        },
        removeAll: function removeAll() {
          objects = {};
        }
      };
    };
    /*********************************/

    /********** EXTENSIONS ***********/

    /*********************************/


    /**
     * DDS Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
     *
     */
    var GLTFTextureDDSExtension = function GLTFTextureDDSExtension(ddsLoader) {
      if (!ddsLoader) {
        throw new Error('THREE._GLTFLoader: Attempting to load .dds texture without importing DDSLoader');
      }

      this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
      this.ddsLoader = ddsLoader;
    };
    /**
     * Punctual Lights Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
     */


    var GLTFLightsExtension = function GLTFLightsExtension(json) {
      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
      var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};
      this.lightDefs = extension.lights || [];
    };

    /**
     * Unlit Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
     */
    var GLTFMaterialsUnlitExtension = function GLTFMaterialsUnlitExtension() {
      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    };

    /**
     * Clearcoat Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
     */
    var GLTFMaterialsClearcoatExtension = function GLTFMaterialsClearcoatExtension() {
      this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    };

    var GLTFBinaryExtension = function GLTFBinaryExtension(data) {
      this.name = EXTENSIONS.KHR_BINARY_GLTF;
      this.content = null;
      this.body = null;
      var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
      this.header = {
        magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true)
      };

      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
        throw new Error('THREE._GLTFLoader: Unsupported glTF-Binary header.');
      } else if (this.header.version < 2.0) {
        throw new Error('THREE._GLTFLoader: Legacy binary file detected.');
      }

      var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
      var chunkIndex = 0;

      while (chunkIndex < chunkView.byteLength) {
        var chunkLength = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        if (chunkIndex >= chunkView.byteLength) break;
        var chunkType = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        if (chunkIndex >= chunkView.byteLength) break;

        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
          var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
          this.content = LoaderUtils.decodeText(contentArray);
        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
          var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
          this.body = data.slice(byteOffset, byteOffset + chunkLength);
        } // Clients must ignore chunks with unknown types.


        chunkIndex += chunkLength;
      }

      if (this.content === null) {
        throw new Error('THREE._GLTFLoader: JSON content not found.');
      }
    };
    /**
     * DRACO Mesh Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
     */


    var GLTFDracoMeshCompressionExtension = function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
      if (!dracoLoader) {
        throw new Error('THREE._GLTFLoader: No DRACOLoader instance provided.');
      }

      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
      this.json = json;
      this.dracoLoader = dracoLoader;
      this.dracoLoader.preload();
    };

    /**
     * Texture Transform Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
     */
    var GLTFTextureTransformExtension = function GLTFTextureTransformExtension() {
      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    };

    /**
     * Specular-Glossiness Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
     */

    /**
     * A sub class of StandardMaterial with some of the functionality
     * changed via the `onBeforeCompile` callback
     * @pailhead
     */
    var GLTFMeshStandardSGMaterial = function GLTFMeshStandardSGMaterial(params) {
      MeshStandardMaterial.call(this);
      this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing

      var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
      var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
      var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
      var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
      var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\n');
      var uniforms = {
        specular: {
          value: new Color().setHex(0xffffff)
        },
        glossiness: {
          value: 1
        },
        specularMap: {
          value: null
        },
        glossinessMap: {
          value: null
        }
      };
      this._extraUniforms = uniforms; // please see #14031 or #13198 for an alternate approach

      this.onBeforeCompile = function (shader) {
        for (var uniformName in uniforms) {
          shader.uniforms[uniformName] = uniforms[uniformName];
        }

        shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;');
        shader.fragmentShader = shader.fragmentShader.replace('uniform float metalness;', 'uniform float glossiness;');
        shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_fragment>', specularMapFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
      };
      /*eslint-disable*/


      Object.defineProperties(this, {
        specular: {
          get: function get() {
            return uniforms.specular.value;
          },
          set: function set(v) {
            uniforms.specular.value = v;
          }
        },
        specularMap: {
          get: function get() {
            return uniforms.specularMap.value;
          },
          set: function set(v) {
            uniforms.specularMap.value = v;
          }
        },
        glossiness: {
          get: function get() {
            return uniforms.glossiness.value;
          },
          set: function set(v) {
            uniforms.glossiness.value = v;
          }
        },
        glossinessMap: {
          get: function get() {
            return uniforms.glossinessMap.value;
          },
          set: function set(v) {
            uniforms.glossinessMap.value = v; //how about something like this - @pailhead

            if (v) {
              this.defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv

              this.defines.USE_ROUGHNESSMAP = '';
            } else {
              delete this.defines.USE_ROUGHNESSMAP;
              delete this.defines.USE_GLOSSINESSMAP;
            }
          }
        }
      });
      /*eslint-enable*/

      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      this.setValues(params);
    };

    var GLTFMaterialsPbrSpecularGlossinessExtension = function GLTFMaterialsPbrSpecularGlossinessExtension() {
      return {
        name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],
        getMaterialType: function getMaterialType() {
          return GLTFMeshStandardSGMaterial;
        },
        extendParams: function extendParams(materialParams, materialDef, parser) {
          var pbrSpecularGlossiness = materialDef.extensions[this.name];
          materialParams.color = new Color(1.0, 1.0, 1.0);
          materialParams.opacity = 1.0;
          var pending = [];

          if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
            var array = pbrSpecularGlossiness.diffuseFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }

          if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
          }

          materialParams.emissive = new Color(0.0, 0.0, 0.0);
          materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
          materialParams.specular = new Color(1.0, 1.0, 1.0);

          if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
            materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
          }

          if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
            var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
            pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
            pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
          }

          return Promise.all(pending);
        },
        createMaterial: function createMaterial(materialParams) {
          var material = new GLTFMeshStandardSGMaterial(materialParams);
          material.fog = true;
          material.color = materialParams.color;
          material.map = materialParams.map === undefined ? null : materialParams.map;
          material.lightMap = null;
          material.lightMapIntensity = 1.0;
          material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
          material.aoMapIntensity = 1.0;
          material.emissive = materialParams.emissive;
          material.emissiveIntensity = 1.0;
          material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
          material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
          material.bumpScale = 1;
          material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
          material.normalMapType = TangentSpaceNormalMap;
          if (materialParams.normalScale) material.normalScale = materialParams.normalScale;
          material.displacementMap = null;
          material.displacementScale = 1;
          material.displacementBias = 0;
          material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
          material.specular = materialParams.specular;
          material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
          material.glossiness = materialParams.glossiness;
          material.alphaMap = null;
          material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
          material.envMapIntensity = 1.0;
          material.refractionRatio = 0.98;
          return material;
        }
      };
    };
    /**
     * Mesh Quantization Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
     */


    var GLTFMeshQuantizationExtension = function GLTFMeshQuantizationExtension() {
      this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    };

    var GLTFMeaterialTechniquesWebglExtension = function GLTFMeaterialTechniquesWebglExtension(json) {
      this.name = EXTENSIONS.KHR_TECHNIQUES_WEBGL;

      this.getMaterialType = function () {
        return ShaderMaterial;
      };

      this.getUniformTexture = function (uniform, textureIndex, parser) {
        return parser.loadTexture(textureIndex).then(function (texture) {
          uniform.value = texture;
        });
      };

      this.extendParams = function (materialParams, materialDef, parser) {
        var extension = json.extensions[this.name];
        var ktwDef = materialDef.extensions[this.name];
        var technique = extension.techniques[ktwDef.technique];
        materialParams.name = technique.name;
        var program = extension.programs[technique.program];
        var techniqueUniforms = technique.uniforms;
        var uniforms = {};
        var pending = [];

        for (var uniformName in ktwDef.values) {
          if (ktwDef.values.hasOwnProperty(uniformName) && techniqueUniforms[uniformName]) {
            var uniformVal = ktwDef.values[uniformName];
            var unifromType = techniqueUniforms[uniformName].type;
            uniforms[uniformName] = {
              value: null
            };
            var unifrom = uniforms[uniformName];

            switch (unifromType) {
              case WEBGL_CONSTANTS.FLOAT:
                unifrom.value = {
                  value: uniformVal
                };
                break;

              case WEBGL_CONSTANTS.FLOAT_VEC2:
                unifrom.value = new Vector2().fromArray(uniformVal);
                break;

              case WEBGL_CONSTANTS.FLOAT_VEC3:
                unifrom.value = new Vector3().fromArray(uniformVal);
                break;

              case WEBGL_CONSTANTS.FLOAT_VEC4:
                unifrom.value = new Color().fromArray(uniformVal);
                break;

              case WEBGL_CONSTANTS.FLOAT_MAT3:
                unifrom.value = new Matrix3().fromArray(uniformVal);
                break;

              case WEBGL_CONSTANTS.FLOAT_MAT4:
                unifrom.value = new Matrix4().fromArray(uniformVal);
                break;

              case WEBGL_CONSTANTS.SAMPLER_2D:
                var textureIndex = uniformVal.index;
                pending.push(this.getUniformTexture(unifrom, textureIndex, parser)); //console.warn('_GLTFLoader:unsupport uniform type ' + unifromType);
                // parser.assignTexture
                //uniforms[uniformName] = new THREE.Matrix4().fromArray(uniformVal);

                break;

              default:
                break;
            }
          }
        }

        materialParams.uniforms = uniforms;
        var fragmentShaderDef = extension.shaders[program.fragmentShader];
        var vertexShaderDef = extension.shaders[program.vertexShader]; // pending.push(parser.getDependency('bufferView', fragmentShaderDef.bufferView).then((buffer) => {
        // 	materialParams.fragmentShader = LoaderUtils.decodeText(new Uint8Array(buffer));
        // 	return materialParams;
        // }));
        // pending.push(parser.getDependency('bufferView', vertexShaderDef.bufferView).then((buffer) => {
        // 	materialParams.vertexShader = LoaderUtils.decodeText(new Uint8Array(buffer));
        // 	return materialParams;
        // }));

        return Promise.all(pending);
      };

      this.createMaterial = function (materialParams) {
        var material = new ShaderMaterial(materialParams);
        return material;
      };
    };

    var GLTFCesiumRTCExtension = function GLTFCesiumRTCExtension(json) {
      this.name = EXTENSIONS.CESIUM_RTC;
      var rtcCenter = new Vector3().fromArray(json.extensions[this.name].center);
      this.rtcCenterTransform = new Matrix4().setPosition(rtcCenter);
    };
    /*********************************/

    /********** INTERPOLATION ********/

    /*********************************/
    // Spline Interpolation
    // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


    var GLTFCubicSplineInterpolant = function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    };

    /* UTILITY FUNCTIONS */
    var resolveURL = function resolveURL(url, path) {
      // Invalid URL
      if (typeof url !== 'string' || url === '') return ''; // Host Relative URL

      if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
        path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
      } // Absolute URL http://,https://,//


      if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

      if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

      if (/^blob:.*$/i.test(url)) return url; // Relative URL

      return path + url;
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
     */


    var createDefaultMaterial = function createDefaultMaterial(cache) {
      if (cache['DefaultMaterial'] === undefined) {
        cache['DefaultMaterial'] = new MeshStandardMaterial({
          color: 0xFFFFFF,
          emissive: 0x000000,
          metalness: 1,
          roughness: 1,
          transparent: false,
          depthTest: true,
          side: FrontSide
        });
      }

      return cache['DefaultMaterial'];
    };

    var addUnknownExtensionsToUserData = function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
      // Add unknown glTF extensions to an object's userData.
      for (var name in objectDef.extensions) {
        if (knownExtensions[name] === undefined) {
          object.userData.gltfExtensions = object.userData.gltfExtensions || {};
          object.userData.gltfExtensions[name] = objectDef.extensions[name];
        }
      }
    };
    /**
     * @param {Object3D|Material|BufferGeometry} object
     * @param {GLTF.definition} gltfDef
     */


    var assignExtrasToUserData = function assignExtrasToUserData(object, gltfDef) {
      if (gltfDef.extras !== undefined) {
        if ((0, _typeof2["default"])(gltfDef.extras) === 'object') {
          Object.assign(object.userData, gltfDef.extras);
        } else {
          console.warn('THREE._GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
        }
      }
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
     *
     * @param {BufferGeometry} geometry
     * @param {Array<GLTF.Target>} targets
     * @param {GLTFParser} parser
     * @return {Promise<BufferGeometry>}
     */


    var addMorphTargets = function addMorphTargets(geometry, targets, parser) {
      var hasMorphPosition = false;
      var hasMorphNormal = false;

      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];
        if (target.POSITION !== undefined) hasMorphPosition = true;
        if (target.NORMAL !== undefined) hasMorphNormal = true;
        if (hasMorphPosition && hasMorphNormal) break;
      }

      if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
      var pendingPositionAccessors = [];
      var pendingNormalAccessors = [];

      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];

        if (hasMorphPosition) {
          var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;
          pendingPositionAccessors.push(pendingAccessor);
        }

        if (hasMorphNormal) {
          var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;
          pendingNormalAccessors.push(pendingAccessor);
        }
      }

      return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
        var morphPositions = accessors[0];
        var morphNormals = accessors[1];
        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
        geometry.morphTargetsRelative = true;
        return geometry;
      });
    };
    /**
     * @param {Mesh} mesh
     * @param {GLTF.Mesh} meshDef
     */


    var updateMorphTargets = function updateMorphTargets(mesh, meshDef) {
      mesh.updateMorphTargets();

      if (meshDef.weights !== undefined) {
        for (var i = 0, il = meshDef.weights.length; i < il; i++) {
          mesh.morphTargetInfluences[i] = meshDef.weights[i];
        }
      } // .extras has user-defined data, so check that .extras.targetNames is an array.


      if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
        var targetNames = meshDef.extras.targetNames;

        if (mesh.morphTargetInfluences.length === targetNames.length) {
          mesh.morphTargetDictionary = {};

          for (var i = 0, il = targetNames.length; i < il; i++) {
            mesh.morphTargetDictionary[targetNames[i]] = i;
          }
        } else {
          console.warn('THREE._GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
        }
      }
    };

    var createPrimitiveKey = function createPrimitiveKey(primitiveDef) {
      var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
      var geometryKey;

      if (dracoExtension) {
        geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
      } else {
        geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
      }

      return geometryKey;
    };

    var createAttributesKey = function createAttributesKey(attributes) {
      var attributesKey = '';
      var keys = Object.keys(attributes).sort();

      for (var i = 0, il = keys.length; i < il; i++) {
        attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
      }

      return attributesKey;
    };
    /* GLTF PARSER */


    var GLTFParser = function GLTFParser(json, extensions, options) {
      this.json = json || {};
      this.extensions = extensions || {};
      this.options = options || {}; // loader object cache

      this.cache = new GLTFRegistry(); // BufferGeometry caching

      this.primitiveCache = {};
      this.textureLoader = new TextureLoader(this.options.manager);
      this.textureLoader.setCrossOrigin(this.options.crossOrigin);
      this.fileLoader = new FileLoader(this.options.manager);
      this.fileLoader.setResponseType('arraybuffer');

      if (this.options.crossOrigin === 'use-credentials') {
        this.fileLoader.setWithCredentials(true);
      }
    };

    /**
     * @param {BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     */
    var computeBounds = function computeBounds(geometry, primitiveDef, parser) {
      var attributes = primitiveDef.attributes;
      var box = new Box3();

      if (attributes.POSITION !== undefined) {
        var accessor = parser.json.accessors[attributes.POSITION];
        var min = accessor.min;
        var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

        if (min !== undefined && max !== undefined) {
          box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
        } else {
          console.warn('THREE._GLTFLoader: Missing min/max properties for accessor POSITION.');
          return;
        }
      } else {
        return;
      }

      var targets = primitiveDef.targets;

      if (targets !== undefined) {
        var maxDisplacement = new Vector3();
        var vector = new Vector3();

        for (var i = 0, il = targets.length; i < il; i++) {
          var target = targets[i];

          if (target.POSITION !== undefined) {
            var accessor = parser.json.accessors[target.POSITION];
            var min = accessor.min;
            var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

            if (min !== undefined && max !== undefined) {
              // we need to get max of absolute components because target weight is [-1,1]
              vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
              vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
              vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2]))); // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
              // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
              // are used to implement key-frame animations and as such only two are active at a time - this results in very large
              // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.

              maxDisplacement.max(vector);
            } else {
              console.warn('THREE._GLTFLoader: Missing min/max properties for accessor POSITION.');
            }
          }
        } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.


        box.expandByVector(maxDisplacement);
      }

      geometry.boundingBox = box;
      var sphere = new Sphere();
      box.getCenter(sphere.center);
      sphere.radius = box.min.distanceTo(box.max) / 2;
      geometry.boundingSphere = sphere;
    };
    /**
     * @param {BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     * @return {Promise<BufferGeometry>}
     */


    var addPrimitiveAttributes = function addPrimitiveAttributes(geometry, primitiveDef, parser) {
      var attributes = primitiveDef.attributes;
      var pending = [];

      function assignAttributeAccessor(accessorIndex, attributeName) {
        return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
          geometry.setAttribute(attributeName, accessor);
        });
      }

      for (var gltfAttributeName in attributes) {
        var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.

        if (threeAttributeName in geometry.attributes) continue;
        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
      }

      if (primitiveDef.indices !== undefined && !geometry.index) {
        var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
          geometry.setIndex(accessor);
        });
        pending.push(accessor);
      }

      assignExtrasToUserData(geometry, primitiveDef);
      computeBounds(geometry, primitiveDef, parser);
      return Promise.all(pending).then(function () {
        return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
      });
    };
    /**
     * @param {BufferGeometry} geometry
     * @param {Number} drawMode
     * @return {BufferGeometry}
     */


    var toTrianglesDrawMode = function toTrianglesDrawMode(geometry, drawMode) {
      var index = geometry.getIndex(); // generate index if not present

      if (index === null) {
        var indices = [];
        var position = geometry.getAttribute('position');

        if (position !== undefined) {
          for (var i = 0; i < position.count; i++) {
            indices.push(i);
          }

          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error('THREE._GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
          return geometry;
        }
      } //


      var numberOfTriangles = index.count - 2;
      var newIndices = [];

      if (drawMode === TriangleFanDrawMode) {
        // gl.TRIANGLE_FAN
        for (var i = 1; i <= numberOfTriangles; i++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
        }
      } else {
        // gl.TRIANGLE_STRIP
        for (var i = 0; i < numberOfTriangles; i++) {
          if (i % 2 === 0) {
            newIndices.push(index.getX(i));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i + 2));
          } else {
            newIndices.push(index.getX(i + 2));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i));
          }
        }
      }

      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error('THREE._GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
      } // build final geometry


      var newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      return newGeometry;
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
     *
     * Creates BufferGeometries from primitives.
     *
     * @param {Array<GLTF.Primitive>} primitives
     * @return {Promise<Array<BufferGeometry>>}
     */


    var _GLTFLoaderProptotype_ = {
      // constructor: _GLTFLoader,
      load: function load(url, onLoad, onProgress, onError, onBufferLoad, options) {
        var scope = this;
        var resourcePath;

        if (this.resourcePath !== '') {
          resourcePath = this.resourcePath;
        } else if (this.path !== '') {
          resourcePath = this.path;
        } else {
          resourcePath = LoaderUtils.extractUrlBase(url);
        } // Tells the LoadingManager to track an extra item, which resolves after
        // the model is fully loaded. This means the count of items loaded will
        // be incorrect, but ensures manager.onLoad() does not fire early.


        scope.manager.itemStart(url);

        var _onError = function _onError(e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        };

        var loader = new FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');

        if (scope.crossOrigin === 'use-credentials') {
          loader.setWithCredentials(true);
        }

        loader.load(url, function (data) {
          try {
            if (onBufferLoad) {
              var result = onBufferLoad(data);
              if (result) data = result;
            }

            scope.parse(data, resourcePath, function (gltf) {
              onLoad(gltf);
              scope.manager.itemEnd(url);
            }, _onError, options);
          } catch (e) {
            _onError(e);
          }
        }, onProgress, _onError);
      },
      setDRACOLoader: function setDRACOLoader(dracoLoader) {
        this.dracoLoader = dracoLoader;
        return this;
      },
      setDDSLoader: function setDDSLoader(ddsLoader) {
        this.ddsLoader = ddsLoader;
        return this;
      },
      parse: function parse(data, path, onLoad, onError, options) {
        var _Cesium = Cesium;
        var content;
        var extensions = {};
        var json;

        if (typeof data === 'string') {
          content = data;
          json = JSON.parse(content);
        } else {
          if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
            if (data instanceof Uint8Array) {
              data = data.slice().buffer; //new Uint8Array(data);
            }

            var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
              try {
                extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
                content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
                json = JSON.parse(content);
              } catch (error) {
                try {
                  //support v1.0
                  json = _Cesium.parseGlb(new Uint8Array(data));
                } catch (error) {
                  if (onError) onError(error);
                  return;
                }
              }
            } else {
              content = LoaderUtils.decodeText(new Uint8Array(data));
              json = JSON.parse(content);
            }
          } else {
            json = data;
          }
        } // var json = JSON.parse(content);


        try {
          if (json.asset === undefined || json.asset.version[0] < 2 || json.asset.version < 2) {
            json = _Cesium.updateVersion(json);
            var buffers = json.buffers;

            if (buffers.length == 1 && buffers[0].extras && buffers[0].extras._pipeline && buffers[0].extras._pipeline.source) {
              var header = new Uint32Array(data.buffer || data, 0, 5);
              var contentLength = header[3];
              var jsonStart = 20;
              var binaryStart = jsonStart + contentLength;
              json.binaryStart = binaryStart;
            } // if (onError) onError(new Error('THREE._GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
            // return;

          }
        } catch (error) {
          if (onError) onError(error);
          return;
        }

        if (json.extensionsUsed) {
          for (var i = 0; i < json.extensionsUsed.length; ++i) {
            var extensionName = json.extensionsUsed[i];
            var extensionsRequired = json.extensionsRequired || [];

            switch (extensionName) {
              case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
                extensions[extensionName] = new GLTFLightsExtension(json);
                break;

              case EXTENSIONS.KHR_MATERIALS_CLEARCOAT:
                extensions[extensionName] = new GLTFMaterialsClearcoatExtension();
                break;

              case EXTENSIONS.KHR_MATERIALS_UNLIT:
                extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                break;

              case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                break;

              case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                break;

              case EXTENSIONS.MSFT_TEXTURE_DDS:
                extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);
                break;

              case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                extensions[extensionName] = new GLTFTextureTransformExtension();
                break;

              case EXTENSIONS.KHR_MESH_QUANTIZATION:
                extensions[extensionName] = new GLTFMeshQuantizationExtension();
                break;
              //support ShaderMaterial

              case EXTENSIONS.KHR_TECHNIQUES_WEBGL:
                extensions[extensionName] = new GLTFMeaterialTechniquesWebglExtension(json);
                break;
              //support CESIUM_RTC

              case EXTENSIONS.CESIUM_RTC:
                extensions[extensionName] = new GLTFCesiumRTCExtension(json);
                break;

              default:
                if (extensionsRequired.indexOf(extensionName) >= 0) {
                  console.warn('THREE._GLTFLoader: Unknown extension "' + extensionName + '".');
                }

            }
          }
        }

        var parser = new GLTFParser(json, extensions, {
          path: path || this.resourcePath || '',
          crossOrigin: this.crossOrigin,
          manager: this.manager,
          loadTexture: options ? options.loadTexture : undefined
        });
        parser.parse(onLoad, onError);
      }
    };
    _GLTFLoader = (0, _esExtends["default"])(Loader, {
      esConstructor: function esConstructor(constructor) {
        var _esCtor = /*#__PURE__*/function (_Loader) {
          (0, _inherits2["default"])(_esCtor, _Loader);

          var _super = _createSuper(_esCtor);

          function _esCtor(manager) {
            var _this;

            (0, _classCallCheck2["default"])(this, _esCtor);
            _this = _super.call(this, manager);
            constructor.call((0, _assertThisInitialized2["default"])(_this), manager);
            return _this;
          }

          return _esCtor;
        }(Loader);

        return _esCtor;
      },
      constructor: function constructor() {
        this.dracoLoader = null;
        this.ddsLoader = null;
      },
      prototype: _GLTFLoaderProptotype_
    });
    var EXTENSIONS = {
      KHR_BINARY_GLTF: 'KHR_binary_glTF',
      KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
      KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
      KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
      KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
      KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
      KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
      MSFT_TEXTURE_DDS: 'MSFT_texture_dds',
      //
      KHR_TECHNIQUES_WEBGL: "KHR_techniques_webgl",
      CESIUM_RTC: "CESIUM_RTC"
    };

    GLTFLightsExtension.prototype.loadLight = function (lightIndex) {
      var lightDef = this.lightDefs[lightIndex];
      var lightNode;
      var color = new Color(0xffffff);
      if (lightDef.color !== undefined) color.fromArray(lightDef.color);
      var range = lightDef.range !== undefined ? lightDef.range : 0;

      switch (lightDef.type) {
        case 'directional':
          lightNode = new DirectionalLight(color);
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        case 'point':
          lightNode = new PointLight(color);
          lightNode.distance = range;
          break;

        case 'spot':
          lightNode = new SpotLight(color);
          lightNode.distance = range; // Handle spotlight properties.

          lightDef.spot = lightDef.spot || {};
          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
          lightNode.angle = lightDef.spot.outerConeAngle;
          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        default:
          throw new Error('THREE._GLTFLoader: Unexpected light type, "' + lightDef.type + '".');
      } // Some lights (e.g. spot) default to a position other than the origin. Reset the position
      // here, because node-level parsing will only override position if explicitly specified.


      lightNode.position.set(0, 0, 0);
      lightNode.decay = 2;
      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
      lightNode.name = lightDef.name || 'light_' + lightIndex;
      return Promise.resolve(lightNode);
    };

    GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {
      return MeshBasicMaterial;
    };

    GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {
      var pending = [];
      materialParams.color = new Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      var metallicRoughness = materialDef.pbrMetallicRoughness;

      if (metallicRoughness) {
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }
      }

      return Promise.all(pending);
    };

    GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function () {
      return MeshPhysicalMaterial;
    };

    GLTFMaterialsClearcoatExtension.prototype.extendParams = function (materialParams, materialDef, parser) {
      var pending = [];
      var extension = materialDef.extensions[this.name];

      if (extension.clearcoatFactor !== undefined) {
        materialParams.clearcoat = extension.clearcoatFactor;
      }

      if (extension.clearcoatTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));
      }

      if (extension.clearcoatRoughnessFactor !== undefined) {
        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
      }

      if (extension.clearcoatRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));
      }

      if (extension.clearcoatNormalTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));

        if (extension.clearcoatNormalTexture.scale !== undefined) {
          var scale = extension.clearcoatNormalTexture.scale;
          materialParams.clearcoatNormalScale = new Vector2(scale, scale);
        }
      }

      return Promise.all(pending);
    };
    /* BINARY EXTENSION */


    var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
    var BINARY_EXTENSION_HEADER_LENGTH = 12;
    var BINARY_EXTENSION_CHUNK_TYPES = {
      JSON: 0x4E4F534A,
      BIN: 0x004E4942
    };

    GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {
      var json = this.json;
      var dracoLoader = this.dracoLoader;
      var bufferViewIndex = primitive.extensions[this.name].bufferView;
      var gltfAttributeMap = primitive.extensions[this.name].attributes;
      var threeAttributeMap = {};
      var attributeNormalizedMap = {};
      var attributeTypeMap = {};

      for (var attributeName in gltfAttributeMap) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
      }

      for (attributeName in primitive.attributes) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

        if (gltfAttributeMap[attributeName] !== undefined) {
          var accessorDef = json.accessors[primitive.attributes[attributeName]];
          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          attributeTypeMap[threeAttributeName] = componentType;
          attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
        }
      }

      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
        return new Promise(function (resolve) {
          dracoLoader.decodeDracoFile(bufferView, function (geometry) {
            for (var attributeName in geometry.attributes) {
              var attribute = geometry.attributes[attributeName];
              var normalized = attributeNormalizedMap[attributeName];
              if (normalized !== undefined) attribute.normalized = normalized;
            }

            resolve(geometry);
          }, threeAttributeMap, attributeTypeMap);
        });
      });
    };

    GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {
      texture = texture.clone();

      if (transform.offset !== undefined) {
        texture.offset.fromArray(transform.offset);
      }

      if (transform.rotation !== undefined) {
        texture.rotation = transform.rotation;
      }

      if (transform.scale !== undefined) {
        texture.repeat.fromArray(transform.scale);
      }

      if (transform.texCoord !== undefined) {
        console.warn('THREE._GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
      }

      texture.needsUpdate = true;
      return texture;
    };

    GLTFMeshStandardSGMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

    GLTFMeshStandardSGMaterial.prototype.copy = function (source) {
      MeshStandardMaterial.prototype.copy.call(this, source);
      this.specularMap = source.specularMap;
      this.specular.copy(source.specular);
      this.glossinessMap = source.glossinessMap;
      this.glossiness = source.glossiness;
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      return this;
    };

    GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);
    GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

    GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {
      // Copies a sample value to the result buffer. See description of glTF
      // CUBICSPLINE values layout in interpolate_() function below.
      var result = this.resultBuffer,
          values = this.sampleValues,
          valueSize = this.valueSize,
          offset = index * valueSize * 3 + valueSize;

      for (var i = 0; i !== valueSize; i++) {
        result[i] = values[offset + i];
      }

      return result;
    };

    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
      var result = this.resultBuffer;
      var values = this.sampleValues;
      var stride = this.valueSize;
      var stride2 = stride * 2;
      var stride3 = stride * 3;
      var td = t1 - t0;
      var p = (t - t0) / td;
      var pp = p * p;
      var ppp = pp * p;
      var offset1 = i1 * stride3;
      var offset0 = offset1 - stride3;
      var s2 = -2 * ppp + 3 * pp;
      var s3 = ppp - pp;
      var s0 = 1 - s2;
      var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
      //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

      for (var i = 0; i !== stride; i++) {
        var p0 = values[offset0 + i + stride]; // splineVertex_k

        var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)

        var p1 = values[offset1 + i + stride]; // splineVertex_k+1

        var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

        result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
      }

      return result;
    };
    /*********************************/

    /********** INTERNALS ************/

    /*********************************/

    /* CONSTANTS */


    var WEBGL_CONSTANTS = {
      FLOAT: 5126,
      //FLOAT_MAT2: 35674,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123
    };
    var WEBGL_COMPONENT_TYPES = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    };
    var WEBGL_FILTERS = {
      9728: NearestFilter,
      9729: LinearFilter,
      9984: NearestMipmapNearestFilter,
      9985: LinearMipmapNearestFilter,
      9986: NearestMipmapLinearFilter,
      9987: LinearMipmapLinearFilter
    };
    var WEBGL_WRAPPINGS = {
      33071: ClampToEdgeWrapping,
      33648: MirroredRepeatWrapping,
      10497: RepeatWrapping
    };
    var WEBGL_TYPE_SIZES = {
      'SCALAR': 1,
      'VEC2': 2,
      'VEC3': 3,
      'VEC4': 4,
      'MAT2': 4,
      'MAT3': 9,
      'MAT4': 16
    };
    var ATTRIBUTES = {
      POSITION: 'position',
      NORMAL: 'normal',
      TANGENT: 'tangent',
      TEXCOORD_0: 'uv',
      TEXCOORD_1: 'uv2',
      COLOR_0: 'color',
      WEIGHTS_0: 'skinWeight',
      JOINTS_0: 'skinIndex'
    };
    var PATH_PROPERTIES = {
      scale: 'scale',
      translation: 'position',
      rotation: 'quaternion',
      weights: 'morphTargetInfluences'
    };
    var INTERPOLATION = {
      CUBICSPLINE: undefined,
      // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
      // keyframe track will be initialized with a default interpolation type, then modified.
      LINEAR: InterpolateLinear,
      STEP: InterpolateDiscrete
    };
    var ALPHA_MODES = {
      OPAQUE: 'OPAQUE',
      MASK: 'MASK',
      BLEND: 'BLEND'
    };
    var MIME_TYPE_FORMATS = {
      'image/png': RGBAFormat,
      'image/jpeg': RGBFormat
    };

    GLTFParser.prototype.parse = function (onLoad, onError) {
      var _this2 = this;

      var parser = this;
      var json = this.json;
      var extensions = this.extensions; // Clear the loader cache

      this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

      this.markDefs();
      Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {
        var result = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser: parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, result, json);
        assignExtrasToUserData(result, json);

        if (extensions[EXTENSIONS.CESIUM_RTC]) {
          result.CESIUM_RTC = json.extensions[EXTENSIONS.CESIUM_RTC].center; // var rtcCenterTransform = extensions[EXTENSIONS.CESIUM_RTC].rtcCenterTransform;
          // var scene = result.scene;
          // scene.matrix.multiply(rtcCenterTransform);
          // scene.matrix.decompose(scene.position, scene.quaternion, scene.scale);
          // scene.updateMatrixWorld();
        }

        onLoad(result);
      })["catch"](function (e) {
        _this2.cache.removeAll();

        onError(e);
      });
    };
    /**
     * Marks the special nodes/meshes in json for efficient parse.
     */


    GLTFParser.prototype.markDefs = function () {
      var nodeDefs = this.json.nodes || [];
      var skinDefs = this.json.skins || [];
      var meshDefs = this.json.meshes || [];
      var meshReferences = {};
      var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an
      // Object3D. Use the skins' joint references to mark bones.

      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
        var joints = skinDefs[skinIndex].joints;

        for (var i = 0, il = joints.length; i < il; i++) {
          nodeDefs[joints[i]].isBone = true;
        }
      } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To
      // avoid having more than one Mesh with the same name, count
      // references and rename instances below.
      //
      // Example: CesiumMilkTruck sample model reuses "Wheel" meshes.


      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];

        if (nodeDef.mesh !== undefined) {
          if (meshReferences[nodeDef.mesh] === undefined) {
            meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
          }

          meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is
          // a SkinnedMesh or Mesh. Use the node's mesh reference
          // to mark SkinnedMesh if node has skin.

          if (nodeDef.skin !== undefined) {
            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
          }
        }
      }

      this.json.meshReferences = meshReferences;
      this.json.meshUses = meshUses;
    };
    /**
     * Requests the specified dependency asynchronously, with caching.
     * @param {string} type
     * @param {number} index
     * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
     */


    GLTFParser.prototype.getDependency = function (type, index) {
      var cacheKey = type + ':' + index;
      var dependency = this.cache.get(cacheKey);

      if (!dependency) {
        switch (type) {
          case 'scene':
            dependency = this.loadScene(index);
            break;

          case 'node':
            dependency = this.loadNode(index);
            break;

          case 'mesh':
            dependency = this.loadMesh(index);
            break;

          case 'accessor':
            dependency = this.loadAccessor(index);
            break;

          case 'bufferView':
            dependency = this.loadBufferView(index);
            break;

          case 'buffer':
            dependency = this.loadBuffer(index);
            break;

          case 'material':
            dependency = this.loadMaterial(index);
            break;

          case 'texture':
            dependency = this.loadTexture(index);
            break;

          case 'skin':
            dependency = this.loadSkin(index);
            break;

          case 'animation':
            dependency = this.loadAnimation(index);
            break;

          case 'camera':
            dependency = this.loadCamera(index);
            break;

          case 'light':
            dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
            break;

          default:
            throw new Error('Unknown type: ' + type);
        }

        this.cache.add(cacheKey, dependency);
      }

      return dependency;
    };
    /**
     * Requests all dependencies of the specified type asynchronously, with caching.
     * @param {string} type
     * @return {Promise<Array<Object>>}
     */


    GLTFParser.prototype.getDependencies = function (type) {
      var dependencies = this.cache.get(type);

      if (!dependencies) {
        var parser = this;
        var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
        dependencies = Promise.all(defs.map(function (def, index) {
          return parser.getDependency(type, index);
        }));
        this.cache.add(type, dependencies);
      }

      return dependencies;
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferIndex
     * @return {Promise<ArrayBuffer>}
     */


    GLTFParser.prototype.loadBuffer = function (bufferIndex) {
      var bufferDef = this.json.buffers[bufferIndex];
      var loader = this.fileLoader;

      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
        throw new Error('THREE._GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
      } // If present, GLB container is required to be the first buffer.


      if (bufferDef.uri === undefined && bufferIndex === 0) {
        if (bufferDef.extras && bufferDef.extras._pipeline) {
          return Promise.resolve(bufferDef.extras._pipeline.source.buffer);
        }

        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
      }

      var options = this.options;
      return new Promise(function (resolve, reject) {
        if (bufferDef.extras && bufferDef.extras._pipeline) {
          resolve(bufferDef.extras._pipeline.source.buffer);
        } else {
          loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
            reject(new Error('THREE._GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
          });
        }
      });
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferViewIndex
     * @return {Promise<ArrayBuffer>}
     */


    GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {
      var bufferViewDef = this.json.bufferViews[bufferViewIndex];
      var binaryStart = this.json.binaryStart || 0;
      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
        var byteLength = bufferViewDef.byteLength || 0;
        var byteOffset = bufferViewDef.byteOffset || 0;
        return buffer.slice(binaryStart + byteOffset, binaryStart + byteOffset + byteLength);
      });
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
     * @param {number} accessorIndex
     * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
     */


    GLTFParser.prototype.loadAccessor = function (accessorIndex) {
      var parser = this;
      var json = this.json;
      var accessorDef = this.json.accessors[accessorIndex];

      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
        // Ignore empty accessors, which may be used to declare runtime
        // information about attributes coming from another source (e.g. Draco
        // compression extension).
        return Promise.resolve(null);
      }

      var pendingBufferViews = [];

      if (accessorDef.bufferView !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
      } else {
        pendingBufferViews.push(null);
      }

      if (accessorDef.sparse !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
      }

      return Promise.all(pendingBufferViews).then(function (bufferViews) {
        var bufferView = bufferViews[0];
        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

        var elementBytes = TypedArray.BYTES_PER_ELEMENT;
        var itemBytes = elementBytes * itemSize;
        var byteOffset = accessorDef.byteOffset || 0;
        var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
        var normalized = accessorDef.normalized === true;
        var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

        if (byteStride && byteStride !== itemBytes) {
          // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
          // This makes sure that IBA.count reflects accessor.count properly
          var ibSlice = Math.floor(byteOffset / byteStride);
          var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
          var ib = parser.cache.get(ibCacheKey);

          if (!ib) {
            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.

            ib = new InterleavedBuffer(array, byteStride / elementBytes);
            parser.cache.add(ibCacheKey, ib);
          }

          bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
        } else {
          if (bufferView === null) {
            array = new TypedArray(accessorDef.count * itemSize);
          } else {
            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
          }

          bufferAttribute = new BufferAttribute(array, itemSize, normalized);
        } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


        if (accessorDef.sparse !== undefined) {
          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

          if (bufferView !== null) {
            // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
            bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
          }

          for (var i = 0, il = sparseIndices.length; i < il; i++) {
            var index = sparseIndices[i];
            bufferAttribute.setX(index, sparseValues[i * itemSize]);
            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
            if (itemSize >= 5) throw new Error('THREE._GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
          }
        }

        return bufferAttribute;
      });
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
     * @param {number} textureIndex
     * @return {Promise<THREE.Texture>}
     */


    GLTFParser.prototype.loadTexture = function (textureIndex) {
      var parser = this;
      var json = this.json;
      var options = this.options;
      var textureLoader = this.textureLoader;
      var URL = self.URL || self.webkitURL;
      var textureDef = json.textures[textureIndex];
      var textureExtensions = textureDef.extensions || {};
      var source;

      if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
        source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
      } else {
        source = json.images[textureDef.source];
      }

      var cacheKey = 'texture-' + JSON.stringify(textureDef);
      var pending = this.cache.get(cacheKey);

      if (textureDef.name && pending) {
        debugger;
        return pending;
      }

      var sourceURI = source.uri;
      var isObjectURL = false;

      if (source.bufferView !== undefined) {
        // Load binary image data from bufferView, if provided.
        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
          isObjectURL = true;
          var blob = new Blob([bufferView], {
            type: source.mimeType
          });
          sourceURI = URL.createObjectURL(blob);
          return sourceURI;
        });
      }

      pending = Promise.resolve(sourceURI).then(function (sourceURI) {
        // Load Texture resource.
        var loader = options.manager.getHandler(sourceURI);

        if (!loader) {
          loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
        }

        return new Promise(function (resolve, reject) {
          if (options.loadTexture == false) {
            var texture = new Texture();
            var url = resolveURL(sourceURI, options.path); // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

            var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat; // texture.needsUpdate = true;
            // if (typeof Image != 'undefined') {
            // 	var img = new Image();
            // 	img.onload = () => {
            // 		texture.image = img;
            // 		resolve(texture);
            // 	}
            // 	img.onerror = reject;
            // 	img.src = url;
            // } else {
            // 	texture.image = url;
            // 	resolve(texture);
            // }

            texture.image = url;
            resolve(texture);
            return;
          } else {
            loader.load(resolveURL(sourceURI, options.path), resolve, undefined, function (err) {
              reject('Failed to load image ' + sourceURI);
            });
          }
        });
      }).then(function (texture) {
        // Clean up resources and configure Texture.
        if (isObjectURL === true) {
          URL.revokeObjectURL(sourceURI);
        }

        texture.flipY = false;
        if (textureDef.name) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.

        if (source.mimeType in MIME_TYPE_FORMATS) {
          texture.format = MIME_TYPE_FORMATS[source.mimeType];
        }

        var samplers = json.samplers || {};
        var sampler = samplers[textureDef.sampler] || {};
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
        return texture;
      });
      this.cache.add('texture-' + textureDef.name, pending);
      return pending;
    };
    /**
     * Asynchronously assigns a texture to the given material parameters.
     * @param {Object} materialParams
     * @param {string} mapName
     * @param {Object} mapDef
     * @return {Promise}
     */


    GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {
      var parser = this;
      return this.getDependency('texture', mapDef.index).then(function (texture) {
        if (!texture.isCompressedTexture) {
          switch (mapName) {
            case 'aoMap':
            case 'emissiveMap':
            case 'metalnessMap':
            case 'normalMap':
            case 'roughnessMap':
              texture.format = RGBFormat;
              break;
          }
        } // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
        // However, we will copy UV set 0 to UV set 1 on demand for aoMap


        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
          console.warn('THREE._GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
        }

        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
          var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

          if (transform) {
            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          }
        }

        materialParams[mapName] = texture;
      });
    };
    /**
     * Assigns final material to a Mesh, Line, or Points instance. The instance
     * already has a material (generated from the glTF material options alone)
     * but reuse of the same glTF material may require multiple threejs materials
     * to accomodate different primitive types, defines, etc. New materials will
     * be created if necessary, and reused from a cache.
     * @param  {Object3D} mesh Mesh, Line, or Points instance.
     */


    GLTFParser.prototype.assignFinalMaterial = function (mesh) {
      var geometry = mesh.geometry;
      var material = mesh.material;
      var useVertexTangents = geometry.attributes.tangent !== undefined;
      var useVertexColors = geometry.attributes.color !== undefined;
      var useFlatShading = geometry.attributes.normal === undefined;
      var useSkinning = mesh.isSkinnedMesh === true;
      var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
      var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

      if (mesh.isPoints) {
        var cacheKey = 'PointsMaterial:' + material.uuid;
        var pointsMaterial = this.cache.get(cacheKey);

        if (!pointsMaterial) {
          pointsMaterial = new PointsMaterial();
          Material.prototype.copy.call(pointsMaterial, material);
          pointsMaterial.color.copy(material.color);
          pointsMaterial.map = material.map;
          pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

          this.cache.add(cacheKey, pointsMaterial);
        }

        material = pointsMaterial;
      } else if (mesh.isLine) {
        var cacheKey = 'LineBasicMaterial:' + material.uuid;
        var lineMaterial = this.cache.get(cacheKey);

        if (!lineMaterial) {
          lineMaterial = new LineBasicMaterial();
          Material.prototype.copy.call(lineMaterial, material);
          lineMaterial.color.copy(material.color);
          this.cache.add(cacheKey, lineMaterial);
        }

        material = lineMaterial;
      } // Clone the material if it will be modified


      if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
        var cacheKey = 'ClonedMaterial:' + material.uuid + ':';
        if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
        if (useSkinning) cacheKey += 'skinning:';
        if (useVertexTangents) cacheKey += 'vertex-tangents:';
        if (useVertexColors) cacheKey += 'vertex-colors:';
        if (useFlatShading) cacheKey += 'flat-shading:';
        if (useMorphTargets) cacheKey += 'morph-targets:';
        if (useMorphNormals) cacheKey += 'morph-normals:';
        var cachedMaterial = this.cache.get(cacheKey);

        if (!cachedMaterial) {
          cachedMaterial = material.clone();
          if (useSkinning) cachedMaterial.skinning = true;
          if (useVertexTangents) cachedMaterial.vertexTangents = true;
          if (useVertexColors) cachedMaterial.vertexColors = true;
          if (useFlatShading) cachedMaterial.flatShading = true;
          if (useMorphTargets) cachedMaterial.morphTargets = true;
          if (useMorphNormals) cachedMaterial.morphNormals = true;
          this.cache.add(cacheKey, cachedMaterial);
        }

        material = cachedMaterial;
      } // workarounds for mesh and geometry


      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
        geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));
      } // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995


      if (material.normalScale && !useVertexTangents) {
        material.normalScale.y = -material.normalScale.y;
      }

      if (material.clearcoatNormalScale && !useVertexTangents) {
        material.clearcoatNormalScale.y = -material.clearcoatNormalScale.y;
      }

      mesh.material = material;
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
     * @param {number} materialIndex
     * @return {Promise<Material>}
     */


    GLTFParser.prototype.loadMaterial = function (materialIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var materialDef = json.materials[materialIndex];
      var materialType;
      var materialParams = {};
      var materialExtensions = materialDef.extensions || {};
      var pending = [];

      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];

        if (!sgExtension) {
          sgExtension = new GLTFMaterialsPbrSpecularGlossinessExtension();
          extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = sgExtension;
        }

        materialType = sgExtension.getMaterialType();
        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
        materialType = kmuExtension.getMaterialType();
        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
      } else {
        var shaderMaterialParams;

        if (materialExtensions[EXTENSIONS.KHR_TECHNIQUES_WEBGL]) {
          //Use ShaderMaterial
          shaderMaterialParams = {};
          var ktwExtension = extensions[EXTENSIONS.KHR_TECHNIQUES_WEBGL]; // materialType = ktwExtension.getMaterialType();

          pending.push(ktwExtension.extendParams(shaderMaterialParams, materialDef, parser));
        } // Specification:
        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material


        materialType = MeshStandardMaterial;
        var metallicRoughness = materialDef.pbrMetallicRoughness || {};
        materialParams.color = new Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;

        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }

        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

        if (metallicRoughness.metallicRoughnessTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
        }
      }

      if (materialDef.doubleSided === true) {
        materialParams.side = DoubleSide;
      }

      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

      if (alphaMode === ALPHA_MODES.BLEND) {
        materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706

        materialParams.depthWrite = false;
      } else {
        materialParams.transparent = false;

        if (alphaMode === ALPHA_MODES.MASK) {
          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
        }
      }

      if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
        materialParams.normalScale = new Vector2(1, 1);

        if (materialDef.normalTexture.scale !== undefined) {
          materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
        }
      }

      if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

        if (materialDef.occlusionTexture.strength !== undefined) {
          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
      }

      if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {
        materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
      }

      if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
      }

      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_CLEARCOAT]) {
        var clearcoatExtension = extensions[EXTENSIONS.KHR_MATERIALS_CLEARCOAT];
        materialType = clearcoatExtension.getMaterialType();
        pending.push(clearcoatExtension.extendParams(materialParams, {
          extensions: materialExtensions
        }, parser));
      }

      return Promise.all(pending).then(function () {
        var material;

        if (materialType === GLTFMeshStandardSGMaterial) {
          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
        } else {
          if (shaderMaterialParams) {
            var u_diffuse = shaderMaterialParams.uniforms.u_diffuse;

            if (u_diffuse) {
              if (u_diffuse.value.isTexture) {
                materialParams.map = u_diffuse.value;
              } else materialParams.color = u_diffuse.value;
            }

            var u_emission = shaderMaterialParams.uniforms.u_emission;

            if (u_emission) {
              if (u_emission.value.isTexture) {
                materialParams.emissiveMap = u_emission.value;
              } else materialParams.emissive = u_emission.value;
            }

            var u_shininess = shaderMaterialParams.uniforms.u_shininess;

            if (u_shininess) {
              materialParams.shininess = u_shininess.value;
            }
          }

          material = new materialType(materialParams);
        }

        if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.

        if (material.map) material.map.encoding = sRGBEncoding;
        if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;
        assignExtrasToUserData(material, materialDef);
        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
        return material;
      });
    };

    GLTFParser.prototype.loadGeometries = function (primitives) {
      var parser = this;
      var extensions = this.extensions;
      var cache = this.primitiveCache;

      function createDracoPrimitive(primitive) {
        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
          return addPrimitiveAttributes(geometry, primitive, parser);
        });
      }

      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var primitive = primitives[i];
        var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry

        var cached = cache[cacheKey];

        if (cached) {
          // Use the cached geometry if it exists
          pending.push(cached.promise);
        } else {
          var geometryPromise;

          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            // Use DRACO geometry if available
            geometryPromise = createDracoPrimitive(primitive);
          } else {
            // Otherwise create a new geometry
            geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
          } // Cache this geometry


          cache[cacheKey] = {
            primitive: primitive,
            promise: geometryPromise
          };
          pending.push(geometryPromise);
        }
      }

      return Promise.all(pending);
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
     * @param {number} meshIndex
     * @return {Promise<Group|Mesh|SkinnedMesh>}
     */


    GLTFParser.prototype.loadMesh = function (meshIndex) {
      var parser = this;
      var json = this.json;
      var meshDef = json.meshes[meshIndex];
      var primitives = meshDef.primitives;
      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
        pending.push(material);
      }

      pending.push(parser.loadGeometries(primitives));
      return Promise.all(pending).then(function (results) {
        var materials = results.slice(0, results.length - 1);
        var geometries = results[results.length - 1];
        var meshes = [];

        for (var i = 0, il = geometries.length; i < il; i++) {
          var geometry = geometries[i];
          var primitive = primitives[i]; // 1. create Mesh

          var mesh;
          var material = materials[i];

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
            // .isSkinnedMesh isn't in glTF spec. See .markDefs()
            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);

            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
              // we normalize floating point skin weight array to fix malformed assets (see #15319)
              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
              mesh.normalizeSkinWeights();
            }

            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new LineSegments(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new Line(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new LineLoop(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new Points(geometry, material);
          } else {
            throw new Error('THREE._GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
          }

          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }

          mesh.name = meshDef.name || 'mesh_' + meshIndex;
          if (geometries.length > 1) mesh.name += '_' + i;
          assignExtrasToUserData(mesh, meshDef);
          parser.assignFinalMaterial(mesh);
          meshes.push(mesh);
        }

        if (meshes.length === 1) {
          return meshes[0];
        }

        var group = new Group();

        for (var i = 0, il = meshes.length; i < il; i++) {
          group.add(meshes[i]);
        }

        return group;
      });
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
     * @param {number} cameraIndex
     * @return {Promise<THREE.Camera>}
     */


    GLTFParser.prototype.loadCamera = function (cameraIndex) {
      var camera;
      var cameraDef = this.json.cameras[cameraIndex];
      var params = cameraDef[cameraDef.type];

      if (!params) {
        console.warn('THREE._GLTFLoader: Missing camera parameters.');
        return;
      }

      if (cameraDef.type === 'perspective') {
        camera = new PerspectiveCamera(_Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
      } else if (cameraDef.type === 'orthographic') {
        camera = new OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);
      }

      if (cameraDef.name) camera.name = cameraDef.name;
      assignExtrasToUserData(camera, cameraDef);
      return Promise.resolve(camera);
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
     * @param {number} skinIndex
     * @return {Promise<Object>}
     */


    GLTFParser.prototype.loadSkin = function (skinIndex) {
      var skinDef = this.json.skins[skinIndex];
      var skinEntry = {
        joints: skinDef.joints
      };

      if (skinDef.inverseBindMatrices === undefined) {
        return Promise.resolve(skinEntry);
      }

      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
        skinEntry.inverseBindMatrices = accessor;
        return skinEntry;
      });
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
     * @param {number} animationIndex
     * @return {Promise<AnimationClip>}
     */


    GLTFParser.prototype.loadAnimation = function (animationIndex) {
      var json = this.json;
      var animationDef = json.animations[animationIndex];
      var pendingNodes = [];
      var pendingInputAccessors = [];
      var pendingOutputAccessors = [];
      var pendingSamplers = [];
      var pendingTargets = [];

      for (var i = 0, il = animationDef.channels.length; i < il; i++) {
        var channel = animationDef.channels[i];
        var sampler = animationDef.samplers[channel.sampler];
        var target = channel.target;
        var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

        var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
        var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
        pendingNodes.push(this.getDependency('node', name));
        pendingInputAccessors.push(this.getDependency('accessor', input));
        pendingOutputAccessors.push(this.getDependency('accessor', output));
        pendingSamplers.push(sampler);
        pendingTargets.push(target);
      }

      return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
        var nodes = dependencies[0];
        var inputAccessors = dependencies[1];
        var outputAccessors = dependencies[2];
        var samplers = dependencies[3];
        var targets = dependencies[4];
        var tracks = [];

        for (var i = 0, il = nodes.length; i < il; i++) {
          var node = nodes[i];
          var inputAccessor = inputAccessors[i];
          var outputAccessor = outputAccessors[i];
          var sampler = samplers[i];
          var target = targets[i];
          if (node === undefined) continue;
          node.updateMatrix();
          node.matrixAutoUpdate = true;
          var TypedKeyframeTrack;

          switch (PATH_PROPERTIES[target.path]) {
            case PATH_PROPERTIES.weights:
              TypedKeyframeTrack = NumberKeyframeTrack;
              break;

            case PATH_PROPERTIES.rotation:
              TypedKeyframeTrack = QuaternionKeyframeTrack;
              break;

            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
            default:
              TypedKeyframeTrack = VectorKeyframeTrack;
              break;
          }

          var targetName = node.name ? node.name : node.uuid;
          var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
          var targetNames = [];

          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
            // Node may be a Group (glTF mesh with several primitives) or a Mesh.
            node.traverse(function (object) {
              if (object.isMesh === true && object.morphTargetInfluences) {
                targetNames.push(object.name ? object.name : object.uuid);
              }
            });
          } else {
            targetNames.push(targetName);
          }

          var outputArray = outputAccessor.array;

          if (outputAccessor.normalized) {
            var scale;

            if (outputArray.constructor === Int8Array) {
              scale = 1 / 127;
            } else if (outputArray.constructor === Uint8Array) {
              scale = 1 / 255;
            } else if (outputArray.constructor == Int16Array) {
              scale = 1 / 32767;
            } else if (outputArray.constructor === Uint16Array) {
              scale = 1 / 65535;
            } else {
              throw new Error('THREE._GLTFLoader: Unsupported output accessor component type.');
            }

            var scaled = new Float32Array(outputArray.length);

            for (var j = 0, jl = outputArray.length; j < jl; j++) {
              scaled[j] = outputArray[j] * scale;
            }

            outputArray = scaled;
          }

          for (var j = 0, jl = targetNames.length; j < jl; j++) {
            var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.

            if (sampler.interpolation === 'CUBICSPLINE') {
              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                // must be divided by three to get the interpolant's sampleSize argument.
                return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
              }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.


              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
            }

            tracks.push(track);
          }
        }

        var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
        return new AnimationClip(name, undefined, tracks);
      });
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
     * @param {number} nodeIndex
     * @return {Promise<Object3D>}
     */


    GLTFParser.prototype.loadNode = function (nodeIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var parser = this;
      var meshReferences = json.meshReferences;
      var meshUses = json.meshUses;
      var nodeDef = json.nodes[nodeIndex];
      return function () {
        var pending = [];

        if (nodeDef.mesh !== undefined) {
          pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
            var node;

            if (meshReferences[nodeDef.mesh] > 1) {
              var instanceNum = meshUses[nodeDef.mesh]++;
              node = mesh.clone();
              node.name += '_instance_' + instanceNum;
            } else {
              node = mesh;
            } // if weights are provided on the node, override weights on the mesh.


            if (nodeDef.weights !== undefined) {
              node.traverse(function (o) {
                if (!o.isMesh) return;

                for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
                  o.morphTargetInfluences[i] = nodeDef.weights[i];
                }
              });
            }

            return node;
          }));
        }

        if (nodeDef.camera !== undefined) {
          pending.push(parser.getDependency('camera', nodeDef.camera));
        }

        if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {
          pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));
        }

        return Promise.all(pending);
      }().then(function (objects) {
        var node; // .isBone isn't in glTF spec. See .markDefs

        if (nodeDef.isBone === true) {
          node = new Bone();
        } else if (objects.length > 1) {
          node = new Group();
        } else if (objects.length === 1) {
          node = objects[0];
        } else {
          node = new Object3D();
        }

        if (node !== objects[0]) {
          for (var i = 0, il = objects.length; i < il; i++) {
            node.add(objects[i]);
          }
        }

        if (nodeDef.name) {
          node.userData.name = nodeDef.name;
          node.name = PropertyBinding.sanitizeNodeName(nodeDef.name);
        }

        assignExtrasToUserData(node, nodeDef);
        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

        if (nodeDef.matrix !== undefined) {
          var matrix = new Matrix4();
          matrix.fromArray(nodeDef.matrix);
          node.applyMatrix4(matrix);
        } else {
          if (nodeDef.translation !== undefined) {
            node.position.fromArray(nodeDef.translation);
          }

          if (nodeDef.rotation !== undefined) {
            node.quaternion.fromArray(nodeDef.rotation);
          }

          if (nodeDef.scale !== undefined) {
            node.scale.fromArray(nodeDef.scale);
          }
        }

        return node;
      });
    };
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
     * @param {number} sceneIndex
     * @return {Promise<Group>}
     */


    GLTFParser.prototype.loadScene = function () {
      // scene node hierachy builder
      function buildNodeHierachy(nodeId, parentObject, json, parser) {
        var nodeDef = json.nodes[nodeId];
        return parser.getDependency('node', nodeId).then(function (node) {
          if (nodeDef.skin === undefined) return node; // build skeleton here as well

          var skinEntry;
          return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
            skinEntry = skin;
            var pendingJoints = [];

            for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
              pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
            }

            return Promise.all(pendingJoints);
          }).then(function (jointNodes) {
            node.traverse(function (mesh) {
              if (!mesh.isMesh) return;
              var bones = [];
              var boneInverses = [];

              for (var j = 0, jl = jointNodes.length; j < jl; j++) {
                var jointNode = jointNodes[j];

                if (jointNode) {
                  bones.push(jointNode);
                  var mat = new Matrix4();

                  if (skinEntry.inverseBindMatrices !== undefined) {
                    mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                  }

                  boneInverses.push(mat);
                } else {
                  console.warn('THREE._GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
                }
              }

              mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
            });
            return node;
          });
        }).then(function (node) {
          // build node hierachy
          parentObject.add(node);
          var pending = [];

          if (nodeDef.children) {
            var children = nodeDef.children;

            for (var i = 0, il = children.length; i < il; i++) {
              var child = children[i];
              pending.push(buildNodeHierachy(child, node, json, parser));
            }
          }

          return Promise.all(pending);
        });
      }

      return function loadScene(sceneIndex) {
        var json = this.json;
        var extensions = this.extensions;
        var sceneDef = this.json.scenes[sceneIndex];
        var parser = this; // Loader returns Group, not Scene.
        // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172

        var scene = new Group();
        if (sceneDef.name) scene.name = sceneDef.name;
        assignExtrasToUserData(scene, sceneDef);
        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
        var nodeIds = sceneDef.nodes || [];
        var pending = [];

        for (var i = 0, il = nodeIds.length; i < il; i++) {
          pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
        }

        return Promise.all(pending).then(function () {
          return scene;
        });
      };
    }();
  }

  return new _GLTFLoader(manager);
};

exports.GLTFLoader = GLTFLoader;

},{"M_407":198,"s_332":233,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242,"M_110":245}],95:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RGBELoader = RGBELoader;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _esExtends = _interopRequireDefault(require("M_407"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format
var _RGBELoader;

function RGBELoader(manager) {
  if (!_RGBELoader) {
    var _THREE = THREE,
        DataTextureLoader = _THREE.DataTextureLoader,
        FloatType = 1015,
        HalfFloatType = 1016,
        LinearEncoding = 3000,
        LinearFilter = 1006,
        NearestFilter = 1003,
        RGBEEncoding = 3002,
        RGBEFormat = 1023,
        RGBFormat = 1022,
        UnsignedByteType = 1009;
    var _prototype_ = {
      // constructor: RGBELoader,
      // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
      parse: function parse(buffer) {
        var
        /* return codes for rgbe routines */
        //RGBE_RETURN_SUCCESS = 0,
        RGBE_RETURN_FAILURE = -1,

        /* default error routine.  change this to change error handling */
        rgbe_read_error = 1,
            rgbe_write_error = 2,
            rgbe_format_error = 3,
            rgbe_memory_error = 4,
            rgbe_error = function rgbe_error(rgbe_error_code, msg) {
          switch (rgbe_error_code) {
            case rgbe_read_error:
              console.error("RGBELoader Read Error: " + (msg || ''));
              break;

            case rgbe_write_error:
              console.error("RGBELoader Write Error: " + (msg || ''));
              break;

            case rgbe_format_error:
              console.error("RGBELoader Bad File Format: " + (msg || ''));
              break;

            default:
            case rgbe_memory_error:
              console.error("RGBELoader: Error: " + (msg || ''));
          }

          return RGBE_RETURN_FAILURE;
        },

        /* offsets to red, green, and blue components in a data (float) pixel */
        //RGBE_DATA_RED = 0,
        //RGBE_DATA_GREEN = 1,
        //RGBE_DATA_BLUE = 2,

        /* number of floats per pixel, use 4 since stored in rgba image format */
        //RGBE_DATA_SIZE = 4,

        /* flags indicating which fields in an rgbe_header_info are valid */
        RGBE_VALID_PROGRAMTYPE = 1,
            RGBE_VALID_FORMAT = 2,
            RGBE_VALID_DIMENSIONS = 4,
            NEWLINE = "\n",
            fgets = function fgets(buffer, lineLimit, consume) {
          lineLimit = !lineLimit ? 1024 : lineLimit;
          var p = buffer.pos,
              i = -1,
              len = 0,
              s = '',
              chunkSize = 128,
              chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));

          while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {
            s += chunk;
            len += chunk.length;
            p += chunkSize;
            chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
          }

          if (-1 < i) {
            /*for (i=l-1; i>=0; i--) {
            	byteCode = m.charCodeAt(i);
            	if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
            	else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
            	if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
            }*/
            if (false !== consume) buffer.pos += len + i + 1;
            return s + chunk.slice(0, i);
          }

          return false;
        },

        /* minimal header reading.  modify if you want to parse more information */
        RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {
          var line,
              match,
              // regexes to parse header info fields
          magic_token_re = /^#\?(\S+)$/,
              gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
              exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
              format_re = /^\s*FORMAT=(\S+)\s*$/,
              dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
              // RGBE format header struct
          header = {
            valid: 0,

            /* indicate which fields are valid */
            string: '',

            /* the actual header string */
            comments: '',

            /* comments found in header */
            programtype: 'RGBE',

            /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
            format: '',

            /* RGBE format, default 32-bit_rle_rgbe */
            gamma: 1.0,

            /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
            exposure: 1.0,

            /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
            width: 0,
            height: 0
            /* image dimensions, width/height */

          };

          if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {
            return rgbe_error(rgbe_read_error, "no header found");
          }
          /* if you want to require the magic token then uncomment the next line */


          if (!(match = line.match(magic_token_re))) {
            return rgbe_error(rgbe_format_error, "bad initial token");
          }

          header.valid |= RGBE_VALID_PROGRAMTYPE;
          header.programtype = match[1];
          header.string += line + "\n";

          while (true) {
            line = fgets(buffer);
            if (false === line) break;
            header.string += line + "\n";

            if ('#' === line.charAt(0)) {
              header.comments += line + "\n";
              continue; // comment line
            }

            if (match = line.match(gamma_re)) {
              header.gamma = parseFloat(match[1], 10);
            }

            if (match = line.match(exposure_re)) {
              header.exposure = parseFloat(match[1], 10);
            }

            if (match = line.match(format_re)) {
              header.valid |= RGBE_VALID_FORMAT;
              header.format = match[1]; //'32-bit_rle_rgbe';
            }

            if (match = line.match(dimensions_re)) {
              header.valid |= RGBE_VALID_DIMENSIONS;
              header.height = parseInt(match[1], 10);
              header.width = parseInt(match[2], 10);
            }

            if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
          }

          if (!(header.valid & RGBE_VALID_FORMAT)) {
            return rgbe_error(rgbe_format_error, "missing format specifier");
          }

          if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
            return rgbe_error(rgbe_format_error, "missing image size specifier");
          }

          return header;
        },
            RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {
          var data_rgba,
              offset,
              pos,
              count,
              byteValue,
              scanline_buffer,
              ptr,
              ptr_end,
              i,
              l,
              off,
              isEncodedRun,
              scanline_width = w,
              num_scanlines = h,
              rgbeStart;

          if ( // run length encoding is not allowed so read flat
          scanline_width < 8 || scanline_width > 0x7fff || 2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {
            // return the flat buffer
            return new Uint8Array(buffer);
          }

          if (scanline_width !== (buffer[2] << 8 | buffer[3])) {
            return rgbe_error(rgbe_format_error, "wrong scanline width");
          }

          data_rgba = new Uint8Array(4 * w * h);

          if (!data_rgba || !data_rgba.length) {
            return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
          }

          offset = 0;
          pos = 0;
          ptr_end = 4 * scanline_width;
          rgbeStart = new Uint8Array(4);
          scanline_buffer = new Uint8Array(ptr_end); // read in each successive scanline

          while (num_scanlines > 0 && pos < buffer.byteLength) {
            if (pos + 4 > buffer.byteLength) {
              return rgbe_error(rgbe_read_error);
            }

            rgbeStart[0] = buffer[pos++];
            rgbeStart[1] = buffer[pos++];
            rgbeStart[2] = buffer[pos++];
            rgbeStart[3] = buffer[pos++];

            if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
              return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
            } // read each of the four channels for the scanline into the buffer
            // first red, then green, then blue, then exponent


            ptr = 0;

            while (ptr < ptr_end && pos < buffer.byteLength) {
              count = buffer[pos++];
              isEncodedRun = count > 128;
              if (isEncodedRun) count -= 128;

              if (0 === count || ptr + count > ptr_end) {
                return rgbe_error(rgbe_format_error, "bad scanline data");
              }

              if (isEncodedRun) {
                // a (encoded) run of the same value
                byteValue = buffer[pos++];

                for (i = 0; i < count; i++) {
                  scanline_buffer[ptr++] = byteValue;
                } //ptr += count;

              } else {
                // a literal-run
                scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
                ptr += count;
                pos += count;
              }
            } // now convert data from buffer into rgba
            // first red, then green, then blue, then exponent (alpha)


            l = scanline_width; //scanline_buffer.byteLength;

            for (i = 0; i < l; i++) {
              off = 0;
              data_rgba[offset] = scanline_buffer[i + off];
              off += scanline_width; //1;

              data_rgba[offset + 1] = scanline_buffer[i + off];
              off += scanline_width; //1;

              data_rgba[offset + 2] = scanline_buffer[i + off];
              off += scanline_width; //1;

              data_rgba[offset + 3] = scanline_buffer[i + off];
              offset += 4;
            }

            num_scanlines--;
          }

          return data_rgba;
        };

        var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {
          var e = sourceArray[sourceOffset + 3];
          var scale = Math.pow(2.0, e - 128.0) / 255.0;
          destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
          destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
          destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
        };

        var RGBEByteToRGBHalf = function () {
          // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
          var floatView = new Float32Array(1);
          var int32View = new Int32Array(floatView.buffer);
          /* This method is faster than the OpenEXR implementation (very often
           * used, eg. in Ogre), with the additional benefit of rounding, inspired
           * by James Tursa?s half-precision code. */

          function toHalf(val) {
            floatView[0] = val;
            var x = int32View[0];
            var bits = x >> 16 & 0x8000;
            /* Get the sign */

            var m = x >> 12 & 0x07ff;
            /* Keep one extra bit for rounding */

            var e = x >> 23 & 0xff;
            /* Using int is faster here */

            /* If zero, or denormal, or exponent underflows too much for a denormal
             * half, return signed zero. */

            if (e < 103) return bits;
            /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

            if (e > 142) {
              bits |= 0x7c00;
              /* If exponent was 0xff and one mantissa bit was set, it means NaN,
              		 * not Inf, so make sure we set one mantissa bit too. */

              bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
              return bits;
            }
            /* If exponent underflows but not too much, return a denormal */


            if (e < 113) {
              m |= 0x0800;
              /* Extra rounding may overflow and set mantissa to 0 and exponent
               * to 1, which is OK. */

              bits |= (m >> 114 - e) + (m >> 113 - e & 1);
              return bits;
            }

            bits |= e - 112 << 10 | m >> 1;
            /* Extra rounding. An overflow will set mantissa to 0 and increment
             * the exponent, which is OK. */

            bits += m & 1;
            return bits;
          }

          return function (sourceArray, sourceOffset, destArray, destOffset) {
            var e = sourceArray[sourceOffset + 3];
            var scale = Math.pow(2.0, e - 128.0) / 255.0;
            destArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);
            destArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);
            destArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);
          };
        }();

        var byteArray = new Uint8Array(buffer);
        byteArray.pos = 0;
        var rgbe_header_info = RGBE_ReadHeader(byteArray);

        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
          var w = rgbe_header_info.width,
              h = rgbe_header_info.height,
              image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);

          if (RGBE_RETURN_FAILURE !== image_rgba_data) {
            switch (this.type) {
              case UnsignedByteType:
                var data = image_rgba_data;
                var format = RGBEFormat; // handled as 1023 in shaders

                var type = UnsignedByteType;
                break;

              case FloatType:
                var numElements = image_rgba_data.length / 4 * 3;
                var floatArray = new Float32Array(numElements);

                for (var j = 0; j < numElements; j++) {
                  RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);
                }

                var data = floatArray;
                var format = RGBFormat;
                var type = FloatType;
                break;

              case HalfFloatType:
                var numElements = image_rgba_data.length / 4 * 3;
                var halfArray = new Uint16Array(numElements);

                for (var j = 0; j < numElements; j++) {
                  RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);
                }

                var data = halfArray;
                var format = RGBFormat;
                var type = HalfFloatType;
                break;

              default:
                console.error('THREE.RGBELoader: unsupported type: ', this.type);
                break;
            }

            return {
              width: w,
              height: h,
              data: data,
              header: rgbe_header_info.string,
              gamma: rgbe_header_info.gamma,
              exposure: rgbe_header_info.exposure,
              format: format,
              type: type
            };
          }
        }

        return null;
      },
      setDataType: function setDataType(value) {
        this.type = value;
        return this;
      },
      load: function load(url, onLoad, onProgress, onError) {
        function onLoadCallback(texture, texData) {
          switch (texture.type) {
            case UnsignedByteType:
              texture.encoding = RGBEEncoding;
              texture.minFilter = NearestFilter;
              texture.magFilter = NearestFilter;
              texture.generateMipmaps = false;
              texture.flipY = true;
              break;

            case FloatType:
              texture.encoding = LinearEncoding;
              texture.minFilter = LinearFilter;
              texture.magFilter = LinearFilter;
              texture.generateMipmaps = false;
              texture.flipY = true;
              break;

            case HalfFloatType:
              texture.encoding = LinearEncoding;
              texture.minFilter = LinearFilter;
              texture.magFilter = LinearFilter;
              texture.generateMipmaps = false;
              texture.flipY = true;
              break;
          }

          if (onLoad) onLoad(texture, texData);
        }

        return DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);
      }
    };
    _RGBELoader = (0, _esExtends["default"])(DataTextureLoader, {
      esConstructor: function esConstructor() {
        var _esCtor = /*#__PURE__*/function (_DataTextureLoader) {
          (0, _inherits2["default"])(_esCtor, _DataTextureLoader);

          var _super = _createSuper(_esCtor);

          function _esCtor(manager) {
            var _this;

            (0, _classCallCheck2["default"])(this, _esCtor);
            _this = _super.call(this, manager);
            constructor.call((0, _assertThisInitialized2["default"])(_this), manager);
            return _this;
          }

          return _esCtor;
        }(DataTextureLoader);

        return _esCtor;
      },
      constructor: function constructor(manager) {
        this.type = UnsignedByteType;
      },
      prototype: _prototype_
    });
  }

  return new _RGBELoader(manager);
}

},{"M_407":198,"s_332":233,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],96:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TGALoader = TGALoader;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _esExtends = _interopRequireDefault(require("M_407"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 * @author mrdoob / http://mrdoob.com/
 * @author takahirox / https://github.com/takahirox/
 */
// import {
var FileLoader, Loader, Texture; // } from "../../../build/three.module.js";

var _TGALoader;

function TGALoader(manager) {
  if (!_TGALoader) {
    var _THREE = THREE,
        _FileLoader = _THREE.FileLoader,
        _Loader = _THREE.Loader,
        _Texture = _THREE.Texture;
    var _TGALoaderPrototype_ = {
      load: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new _Texture();
        var loader = new _FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(this.path);
        loader.load(url, function (buffer) {
          texture.image = scope.parse(buffer);
          texture.needsUpdate = true;

          if (onLoad !== undefined) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      },
      parse: function parse(buffer) {
        // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js
        function tgaCheckHeader(header) {
          switch (header.image_type) {
            // check indexed type
            case TGA_TYPE_INDEXED:
            case TGA_TYPE_RLE_INDEXED:
              if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {
                console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');
              }

              break;
            // check colormap type

            case TGA_TYPE_RGB:
            case TGA_TYPE_GREY:
            case TGA_TYPE_RLE_RGB:
            case TGA_TYPE_RLE_GREY:
              if (header.colormap_type) {
                console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');
              }

              break;
            // What the need of a file without data ?

            case TGA_TYPE_NO_DATA:
              console.error('THREE.TGALoader: No data.');
            // Invalid type ?

            default:
              console.error('THREE.TGALoader: Invalid type "%s".', header.image_type);
          } // check image width and height


          if (header.width <= 0 || header.height <= 0) {
            console.error('THREE.TGALoader: Invalid image size.');
          } // check image pixel size


          if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {
            console.error('THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size);
          }
        } // parse tga image buffer


        function tgaParse(use_rle, use_pal, header, offset, data) {
          var pixel_data, pixel_size, pixel_total, palettes;
          pixel_size = header.pixel_size >> 3;
          pixel_total = header.width * header.height * pixel_size; // read palettes

          if (use_pal) {
            palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
          } // read RLE


          if (use_rle) {
            pixel_data = new Uint8Array(pixel_total);
            var c, count, i;
            var shift = 0;
            var pixels = new Uint8Array(pixel_size);

            while (shift < pixel_total) {
              c = data[offset++];
              count = (c & 0x7f) + 1; // RLE pixels

              if (c & 0x80) {
                // bind pixel tmp array
                for (i = 0; i < pixel_size; ++i) {
                  pixels[i] = data[offset++];
                } // copy pixel array


                for (i = 0; i < count; ++i) {
                  pixel_data.set(pixels, shift + i * pixel_size);
                }

                shift += pixel_size * count;
              } else {
                // raw pixels
                count *= pixel_size;

                for (i = 0; i < count; ++i) {
                  pixel_data[shift + i] = data[offset++];
                }

                shift += count;
              }
            }
          } else {
            // raw pixels
            pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
          }

          return {
            pixel_data: pixel_data,
            palettes: palettes
          };
        }

        function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
          var colormap = palettes;
          var color,
              i = 0,
              x,
              y;
          var width = header.width;

          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i++) {
              color = image[i];
              imageData[(x + width * y) * 4 + 3] = 255;
              imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
              imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
              imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
            }
          }

          return imageData;
        }

        function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          var color,
              i = 0,
              x,
              y;
          var width = header.width;

          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 2) {
              color = image[i + 0] + (image[i + 1] << 8); // Inversed ?

              imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
              imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
              imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
              imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;
            }
          }

          return imageData;
        }

        function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          var i = 0,
              x,
              y;
          var width = header.width;

          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 3) {
              imageData[(x + width * y) * 4 + 3] = 255;
              imageData[(x + width * y) * 4 + 2] = image[i + 0];
              imageData[(x + width * y) * 4 + 1] = image[i + 1];
              imageData[(x + width * y) * 4 + 0] = image[i + 2];
            }
          }

          return imageData;
        }

        function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          var i = 0,
              x,
              y;
          var width = header.width;

          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 4) {
              imageData[(x + width * y) * 4 + 2] = image[i + 0];
              imageData[(x + width * y) * 4 + 1] = image[i + 1];
              imageData[(x + width * y) * 4 + 0] = image[i + 2];
              imageData[(x + width * y) * 4 + 3] = image[i + 3];
            }
          }

          return imageData;
        }

        function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          var color,
              i = 0,
              x,
              y;
          var width = header.width;

          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i++) {
              color = image[i];
              imageData[(x + width * y) * 4 + 0] = color;
              imageData[(x + width * y) * 4 + 1] = color;
              imageData[(x + width * y) * 4 + 2] = color;
              imageData[(x + width * y) * 4 + 3] = 255;
            }
          }

          return imageData;
        }

        function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
          var i = 0,
              x,
              y;
          var width = header.width;

          for (y = y_start; y !== y_end; y += y_step) {
            for (x = x_start; x !== x_end; x += x_step, i += 2) {
              imageData[(x + width * y) * 4 + 0] = image[i + 0];
              imageData[(x + width * y) * 4 + 1] = image[i + 0];
              imageData[(x + width * y) * 4 + 2] = image[i + 0];
              imageData[(x + width * y) * 4 + 3] = image[i + 1];
            }
          }

          return imageData;
        }

        function getTgaRGBA(data, width, height, image, palette) {
          var x_start, y_start, x_step, y_step, x_end, y_end;

          switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
            default:
            case TGA_ORIGIN_UL:
              x_start = 0;
              x_step = 1;
              x_end = width;
              y_start = 0;
              y_step = 1;
              y_end = height;
              break;

            case TGA_ORIGIN_BL:
              x_start = 0;
              x_step = 1;
              x_end = width;
              y_start = height - 1;
              y_step = -1;
              y_end = -1;
              break;

            case TGA_ORIGIN_UR:
              x_start = width - 1;
              x_step = -1;
              x_end = -1;
              y_start = 0;
              y_step = 1;
              y_end = height;
              break;

            case TGA_ORIGIN_BR:
              x_start = width - 1;
              x_step = -1;
              x_end = -1;
              y_start = height - 1;
              y_step = -1;
              y_end = -1;
              break;
          }

          if (use_grey) {
            switch (header.pixel_size) {
              case 8:
                tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;

              case 16:
                tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;

              default:
                console.error('THREE.TGALoader: Format not supported.');
                break;
            }
          } else {
            switch (header.pixel_size) {
              case 8:
                tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
                break;

              case 16:
                tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;

              case 24:
                tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;

              case 32:
                tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                break;

              default:
                console.error('THREE.TGALoader: Format not supported.');
                break;
            }
          } // Load image data according to specific method
          // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
          // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );


          return data;
        } // TGA constants


        var TGA_TYPE_NO_DATA = 0,
            TGA_TYPE_INDEXED = 1,
            TGA_TYPE_RGB = 2,
            TGA_TYPE_GREY = 3,
            TGA_TYPE_RLE_INDEXED = 9,
            TGA_TYPE_RLE_RGB = 10,
            TGA_TYPE_RLE_GREY = 11,
            TGA_ORIGIN_MASK = 0x30,
            TGA_ORIGIN_SHIFT = 0x04,
            TGA_ORIGIN_BL = 0x00,
            TGA_ORIGIN_BR = 0x01,
            TGA_ORIGIN_UL = 0x02,
            TGA_ORIGIN_UR = 0x03;
        if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');
        var content = new Uint8Array(buffer),
            offset = 0,
            header = {
          id_length: content[offset++],
          colormap_type: content[offset++],
          image_type: content[offset++],
          colormap_index: content[offset++] | content[offset++] << 8,
          colormap_length: content[offset++] | content[offset++] << 8,
          colormap_size: content[offset++],
          origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],
          width: content[offset++] | content[offset++] << 8,
          height: content[offset++] | content[offset++] << 8,
          pixel_size: content[offset++],
          flags: content[offset++]
        }; // check tga if it is valid format

        tgaCheckHeader(header);

        if (header.id_length + offset > buffer.length) {
          console.error('THREE.TGALoader: No data.');
        } // skip the needn't data


        offset += header.id_length; // get targa information about RLE compression and palette

        var use_rle = false,
            use_pal = false,
            use_grey = false;

        switch (header.image_type) {
          case TGA_TYPE_RLE_INDEXED:
            use_rle = true;
            use_pal = true;
            break;

          case TGA_TYPE_INDEXED:
            use_pal = true;
            break;

          case TGA_TYPE_RLE_RGB:
            use_rle = true;
            break;

          case TGA_TYPE_RGB:
            break;

          case TGA_TYPE_RLE_GREY:
            use_rle = true;
            use_grey = true;
            break;

          case TGA_TYPE_GREY:
            use_grey = true;
            break;
        } //


        var useOffscreen = typeof OffscreenCanvas !== 'undefined';
        var canvas = useOffscreen ? new OffscreenCanvas(header.width, header.height) : document.createElement('canvas');
        canvas.width = header.width;
        canvas.height = header.height;
        var context = canvas.getContext('2d');
        var imageData = context.createImageData(header.width, header.height);
        var result = tgaParse(use_rle, use_pal, header, offset, content);
        var rgbaData = getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);
        context.putImageData(imageData, 0, 0);
        return useOffscreen ? canvas.transferToImageBitmap() : canvas;
      }
    };
    _TGALoader = (0, _esExtends["default"])(_Loader, {
      esConstructor: function esConstructor(constructor) {
        var _esCtor = /*#__PURE__*/function (_Loader2) {
          (0, _inherits2["default"])(_esCtor, _Loader2);

          var _super = _createSuper(_esCtor);

          function _esCtor(manager) {
            var _this;

            (0, _classCallCheck2["default"])(this, _esCtor);
            _this = _super.call(this, manager);
            constructor.call((0, _assertThisInitialized2["default"])(_this), manager);
            return _this;
          }

          return _esCtor;
        }(_Loader);

        return _esCtor;
      },
      constructor: function constructor(manager) {},
      prototype: _TGALoaderPrototype_
    });
  }

  return new _TGALoader(manager);
}

},{"M_407":198,"s_332":233,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],97:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Base64Encoder = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var Base64Encoder = /*#__PURE__*/function () {
  function Base64Encoder() {
    (0, _classCallCheck2["default"])(this, Base64Encoder);
  }

  (0, _createClass2["default"])(Base64Encoder, null, [{
    key: "decodeArray",
    value: function decodeArray(encodedData) {
      var positions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (encodedData.length === 0) return new Buffer(0);
      var buf,
          buffers = [],
          size = 0;

      for (var i = 0; i < encodedData.length; i++) {
        if (typeof Buffer.from === "function") {
          // Node 5.10+
          buf = Buffer.from(encodedData[i], 'base64');
        } else {
          // older Node versions
          buf = new Buffer(encodedData[i], 'base64');
        }

        size += buf.length;
        positions.push(size);
        buffers.push(buf);
      }

      if (encodedData.length === 1) {
        return buffers[0];
      }

      var fullBuffer = new Buffer(size),
          pos = 0;

      for (var _i = 0; _i < encodedData.length; _i++) {
        buffers[_i].copy(fullBuffer, pos);

        pos += buffers[_i].length;
      }

      return fullBuffer;
    }
  }]);
  return Base64Encoder;
}();

exports.Base64Encoder = Base64Encoder;

}).call(this)}).call(this,require("buffer").Buffer)

},{"e_1":235,"s_2":236,"M_0":241,"buffer":248}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Constants = void 0;
var Constants = {
  INDENT_VALUE: 2,
  Sizes: {
    BOOL_SIZE: 1,
    CHAR_SIZE: 1,
    SHORT_SIZE: 2,
    INT_SIZE: 4,
    LONG_SIZE: 4,
    INT64_SIZE: 8,
    FLOAT_SIZE: 4,
    DOUBLE_SIZE: 8,
    GLENUM_SIZE: 4
  },
  TypeIds: {
    ID_BYTE_ARRAY: 0,
    ID_UBYTE_ARRAY: 1,
    ID_SHORT_ARRAY: 2,
    ID_USHORT_ARRAY: 3,
    ID_INT_ARRAY: 4,
    ID_UINT_ARRAY: 5,
    ID_FLOAT_ARRAY: 6,
    ID_DOUBLE_ARRAY: 7,
    ID_VEC2B_ARRAY: 8,
    ID_VEC3B_ARRAY: 9,
    ID_VEC4B_ARRAY: 10,
    ID_VEC4UB_ARRAY: 11,
    ID_VEC2S_ARRAY: 12,
    ID_VEC3S_ARRAY: 13,
    ID_VEC4S_ARRAY: 14,
    ID_VEC2_ARRAY: 15,
    ID_VEC3_ARRAY: 16,
    ID_VEC4_ARRAY: 17,
    ID_VEC2D_ARRAY: 18,
    ID_VEC3D_ARRAY: 19,
    ID_VEC4D_ARRAY: 20,
    ID_VEC2UB_ARRAY: 21,
    ID_VEC3UB_ARRAY: 22,
    ID_VEC2US_ARRAY: 23,
    ID_VEC3US_ARRAY: 24,
    ID_VEC4US_ARRAY: 25,
    ID_VEC2I_ARRAY: 26,
    ID_VEC3I_ARRAY: 27,
    ID_VEC4I_ARRAY: 28,
    ID_VEC2UI_ARRAY: 29,
    ID_VEC3UI_ARRAY: 30,
    ID_VEC4UI_ARRAY: 31,
    ID_UINT64_ARRAY: 32,
    ID_INT64_ARRAY: 33,
    ID_DRAWARRAYS: 50,
    ID_DRAWARRAY_LENGTH: 51,
    ID_DRAWELEMENTS_UBYTE: 52,
    ID_DRAWELEMENTS_USHORT: 53,
    ID_DRAWELEMENTS_UINT: 54
  }
};
exports.Constants = Constants;

},{}],99:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataTypes = exports.ObjectProperty = exports.ObjectMark = exports.ObjectGLEnum = void 0;

var _createClass2 = _interopRequireDefault(require("s_2"));

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var ObjectGLEnum = function ObjectGLEnum() {
  var _value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  (0, _classCallCheck2["default"])(this, ObjectGLEnum);
  this.value = _value;
};

exports.ObjectGLEnum = ObjectGLEnum;

var ObjectMark = function ObjectMark(_name) {
  var _indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  (0, _classCallCheck2["default"])(this, ObjectMark);
  this.name = _name;
  this.indent = _indent;
};

exports.ObjectMark = ObjectMark;

var ObjectProperty = /*#__PURE__*/function () {
  function ObjectProperty(_name) {
    var _value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var _mapProperty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    (0, _classCallCheck2["default"])(this, ObjectProperty);
    this.name = _name;
    this.value = _value;
    this.mapProperty = _mapProperty;
  }

  (0, _createClass2["default"])(ObjectProperty, [{
    key: "set",
    value: function set(_value) {
      if (typeof _value === "string") this.name = _value;else if (typeof _value === "number") this.value = _value;
      return this;
    }
  }]);
  return ObjectProperty;
}();

exports.ObjectProperty = ObjectProperty;
var DataTypes = {
  ObjectProperty: ObjectProperty,
  ObjectMark: ObjectMark,
  ObjectGLEnum: ObjectGLEnum
};
exports.DataTypes = DataTypes;

},{"e_1":235,"s_2":236,"M_0":241}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Log = void 0;
var LEVELS = {
  LOG: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4
};
var logHandler = null;

function applyLog(message, level) {
  var messagePrefix = "";

  if (level > LEVELS.LOG) {
    messagePrefix = Object.keys(LEVELS).filter(function (key) {
      return LEVELS[key] === level;
    }) + " : ";
  }

  if (level > Log.level) {
    console.log(messagePrefix + message);
  }

  if (logHandler) {
    try {
      logHandler(message, level);
    } catch (e) {}
  }
}

var Log = function Log(message) {
  return applyLog(message, LEVELS.LOG);
};

exports.Log = Log;

Log.log = function (message) {
  return applyLog(message, LEVELS.LOG);
};

Log.warn = function (message) {
  return applyLog(message, LEVELS.WARN);
};

Log.error = function (message) {
  return applyLog(message, LEVELS.ERROR);
};

Log.fatal = function (message) {
  return applyLog(message, LEVELS.FATAL);
};

Log.setLogLog = function () {
  Log.level = LEVELS.LOG;
};

Log.setLogWarn = function () {
  Log.level = LEVELS.WARN;
};

Log.setLogError = function () {
  Log.level = LEVELS.ERROR;
};

Log.setLogFatal = function () {
  Log.level = LEVELS.FATAL;
};

Log.setLogOff = function () {
  Log.level = Number.MAX_VALUE;
}; // Default logger - Warning


Log.level = LEVELS.WARN;

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayTableEnum = void 0;
var ArrayTableEnum = {
  ByteArray: 0,
  UByteArray: 1,
  ShortArray: 2,
  UShortArray: 3,
  IntArray: 4,
  UIntArray: 5,
  FloatArray: 6,
  DoubleArray: 7,
  Vec2bArray: 8,
  Vec3bArray: 9,
  Vec4bArray: 10,
  Vec2ubArray: 21,
  Vec3ubArray: 22,
  Vec4ubArray: 11,
  Vec2sArray: 12,
  Vec3sArray: 13,
  Vec4sArray: 14,
  Vec2usArray: 23,
  Vec3usArray: 24,
  Vec4usArray: 25,
  Vec2fArray: 15,
  Vec3fArray: 16,
  Vec4fArray: 17,
  Vec2dArray: 18,
  Vec3dArray: 19,
  Vec4dArray: 20,
  Vec2iArray: 26,
  Vec3iArray: 27,
  Vec4iArray: 28,
  Vec2uiArray: 29,
  Vec3uiArray: 30,
  Vec4uiArray: 31
};
exports.ArrayTableEnum = ArrayTableEnum;

},{}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttributeBinding = void 0;
var AttributeBinding = {
  BIND_OFF: 0,
  // ADD_USER_VALUE("ADD_USER_VALUE( BIND_OFF );
  BIND_OVERALL: 1,
  // ADD_USER_VALUE( BIND_OVERALL );
  BIND_PER_PRIMITIVE_SET: 2,
  // ADD_USER_VALUE( BIND_PER_PRIMITIVE_SET );
  BIND_PER_PRIMITIVE: 3,
  //ADD_USER_VALUE( BIND_PER_PRIMITIVE );
  BIND_PER_VERTEX: 4 // ADD_USER_VALUE( BIND_PER_VERTEX );

};
exports.AttributeBinding = AttributeBinding;

},{}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CenterMode = void 0;
var CenterMode = {
  /**
   * Uses the bounding sphere's center as the center of object and the geometrical bounding sphere of the node's children
   */
  USE_BOUNDING_SPHERE_CENTER: 0,

  /**
   * Uses the user defined center as the center of object; the bounding sphere is determined by the user defined center and user defined radius
   */
  USER_DEFINED_CENTER: 1,

  /**
   * Uses the user defined center as the center of object; the bounding sphere is the user defined bounding sphere expanded by the geometrical bounding sphere of the node's children
   */
  UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED: 2
};
exports.CenterMode = CenterMode;

},{}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceMode = void 0;

var _GLEnum = require("M_451");

var FaceMode = {
  FRONT: _GLEnum.GLEnum.FRONT,
  BACK: _GLEnum.GLEnum.BACK,
  FRONT_AND_BACK: _GLEnum.GLEnum.FRONT_AND_BACK
};
exports.FaceMode = FaceMode;

},{"M_451":106}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnumToString = EnumToString;

function EnumToString(enumMap, enumVal) {
  for (var key in enumMap) {
    if (enumMap[key] == enumVal) {
      return key;
    }
  }
}

},{}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLEnum = void 0;
var GLEnum = {
  // Modes
  GL_ALPHA_TEST: 0x0BC0,
  GL_BLEND: 0x0BE2,
  GL_COLOR_LOGIC_OP: 0x0BF2,
  GL_COLOR_MATERIAL: 0x0B57,
  GL_CULL_FACE: 0x0B44,
  GL_DEPTH_TEST: 0x0B71,
  GL_FOG: 0x0B60,
  GL_FRAGMENT_PROGRAM_ARB: 0x8804,
  GL_LINE_STIPPLE: 0x0B24,
  GL_POINT_SMOOTH: 0x0B10,
  GL_POINT_SPRITE_ARB: 0x8861,
  GL_POLYGON_OFFSET_FILL: 0x8037,
  GL_POLYGON_OFFSET_LINE: 0x2A02,
  GL_POLYGON_OFFSET_POINT: 0x2A01,
  GL_POLYGON_STIPPLE: 0x0B42,
  GL_SCISSOR_TEST: 0x0C11,
  GL_STENCIL_TEST: 0x0B90,
  GL_STENCIL_TEST_TWO_SIDE: 0x8910,
  GL_VERTEX_PROGRAM_ARB: 0x8620,
  GL_COLOR_SUM: 0x8458,
  GL_LIGHTING: 0x0B50,
  GL_NORMALIZE: 0x0BA1,
  GL_RESCALE_NORMAL: 0x803A,
  GL_TEXTURE_1D: 0x0DE0,
  GL_TEXTURE_2D: 0x0DE1,
  GL_TEXTURE_3D: 0x806F,
  GL_TEXTURE_CUBE_MAP: 0x8513,
  GL_TEXTURE_RECTANGLE: 0x84F5,
  GL_TEXTURE_GEN_Q: 0x0C63,
  GL_TEXTURE_GEN_R: 0x0C62,
  GL_TEXTURE_GEN_S: 0x0C60,
  GL_TEXTURE_GEN_T: 0x0C61,
  GL_CLIP_PLANE0: 0x3000,
  GL_CLIP_PLANE1: 0x3001,
  GL_CLIP_PLANE2: 0x3002,
  GL_CLIP_PLANE3: 0x3003,
  GL_CLIP_PLANE4: 0x3004,
  GL_CLIP_PLANE5: 0x3005,
  GL_LIGHT0: 0x4000,
  GL_LIGHT1: 0x4001,
  GL_LIGHT2: 0x4002,
  GL_LIGHT3: 0x4003,
  GL_LIGHT4: 0x4004,
  GL_LIGHT5: 0x4005,
  GL_LIGHT6: 0x4006,
  GL_LIGHT7: 0x4007,
  GL_VERTEX_PROGRAM_POINT_SIZE: 0x8642,
  GL_VERTEX_PROGRAM_TWO_SIDE: 0x8643,
  // Functions
  NEVER: 0x0200,
  LESS: 0x0201,
  EQUAL: 0x0202,
  LEQUAL: 0x0203,
  GREATER: 0x0204,
  NOTEQUAL: 0x0205,
  GEQUAL: 0x0206,
  ALWAYS: 0x0207,
  // Texture environment states
  REPLACE: 0x1E01,
  MODULATE: 0x2100,
  ADD: 0x0104,
  ADD_SIGNED: 0x8574,
  INTERPOLATE: 0x8575,
  SUBTRACT: 0x84E7,
  DOT3_RGB: 0x86AE,
  DOT3_RGBA: 0x86AF,
  CONSTANT: 0x8576,
  PRIMARY_COLOR: 0x8577,
  PREVIOUS: 0x8578,
  TEXTURE: 0x1702,
  TEXTURE0: 0x84C0,
  TEXTURE1: 0x84C1,
  TEXTURE2: 0x84C2,
  TEXTURE3: 0x84C3,
  TEXTURE4: 0x84C4,
  TEXTURE5: 0x84C5,
  TEXTURE6: 0x84C6,
  TEXTURE7: 0x84C7,
  // Texture clamp modes
  CLAMP: 0x2900,
  CLAMP_TO_EDGE: 0x812F,
  CLAMP_TO_BORDER: 0x812D,
  REPEAT: 0x2901,
  MIRROR: 0x8370,
  // Texture filter modes
  LINEAR: 0x2601,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST: 0x2600,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  // Texture formats
  GL_INTENSITY: 0x8049,
  GL_LUMINANCE: 0x1909,
  GL_ALPHA: 0x1906,
  GL_LUMINANCE_ALPHA: 0x190A,
  GL_RGB: 0x1907,
  GL_RGBA: 0x1908,
  GL_COMPRESSED_ALPHA_ARB: 0x84E9,
  GL_COMPRESSED_LUMINANCE_ARB: 0x84EA,
  GL_COMPRESSED_INTENSITY_ARB: 0x84EC,
  GL_COMPRESSED_LUMINANCE_ALPHA_ARB: 0x84EB,
  GL_COMPRESSED_RGB_ARB: 0x84ED,
  GL_COMPRESSED_RGBA_ARB: 0x84EE,
  GL_COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0,
  GL_COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1,
  GL_COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2,
  GL_COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3,
  GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00,
  GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01,
  GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02,
  GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03,
  GL_ETC1_RGB8_OES: 0x8D64,
  GL_COMPRESSED_RGB8_ETC2: 0x9274,
  GL_COMPRESSED_SRGB8_ETC2: 0x9275,
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276,
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277,
  GL_COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279,
  GL_COMPRESSED_R11_EAC: 0x9270,
  GL_COMPRESSED_SIGNED_R11_EAC: 0x9271,
  GL_COMPRESSED_RG11_EAC: 0x9272,
  GL_COMPRESSED_SIGNED_RG11_EAC: 0x9273,
  // Texture source types
  GL_BYTE: 0x1400,
  GL_SHORT: 0x1402,
  GL_INT: 0x1404,
  GL_FLOAT: 0x1406,
  GL_DOUBLE: 0x140A,
  GL_UNSIGNED_BYTE: 0x1401,
  GL_UNSIGNED_SHORT: 0x1403,
  GL_UNSIGNED_INT: 0x1405,
  // Blend values
  DST_ALPHA: 0x0304,
  DST_COLOR: 0x0306,
  ONE: 1,
  ONE_MINUS_DST_ALPHA: 0x0305,
  ONE_MINUS_DST_COLOR: 0x0307,
  ONE_MINUS_SRC_ALPHA: 0x0303,
  ONE_MINUS_SRC_COLOR: 0x0301,
  SRC_ALPHA: 0x0302,
  SRC_ALPHA_SATURATE: 0x0308,
  SRC_COLOR: 0x0300,
  CONSTANT_COLOR: 0x8001,
  ONE_MINUS_CONSTANT_COLOR: 0x8002,
  CONSTANT_ALPHA: 0x8003,
  ONE_MINUS_CONSTANT_ALPHA: 0x8004,
  ZERO: 0,
  // Fog coordinate sources
  COORDINATE: 0x8451,
  DEPTH: 0x8452,
  // Hint targets
  FOG_HINT: 0x0C54,
  GENERATE_MIPMAP_HINT: 0x8192,
  LINE_SMOOTH_HINT: 0x0C52,
  PERSPECTIVE_CORRECTION_HINT: 0x0C50,
  POINT_SMOOTH_HINT: 0x0C51,
  POLYGON_SMOOTH_HINT: 0x0C53,
  TEXTURE_COMPRESSION_HINT: 0x84EF,
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B,
  // Polygon modes
  POINT: 0x1B00,
  LINE: 0x1B01,
  FILL: 0x1B00,
  // Misc
  BACK: 0x0405,
  FRONT: 0x0404,
  FRONT_AND_BACK: 0x0408,
  FIXED_ONLY: 0x891D,
  FASTEST: 0x1101,
  NICEST: 0x1101,
  DONT_CARE: 0x1100
};
exports.GLEnum = GLEnum;

},{}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageType = void 0;
var ImageType = {
  IMAGE_INLINE_DATA: 0,
  IMAGE_INLINE_FILE: 1,
  IMAGE_EXTERNAL: 2
};
exports.ImageType = ImageType;

},{}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorMode = void 0;
var ColorMode = {
  AMBIENT: 0x1200,
  DIFFUSE: 0x1201,
  SPECULAR: 0x1202,
  EMISSION: 0x1600,
  AMBIENT_AND_DIFFUSE: 0x1602,
  OFF: 0x1602 + 1
};
exports.ColorMode = ColorMode;

},{}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectDataVariance = void 0;
var ObjectDataVariance = {
  DYNAMIC: 0,
  STATIC: 1,
  UNSPECIFIED: 2
};
exports.ObjectDataVariance = ObjectDataVariance;

},{}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrimitiveMode = void 0;
var PrimitiveMode = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_STRIP: 0x0003,
  LINE_LOOP: 0x0002,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006,
  GL_QUADS: 0x0007
};
exports.PrimitiveMode = PrimitiveMode;

},{}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrimitiveTableEnum = void 0;
var PrimitiveTableEnum = {
  DrawArrays: 50,
  DrawArraysLength: 51,
  DrawElementsUByte: 52,
  DrawElementsUShort: 53,
  DrawElementsUInt: 54,
  GL_POINTS: 0x0000,
  GL_LINES: 0x0001,
  GL_LINE_STRIP: 0x0003,
  GL_LINE_LOOP: 0x0002,
  GL_TRIANGLES: 0x0004,
  GL_TRIANGLE_STRIP: 0x0005,
  GL_TRIANGLE_FAN: 0x0006,
  GL_QUADS: 0x0007,
  GL_QUAD_STRIP: 0x0008,
  GL_POLYGON: 0x0009,
  GL_LINES_ADJACENCY: 0x000A,
  GL_LINES_ADJACENCY_EXT: 0x000A,
  GL_LINE_STRIP_ADJACENCY_EXT: 0x000B,
  GL_LINE_STRIP_ADJACENCY: 0x000B,
  GL_TRIANGLES_ADJACENCY: 0x000C,
  GL_TRIANGLES_ADJACENCY_EXT: 0x000C,
  GL_TRIANGLE_STRIP_ADJACENCY: 0x000D,
  GL_TRIANGLE_STRIP_ADJACENCY_EXT: 0x000D,
  GL_PATCHES: 0x000E
};
exports.PrimitiveTableEnum = PrimitiveTableEnum;

},{}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RangeMode = void 0;
var RangeMode = {
  DISTANCE_FROM_EYE_POINT: 0,
  PIXEL_SIZE_ON_SCREEN: 1
};
exports.RangeMode = RangeMode;

},{}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShadeModelMode = void 0;
var ShadeModelMode = {
  ConstantsFLAT: 0x1D00,
  SMOOTH: 0x1D01
};
exports.ShadeModelMode = ShadeModelMode;

},{}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateAttributeValue = void 0;
var StateAttributeValue = {
  /** means that associated GLMode and Override is disabled.*/
  OFF: 0,

  /** means that associated GLMode is enabled and Override is disabled.*/
  ON: 1,

  /** Overriding of GLMode's or StateAttributes is enabled, so that state below it is overridden.*/
  OVERRIDE: 2,

  /** Protecting of GLMode's or StateAttributes is enabled, so that state from above cannot override this and below state.*/
  PROTECTED: 4,

  /** means that GLMode or StateAttribute should be inherited from above.*/
  INHERIT: 8
};
exports.StateAttributeValue = StateAttributeValue;

},{}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderBinMode = void 0;
var RenderBinMode = {
  INHERIT_RENDERBIN_DETAILS: 0,
  USE_RENDERBIN_DETAILS: 1,
  OVERRIDE_RENDERBIN_DETAILS: 2,
  PROTECTED_RENDERBIN_DETAILS: 4,
  OVERRIDE_PROTECTED_RENDERBIN_DETAILS: 6
};
exports.RenderBinMode = RenderBinMode;

},{}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderingHint = void 0;
var RenderingHint = {
  DEFAULT_BIN: 0,
  OPAQUE_BIN: 1,
  TRANSPARENT_BIN: 2
};
exports.RenderingHint = RenderingHint;

},{}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternalFormatMode = void 0;
var InternalFormatMode = {
  USE_IMAGE_DATA_FORMAT: 0,
  USE_USER_DEFINED_FORMAT: 1,
  USE_ARB_COMPRESSION: 2,
  USE_S3TC_DXT1_COMPRESSION: 3,
  USE_S3TC_DXT3_COMPRESSION: 4,
  USE_S3TC_DXT5_COMPRESSION: 5,
  USE_PVRTC_2BPP_COMPRESSION: 6,
  USE_PVRTC_4BPP_COMPRESSION: 7,
  USE_ETC_COMPRESSION: 8,
  USE_ETC2_COMPRESSION: 9,
  USE_RGTC1_COMPRESSION: 10,
  USE_RGTC2_COMPRESSION: 11,
  USE_S3TC_DXT1c_COMPRESSION: 12,
  USE_S3TC_DXT1a_COMPRESSION: 13
};
exports.InternalFormatMode = InternalFormatMode;

},{}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShadowCompareFunc = void 0;
var ShadowCompareFunc = {
  NEVER: 0x0200,
  LESS: 0x0201,
  EQUAL: 0x0202,
  LEQUAL: 0x0203,
  GREATER: 0x0204,
  NOTEQUAL: 0x0205,
  GEQUAL: 0x0206,
  ALWAYS: 0x0207
};
exports.ShadowCompareFunc = ShadowCompareFunc;

},{}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShadowTextureMode = void 0;
var ShadowTextureMode = {
  LUMINANCE: 0x1909,
  INTENSITY: 0x8049,
  ALPHA: 0x1906,
  NONE: 0x0000
};
exports.ShadowTextureMode = ShadowTextureMode;

},{}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReferenceFrame = void 0;
var ReferenceFrame = {
  RELATIVE_RF: 0,
  ABSOLUTE_RF: 1,
  ABSOLUTE_RF_INHERIT_VIEWPOINT: 2
};
exports.ReferenceFrame = ReferenceFrame;

},{}],121:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsciiStreamOperator = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _StreamOperator2 = require("._458");

var _ObjectWrapperManager = require("C_459");

var _GLEnum = require("o_460");

var _Log = require("m_461");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var separatorChars = "\0\t\r\n\f ";
var separatorCharsObject = {};

for (var i = 0; i < separatorChars.length; i++) {
  separatorCharsObject[separatorChars.charCodeAt(i)] = true;
}

function lookAtChar(that, position) {
  return that.bufferToString("ASCII", position, position + 1);
}

function isSeparatorChar(buffer, index) {
  index = index || 0;

  if (typeof buffer === 'string') {
    return !!separatorCharsObject[buffer.charCodeAt(index)];
  }

  return !!separatorCharsObject[buffer[index]];
}

function skipGaps(that) {
  while (that._position <= that._buffer.byteLength && isSeparatorChar(that._buffer, that._position)) {
    that._position++;
  }
}

function readIntNumber(that) {
  var word = that.readString();
  return parseInt(word);
}

function readFloatNumber(that) {
  var word = that.readString();
  return parseFloat(word);
}

function isEndlChar(buffer, index) {
  index = index || 0;
  var charCode;

  if (typeof buffer === 'string') {
    charCode = buffer.charCodeAt(index);
  } else {
    charCode = buffer[index];
  }

  return charCode === 10 || charCode === 13;
}

function readString(params) {}

var AsciiStreamOperator = /*#__PURE__*/function (_StreamOperator) {
  (0, _inherits2["default"])(AsciiStreamOperator, _StreamOperator);

  var _super = _createSuper(AsciiStreamOperator);

  function AsciiStreamOperator(buffer, initPosition) {
    var _this;

    (0, _classCallCheck2["default"])(this, AsciiStreamOperator);
    _this = _super.call(this, "AsciiStreamOperator");

    if (typeof Buffer != 'undefined' && buffer instanceof Buffer) {
      buffer = new Uint8Array(buffer);
    } else if (buffer instanceof ArrayBuffer) {
      buffer = new Uint8Array(buffer);
    }

    _this._buffer = buffer;
    _this._position = initPosition;
    _this.version = -1;
    return _this;
  }

  (0, _createClass2["default"])(AsciiStreamOperator, [{
    key: "isBinary",
    value: function isBinary() {
      return false;
    }
  }, {
    key: "bufferToString",
    value: function bufferToString(encoding, start, end) {
      var bytes = this._buffer.subarray(start, end);

      var str = String.fromCharCode.apply(null, bytes);
      return str;
    }
  }, {
    key: "advanceToCurrentEndBracket",
    value: function advanceToCurrentEndBracket() {
      var passString,
          blocks = 0;

      while (this._position < this._buffer.byteLength) {
        passString = this.readString();

        if (passString === "}") {
          if (blocks <= 0) return;else blocks--;
        } else if (passString === "{") blocks++;
      }
    }
  }, {
    key: "readBool",
    value: function readBool() {
      var boolString = this.readString();
      return boolString === "TRUE";
    }
  }, {
    key: "readUInt",
    value: function readUInt() {
      return readIntNumber(this);
    }
  }, {
    key: "readInt",
    value: function readInt() {
      return readIntNumber(this);
    }
  }, {
    key: "readUShort",
    value: function readUShort() {
      return readIntNumber(this);
    }
  }, {
    key: "readShort",
    value: function readShort() {
      return readIntNumber(this);
    }
  }, {
    key: "readUByte",
    value: function readUByte() {
      return readIntNumber(this);
    }
  }, {
    key: "readByte",
    value: function readByte() {
      return readIntNumber(this);
    }
  }, {
    key: "readFloat",
    value: function readFloat() {
      return readFloatNumber(this);
    }
  }, {
    key: "readDouble",
    value: function readDouble() {
      return readFloatNumber(this);
    }
  }, {
    key: "readHex",
    value: function readHex() {
      var word = this.readString();
      word = word.reaplace("0x", "");
      return parseInt(word, 16);
    }
  }, {
    key: "matchString",
    value: function matchString(str) {
      var currentPosition = this._position;
      var word = this.readString();

      if (str === word) {
        return true;
      } else {
        this._position = currentPosition;
        return false;
      }
    }
  }, {
    key: "lookForward",
    value: function lookForward() {
      var currentPosition = this._position;
      var word = this.readString();
      this._position = currentPosition;
      return word;
    }
  }, {
    key: "goToNextRow",
    value: function goToNextRow() {
      while (this._position <= this._buffer.byteLength && !isEndlChar(this._buffer, this._position)) {
        this._position++;
      }
    }
  }, {
    key: "readChar",
    value: function readChar() {
      skipGaps(this);
      this._position += 1;
      return this.bufferToString("ASCII", this._position - 1, this._position);
    }
  }, {
    key: "readString",
    value: function readString() {
      skipGaps(this);
      var endPosition = this._position;

      while (endPosition <= this._buffer.byteLength && !isSeparatorChar(this._buffer, endPosition)) {
        endPosition++;
      }

      var word = this.bufferToString('ASCII', this._position, endPosition);
      this._position = endPosition;
      return word;
    }
  }, {
    key: "readWrappedString",
    value: function readWrappedString() {
      skipGaps(this);
      var ch = lookAtChar(this, this._position);

      if (ch === '"') {
        this._position++; //

        var endPosition = this._position;

        while (endPosition <= this._buffer.byteLength && lookAtChar(this, endPosition) !== '"') {
          endPosition++;
        }

        var word = this.bufferToString('ASCII', this._position, endPosition);
        this._position = endPosition + 1;
        return word;
      } else {
        return this.readString();
      }
    }
  }, {
    key: "readGLEnum",
    value: function readGLEnum(objectGLEnum) {
      var enumString = this.readString();
      if (!objectGLEnum.hasOwnProperty(enumString)) _Log.Log.warn("readGLEnum: " + enumString + " enum not found");
      objectGLEnum.value = _GLEnum.GLEnum[enumString];
    }
  }, {
    key: "readObjectMark",
    value: function readObjectMark(mark) {
      var word = this.readString();

      if (mark.name !== word) {
        _Log.Log.warn("AsciiStreamOperator.readObjectMark mismatch: expecting " + mark.name + ", actual: " + word);
      }
    }
  }, {
    key: "readObjectProperty",
    value: function readObjectProperty(prop) {
      var value = 0,
          enumString = this.readString();

      if (prop.mapProperty) {
        value = _ObjectWrapperManager.ObjectWrapperManager.getValue(prop.name, enumString);
      } else {
        if (prop.name !== enumString) {
          debugger;
          throw "Unmatched property " + prop.name + " != " + enumString;
        }
      }

      prop.set(value);
    }
  }]);
  return AsciiStreamOperator;
}(_StreamOperator2.StreamOperator);

exports.AsciiStreamOperator = AsciiStreamOperator;

}).call(this)}).call(this,require("buffer").Buffer)

},{"m_461":100,"o_460":106,"C_459":156,"._458":125,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242,"buffer":248}],122:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BinaryStreamOperator = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _StreamOperator2 = require("._458");

var _Log = require("m_461");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BinaryStreamOperator = /*#__PURE__*/function (_StreamOperator) {
  (0, _inherits2["default"])(BinaryStreamOperator, _StreamOperator);

  var _super = _createSuper(BinaryStreamOperator);

  function BinaryStreamOperator(buffer, initPosition) {
    var _this;

    (0, _classCallCheck2["default"])(this, BinaryStreamOperator);
    _this = _super.call(this, "BinaryStreamOperator");

    if (typeof Buffer != 'undefined' && buffer instanceof Buffer) {
      buffer = new Uint8Array(buffer).buffer;
    }

    _this.supportBinaryBrackets = false;
    _this.version = -1;
    _this._buffer = buffer;
    _this._dv = new DataView(buffer);
    _this._position = initPosition;
    _this._beginPositions = [];
    _this._blockSizes = [];
    return _this;
  }

  (0, _createClass2["default"])(BinaryStreamOperator, [{
    key: "isBinary",
    value: function isBinary() {
      return true;
    }
  }, {
    key: "advanceToCurrentEndBracket",
    value: function advanceToCurrentEndBracket() {
      if (this.supportBinaryBrackets && this._beginPositions.length > 0) {
        var position = this._beginPositions.pop();

        position += this._blockSizes.pop();
        this._position = position;
      }
    }
  }, {
    key: "readObjectProperty",
    value: function readObjectProperty(prop) {
      var value = 0;
      if (prop.mapProperty) value = this.readInt();
      prop.set(value);
    }
  }, {
    key: "readObjectMark",
    value: function readObjectMark(mark) {
      if (this.supportBinaryBrackets) {
        if (mark.name === "{") {
          this._beginPositions.push(this._position);

          if (this.version !== -1 && this.version > 148) {
            // 64bit size
            var sizeLow = this.readInt();
            var sizeHigh = this.readInt();
            if (sizeHigh > Math.pow(2, 21)) throw "Too high value - size of file. nodeJS can manage 2^53 numbers only";
            var size = Math.pow(2, 32) * sizeHigh + sizeLow;

            this._blockSizes.push(size);
          } else {
            var _size = this.readInt();

            this._blockSizes.push(_size);
          }
        } else if (mark.name === "}" && this._beginPositions.length > 0) {
          this._beginPositions.pop();

          this._blockSizes.pop();
        }
      }
    }
  }, {
    key: "readBool",
    value: function readBool() {
      var ch = this.readChar().charCodeAt(0);
      if (ch > 1) _Log.Log.warn("found boolean who is not 0 or 1 - " + ch + ". may indicate failure in reading binary");
      return ch !== 0;
    }
  }, {
    key: "readByte",
    value: function readByte() {
      this._position += 1;
      return this._dv.getInt8(this._position - 1); //return this._buffer.readInt8(this._position - 1);
    }
  }, {
    key: "readUByte",
    value: function readUByte() {
      this._position += 1;
      return this._dv.getUint8(this._position - 1); //return this._buffer.readUInt8(this._position - 1);
    }
  }, {
    key: "readShort",
    value: function readShort() {
      this._position += 2;
      return this._dv.getInt16(this._position - 2, true); // return this._buffer.readInt16LE(this._position - 2);
    }
  }, {
    key: "readUShort",
    value: function readUShort() {
      this._position += 2;
      return this._dv.getUint16(this._position - 2, true); // return this._buffer.readUInt16LE(this._position - 2);
    }
  }, {
    key: "readInt",
    value: function readInt() {
      this._position += 4;
      return this._dv.getInt32(this._position - 4, true); // return this._buffer.readInt32LE(this._position - 4);
    }
  }, {
    key: "readUInt",
    value: function readUInt() {
      this._position += 4;
      return this._dv.getUint32(this._position - 4, true); // return this._buffer.readUInt32LE(this._position - 4);
    }
  }, {
    key: "readFloat",
    value: function readFloat() {
      this._position += 4;
      return this._dv.getFloat32(this._position - 4, true); // return this._buffer.readFloatLE(this._position - 4);
    }
  }, {
    key: "readDouble",
    value: function readDouble() {
      this._position += 8;
      return this._dv.getFloat64(this._position - 8, true); // return this._buffer.readDoubleLE(this._position - 8);
    }
  }, {
    key: "readChar",
    value: function readChar() {
      // this._position += 1;
      var ch = this.readUByte();
      return String.fromCharCode(ch); //this._buffer.toString("ASCII", this._position - 1, this._position);
    }
  }, {
    key: "readString",
    value: function readString() {
      var size = this.readUInt();
      this._position += size;
      var bytes = new Uint8Array(this._buffer, this._position - size, size);
      return String.fromCharCode.apply(null, bytes); // return this._buffer.toString("ASCII", this._position - size, this._position);
    }
  }, {
    key: "readWrappedString",
    value: function readWrappedString() {
      return this.readString();
    }
  }, {
    key: "readGLEnum",
    value: function readGLEnum(objectGLEnum) {
      objectGLEnum.value = this.readUInt();
    }
  }, {
    key: "readBuffer",
    value: function readBuffer(size) {
      var subBuffer = new Uint8Array(this._buffer, this._position, size); //new Buffer(size);
      // this._buffer.copy(subBuffer, 0, this._position, this._position + size);

      this._position += size;
      return subBuffer;
    }
  }]);
  return BinaryStreamOperator;
}(_StreamOperator2.StreamOperator);

exports.BinaryStreamOperator = BinaryStreamOperator;

}).call(this)}).call(this,require("buffer").Buffer)

},{"m_461":100,"._458":125,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242,"buffer":248}],123:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputStream = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

require("M_473");

var _ObjectWrapperManager = require("C_459");

var _DataTypes = require("s_475");

var _Constants = require("h_476");

var _Image = require("-_477");

var _Log = require("m_461");

var _Base64Encoder = require("D_479");

var _ImageType = require("._480");

var TypeIds = _Constants.Constants.TypeIds;
var IMAGE_INLINE_DATA = 0;
var IMAGE_INLINE_FILE = 1;
var IMAGE_EXTERNAL = 2;
var IMAGE_WRITE_OUT = 3;

function _readProperty(stream, value) {
  stream.inputOperator.readObjectProperty(stream.PROPERTY.set(value));
}

function getTypeReader(stream, type) {
  if (stream.typeReaderMap[type]) {
    return stream.typeReaderMap[type];
  }

  var funcName = "read" + type;
  var reader; // if the function exists in the InputOperator

  var typeReaderFunction = stream.inputOperator[funcName];
  if (typeReaderFunction) reader = typeReaderFunction.bind(stream.inputOperator); // if the function exists in the InputStream

  typeReaderFunction = stream[funcName];
  if (typeReaderFunction) reader = typeReaderFunction.bind(stream);

  if (reader) {
    stream.typeReaderMap[type] = reader;
    return reader;
  }

  throw "reader type: " + type + " not found";
}

function readVectorFromReader(size, reader) {
  var arr = []; // todo when reading array of vectors - maybe use single array fot all

  for (var i = 0; i < size; i++) {
    arr.push(reader());
  }

  return arr;
}

function readArrayImplementation(stream, readFunction, typeCtor, itemSize) {
  var size = stream.inputOperator.readInt();
  stream.readBeginBracket();
  var arr = {
    Value: [],
    Type: typeCtor.name,
    Count: size,
    ItemSize: itemSize
  };

  if (size > 0) {
    // presets the size of arr so the array will not be extended with every push
    // arr[size - 1] = null;
    if (stream.isBinary()) {
      var BYTES_PER_ELEMENT = typeCtor.BYTES_PER_ELEMENT;
      var subBuffer = stream.inputOperator.readBuffer(size * itemSize * BYTES_PER_ELEMENT);
      subBuffer = subBuffer.slice().buffer;
      arr.Value = new typeCtor(subBuffer);
    } else {
      arr.Value = new typeCtor(size * itemSize);
      var vIdx = 0;

      for (var i = 0; i < size; i++) {
        var itemValue = readFunction();

        for (var j = 0; j < itemSize; j++) {
          arr.Value[vIdx++] = itemValue[j];
        }
      }
    }
  } // if (arr.Value) {
  //     var vals = [];
  //     for (let i = 0; i < arr.Value.length; i++) {
  //         const element = arr.Value[i];
  //         vals.push(element);
  //     }
  //     arr.Value = vals;
  // }


  stream.readEndBracket();
  return arr;
}

var InputStream = /*#__PURE__*/function () {
  function InputStream(inputOperator) {
    (0, _classCallCheck2["default"])(this, InputStream);

    /**
     * @type StreamOperator
     */
    this.inputOperator = inputOperator;
    this._identifierMap = {};
    this._arrayMap = {};
    this._fields = [];
    this.typeReaderMap = {};
    this.PROPERTY = new _DataTypes.DataTypes.ObjectProperty();
    this.BEGIN_BRACKET = new _DataTypes.DataTypes.ObjectMark("{", +_Constants.Constants.INDENT_VALUE);
    this.END_BRACKET = new _DataTypes.DataTypes.ObjectMark("}", -_Constants.Constants.INDENT_VALUE);
  }

  (0, _createClass2["default"])(InputStream, [{
    key: "readObject",
    value: function readObject(existingObj) {
      var className = this.inputOperator.readString();
      if (className === "NULL") return null; // console.log(className);

      this.readBeginBracket();

      _readProperty(this, "UniqueID");

      if (!_ObjectWrapperManager.ObjectWrapperManager.findWrapper(className)) {
        //
        console.warn(className + ": wrapper for class not found");
        this.advanceToCurrentEndBracket();
        return existingObj;
      }

      var obj,
          id = this.inputOperator.readUInt();

      if (this._identifierMap[id]) {
        this.advanceToCurrentEndBracket();
        obj = this._identifierMap[id];
      } else {
        obj = this.readObjectFields(className, id, existingObj);
        this.advanceToCurrentEndBracket();
      } // console.log(obj);


      return obj;
    }
  }, {
    key: "readObjectOfType",
    value: function readObjectOfType() {
      return this.readObject();
    }
  }, {
    key: "readBeginBracket",
    value: function readBeginBracket() {
      this.inputOperator.readObjectMark(this.BEGIN_BRACKET);
    }
  }, {
    key: "readEndBracket",
    value: function readEndBracket() {
      this.inputOperator.readObjectMark(this.END_BRACKET);
    }
  }, {
    key: "readMatrix",
    value: function readMatrix(type) {
      var reader = getTypeReader(this, type);
      var arr = [];

      for (var i = 0; i < 16; i++) {
        arr.push(reader());
      }

      return arr;
    }
  }, {
    key: "readPrimitiveSet",
    value: function readPrimitiveSet() {
      if (this.getVersion() >= 112) return this.readObjectOfType("osg::PrimitiveSet");else {
        var numInstances = 0,
            primitive = null;
        var type = new _DataTypes.ObjectProperty("PrimitiveType", 0, true);

        var _mode = new _DataTypes.ObjectProperty("PrimitiveType", 0, true);

        var inputOperator = this.inputOperator;
        inputOperator.readObjectProperty(type);
        inputOperator.readObjectProperty(_mode);
        if (this.getVersion() > 96) numInstances = inputOperator.readUInt();

        if (type.value === TypeIds.ID_DRAWARRAYS) {
          var first = inputOperator.readInt();
          var count = inputOperator.readInt();
          primitive = {
            // osg::DrawArrays
            First: first,
            Count: count,
            Mode: _mode.value,
            NumInstances: numInstances
          };
        } else if (type.value === TypeIds.ID_DRAWARRAY_LENGTH) {
          var _first = inputOperator.readInt();

          var size = inputOperator.readUInt();
          this.readBeginBracket();
          var typeCtor = Int32Array;
          primitive = {
            // osg::DrawArrayLengths
            First: _first,
            Mode: _mode.value,
            Indices: {
              ItemSize: 1,
              Type: typeCtor.name,
              Value: [],
              Count: size
            },
            NumInstances: numInstances
          };

          if (this.isBinary()) {
            primitive.Indices.Value = new typeCtor(inputOperator._buffer, inputOperator._position, size);
            inputOperator._position += size;
          } else {
            primitive.Indices.Value = new typeCtor(size);

            for (var i = 0; i < size; i++) {
              primitive.Indices.Value[i] = inputOperator.readInt();
            }
          }

          this.readEndBracket();
        } else if (type.value === TypeIds.ID_DRAWELEMENTS_UBYTE) {
          var _typeCtor = Uint8Array;

          var _size = inputOperator.readUInt();

          primitive = {
            // osg::DrawElementsUByte
            Mode: _mode.value,
            Indices: {
              ItemSize: 1,
              Type: _typeCtor.name,
              Value: [],
              Count: _size
            },
            NumInstances: numInstances
          };
          this.readBeginBracket();

          if (this.isBinary()) {
            primitive.Indices.Value = new _typeCtor(inputOperator._buffer, inputOperator._position, _size);
            inputOperator._position += _size;
          } else {
            primitive.Indices.Value = new _typeCtor(_size);

            for (var _i = 0; _i < _size; _i++) {
              primitive.Indices.Value[_i] = inputOperator.readUByte();
            }
          }

          this.readEndBracket();
        } else if (type.value === TypeIds.ID_DRAWELEMENTS_USHORT) {
          var _typeCtor2 = Uint16Array;

          var _size2 = inputOperator.readUInt();

          primitive = {
            // osg::DrawElementsUShort
            Mode: _mode.value,
            Indices: {
              ItemSize: 1,
              Type: _typeCtor2.name,
              Value: [],
              Count: _size2
            },
            NumInstances: numInstances
          };
          this.readBeginBracket();

          if (this.isBinary()) {
            var BYTES_PER_ELEMENT = _typeCtor2.BYTES_PER_ELEMENT;
            var subBuffer = inputOperator.readBuffer(_size2 * BYTES_PER_ELEMENT);
            subBuffer = subBuffer.slice().buffer;
            primitive.Indices.Value = new _typeCtor2(subBuffer);
          } else {
            primitive.Indices.Value = new _typeCtor2(_size2);

            for (var _i2 = 0; _i2 < _size2; _i2++) {
              primitive.Indices.Value[_i2] = inputOperator.readUShort();
            }
          }

          this.readEndBracket();
        } else if (type.value === TypeIds.ID_DRAWELEMENTS_UINT) {
          var _typeCtor3 = Uint32Array;

          var _size3 = inputOperator.readUInt();

          primitive = {
            // osg::DrawElementsUInt
            Mode: _mode.value,
            Indices: {
              ItemSize: 1,
              Type: _typeCtor3.name,
              Value: [],
              Count: _size3
            },
            NumInstances: numInstances
          };
          this.readBeginBracket();

          if (this.isBinary()) {
            var BYTES_PER_ELEMENT = _typeCtor3.BYTES_PER_ELEMENT;

            var _subBuffer = inputOperator.readBuffer(_size3 * BYTES_PER_ELEMENT);

            _subBuffer = _subBuffer.slice().buffer;
            primitive.Indices.Value = new _typeCtor3(_subBuffer);
          } else {
            primitive.Indices.Value = new _typeCtor3(_size3);

            for (var _i3 = 0; _i3 < _size3; _i3++) {
              primitive.Indices.Value[_i3] = inputOperator.readUInt();
            }
          }

          this.readEndBracket();
        } else {
          throw "InputStream.readPrimitiveSet: " + type.value + " ID not found";
        }

        return primitive;
      }
    }
  }, {
    key: "readProperty",
    value: function readProperty(value) {
      return _readProperty(this, value); // this.inputOperator.readObjectProperty(this.PROPERTY.set(value));
    } // getTypeReader(type) {
    //     if (this.typeReaderMap[type]) {
    //         return this.typeReaderMap[type];
    //     }
    //     let funcName = "read" + type;
    //     let reader;
    //     // if the function exists in the InputOperator
    //     let typeReaderFunction = this.inputOperator[funcName];
    //     if (typeReaderFunction)
    //         reader = typeReaderFunction.bind(this.inputOperator);
    //     // if the function exists in the InputStream
    //     typeReaderFunction = this[funcName];
    //     if (typeReaderFunction)
    //         reader = typeReaderFunction.bind(this);
    //     if (reader) {
    //         this.typeReaderMap[type] = reader;
    //         return reader;
    //     }
    //     throw "reader type: " + type + " not found";
    // }
    // readVectorFromReader(size, reader) {
    //     let arr = []; // todo when reading array of vectors - maybe use single array fot all
    //     for (let i = 0; i < size; i++)
    //         arr.push(reader());
    //     return arr;
    // }

  }, {
    key: "readVectorOfType",
    value: function readVectorOfType(size, type) {
      return readVectorFromReader(size, getTypeReader(this, type));
    }
  }, {
    key: "readArray",
    value: function readArray() {
      var scope = this;
      var array = null;

      _readProperty(this, "ArrayID");

      var inputOperator = this.inputOperator;
      var id = inputOperator.readUInt("ArrayID");
      if (this._arrayMap[id]) return this._arrayMap[id];
      var type = new _DataTypes.ObjectProperty("ArrayType", 0, true);
      inputOperator.readObjectProperty(type);
      var io = inputOperator;
      var itemSize = 1;

      if (type.value === TypeIds.ID_BYTE_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readByte();
        }, Int8Array, itemSize);
      } else if (type.value === TypeIds.ID_UBYTE_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readUByte();
        }, Uint8Array, itemSize);
      } else if (type.value === TypeIds.ID_SHORT_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readShort();
        }, Int16Array, itemSize);
      } else if (type.value === TypeIds.ID_USHORT_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readUShort();
        }, Uint16Array, itemSize);
      } else if (type.value === TypeIds.ID_INT_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readInt();
        }, Int32Array, itemSize);
      } else if (type.value === TypeIds.ID_UINT_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readUInt();
        }, Uint32Array, itemSize);
      } else if (type.value === TypeIds.ID_FLOAT_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readFloat();
        }, Float32Array, itemSize);
      } else if (type.value === TypeIds.ID_DOUBLE_ARRAY) {
        array = readArrayImplementation(scope, function () {
          return io.readDouble();
        }, Float64Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2B_ARRAY) {
        itemSize = 2;
        var reader = getTypeReader(scope, "Byte");
        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, reader);
        }, Int8Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3B_ARRAY) {
        itemSize = 3;

        var _reader = getTypeReader(scope, "Byte");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader);
        }, Int8Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4B_ARRAY) {
        itemSize = 4;

        var _reader2 = getTypeReader(scope, "Byte");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader2);
        }, Int8Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2UB_ARRAY) {
        itemSize = 2;

        var _reader3 = getTypeReader(scope, "UByte");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, _reader3);
        }, Uint8Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3UB_ARRAY) {
        itemSize = 3;

        var _reader4 = getTypeReader(scope, "UByte");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader4);
        }, Uint8Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4UB_ARRAY) {
        itemSize = 4;

        var _reader5 = getTypeReader(scope, "UByte");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader5);
        }, Uint8Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2S_ARRAY) {
        itemSize = 2;

        var _reader6 = getTypeReader(scope, "Short");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, _reader6);
        }, Int16Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3S_ARRAY) {
        itemSize = 3;

        var _reader7 = getTypeReader(scope, "Short");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader7);
        }, Int16Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4S_ARRAY) {
        itemSize = 4;

        var _reader8 = getTypeReader(scope, "Short");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader8);
        }, Int16Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2US_ARRAY) {
        itemSize = 2;

        var _reader9 = getTypeReader(scope, "UShort");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, _reader9);
        }, Uint16Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3US_ARRAY) {
        itemSize = 3;

        var _reader10 = getTypeReader(scope, "UShort");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader10);
        }, Uint16Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4US_ARRAY) {
        itemSize = 4;

        var _reader11 = getTypeReader(scope, "UShort");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader11);
        }, Uint16Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2_ARRAY) {
        itemSize = 2;

        var _reader12 = getTypeReader(scope, "Float");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, _reader12);
        }, Float32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3_ARRAY) {
        itemSize = 3;

        var _reader13 = getTypeReader(scope, "Float");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader13);
        }, Float32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4_ARRAY) {
        itemSize = 4;

        var _reader14 = getTypeReader(scope, "Float");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader14);
        }, Float32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2D_ARRAY) {
        itemSize = 2;

        var _reader15 = getTypeReader(scope, "Double");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, _reader15);
        }, Float64Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3D_ARRAY) {
        itemSize = 3;

        var _reader16 = getTypeReader(scope, "Double");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader16);
        }, Float64Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4D_ARRAY) {
        itemSize = 4;

        var _reader17 = getTypeReader(scope, "Double");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader17);
        }, Float64Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2I_ARRAY) {
        itemSize = 2;

        var _reader18 = getTypeReader(scope, "Int");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, _reader18);
        }, Int32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3I_ARRAY) {
        itemSize = 3;

        var _reader19 = getTypeReader(scope, "Int");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader19);
        }, Int32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4I_ARRAY) {
        itemSize = 4;

        var _reader20 = getTypeReader(scope, "Int");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader20);
        }, Int32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC2UI_ARRAY) {
        itemSize = 2;

        var _reader21 = getTypeReader(scope, "UInt");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(2, _reader21);
        }, Uint32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC3UI_ARRAY) {
        itemSize = 3;

        var _reader22 = getTypeReader(scope, "UInt");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(3, _reader22);
        }, Uint32Array, itemSize);
      } else if (type.value === TypeIds.ID_VEC4UI_ARRAY) {
        itemSize = 4;

        var _reader23 = getTypeReader(scope, "UInt");

        array = readArrayImplementation(scope, function () {
          return readVectorFromReader(4, _reader23);
        }, Uint32Array, itemSize);
      } else {
        throw "InputStream.readArray(): Unsupported array type.";
      }

      this._arrayMap[id] = array;
      return array;
    } // readArrayImplementation(readFunction, typeCtor, itemSize) {
    //     let size = this.inputOperator.readInt();
    //     this.readBeginBracket();
    //     let arr = {
    //         Value: [],
    //         Type: typeCtor.name,
    //         Count: size,
    //         ItemSize: itemSize
    //     };
    //     if (size > 0) {
    //         // presets the size of arr so the array will not be extended with every push
    //         // arr[size - 1] = null;
    //         if (this.isBinary()) {
    //             var BYTES_PER_ELEMENT = typeCtor.BYTES_PER_ELEMENT;
    //             var subBuffer = this.inputOperator.readBuffer(size * itemSize * BYTES_PER_ELEMENT);
    //             subBuffer = subBuffer.slice().buffer;
    //             arr.Value = new typeCtor(subBuffer);
    //         }
    //         else {
    //             arr.Value = new typeCtor(size * itemSize);
    //             let vIdx = 0;
    //             for (let i = 0; i < size; i++) {
    //                 let itemValue = readFunction();
    //                 for (let j = 0; j < itemSize; j++) {
    //                     arr.Value[vIdx++] = itemValue[j];
    //                 }
    //             }
    //         }
    //     }
    //     // if (arr.Value) {
    //     //     var vals = [];
    //     //     for (let i = 0; i < arr.Value.length; i++) {
    //     //         const element = arr.Value[i];
    //     //         vals.push(element);
    //     //     }
    //     //     arr.Value = vals;
    //     // }
    //     this.readEndBracket();
    //     return arr
    // }

  }, {
    key: "getVersion",
    value: function getVersion() {
      // domain currently not implemented
      return this.inputOperator.version;
    }
  }, {
    key: "advanceToCurrentEndBracket",
    value: function advanceToCurrentEndBracket() {
      this.inputOperator.advanceToCurrentEndBracket();
    }
  }, {
    key: "isBinary",
    value: function isBinary() {
      return this.inputOperator.isBinary();
    }
  }, {
    key: "readObjectFields",
    value: function readObjectFields(classname, id, existingObj) {
      var _this = this;

      // console.log(classname);
      var wrapper = _ObjectWrapperManager.ObjectWrapperManager.findWrapper(classname);

      if (!wrapper) {
        console.warn(classname + ": wrapper for class not found");
        this.advanceToCurrentEndBracket();
        return;
      }

      var inputVersion = this.inputOperator.version;
      var obj = existingObj || wrapper.createInstance();
      this._identifierMap[id] = obj;
      wrapper.associates.forEach(function (associate) {
        if (associate.minVersion <= inputVersion && associate.maxVersion >= inputVersion) {
          var associateWrapper = _ObjectWrapperManager.ObjectWrapperManager.findWrapper(associate.name);

          if (!associateWrapper) {
            _Log.Log.warn(associate.name + ": wrapper for associate not found. continuing to next associate");
          } else {
            _this._fields.push(associateWrapper.getName());

            associateWrapper.read(_this, obj);

            _this._fields.pop();
          }
        } else {// associate is not supported in version
        }
      });
      return obj;
    }
  }, {
    key: "readImage",
    value: function readImage() {
      var readFromExternal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var scope = this;
      var inputOperator = scope.inputOperator;

      if (scope.getVersion() > 94) {
        _readProperty(scope, "ClassName");

        inputOperator.readString();
      }

      _readProperty(scope, "UniqueID");

      var id = inputOperator.readUInt();

      if (scope._identifierMap[id]) {
        return scope._identifierMap[id];
      }

      _readProperty(scope, "FileName");

      var name = inputOperator.readWrappedString();

      _readProperty(scope, "WriteHint");

      var writeHint = inputOperator.readInt();
      var decision = inputOperator.readInt();
      var image = null;

      if (decision === IMAGE_INLINE_DATA) {
        if (this.isBinary()) {
          var origin = inputOperator.readInt();
          var s = inputOperator.readInt();
          var t = inputOperator.readInt();
          var r = inputOperator.readInt();
          var internalFormat = inputOperator.readInt();
          var pixelFormat = inputOperator.readInt();
          var dataType = inputOperator.readInt();
          var packing = inputOperator.readInt();

          var _mode2 = inputOperator.readInt();

          var size = inputOperator.readUInt();

          if (size > 0) {
            var _data = inputOperator.readBuffer(size);

            image = new _Image.Image();
            image.setProperty('ImageType', _ImageType.ImageType.IMAGE_INLINE_DATA);
            image.setProperty("Origin", origin);
            image.setImage(s, t, r, internalFormat, pixelFormat, dataType, _data, 1);
          }

          var levelSize = inputOperator.readUInt();
          var levels = [];

          for (var i = 0; i < levelSize; i++) {
            levels.push(inputOperator.readUInt());
          }

          if (image && levelSize > 0) image.setProperty("Levels", levels);
          readFromExternal = false;
        } else {
          //Ascii
          _readProperty(scope, "Origin");

          var _origin = inputOperator.readInt();

          _readProperty(scope, "Size");

          var _s = inputOperator.readInt();

          var _t = inputOperator.readInt();

          var _r = inputOperator.readInt();

          _readProperty(scope, "InternalTextureFormat");

          var _internalFormat = inputOperator.readInt();

          _readProperty(scope, "PixelFormat");

          var _pixelFormat = inputOperator.readInt();

          _readProperty(scope, "DataType");

          var _dataType = inputOperator.readInt();

          _readProperty(scope, "Packing");

          var _packing = inputOperator.readInt();

          _readProperty(scope, "AllocationMode");

          _readProperty(scope, "Data");

          var _levelSize = inputOperator.readUInt() - 1;

          scope.readBeginBracket();
          var encodedData = []; // total size: levelSize+1

          for (var _i4 = 0; _i4 <= _levelSize; _i4++) {
            encodedData.push(inputOperator.readWrappedString());
          }

          var _levels = [];

          _Base64Encoder.Base64Encoder.decodeArray(encodedData, _levels);

          _levels.pop();

          scope.readEndBracket();
          image = new _Image.Image();
          image.setProperty('ImageType', _ImageType.ImageType.IMAGE_INLINE_DATA);
          image.setProperty("Origin", _origin);
          image.setImage(_s, _t, _r, _internalFormat, _pixelFormat, _dataType, data, mode, _packing);
          if (_levelSize > 0) image.setProperty("Levels", _levels);
          readFromExternal = false;
        }
      } else if (decision === IMAGE_INLINE_FILE) {
        if (scope.isBinary()) {
          var _size4 = inputOperator.readUInt();

          var _data2 = inputOperator.readBuffer(_size4);

          image = new _Image.Image();
          image.setProperty('ImageType', _ImageType.ImageType.IMAGE_INLINE_FILE);
          image.setProperty("Data", _data2);
          readFromExternal = false;
        }
      } // let loadedFromCache = false; // not implemented


      if (readFromExternal && name !== "") {
        image = new _Image.Image();
        image.setProperty('ImageType', _ImageType.ImageType.IMAGE_EXTERNAL);
        image.FileName = name;

        _Log.Log.warn("InputStream,readImage - reading from external file - not implemented");
      } //if(loadedFromCache){}else{}


      image = scope.readObjectFields("osg::Object", id, image);
      image.setProperty("Name", name);
      image.setProperty("WriteHint", name);
      scope._identifierMap[id] = image;
      return image;
    }
  }]);
  return InputStream;
}();

exports.InputStream = InputStream;

},{"D_479":97,"h_476":98,"s_475":99,"m_461":100,"._480":107,"-_477":133,"C_459":156,"M_473":178,"e_1":235,"s_2":236,"M_0":241}],124:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readBuffer = readBuffer;
exports.readFile = readFile;

var _InputStream = require("C_481");

var _DataTypes = require("s_475");

var _BinaryStreamOperator = require("m_483");

var _AsciiStreamOperator = require("M_484");

var _Log = require("m_461");

var PROPERTY = new _DataTypes.DataTypes.ObjectProperty();
var OSG_HEADER_LOW = 0x6C910EA1;
var OSG_HEADER_HIGH = 0x1AFB4545;
var OSGT_HEADER = "#Ascii";
var WriteType = {
  WRITE_UNKNOWN: 0,
  WRITE_SCENE: 1,
  WRITE_IMAGE: 2,
  WRITE_OBJECT: 3
};
/**
 *
 * @param {buffer} buffer
 * @return {object} the serialized node
 */

function readBuffer(buffer) {
  if (typeof Buffer != 'undefined' && buffer instanceof Buffer) {
    buffer = new Uint8Array(buffer).buffer;
  }

  var reader = new _BinaryStreamOperator.BinaryStreamOperator(buffer, 0);
  var low = reader.readUInt();
  var high = reader.readUInt();
  reader._position = 0;
  var isASCIIFormat = buffer.byteLength >= OSGT_HEADER.length;

  if (isASCIIFormat) {
    var magicBuffer = reader.readBuffer(OSGT_HEADER.length);
    var magic = String.fromCharCode.apply(null, magicBuffer);
    isASCIIFormat = magic === OSGT_HEADER;
  }

  var type, version, openscenegraph_soversion, hasDomainVersion;

  if (low === OSG_HEADER_LOW && high === OSG_HEADER_HIGH) {
    reader._position = 8;
    var useCompressSource, useRobustBinaryFormat;
    type = reader.readUInt(); // buf.readUInt32LE(ReadPosition);

    openscenegraph_soversion = reader.readUInt();
    var attributes = reader.readUInt();
    hasDomainVersion = (attributes & 0x1) !== 0;
    useCompressSource = (attributes & 0x2) !== 0;
    useRobustBinaryFormat = (attributes & 0x4) !== 0;
    reader.supportBinaryBrackets = useRobustBinaryFormat;
    var next = reader.readString();

    if (next !== "0") {
      throw "compresses data not supported";
    }
  } else if (isASCIIFormat) {
    (0, _Log.Log)("OSGT File");
    reader = new _AsciiStreamOperator.AsciiStreamOperator(buffer, OSGT_HEADER.length);
    type = reader.readString();
    reader.goToNextRow();
    type = WriteType["WRITE_" + type.toUpperCase()] || 0;
    reader.readObjectProperty(PROPERTY.set("#Version"));
    openscenegraph_soversion = reader.readUInt();
    reader.goToNextRow();
    reader.readObjectProperty(PROPERTY.set("#Generator"));
    reader.readString(); // Generator Name

    reader.goToNextRow();
    hasDomainVersion = reader.lookForward() === "#CustomDomain";
  } else {
    console.warn("osg-serializer-js: osg format not supported. use  `parseOsg` instead");
    return false;
  }

  if (hasDomainVersion) {
    // TODO
    throw new Error("osg DomainVersion not supported.");
  }

  reader.version = openscenegraph_soversion;
  var inputStream = new _InputStream.InputStream(reader);
  var startTime = new Date().getTime();
  var obj = inputStream.readObject();
  (0, _Log.Log)("timeElapsed:", new Date().getTime() - startTime);
  return obj;
}
/**
 *
 * @param {string} path
 * @param {function} cb callback function
 */


function readFile(path, cb) {
  if (!cb) {
    throw "Call back required";
  }

  var req = 'require';
  var fs = eval(req + '(\'fs\');');
  fs.readFile(path, function (err, data) {
    if (err) cb(err);
    var node;

    try {
      console.log(err, data);
      node = readBuffer(data);
    } catch (e) {
      console.trace(e);
      return cb(e);
    }

    if (!node) {
      return cb("Failed to convert file");
    }

    cb(null, node);
  });
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"s_475":99,"m_461":100,"M_484":121,"m_483":122,"C_481":123,"buffer":248}],125:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamOperator = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

function notImplemented(name, funcName) {
  throw "function " + funcName + " Not Implemented in " + name;
}

var StreamOperator = /*#__PURE__*/function () {
  function StreamOperator(name) {
    (0, _classCallCheck2["default"])(this, StreamOperator);
    this.name = name;
  }

  (0, _createClass2["default"])(StreamOperator, [{
    key: "readChar",
    value: function readChar() {
      notImplemented(this.name, "readChar");
    }
  }, {
    key: "readUByte",
    value: function readUByte() {
      notImplemented(this.name, "readUByte");
    } // TODO implement in binary

  }, {
    key: "readByte",
    value: function readByte() {
      notImplemented(this.name, "readByte");
    } // TODO implement in binary

  }, {
    key: "readShort",
    value: function readShort() {
      notImplemented(this.name, "readShort");
    } // TODO implement in binary

  }, {
    key: "readUShort",
    value: function readUShort() {
      notImplemented(this.name, "readUShort");
    } // TODO implement in binary

  }, {
    key: "readInt",
    value: function readInt() {
      notImplemented(this.name, "readInt");
    }
  }, {
    key: "readUInt",
    value: function readUInt() {
      notImplemented(this.name, "readUInt");
    }
  }, {
    key: "readBool",
    value: function readBool() {
      notImplemented(this.name, "readBool");
    }
  }, {
    key: "readString",
    value: function readString() {
      notImplemented(this.name, "readString");
    }
    /** @param {ObjectProperty} prop */

  }, {
    key: "readObjectProperty",
    value: function readObjectProperty(prop) {
      notImplemented(this.name, "readObjectProperty");
    }
    /** @param {ObjectMark} mark */

  }, {
    key: "readObjectMark",
    value: function readObjectMark(mark) {
      notImplemented(this.name, "readObjectMark");
    }
  }, {
    key: "advanceToCurrentEndBracket",
    value: function advanceToCurrentEndBracket() {
      notImplemented(this.name, "advanceToCurrentEndBracket");
    }
  }, {
    key: "isBinary",
    value: function isBinary() {
      notImplemented(this.name, "isBinary");
    }
  }, {
    key: "readWrappedString",
    value: function readWrappedString() {
      notImplemented(this.name, "readWrappedString");
    }
  }, {
    key: "readGLEnum",
    value: function readGLEnum(objectGLEnum) {
      notImplemented(this.name, "readGLenum");
    }
  }, {
    key: "readFloat",
    value: function readFloat() {
      notImplemented(this.name, "readFloat");
    }
  }, {
    key: "readDouble",
    value: function readDouble() {
      notImplemented(this.name, "readDouble");
    }
  }, {
    key: "readBuffer",
    value: function readBuffer(size) {
      notImplemented(this.name, "readBuffer");
    }
  }]);
  return StreamOperator;
}();

exports.StreamOperator = StreamOperator;

},{"e_1":235,"s_2":236,"M_0":241}],126:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferData = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Object = require("m_494");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BufferData = /*#__PURE__*/function (_ObjectClass) {
  (0, _inherits2["default"])(BufferData, _ObjectClass);

  var _super = _createSuper(BufferData);

  function BufferData() {
    (0, _classCallCheck2["default"])(this, BufferData);
    return _super.call(this);
  }

  return BufferData;
}(_Object.ObjectClass);

exports.BufferData = BufferData;

},{"m_494":138,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CullFace = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _StateAttribute2 = require("3_500");

var _CullFace_FaceMode = require("D_501");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var CullFace = /*#__PURE__*/function (_StateAttribute) {
  (0, _inherits2["default"])(CullFace, _StateAttribute);

  var _super = _createSuper(CullFace);

  function CullFace() {
    var _this;

    (0, _classCallCheck2["default"])(this, CullFace);
    _this = _super.call(this);
    _this.Type = "osg::CullFace";
    _this.Mode = _CullFace_FaceMode.FaceMode.BACK;
    return _this;
  }

  return CullFace;
}(_StateAttribute2.StateAttribute);

exports.CullFace = CullFace;

},{"D_501":104,"3_500":142,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],128:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultUserDataContainer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _UserDataContainer2 = require("e_507");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DefaultUserDataContainer = /*#__PURE__*/function (_UserDataContainer) {
  (0, _inherits2["default"])(DefaultUserDataContainer, _UserDataContainer);

  var _super = _createSuper(DefaultUserDataContainer);

  function DefaultUserDataContainer() {
    var _this;

    (0, _classCallCheck2["default"])(this, DefaultUserDataContainer);
    _this = _super.call(this);
    _this.Type = "Osg::DefaultUserDataContainer";
    return _this;
  }

  return DefaultUserDataContainer;
}(_UserDataContainer2.UserDataContainer);

exports.DefaultUserDataContainer = DefaultUserDataContainer;

},{"e_507":147,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],129:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Drawable = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Node2 = require("._513");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Drawable = /*#__PURE__*/function (_Node) {
  (0, _inherits2["default"])(Drawable, _Node);

  var _super = _createSuper(Drawable);

  function Drawable() {
    var _this;

    (0, _classCallCheck2["default"])(this, Drawable);
    _this = _super.call(this);
    _this.InitialBound = null;
    _this.BoundingBox = null;
    _this.Shape = null;
    _this.SupportsDisplayList = true;
    _this.UseDisplayList = true;
    _this.UseVertexBufferObjects = false;
    _this.Type = "osg::Drawable";
    return _this;
  }

  return Drawable;
}(_Node2.Node);

exports.Drawable = Drawable;

},{"._513":137,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],130:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Geode = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Group2 = require("s_519");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Geode = /*#__PURE__*/function (_Group) {
  (0, _inherits2["default"])(Geode, _Group);

  var _super = _createSuper(Geode);

  function Geode() {
    var _this;

    (0, _classCallCheck2["default"])(this, Geode);
    _this = _super.call(this);
    _this.Type = "Osg::Geode";
    return _this;
  }

  return Geode;
}(_Group2.Group);

exports.Geode = Geode;

},{"s_519":132,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],131:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Geometry = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Drawable2 = require("C_525");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Geometry = /*#__PURE__*/function (_Drawable) {
  (0, _inherits2["default"])(Geometry, _Drawable);

  var _super = _createSuper(Geometry);

  function Geometry() {
    var _this;

    (0, _classCallCheck2["default"])(this, Geometry);
    _this = _super.call(this);
    _this.Type = "Osg::Geometry";
    _this.InitialBound = null;
    _this.BoundingBox = null;
    _this.PrimitiveSetList = [];
    _this.TexCoordArray = [];
    _this.VertexAttribArray = [];
    return _this;
  }

  return Geometry;
}(_Drawable2.Drawable);

exports.Geometry = Geometry;

},{"C_525":129,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],132:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Group = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Node2 = require("._513");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Group = /*#__PURE__*/function (_Node) {
  (0, _inherits2["default"])(Group, _Node);

  var _super = _createSuper(Group);

  function Group() {
    var _this;

    (0, _classCallCheck2["default"])(this, Group);
    _this = _super.call(this);
    _this.Children = [];
    _this.Type = "Osg::Group";
    return _this;
  }

  return Group;
}(_Node2.Node);

exports.Group = Group;

},{"._513":137,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],133:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Image = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BufferData2 = require("m_538");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Image = /*#__PURE__*/function (_BufferData) {
  (0, _inherits2["default"])(Image, _BufferData);

  var _super = _createSuper(Image);

  function Image() {
    var _this;

    (0, _classCallCheck2["default"])(this, Image);
    _this = _super.call(this);
    _this.S = 0;
    _this.T = 0;
    _this.R = 0;
    _this.InternalTextureFormat = 0;
    _this.PixelFormat = 0;
    _this.DataType = 0;
    _this.Data = null;
    _this.Mode = 0;
    _this.Packing = 1;
    _this.RowLength = 0;
    _this.Origin = 0;
    _this.FileName = "";
    _this.Levels = null;
    _this.WriteHint = null;
    _this.Type = "Osg::Image";
    _this.FromExternal = false;
    return _this;
  }

  (0, _createClass2["default"])(Image, [{
    key: "setImage",
    value: function setImage(s, t, r, internalTextureFormat, pixelFormat, dataType, data, aloccationMode) {
      var packing = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
      var rowLength = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      this.S = s;
      this.T = t;
      this.R = r;
      this.InternalTextureFormat = internalTextureFormat;
      this.PixelFormat = pixelFormat;
      this.DataType = dataType;
      this.Data = data;
      this.Packing = packing;
      this.Mode = aloccationMode;
      this.RowLength = rowLength;
    }
  }]);
  return Image;
}(_BufferData2.BufferData);

exports.Image = Image;

},{"m_538":126,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],134:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LOD = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Node2 = require("._513");

var _CenterMode = require("D_545");

var _RangeMode = require("._546");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var LOD = /*#__PURE__*/function (_Node) {
  (0, _inherits2["default"])(LOD, _Node);

  var _super = _createSuper(LOD);

  function LOD() {
    var _this;

    (0, _classCallCheck2["default"])(this, LOD);
    _this = _super.call(this);
    _this.CenterMode = _CenterMode.CenterMode.USE_BOUNDING_SPHERE_CENTER;
    _this.RangeMode = _RangeMode.RangeMode.DISTANCE_FROM_EYE_POINT;
    _this.UserCenter = {
      center: [],
      radius: 0
    };
    _this.RangeList = [];
    _this.Type = "Osg::LOD";
    return _this;
  }

  return LOD;
}(_Node2.Node);

exports.LOD = LOD;

},{"D_545":103,"._546":112,"._513":137,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],135:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Material = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _StateAttribute2 = require("3_500");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Material = /*#__PURE__*/function (_StateAttribute) {
  (0, _inherits2["default"])(Material, _StateAttribute);

  var _super = _createSuper(Material);

  function Material() {
    var _this;

    (0, _classCallCheck2["default"])(this, Material);
    _this = _super.call(this);
    _this.AmbientFrontAndBack = true;
    _this.AmbientFront = null;
    _this.AmbientBack = null;
    _this.DiffuseFrontAndBack = true;
    _this.DiffuseFront = null;
    _this.DiffuseBack = null;
    _this.SpecularFrontAndBack = true;
    _this.SpecularFront = null;
    _this.SpecularBack = null;
    _this.EmissionFrontAndBack = true;
    _this.EmissionFront = null;
    _this.EmissionBack = null;
    _this.ShininessFrontAndBack = true;
    _this.ShininessFront = 0;
    _this.ShininessBack = 0;
    _this.Type = "Osg::Material";
    return _this;
  }

  return Material;
}(_StateAttribute2.StateAttribute);

exports.Material = Material;

},{"3_500":142,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],136:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatrixTransform = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Transform2 = require("C_558");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var MatrixTransform = /*#__PURE__*/function (_Transform) {
  (0, _inherits2["default"])(MatrixTransform, _Transform);

  var _super = _createSuper(MatrixTransform);

  function MatrixTransform() {
    var _this;

    (0, _classCallCheck2["default"])(this, MatrixTransform);
    _this = _super.call(this);
    _this.Type = "Osg::MatrixTransform";
    _this.Matrix = null;
    return _this;
  }

  return MatrixTransform;
}(_Transform2.Transform);

exports.MatrixTransform = MatrixTransform;

},{"C_558":146,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],137:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Node = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Object = require("m_494");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Node = /*#__PURE__*/function (_ObjectClass) {
  (0, _inherits2["default"])(Node, _ObjectClass);

  var _super = _createSuper(Node);

  function Node() {
    var _this;

    (0, _classCallCheck2["default"])(this, Node);
    _this = _super.call(this);
    _this.CullingActive = true;
    _this.NodeMask = 0xffffffff;
    _this.Descriptions = [];
    _this.InitialBound = null;
    _this.StateSet = null;
    _this.Type = "Osg::Node";
    return _this;
  }

  return Node;
}(_Object.ObjectClass);

exports.Node = Node;

},{"m_494":138,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],138:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectClass = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _Log = require("m_461");

// todo rename to SsgClass
var ObjectClass = /*#__PURE__*/function () {
  function ObjectClass() {
    (0, _classCallCheck2["default"])(this, ObjectClass);
    this.Name = "";
    this.DataVariance = null;
    /** @type {UserDataContainer} */

    this.UserDataContainer = null;
    this.Type = "Osg::Object";
  }
  /**
   * @param {string} name
   * @param {*} value
   */


  (0, _createClass2["default"])(ObjectClass, [{
    key: "setProperty",
    value: function setProperty(name, value) {
      // TODO all properties in all objects should start whit LowerCase
      if (this[name] === undefined) {
        _Log.Log.warn("setProperty: " + this.Type + "." + name + " have not been defined");
      }

      this[name] = value;
    }
    /**
     * @param {string} name
     * @return {*}
     */

  }, {
    key: "getProperty",
    value: function getProperty(name) {
      // TODO all properties in all objects should start whit LowerCase
      if (this[name] === undefined) {
        _Log.Log.warn("getProperty: " + this.Type + "." + name + " have not been defined");
      }

      return this[name];
    }
  }]);
  return ObjectClass;
}();

exports.ObjectClass = ObjectClass;

},{"m_461":100,"e_1":235,"s_2":236,"M_0":241}],139:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OsgArray = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BufferData2 = require("m_538");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var OsgArray = /*#__PURE__*/function (_BufferData) {
  (0, _inherits2["default"])(OsgArray, _BufferData);

  var _super = _createSuper(OsgArray);

  function OsgArray() {
    var _this;

    (0, _classCallCheck2["default"])(this, OsgArray);
    _this = _super.call(this);
    _this.Binding = null;
    _this.Normalize = false;
    return _this;
  }

  return OsgArray;
}(_BufferData2.BufferData);

exports.OsgArray = OsgArray;

},{"m_538":126,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],140:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PagedLOD = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _LOD2 = require("C_580");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var PagedLOD = /*#__PURE__*/function (_LOD) {
  (0, _inherits2["default"])(PagedLOD, _LOD);

  var _super = _createSuper(PagedLOD);

  function PagedLOD() {
    var _this;

    (0, _classCallCheck2["default"])(this, PagedLOD);
    _this = _super.call(this);
    _this.DatabasePath = '';
    _this.FileNames = [];
    _this.PriorityOffset = [];
    _this.PriorityScale = [];
    _this.FrameNumberOfLastTraversal = 0;
    _this.NumChildrenThatCannotBeExpired = 0;
    _this.DisableExternalChildrenPaging = false;
    _this.Children = [];
    _this.Type = "Osg::PagedLOD";
    return _this;
  }

  return PagedLOD;
}(_LOD2.LOD);

exports.PagedLOD = PagedLOD;

},{"C_580":134,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],141:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShadeModel = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _StateAttribute2 = require("3_500");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ShadeModel = /*#__PURE__*/function (_StateAttribute) {
  (0, _inherits2["default"])(ShadeModel, _StateAttribute);

  var _super = _createSuper(ShadeModel);

  function ShadeModel() {
    var _this;

    (0, _classCallCheck2["default"])(this, ShadeModel);
    _this = _super.call(this);
    _this.Mode = null;
    _this.Type = 'Osg::ShadeModel';
    return _this;
  }

  return ShadeModel;
}(_StateAttribute2.StateAttribute);

exports.ShadeModel = ShadeModel;

},{"3_500":142,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],142:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateAttribute = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Object = require("m_494");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var StateAttribute = /*#__PURE__*/function (_ObjectClass) {
  (0, _inherits2["default"])(StateAttribute, _ObjectClass);

  var _super = _createSuper(StateAttribute);

  function StateAttribute() {
    var _this;

    (0, _classCallCheck2["default"])(this, StateAttribute);
    _this = _super.call(this);
    _this.Type = "Osg::StateAttribute";
    return _this;
  }

  (0, _createClass2["default"])(StateAttribute, [{
    key: "getMember",
    value: function getMember() {
      return 0;
    }
  }, {
    key: "getTypeMemberPair",
    value: function getTypeMemberPair() {
      return {
        type: this.Type,
        member: this.getMember()
      };
    }
  }]);
  return StateAttribute;
}(_Object.ObjectClass);

exports.StateAttribute = StateAttribute;

},{"m_494":138,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],143:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateSet = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Object = require("m_494");

var _StateSet_RenderingHint = require("D_600");

var _StateSet_RenderBinMode = require("._601");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var StateSet = /*#__PURE__*/function (_ObjectClass) {
  (0, _inherits2["default"])(StateSet, _ObjectClass);

  var _super = _createSuper(StateSet);

  function StateSet() {
    var _this;

    (0, _classCallCheck2["default"])(this, StateSet);
    _this = _super.call(this);
    _this.ModeList = [];
    _this.AttributeList = [];
    _this.TextureModeList = [];
    _this.TextureAttributeList = [];
    _this.UniformList = [];
    _this.RenderingHint = _StateSet_RenderingHint.RenderingHint.DEFAULT_BIN;
    _this.RenderBinMode = _StateSet_RenderBinMode.RenderBinMode.INHERIT_RENDERBIN_DETAILS;
    _this.BinNumber = 0;
    _this.BinName = "";
    _this.NestRenderBins = true;
    _this.DefineList = {};
    _this.Type = "Osg::StateSet";
    return _this;
  }

  return StateSet;
}(_Object.ObjectClass);

exports.StateSet = StateSet;

},{"._601":115,"D_600":116,"m_494":138,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],144:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Texture = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _StateAttribute2 = require("3_500");

var _Texture_InternalFormatMode = require("-_609");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Texture = /*#__PURE__*/function (_StateAttribute) {
  (0, _inherits2["default"])(Texture, _StateAttribute);

  var _super = _createSuper(Texture);

  function Texture() {
    var _this;

    (0, _classCallCheck2["default"])(this, Texture);
    _this = _super.call(this);
    _this.InternalFormatMode = 0;
    _this.InternalFormat = 0;
    _this.Type = "Osg::Texture";
    return _this;
  }

  (0, _createClass2["default"])(Texture, [{
    key: "computeInternalFormatType",
    value: function computeInternalFormatType() {// TODO
    }
  }, {
    key: "setInternalFormat",
    value: function setInternalFormat(internalFormat) {
      this.InternalFormatMode = _Texture_InternalFormatMode.InternalFormatMode.USE_USER_DEFINED_FORMAT;
      this.InternalFormat = internalFormat;
      computeInternalFormatType();
    }
  }]);
  return Texture;
}(_StateAttribute2.StateAttribute);

exports.Texture = Texture;

},{"-_609":117,"3_500":142,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],145:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Texture2D = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Texture2 = require("m_615");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Texture2D = /*#__PURE__*/function (_Texture) {
  (0, _inherits2["default"])(Texture2D, _Texture);

  var _super = _createSuper(Texture2D);

  function Texture2D() {
    var _this;

    (0, _classCallCheck2["default"])(this, Texture2D);
    _this = _super.call(this);
    _this.Image = null;
    _this.TextureWidth = 0;
    _this.TextureHeight = 0;
    _this.Type = "Osg::Texture2D";
    return _this;
  }

  return Texture2D;
}(_Texture2.Texture);

exports.Texture2D = Texture2D;

},{"m_615":144,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],146:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transform = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Group2 = require("s_519");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Transform = /*#__PURE__*/function (_Group) {
  (0, _inherits2["default"])(Transform, _Group);

  var _super = _createSuper(Transform);

  function Transform() {
    var _this;

    (0, _classCallCheck2["default"])(this, Transform);
    _this = _super.call(this);
    _this.Type = "Osg::Transform";
    _this.ReferenceFrame = 0;
    return _this;
  }

  return Transform;
}(_Group2.Group);

exports.Transform = Transform;

},{"s_519":132,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],147:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserDataContainer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Object = require("m_494");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var UserDataContainer = /*#__PURE__*/function (_ObjectClass) {
  (0, _inherits2["default"])(UserDataContainer, _ObjectClass);

  var _super = _createSuper(UserDataContainer);

  function UserDataContainer() {
    var _this;

    (0, _classCallCheck2["default"])(this, UserDataContainer);
    _this = _super.call(this);
    _this.DescriptionList = [];
    _this.ObjectList = [];
    _this.UserData = null;
    _this.Type = "Osg::UserDataContainer";
    return _this;
  }

  return UserDataContainer;
}(_Object.ObjectClass);

exports.UserDataContainer = UserDataContainer;

},{"m_494":138,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],148:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Associate = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var Associate = function Associate(_name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _classCallCheck2["default"])(this, Associate);
  this.name = _name;
  this.minVersion = options.minVersion || 0;
  this.maxVersion = options.maxVersion || 100000000;
};

exports.Associate = Associate;

},{"e_1":235,"M_0":241}],149:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var BaseSerializer = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} name
   * @param options
   * @param {number} options.minVersion first osgb/osgb version in which this serializer is defind
   * @param {number} options.maxVersion last osgb/osgb version in which this serializer is defind
   */
  function BaseSerializer(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, BaseSerializer);
    this._options = options;
    this._name = name;
  }
  /**
   *
   * @returns {string}
   */


  (0, _createClass2["default"])(BaseSerializer, [{
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     *
     * @returns {number}
     */

  }, {
    key: "getMinVersion",
    value: function getMinVersion() {
      // TODO replace getMinVersion & getMaxVersion --> is supported in version
      return this._options.minVersion || 0;
    }
    /**
     *
     * @returns {number}
     */

  }, {
    key: "getMaxVersion",
    value: function getMaxVersion() {
      return this._options.maxVersion || 1000000000;
    }
    /**
     *
     * @param {InputStream} inputStream
     * @param {ObjectClass} object
     */

  }, {
    key: "read",
    value: function read(inputStream, object) {
      throw "BaseSerializer.read not implemented";
    }
  }]);
  return BaseSerializer;
}();

exports.BaseSerializer = BaseSerializer;

},{"e_1":235,"s_2":236,"M_0":241}],150:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnumSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _Log = require("m_461");

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function reverseMap(map) {
  var ret = {};
  Object.keys(map).forEach(function (key) {
    var val = map[key];
    if (ret[val]) _Log.Log.warn("EnumSerializer: Duplicate value: " + ret[val] + ", " + key);
    ret[val] = key;
  });
  return ret;
}

var EnumSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(EnumSerializer, _BaseSerializer);

  var _super = _createSuper(EnumSerializer);

  function EnumSerializer(name, enumMap, defaultValue, options) {
    var _this;

    (0, _classCallCheck2["default"])(this, EnumSerializer);
    _this = _super.call(this, name, options);
    _this._defaultValue = defaultValue;
    _this._enumMap = enumMap;
    _this._reverseMap = reverseMap(enumMap);
    return _this;
  }
  /** @override */


  (0, _createClass2["default"])(EnumSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      if (inputStream.isBinary()) {
        var value = inputStream.inputOperator.readInt();

        if (!this._reverseMap.hasOwnProperty(value)) {
          _Log.Log.warn("EnumSerializer: failed to find ENUM value " + value + " for serializer " + this.getName() + ". Setting to default value.");

          value = this._defaultValue;
        }

        object.setProperty(this.getName(), value);
      } else if (inputStream.inputOperator.matchString(this.getName())) {
        var key = inputStream.inputOperator.readString();
        var _value = this._enumMap[key];

        if (!this._enumMap.hasOwnProperty(key)) {
          _Log.Log.warn("EnumSerializer: failed to find ENUM key " + key + " for serializer " + this.getName() + ". Setting to default value.");

          _value = this._defaultValue;
        }

        object.setProperty(this.getName(), _value);
      }
    }
  }]);
  return EnumSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.EnumSerializer = EnumSerializer;

},{"m_461":100,"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],151:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ImageSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(ImageSerializer, _BaseSerializer);

  var _super = _createSuper(ImageSerializer);

  function ImageSerializer(name, defaultValue, options) {
    var _this;

    (0, _classCallCheck2["default"])(this, ImageSerializer);
    _this = _super.call(this, name, options);
    _this._defaultValue = defaultValue;
    return _this;
  }
  /** @override */


  (0, _createClass2["default"])(ImageSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      if (inputStream.isBinary()) {
        var hasImage = inputStream.inputOperator.readBool();

        if (hasImage) {
          var name = this.getName(),
              image = inputStream.readImage();
          object.setProperty(name, image);
        }
      } else if (inputStream.inputOperator.matchString(this.getName())) {
        var _hasImage = inputStream.inputOperator.readBool();

        if (_hasImage) {
          inputStream.readBeginBracket();
          object.setProperty(this.getName(), inputStream.readImage());
          inputStream.readEndBracket();
        }
      }
    }
  }]);
  return ImageSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.ImageSerializer = ImageSerializer;

},{"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],152:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatrixSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 *
 * @param {InputStream} inputStream
 * @param {string} type
 * @return {function}
 */
function getTypeReaderFunction(inputStream, type) {
  var funcName = "read" + type; // if the function exists in the InputOperator

  var typeReaderFunction = inputStream.inputOperator[funcName];
  if (typeReaderFunction) return typeReaderFunction.bind(inputStream.inputOperator); // if the function exists in the InputStream

  typeReaderFunction = inputStream[funcName];
  if (typeReaderFunction) return typeReaderFunction.bind(inputStream);
  throw "reader type: " + type + " not found";
}

var MatrixSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(MatrixSerializer, _BaseSerializer);

  var _super = _createSuper(MatrixSerializer);

  function MatrixSerializer(name) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, MatrixSerializer);
    _this = _super.call(this, name, options);
    _this._type = options.type || "Double";
    return _this;
  }
  /** @override */


  (0, _createClass2["default"])(MatrixSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      var matrix = [];

      if (inputStream.isBinary()) {
        inputStream.readMatrix(this._type);
      } else if (inputStream.inputOperator.matchString(this.getName())) {
        inputStream.readMatrix(this._type);
      }

      if (matrix) {
        object.setProperty(this.getName(), matrix);
      }
    }
  }]);
  return MatrixSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.MatrixSerializer = MatrixSerializer;

},{"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],153:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectCallbackSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ObjectCallbackSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(ObjectCallbackSerializer, _BaseSerializer);

  var _super = _createSuper(ObjectCallbackSerializer);

  function ObjectCallbackSerializer(name, options) {
    (0, _classCallCheck2["default"])(this, ObjectCallbackSerializer);
    return _super.call(this, name, options);
  }

  (0, _createClass2["default"])(ObjectCallbackSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      var hasObject = false;

      if (inputStream.isBinary()) {
        hasObject = inputStream.inputOperator.readBool();
      } else if (inputStream.inputOperator.matchString(this.getName())) {
        hasObject = inputStream.inputOperator.readBool();
      }

      if (hasObject) {
        throw "callback object serializing is NOT SUPPORTED - property: " + this.getName();
      }
    }
  }]);
  return ObjectCallbackSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.ObjectCallbackSerializer = ObjectCallbackSerializer;

},{"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],154:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ObjectSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(ObjectSerializer, _BaseSerializer);

  var _super = _createSuper(ObjectSerializer);

  function ObjectSerializer(name, defaultValue, options) {
    var _this;

    (0, _classCallCheck2["default"])(this, ObjectSerializer);
    _this = _super.call(this, name, options);
    _this._defaultValue = defaultValue;
    return _this;
  }

  (0, _createClass2["default"])(ObjectSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      if (inputStream.isBinary()) {
        var hasObject = inputStream.inputOperator.readBool();

        if (hasObject) {
          object[this._name] = inputStream.readObjectOfType();
        }
      } else if (inputStream.inputOperator.matchString(this._name)) {
        var _hasObject = inputStream.inputOperator.readBool();

        if (_hasObject) {
          inputStream.readBeginBracket();
          object[this._name] = inputStream.readObjectOfType();
          inputStream.readEndBracket();
        }
      }
    }
  }]);
  return ObjectSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.ObjectSerializer = ObjectSerializer;

},{"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],155:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectWrapper = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _Associate = require("e_672");

var _Log = require("m_461");

var ObjectWrapper = /*#__PURE__*/function () {
  /**
   * constructor of ObjectWrapper
   * @param {string} name
   * @param {string[]|Associate[]}associates
   * @param {function} typeConstructor
   * @param {object} [options]
   */
  function ObjectWrapper(name, associates, typeConstructor) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, ObjectWrapper);
    this._name = name;
    this._typeCtor = typeConstructor;
    this.associates = associates.map(function (associate) {
      if (typeof associate === "string") return new _Associate.Associate(associate);else return associate;
    });
    /**
     *
     * @type {Array<BaseSerializer>}
     * @private
     */

    this._serializers = options.serializers || [];
  }

  (0, _createClass2["default"])(ObjectWrapper, [{
    key: "read",
    value: function read(inputStream, obj) {
      var _this = this;

      var inputVersion = inputStream.getVersion();

      this._serializers.forEach(function (serializer) {
        if (serializer.getMinVersion() <= inputVersion && inputVersion <= serializer.getMaxVersion() //&& serializer.supportsReadWrite()
        ) {
          try {
            serializer.read(inputStream, obj);
          } catch (e) {
            if (e.stack) {
              e = e.toString() + "\n" + e.stack;
            }

            _Log.Log.fatal(e);

            throw "ObjectWrapper.read: Error reading property " + _this._name + "." + serializer.getName();
          }
        } else {// version mismatch
        }
      });
    }
  }, {
    key: "addSerializer",
    value: function addSerializer(serializer) {
      // assert(serializer);
      // assert(serializer.getName);
      // assert(serializer.read);
      this._serializers.push(serializer);
    }
  }, {
    key: "createInstance",
    value: function createInstance() {
      var typeCtor = this._typeCtor;
      if (typeCtor) return new typeCtor();else return null;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
  }]);
  return ObjectWrapper;
}();

exports.ObjectWrapper = ObjectWrapper;

},{"m_461":100,"e_672":148,"e_1":235,"s_2":236,"M_0":241}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectWrapperManager = void 0;

var _GLEnum = require("o_460");

var _ArrayTableEnum = require("-_675");

var _PrimitiveTableEnum = require("3_676");

var _globalMap = {
  ArrayType: _ArrayTableEnum.ArrayTableEnum,
  PrimitiveType: _PrimitiveTableEnum.PrimitiveTableEnum,
  GL: _GLEnum.GLEnum
};
var ObjectWrapperDictionary = {};

function readWrapperObject(wrapperName) {
  return function (inputStream, obj) {
    wrapperObject = ObjectWrapperDictionary[wrapperName];
    if (!wrapperObject) throw "ObjectWrapperManager.readWrapperObject : " + wrapperName;
  };
}

var ObjectWrapperManager = {
  getValue: function getValue(group, str) {
    var map = _globalMap[group] || _GLEnum.GLEnum;
    return map[str];
  },
  findWrapper: function findWrapper(classname) {
    return ObjectWrapperDictionary[classname];
  },
  addWrapper: function addWrapper(objectWrapper) {
    var classname = objectWrapper.getName();
    ObjectWrapperDictionary[classname] = objectWrapper;
  },
  readWrapperObject: readWrapperObject
};
exports.ObjectWrapperManager = ObjectWrapperManager;

},{"-_675":101,"o_460":106,"3_676":111}],157:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropByValSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function getTypeReaderFunction(reader, type) {
  var funcName = "read" + type;
  var typeReaderFunction = reader[funcName];
  if (!typeReaderFunction) throw new Error("reader type: " + type + " not found");
  return typeReaderFunction.bind(reader);
}

var equalTypesDictionary = {
  HEXINT: "UInt",
  GLInt: "Int" // TODO validate GLInt defined as "Int"

};
var vectorDictionary = {
  Vec4d: {
    size: 4,
    type: "Double"
  }
};

var PropByValSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(PropByValSerializer, _BaseSerializer);

  var _super = _createSuper(PropByValSerializer);

  function PropByValSerializer(type, name, defaultValue) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, PropByValSerializer);
    _this = _super.call(this, name, options);
    _this._defaultValue = defaultValue;
    _this._useHex = false;
    _this._vectorSize = 0;

    if (vectorDictionary[type]) {
      _this._vectorSize = vectorDictionary[type].size;
      _this._type = vectorDictionary[type].type;
    } else if (equalTypesDictionary[type]) {
      _this._type = equalTypesDictionary[type];
      _this._useHex = true;
    } else {
      _this._type = type;
    }

    return _this;
  }

  (0, _createClass2["default"])(PropByValSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      var value;

      if (this._vectorSize > 0) {
        value = inputStream.readVectorOfType(this._vectorSize, this._type);
      } else if (inputStream.isBinary()) {
        var typeReaderFunction = getTypeReaderFunction(inputStream.inputOperator, this._type);
        value = typeReaderFunction();
      } else if (inputStream.inputOperator.matchString(this._name)) {
        if (this._useHex) // the type doesn't metter - its all Number
          value = inputStream.inputOperator.readHex();else {
          var _typeReaderFunction = getTypeReaderFunction(inputStream.inputOperator, this._type);

          value = _typeReaderFunction();
        }
      }

      object.setProperty(this._name, value);
    }
  }]);
  return PropByValSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.PropByValSerializer = PropByValSerializer;

},{"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],158:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var UserSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(UserSerializer, _BaseSerializer);

  var _super = _createSuper(UserSerializer);

  function UserSerializer(name, reader, options) {
    var _this;

    (0, _classCallCheck2["default"])(this, UserSerializer);
    _this = _super.call(this, name, options);
    _this._reader = reader;
    return _this;
  }

  (0, _createClass2["default"])(UserSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      if (inputStream.isBinary()) {
        if (!inputStream.inputOperator.readBool()) {
          return;
        }
      } else {
        if (!inputStream.inputOperator.matchString(this.getName())) return;
      }

      this._reader(inputStream, object);
    }
  }]);
  return UserSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.UserSerializer = UserSerializer;

},{"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],159:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VectorSerializer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _BaseSerializer2 = require("s_640");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 *
 * @param {InputStream} inputStream
 * @param {string} type
 * @return {function}
 */
function getTypeReaderFunction(inputStream, type) {
  var funcName = "read" + type; // if the function exists in the InputOperator

  var typeReaderFunction = inputStream.inputOperator[funcName];
  if (typeReaderFunction) return typeReaderFunction.bind(inputStream.inputOperator); // if the function exists in the InputStream

  typeReaderFunction = inputStream[funcName];
  if (typeReaderFunction) return typeReaderFunction.bind(inputStream);
  throw "reader type: " + type + " not found";
}

var VectorSerializer = /*#__PURE__*/function (_BaseSerializer) {
  (0, _inherits2["default"])(VectorSerializer, _BaseSerializer);

  var _super = _createSuper(VectorSerializer);

  function VectorSerializer(name, type, options) {
    var _this;

    (0, _classCallCheck2["default"])(this, VectorSerializer);
    _this = _super.call(this, name, options);
    _this._type = type;
    return _this;
  }
  /** @override */


  (0, _createClass2["default"])(VectorSerializer, [{
    key: "read",
    value: function read(inputStream, object) {
      var typeReaderFunction = getTypeReaderFunction(inputStream, this._type);
      var list = [];

      if (inputStream.isBinary()) {
        var size = inputStream.inputOperator.readUInt();

        for (var i = 0; i < size; i++) {
          list.push(typeReaderFunction());
        }
      } else if (inputStream.inputOperator.matchString(this.getName())) {
        var _size = inputStream.inputOperator.readUInt();

        if (_size > 0) {
          inputStream.readBeginBracket();

          for (var _i = 0; _i < _size; _i++) {
            list.push(typeReaderFunction());
          }

          inputStream.readEndBracket();
        }
      }

      if (list.length > 0) {
        object.setProperty(this._name, list);
      }
    }
  }]);
  return VectorSerializer;
}(_BaseSerializer2.BaseSerializer);

exports.VectorSerializer = VectorSerializer;

},{"s_640":149,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],160:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _EnumSerializer = require("D_699");

var _ObjectWrapper = require("._700");

var _CullFace = require("C_701");

var _CullFace_FaceMode = require("D_501");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::CullFace", ["osg::Object", "osg::StateAttribute", "osg::CullFace"], _CullFace.CullFace);
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("Mode", _CullFace_FaceMode.FaceMode, _CullFace_FaceMode.FaceMode.BACK));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"D_501":104,"C_701":127,"D_699":150,"._700":155,"C_459":156}],161:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _ObjectSerializer = require("M_704");

var _UserSerializer = require("e_705");

var _ObjectCallbackSerializer = require("s_706");

var _PropByValSerializer = require("h_707");

var _ObjectWrapper = require("._700");

var _Associate = require("3_709");

var _Drawable = require("D_710");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Drawable", ["osg::Object", new _Associate.Associate("osg::Node", {
  minVersion: 154
}), "osg::Drawable"], _Drawable.Drawable);

function readInitialBound() {
  // TODO
  throw "InitialBound not yet implemented";
}

objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("StateSet", null));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("InitialBound", readInitialBound));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("ComputeBoundingBoxCallback"));
objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("Shape", null));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "SupportsDisplayList", true));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "UseDisplayList", true));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "UseVertexBufferObjects", false));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("UpdateCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("EventCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("CullCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("DrawCallback"));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("HEXINT", "NodeMask", 0xffffffff, {
  minVersion: 142
}));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "CullingActive", true, {
  minVersion: 145
}));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"D_710":129,"3_709":148,"s_706":153,"M_704":154,"._700":155,"C_459":156,"h_707":157,"e_705":158}],162:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _UserSerializer = require("e_705");

var _ObjectWrapper = require("._700");

var _Geode = require("m_714");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Geode", ["osg::Object", "osg::Node", "osg::Geode"], _Geode.Geode);

function readDrawables(inputStream, geodeNode) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    var obj = inputStream.readObjectOfType("osg::Drawable");

    if (obj) {
      geodeNode.Children.push(obj);
    }
  }

  inputStream.readEndBracket();
}

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Drawables", readDrawables));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"m_714":130,"._700":155,"C_459":156,"e_705":158}],163:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _VectorSerializer = require("e_716");

var _ObjectSerializer = require("M_704");

var _UserSerializer = require("e_705");

var _ObjectWrapper = require("._700");

var _Geometry = require("3_720");

var _OsgArray = require("D_721");

var _Associate = require("3_709");

var _DefaultUserDataContainer = require("C_723");

var _AttributeBinding = require("o_724");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Geometry", ['osg::Object', new _Associate.Associate("osg::Node", {
  minVersion: 154
}), 'osg::Drawable', 'osg::Geometry'], _Geometry.Geometry);
/**
 *
 * @param {InputStream} inputStream
 * @return {number}
 */

function readAttributeBinding(inputStream) {
  var value = 0;
  if (inputStream.isBinary()) value = inputStream.inputOperator.readInt();else {
    var key = inputStream.inputOperator.readString();
    value = _AttributeBinding.AttributeBinding[key];
  }
  return value;
}
/**
 * @param {InputStream} inputStream
 * @return {OsgArray}
 */


function readArray(inputStream) {
  var array = new _OsgArray.OsgArray();
  inputStream.readProperty("Array");
  var hasArray = inputStream.inputOperator.readBool();

  if (hasArray) {
    array = inputStream.readArray();
  }

  inputStream.readProperty("Indices");
  var hasIndices = inputStream.inputOperator.readBool();

  if (hasIndices) {
    var indices_array = inputStream.readArray();

    if (indices_array) {
      if (!array.UserDataContainer) // Init UserDataContainer
        array.UserDataContainer = new _DefaultUserDataContainer.DefaultUserDataContainer();
      array.UserDataContainer.UserData = indices_array;
    }
  }

  inputStream.readProperty("Binding");
  array.Binding = readAttributeBinding(inputStream);
  inputStream.readProperty("Normalize");
  array.Normalize = inputStream.inputOperator.readInt() !== 0;
  return array;
}

function getReadArrayDataFunction(property) {
  return function (inputStream, geometry) {
    inputStream.readBeginBracket();
    var array = readArray(inputStream);
    geometry.setProperty(property, array);
    inputStream.readEndBracket();
  };
}

function getReadArrayListFunction(property) {
  return function (inputStream, geometry) {
    var size = inputStream.inputOperator.readUInt();
    inputStream.readBeginBracket();
    var ArrayList = [];

    for (var i = 0; i < size; i++) {
      inputStream.readProperty("Data");
      inputStream.readBeginBracket();
      var array = readArray(inputStream);
      ArrayList.push(array);
      inputStream.readEndBracket();
    }

    inputStream.readEndBracket();
    geometry.setProperty(property, ArrayList);
    inputStream.readEndBracket();
  };
}
/**
 * @param {InputStream} inputStream
 * @param {Geometry} Geometry
 */


function readFastPathHint(inputStream, Geometry) {
  if (!inputStream.isBinary()) return inputStream.inputOperator.readBool();
}

objectWrapper.addSerializer(new _VectorSerializer.VectorSerializer("PrimitiveSetList", "PrimitiveSet")); // Until Version 111

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("VertexData", getReadArrayDataFunction("VertexArray"), {
  maxVersion: 111
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("NormalData", getReadArrayDataFunction("NormalArray"), {
  maxVersion: 111
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("ColorData", getReadArrayDataFunction("ColorArray"), {
  maxVersion: 111
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("SecondaryColorData", getReadArrayDataFunction("SecondaryColorArray"), {
  maxVersion: 111
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("FogCoordData", getReadArrayDataFunction("FogCoordArray"), {
  maxVersion: 111
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("TexCoordData", getReadArrayListFunction("TexCoordArray"), {
  maxVersion: 111
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("VertexAttribData", getReadArrayListFunction("VertexAttribArray"), {
  maxVersion: 111
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("FastPathHint ", readFastPathHint, {
  maxVersion: 111
})); // From Version 112

objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("VertexArray", null, {
  minVersion: 112
}));
objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("NormalArray", null, {
  minVersion: 112
}));
objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("ColorArray", null, {
  minVersion: 112
}));
objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("SecondaryColorArray", null, {
  minVersion: 112
}));
objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("FogCoordArray", null, {
  minVersion: 112
}));
objectWrapper.addSerializer(new _VectorSerializer.VectorSerializer("TexCoordArrayList", "Array", {
  minVersion: 112
}));
objectWrapper.addSerializer(new _VectorSerializer.VectorSerializer("VertexAttribArrayList", "Array", {
  minVersion: 112
}));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"o_724":102,"C_723":128,"3_720":131,"D_721":139,"3_709":148,"M_704":154,"._700":155,"C_459":156,"e_705":158,"e_716":159}],164:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _UserSerializer = require("e_705");

var _ObjectWrapper = require("._700");

var _Group = require("s_728");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Group", ["osg::Object", "osg::Node", "osg::Group"], _Group.Group);

function readChildren(inputStream, groupNode) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    var obj = inputStream.readObject();

    if (obj) {
      groupNode.Children.push(obj);
    }
  }

  inputStream.readEndBracket();
}

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Children", readChildren));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"s_728":132,"._700":155,"C_459":156,"e_705":158}],165:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _UserSerializer = require("e_705");

var _EnumSerializer = require("D_699");

var _ObjectWrapper = require("._700");

var _LOD = require("._733");

var _CenterMode = require("D_545");

var _RangeMode = require("._546");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::LOD", ["osg::Object", "osg::Node", "osg::LOD"], _LOD.LOD);

function readRangeList(inputStream, lod) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();
  var ranges = [];

  for (var i = 0; i < size; i++) {
    var min = inputStream.inputOperator.readFloat();
    var max = inputStream.inputOperator.readFloat();
    ranges.push([min, max]);
  }

  inputStream.readEndBracket();
  lod.setProperty("RangeList", ranges);
}

function readUserCenter(inputStream, groupNode) {
  var center = inputStream.readVectorOfType(3, "Double");
  var radius = inputStream.inputOperator.readDouble();
  groupNode.setProperty('UserCenter', {
    center: center,
    radius: radius
  });
}

objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("CenterMode", _CenterMode.CenterMode, _CenterMode.CenterMode.USE_BOUNDING_SPHERE_CENTER));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("UserCenter", readUserCenter));
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("RangeMode", _RangeMode.RangeMode, _RangeMode.RangeMode.DISTANCE_FROM_EYE_POINT));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("RangeList", readRangeList));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"D_545":103,"._546":112,"._733":134,"D_699":150,"._700":155,"C_459":156,"e_705":158}],166:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _EnumSerializer = require("D_699");

var _UserSerializer = require("e_705");

var _ObjectWrapper = require("._700");

var _Material = require("h_740");

var _Material_ColorMode = require("-_741");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Material", ["osg::Object", "osg::StateAttribute", "osg::Material"], _Material.Material);

function readMaterialFunc(property, type) {
  function reader(inputStream, material) {
    // todo create function "readType" this in inputStream; also exist in typeReaderFunction
    var readerFunc;

    if (type === "Float") {
      readerFunc = inputStream.inputOperator.readFloat.bind(inputStream.inputOperator);
    } else if (type === "Vec4f") {
      readerFunc = function readerFunc() {
        return inputStream.readVectorOfType(4, "Float");
      };
    } else {
      throw "serializeMaterial - type not supported";
    }

    var frontAndBack = inputStream.inputOperator.readBool();
    inputStream.readProperty("Front");
    var value1 = readerFunc();
    inputStream.readProperty("Back");
    var value2 = readerFunc();

    if (frontAndBack) {
      material[property + "FrontAndBack"] = true;
      material[property + "Front"] = value1;
      material[property + "Back"] = value1;
    } else {
      material[property + "FrontAndBack"] = false;
      material[property + "Front"] = value1;
      material[property + "Back"] = value2;
    }
  }

  return reader;
}

objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("ColorMode", _Material_ColorMode.ColorMode, _Material_ColorMode.ColorMode.OFF));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Ambient", readMaterialFunc("Ambient", "Vec4f")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Diffuse", readMaterialFunc("Diffuse", "Vec4f")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Specular", readMaterialFunc("Specular", "Vec4f")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Emission", readMaterialFunc("Emission", "Vec4f")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Shininess", readMaterialFunc("Shininess", "Float")));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"-_741":108,"h_740":135,"D_699":150,"._700":155,"C_459":156,"e_705":158}],167:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _MatrixSerializer = require("D_743");

var _ObjectWrapper = require("._700");

var _MatrixTransform = require("C_745");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::MatrixTransform", ["osg::Object", "osg::Node", "osg::Group", "osg::Transform", "osg::MatrixTransform"], _MatrixTransform.MatrixTransform);
objectWrapper.addSerializer(new _MatrixSerializer.MatrixSerializer("Mode"));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"C_745":136,"D_743":152,"._700":155,"C_459":156}],168:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _ObjectCallbackSerializer = require("s_706");

var _ObjectSerializer = require("M_704");

var _UserSerializer = require("e_705");

var _PropByValSerializer = require("h_707");

var _ObjectWrapper = require("._700");

var _Node = require("-_752");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Node", ["osg::Object", "osg::Node"], _Node.Node);

function readInitialBound(inputStream, node) {
  // todo check if readVectorOfType is right
  var center, radius;
  inputStream.readBeginBracket();
  inputStream.readProperty("Center");
  center = inputStream.readVectorOfType(3, "Double");
  inputStream.readProperty("Radius");
  radius = inputStream.inputOperator.readDouble();
  inputStream.readEndBracket();
  node.InitialBound = {
    center: center,
    radius: radius
  };
}

function readDescriptions(inputStream, node) {
  var size = inputStream.inputOperator.readUInt();

  for (var i = 0; i < size; ++i) {
    var value = inputStream.inputOperator.readWrappedString();
    node.descriptions.push(value);
  }

  inputStream.readEndBracket();
}

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("InitialBound", readInitialBound));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("ComputeBoundingSphereCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("UpdateCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("EventCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("CullCallback"));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "CullingActive", true));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("HEXINT", "NodeMask", 0xffffffff));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Descriptions", readDescriptions, {
  maxVersion: 76
}));
objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("StateSet", null));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"-_752":137,"s_706":153,"M_704":154,"._700":155,"C_459":156,"h_707":157,"e_705":158}],169:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _EnumSerializer = require("D_699");

var _ObjectSerializer = require("M_704");

var _UserSerializer = require("e_705");

var _PropByValSerializer = require("h_707");

var _ObjectWrapper = require("._700");

var _Object = require("M_759");

var _ObjectData_Variance = require("e_760");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Object", ["osg::Object"], _Object.ObjectClass);

function UserDataReader() {
  // TODO
  throw "UserDataReader not yet supported";
}

objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("String", "Name", ""));
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("DataVariance", _ObjectData_Variance.ObjectDataVariance, _ObjectData_Variance.ObjectDataVariance.UNSPECIFIED));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("UserData", UserDataReader, {
  maxVersion: 76
}));
objectWrapper.addSerializer(new _ObjectSerializer.ObjectSerializer("UserDataContainer", null, {
  minVersion: 77
}));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"e_760":109,"M_759":138,"D_699":150,"M_704":154,"._700":155,"C_459":156,"h_707":157,"e_705":158}],170:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _UserSerializer = require("e_705");

var _PropByValSerializer = require("h_707");

var _ObjectWrapper = require("._700");

var _PagedLOD = require("D_765");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::PagedLOD", ["osg::Object", "osg::Node", "osg::LOD", "osg::PagedLOD"], _PagedLOD.PagedLOD);

function readRangeDataList(inputStream, lod) {
  var rangeDataList = [],
      priorityOffsets = [],
      priorityScales = [];
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    var name = inputStream.inputOperator.readWrappedString();
    rangeDataList.push(name);
  }

  inputStream.readEndBracket();
  inputStream.readProperty("PriorityList");
  size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var _i = 0; _i < size; _i++) {
    priorityOffsets.push(inputStream.inputOperator.readFloat());
    priorityScales.push(inputStream.inputOperator.readFloat());
  }

  inputStream.readEndBracket();
  lod.setProperty("RangeDataList", rangeDataList);
  lod.setProperty("PriorityOffsets", priorityOffsets);
  lod.setProperty("PriorityScales", priorityScales);
}

function readChildren(inputStream, lod) {
  var size = inputStream.inputOperator.readUInt();

  if (size > 0) {
    var children = [];
    inputStream.readBeginBracket();

    for (var i = 0; i < size; i++) {
      var child = inputStream.readObjectOfType("osg::Node");

      if (child) {
        children.push(child);
      }
    }

    inputStream.readEndBracket();
    lod.setProperty("Children", children);
  }
}

function readDatabasePath(inputStream, pagedLod) {
  var hasPath = inputStream.inputOperator.readBool();
  var databasePath;

  if (hasPath) {
    databasePath = inputStream.inputOperator.readWrappedString();
    pagedLod.setProperty("DatabasePath", databasePath);
  } else {// todo
    // if empty databasePath setted in https://github.com/openscenegraph/OpenSceneGraph/blob/31d78b7bb3994065462fb1163d006c8649e7144f/src/osgDB/Registry.cpp#L1169
  }
}

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("DatabasePath", readDatabasePath));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("UInt", "FrameNumberOfLastTraversal", 0, {
  maxVersion: 69
}));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("UInt", "NumChildrenThatCannotBeExpired", 0));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "DisableExternalChildrenPaging", false));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("RangeDataList", readRangeDataList));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Children", readChildren));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"D_765":140,"._700":155,"C_459":156,"h_707":157,"e_705":158}],171:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _EnumSerializer = require("D_699");

var _ObjectWrapper = require("._700");

var _ShadeModel = require("m_769");

var _ShadeModel_Mode = require("M_770");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::ShadeModel", ["osg::Object", "osg::StateAttribute", "osg::ShadeModel"], _ShadeModel.ShadeModel);
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("Mode", _ShadeModel_Mode.ShadeModelMode, _ShadeModel_Mode.ShadeModelMode.SMOOTH));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"M_770":113,"m_769":141,"D_699":150,"._700":155,"C_459":156}],172:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _ObjectCallbackSerializer = require("s_706");

var _ObjectWrapper = require("._700");

var _StateAttribute = require("-_774");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::StateAttribute", ["osg::Object", "osg::StateAttribute"], _StateAttribute.StateAttribute);
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("UpdateCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("EventCallback"));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"-_774":142,"s_706":153,"._700":155,"C_459":156}],173:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _UserSerializer = require("e_705");

var _EnumSerializer = require("D_699");

var _PropByValSerializer = require("h_707");

var _ObjectCallbackSerializer = require("s_706");

var _ObjectWrapper = require("._700");

var _StateSet = require("M_781");

var _StateSet_RenderingHint = require("D_600");

var _StateSet_RenderBinMode = require("._601");

var _StateAttribute_Value = require("h_784");

var _DataTypes = require("s_475");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::StateSet", ["osg::Object", "osg::StateSet"], _StateSet.StateSet);

function pushMany(arr, toPush) {
  Array.prototype.push.apply(arr, toPush);
} // TODO ALL of reader functions are not exactly like in OGS repo. maybe need to be rewriten
// readModeList, readAttributeList, readTextureModeList, readTextureAttributeList,readUniformList,readDefineList


function readModes(inputStream) {
  var size = inputStream.inputOperator.readUInt();
  var modes = [];

  if (size > 0) {
    inputStream.readBeginBracket();

    for (var i = 0; i < size; i++) {
      var mode = new _DataTypes.DataTypes.ObjectGLEnum();
      inputStream.inputOperator.readGLEnum(mode);
      modes.push({
        key: mode.value,
        value: readValue(inputStream)
      });
    }

    inputStream.readEndBracket();
  }

  return modes;
}

function readAttributes(inputStream) {
  var attributes = [];
  var size = inputStream.inputOperator.readUInt();

  if (size > 0) {
    inputStream.readBeginBracket();

    for (var i = 0; i < size; i++) {
      var sa = inputStream.readObjectOfType("osg::StateAttribute");
      inputStream.readProperty("Value");
      var value = readValue(inputStream);

      if (sa) {
        attributes.push({
          key: sa.getTypeMemberPair(),
          value: {
            StateAttribute: sa,
            Value: value
          }
        });
      }
    }

    inputStream.readEndBracket();
  }

  return attributes;
}

function readValue(inputStream) {
  if (inputStream.isBinary()) return inputStream.inputOperator.readInt();else {
    var enumValue = inputStream.inputOperator.readString();
    var value = 0;
    if (enumValue.indexOf("OFF") >= 0) value = _StateAttribute_Value.StateAttributeValue.OFF;
    if (enumValue.indexOf("ON") >= 0) value = _StateAttribute_Value.StateAttributeValue.ON;
    if (enumValue.indexOf("OVERRIDE") >= 0) value = value | _StateAttribute_Value.StateAttributeValue.OVERRIDE;
    if (enumValue.indexOf("PROTECTED") >= 0) value = value | _StateAttribute_Value.StateAttributeValue.PROTECTED;
    if (enumValue.indexOf("INHERIT") >= 0) value = value | _StateAttribute_Value.StateAttributeValue.INHERIT;
    return value;
  }
}

function readModeList(inputStream, stateSet) {
  var modes = readModes(inputStream);
  pushMany(stateSet.ModeList, modes);
  return true;
}

function readAttributeList(inputStream, stateSet) {
  var modes = readAttributes(inputStream);
  pushMany(stateSet.AttributeList, modes);
}

function readTextureModeList(inputStream, stateSet) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    inputStream.readProperty("Data");
    pushMany(stateSet.TextureModeList, readModes(inputStream));
  }

  inputStream.readEndBracket();
}

function readTextureAttributeList(inputStream, stateSet) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    inputStream.readProperty("Data");
    pushMany(stateSet.TextureAttributeList, readAttributes(inputStream));
  }

  inputStream.readEndBracket();
}

function readDefineList(inputStream, stateSet) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    var defineName = inputStream.inputOperator.readWrappedString();
    var defineValue = inputStream.inputOperator.readWrappedString();
    inputStream.inputOperator.readObjectProperty(inputStream.PROPERTY.set("Value"));
    var overrideValue = readValue(inputStream);
    stateSet.DefineList[defineName] = {
      DefineValue: defineValue,
      OverrideValue: overrideValue
    };
  }

  inputStream.readEndBracket();
}

function readUniformList(inputStream, stateSet) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    var uniform = inputStream.readObjectOfType("osg::Uniform");
    inputStream.inputOperator.readObjectProperty(inputStream.PROPERTY.set("Value"));
    var value = readValue(inputStream);

    if (uniform) {
      stateSet.UniformList.push({
        Uniform: uniform,
        Value: value
      });
    }
  }

  inputStream.readEndBracket();
}

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("ModeList", readModeList));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("AttributeList", readAttributeList));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("TextureModeList", readTextureModeList));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("TextureAttributeList", readTextureAttributeList));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("UniformList", readUniformList));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Int", "RenderingHint", _StateSet_RenderingHint.RenderingHint.DEFAULT_BIN));
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("RenderBinMode", _StateSet_RenderBinMode.RenderBinMode, _StateSet_RenderBinMode.RenderBinMode.DEFAULT_BIN));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Int", "BinNumber", 0));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("String", "BinName", ""));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "NestRenderBins", true));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("UpdateCallback"));
objectWrapper.addSerializer(new _ObjectCallbackSerializer.ObjectCallbackSerializer("EventCallback"));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("DefineList", readDefineList, {
  minVersion: 151
}));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"s_475":99,"h_784":114,"._601":115,"D_600":116,"M_781":143,"D_699":150,"s_706":153,"._700":155,"C_459":156,"h_707":157,"e_705":158}],174:[function(require,module,exports){
"use strict";

var _UserSerializer = require("e_705");

var _PropByValSerializer = require("h_707");

var _EnumSerializer = require("D_699");

var _Texture = require("C_789");

var _Texture_InternalFormatMode = require("-_609");

var _Texture_ShadowCompareFunc = require("m_791");

var _Texture_ShadowTextureMode = require("M_792");

var _DataTypes = require("s_475");

var _ObjectWrapper = require("._700");

var _ObjectWrapperManager = require("C_459");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Texture", ["osg::Object", "osg::StateAttribute", "osg::Texture"], _Texture.Texture);
var swizzleDictionary = {
  "R": 0x1903,
  "G": 0x1904,
  "B": 0x1905,
  "A": 0x1906,
  "0": 0,
  "1": 1
};

function readInternalFormat(inputStream, texture) {
  var mode = new _DataTypes.ObjectGLEnum();
  inputStream.inputOperator.readGLEnum(mode);

  if (texture.getProperty("InternalFormatMode") === _Texture_InternalFormatMode.InternalFormatMode.USE_USER_DEFINED_FORMAT) {
    texture.setInternalFormat(mode.value);
  }
}

function readGLEnum(property) {
  return function (inputStream, texture) {
    var mode = new _DataTypes.ObjectGLEnum();
    inputStream.inputOperator.readGLEnum(mode);
    texture.setProperty(property, mode);
  };
}

function readSwizzle(inputStream, texture) {
  var swizzleString = inputStream.inputOperator.readString();
  var swizzle = [];

  for (var i = 0; i < 4; i++) {
    swizzle.push(swizzleDictionary[swizzleString.charAt(i)]);
  }

  texture.setProperty("Swizzle", swizzle);
}

function readImageAttachment(inputStream) {
  inputStream.inputOperator.readUInt();
  inputStream.inputOperator.readInt();
  inputStream.inputOperator.readBool();
  inputStream.inputOperator.readInt();
  inputStream.inputOperator.readInt();
  inputStream.inputOperator.readInt();
} // todo add all properties to Texture class


objectWrapper.addSerializer(new _UserSerializer.UserSerializer("WRAP_S", readGLEnum("WrapS")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("WRAP_T", readGLEnum("WrapT")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("WRAP_R", readGLEnum("WrapR")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("MIN_FILTER", readGLEnum("MinFilter")));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("MAG_FILTER", readGLEnum("MagFilter")));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Float", "MaxAnisotropy", 1));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "UseHardwareMipMapGeneration", true));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "UnRefImageDataAfterApply", false));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "ClientStorageHint", false));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "ResizeNonPowerOfTwoHint", true));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Vec4d", "BorderColor", [0, 0, 0, 0], {
  minVersion: 79
}));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("GLInt", "BorderWidth", 0, {
  minVersion: 79
}));
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("InternalFormatMode", _Texture_InternalFormatMode.InternalFormatMode, _Texture_InternalFormatMode.InternalFormatMode.USE_IMAGE_DATA_FORMAT, {
  minVersion: 79
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("InternalFormat", readInternalFormat, {
  minVersion: 79
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("SourceFormat", readGLEnum("SourceFormat"), {
  minVersion: 79
}));
objectWrapper.addSerializer(new _UserSerializer.UserSerializer("SourceType", readGLEnum("SourceType"), {
  minVersion: 79
}));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Bool", "ShadowComparison", false, {
  minVersion: 79
}));
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("ShadowCompareFunc", _Texture_ShadowCompareFunc.ShadowCompareFunc, _Texture_ShadowCompareFunc.ShadowCompareFunc.LEQUAL, {
  minVersion: 79
}));
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("ShadowTextureMode", _Texture_ShadowTextureMode.ShadowTextureMode, _Texture_ShadowTextureMode.ShadowTextureMode.LUMINANCE, {
  minVersion: 79
}));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Float", "ShadowAmbient", 0, {
  minVersion: 79
})); // From version 95. removed in version 153

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("ImageAttachment", readImageAttachment, {
  minVersion: 95,
  maxVersion: 152
})); // From version 98

objectWrapper.addSerializer(new _UserSerializer.UserSerializer("Swizzle", readSwizzle, {
  minVersion: 98
})); // From version 155

objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Float", "MinLOD", 0, {
  minVersion: 155
}));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Float", "MaxLOD", -1, {
  minVersion: 155
}));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Float", "LODBias", 0, {
  minVersion: 155
}));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"s_475":99,"-_609":117,"m_791":118,"M_792":119,"C_789":144,"D_699":150,"._700":155,"C_459":156,"h_707":157,"e_705":158}],175:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _PropByValSerializer = require("h_707");

var _ImageSerializer = require("D_798");

var _ObjectWrapper = require("._700");

var _Texture2D = require("C_800");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Texture2D", ["osg::Object", "osg::StateAttribute", "osg::Texture", "osg::Texture2D"], _Texture2D.Texture2D);
objectWrapper.addSerializer(new _ImageSerializer.ImageSerializer("Image", null));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Int", "TextureWidth", 0));
objectWrapper.addSerializer(new _PropByValSerializer.PropByValSerializer("Int", "TextureHeight", 0));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"C_800":145,"D_798":151,"._700":155,"C_459":156,"h_707":157}],176:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _EnumSerializer = require("D_699");

var _ObjectWrapper = require("._700");

var _Transform = require("e_804");

var _Transform_ReferenceFrame = require("s_805");

var objectWrapper = new _ObjectWrapper.ObjectWrapper("osg::Transform", ["osg::Object", "osg::Node", "osg::Group", "osg::Transform"], _Transform.Transform);
objectWrapper.addSerializer(new _EnumSerializer.EnumSerializer("Mode", _Transform_ReferenceFrame.ReferenceFrame, _Transform_ReferenceFrame.ReferenceFrame.RELATIVE_RF));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(objectWrapper);

},{"s_805":120,"e_804":146,"D_699":150,"._700":155,"C_459":156}],177:[function(require,module,exports){
"use strict";

var _ObjectWrapperManager = require("C_459");

var _UserSerializer = require("e_705");

var _ObjectWrapper = require("._700");

var _DefaultUserDataContainer = require("C_723");

var UDCobjectWrapper = new _ObjectWrapper.ObjectWrapper("osg::UserDataContainer", ["osg::Object", "osg::UserDataContainer"], null // UserDataContainer
);
var DUDCobjectWrapper = new _ObjectWrapper.ObjectWrapper("osg::DefaultUserDataContainer", ["osg::Object", "osg::UserDataContainer", "osg::DefaultUserDataContainer"], _DefaultUserDataContainer.DefaultUserDataContainer);

function readUserData(inputStream, obj) {
  inputStream.readBeginBracket();
  obj.UserData = inputStream.readObject();
  inputStream.readEndBracket();
}

function readDescriptions(inputStream, obj) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    var description = inputStream.inputOperator.readWrappedString();
    obj.DescriptionList.push(description);
  }

  inputStream.readEndBracket();
}

function readUserObject(inputStream, obj) {
  var size = inputStream.inputOperator.readUInt();
  inputStream.readBeginBracket();

  for (var i = 0; i < size; i++) {
    var objReaded = inputStream.inputOperator.readWrappedString();
    obj.ObjectList.push(objReaded);
  }

  inputStream.readEndBracket();
}

DUDCobjectWrapper.addSerializer(new _UserSerializer.UserSerializer("UDC_UserData", readUserData));
DUDCobjectWrapper.addSerializer(new _UserSerializer.UserSerializer("UDC_Descriptions", readDescriptions));
DUDCobjectWrapper.addSerializer(new _UserSerializer.UserSerializer("UDC_UserObjects", readUserObject));

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(DUDCobjectWrapper);

_ObjectWrapperManager.ObjectWrapperManager.addWrapper(UDCobjectWrapper);

},{"C_723":128,"._700":155,"C_459":156,"e_705":158}],178:[function(require,module,exports){
"use strict";

require("._810");

require("C_525");

require("o_812");

require("m_813");

require("s_519");

require("e_815");

require("s_816");

require("._513");

require("m_494");

require("3_819");

require("3_500");

require("._821");

require("m_615");

require("o_823");

require("C_558");

require("e_507");

require("C_580");

require("s_827");

},{"._810":160,"C_525":161,"o_812":162,"m_813":163,"s_519":164,"C_580":165,"e_815":166,"s_816":167,"._513":168,"m_494":169,"s_827":170,"3_819":171,"3_500":172,"._821":173,"m_615":174,"o_823":175,"C_558":176,"e_507":177}],179:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = traverse;
Object.defineProperty(exports, "RenderBinMode", {
  enumerable: true,
  get: function get() {
    return _StateSet_RenderBinMode.RenderBinMode;
  }
});
Object.defineProperty(exports, "ShadowTextureMode", {
  enumerable: true,
  get: function get() {
    return _Texture_ShadowTextureMode.ShadowTextureMode;
  }
});
Object.defineProperty(exports, "FaceMode", {
  enumerable: true,
  get: function get() {
    return _CullFace_FaceMode.FaceMode;
  }
});
Object.defineProperty(exports, "ColorMode", {
  enumerable: true,
  get: function get() {
    return _Material_ColorMode.ColorMode;
  }
});
Object.defineProperty(exports, "StateAttributeValue", {
  enumerable: true,
  get: function get() {
    return _StateAttribute_Value.StateAttributeValue;
  }
});
Object.defineProperty(exports, "RenderingHint", {
  enumerable: true,
  get: function get() {
    return _StateSet_RenderingHint.RenderingHint;
  }
});
Object.defineProperty(exports, "ReferenceFrame", {
  enumerable: true,
  get: function get() {
    return _Transform_ReferenceFrame.ReferenceFrame;
  }
});
Object.defineProperty(exports, "InternalFormatMode", {
  enumerable: true,
  get: function get() {
    return _Texture_InternalFormatMode.InternalFormatMode;
  }
});
Object.defineProperty(exports, "PrimitiveMode", {
  enumerable: true,
  get: function get() {
    return _PrimitiveMode.PrimitiveMode;
  }
});
Object.defineProperty(exports, "GLEnum", {
  enumerable: true,
  get: function get() {
    return _GLEnum.GLEnum;
  }
});
Object.defineProperty(exports, "AttributeBinding", {
  enumerable: true,
  get: function get() {
    return _AttributeBinding.AttributeBinding;
  }
});
Object.defineProperty(exports, "ShadeModelMode", {
  enumerable: true,
  get: function get() {
    return _ShadeModel_Mode.ShadeModelMode;
  }
});
Object.defineProperty(exports, "CenterMode", {
  enumerable: true,
  get: function get() {
    return _CenterMode.CenterMode;
  }
});
Object.defineProperty(exports, "RangeMode", {
  enumerable: true,
  get: function get() {
    return _RangeMode.RangeMode;
  }
});
Object.defineProperty(exports, "ImageType", {
  enumerable: true,
  get: function get() {
    return _ImageType.ImageType;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return _Log.Log;
  }
});
Object.defineProperty(exports, "readBuffer", {
  enumerable: true,
  get: function get() {
    return _ReadFile.readBuffer;
  }
});
Object.defineProperty(exports, "readFile", {
  enumerable: true,
  get: function get() {
    return _ReadFile.readFile;
  }
});
Object.defineProperty(exports, "EnumToString", {
  enumerable: true,
  get: function get() {
    return _EnumToString.EnumToString;
  }
});
Object.defineProperty(exports, "Node", {
  enumerable: true,
  get: function get() {
    return _Node.Node;
  }
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return _Group.Group;
  }
});
Object.defineProperty(exports, "Drawable", {
  enumerable: true,
  get: function get() {
    return _Drawable.Drawable;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _Image.Image;
  }
});
Object.defineProperty(exports, "Geode", {
  enumerable: true,
  get: function get() {
    return _Geode.Geode;
  }
});
Object.defineProperty(exports, "OsgArray", {
  enumerable: true,
  get: function get() {
    return _OsgArray.OsgArray;
  }
});
Object.defineProperty(exports, "MatrixTransform", {
  enumerable: true,
  get: function get() {
    return _MatrixTransform.MatrixTransform;
  }
});
Object.defineProperty(exports, "Material", {
  enumerable: true,
  get: function get() {
    return _Material.Material;
  }
});
Object.defineProperty(exports, "StateAttribute", {
  enumerable: true,
  get: function get() {
    return _StateAttribute.StateAttribute;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function get() {
    return _Texture2D.Texture2D;
  }
});
Object.defineProperty(exports, "Texture", {
  enumerable: true,
  get: function get() {
    return _Texture.Texture;
  }
});
Object.defineProperty(exports, "StateSet", {
  enumerable: true,
  get: function get() {
    return _StateSet.StateSet;
  }
});
Object.defineProperty(exports, "ObjectClass", {
  enumerable: true,
  get: function get() {
    return _Object.ObjectClass;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function get() {
    return _Geometry.Geometry;
  }
});
exports.PrimitiveTable = void 0;

var _StateSet_RenderBinMode = require("h_828");

var _Texture_ShadowTextureMode = require("-_829");

var _CullFace_FaceMode = require("3_830");

var _Material_ColorMode = require("D_831");

var _StateAttribute_Value = require("._832");

var _StateSet_RenderingHint = require("C_833");

var _Transform_ReferenceFrame = require("o_834");

var _Texture_InternalFormatMode = require("m_835");

var _PrimitiveMode = require("M_836");

var _GLEnum = require("e_837");

var _AttributeBinding = require("s_838");

var _ShadeModel_Mode = require("h_839");

var _CenterMode = require("-_840");

var _RangeMode = require("3_841");

var _PrimitiveTableEnum = require("D_842");

var _ImageType = require("._843");

var _Log = require("C_844");

var _ReadFile = require("o_845");

var _EnumToString = require("m_846");

var _Node = require("M_847");

var _Group = require("e_848");

var _Drawable = require("s_849");

var _Image = require("h_850");

var _Geode = require("-_851");

var _OsgArray = require("3_852");

var _MatrixTransform = require("D_853");

var _Material = require("._854");

var _StateAttribute = require("C_855");

var _Texture2D = require("o_856");

var _Texture = require("m_857");

var _StateSet = require("M_858");

var _Object = require("e_859");

var _Geometry = require("s_860");

/**
 * 
 * @see "https://github.com/eran-pinhas/osg-serializer-js.git"
 * @author eran-pinhas (https://github.com/eran-pinhas)
 * @author MikesWei (https://github.com/MikesWei)
 */
//
var PrimitiveTable = _PrimitiveTableEnum.PrimitiveTableEnum;
exports.PrimitiveTable = PrimitiveTable;

function traverse(osgNode, callback) {
  if (callback) callback(osgNode);
  var Children = osgNode.Children;

  if (Children && Children.length) {
    for (var i = 0; i < Children.length; i++) {
      var node = Children[i];
      traverse(node, callback);
    }
  }
}
/*module.exports.readFile('./Samples/grass1.osgb',function (err, data) {
    console.log(err,data)
});*/

},{"C_844":100,"s_838":102,"-_840":103,"3_830":104,"m_846":105,"e_837":106,"._843":107,"D_831":108,"M_836":110,"D_842":111,"3_841":112,"h_839":113,"._832":114,"h_828":115,"C_833":116,"m_835":117,"-_829":119,"o_834":120,"o_845":124,"s_849":129,"-_851":130,"s_860":131,"e_848":132,"h_850":133,"._854":135,"D_853":136,"M_847":137,"e_859":138,"3_852":139,"C_855":142,"M_858":143,"m_857":144,"o_856":145}],180:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _GLTFLoader = require("o_867");

var _DRACOLoader = require("m_868");

var _DDSLoader = require("M_869");

var _OSGLoader = _interopRequireDefault(require("e_870"));

var _Path = _interopRequireDefault(require("s_871"));

var _GenericWorker = _interopRequireDefault(require("h_872"));

var _MeshVisModelUtil2 = _interopRequireDefault(require("-_873"));

var _TaskList = require("3_874");

var _IRenderable2 = _interopRequireDefault(require("D_875"));

var _TextureUtils = _interopRequireDefault(require("._876"));

var _releaseResources = _interopRequireDefault(require("C_877"));

var _VISMLoader = _interopRequireDefault(require("o_878"));

var _WebGLGeometries = _interopRequireDefault(require("m_879"));

var _RendererUtils = _interopRequireDefault(require("M_880"));

var _GeometryUtils = _interopRequireDefault(require("M_132"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createDebugVolume(boundingBox, primitive, debugVolumeColor) {
  var _Cesium = Cesium,
      BoxOutlineGeometry = _Cesium.BoxOutlineGeometry,
      Color = _Cesium.Color;
  var geometry = BoxOutlineGeometry.fromAxisAlignedBoundingBox(boundingBox);
  geometry = BoxOutlineGeometry.createGeometry(geometry);

  if (debugVolumeColor && debugVolumeColor instanceof Color) {
    debugVolumeColor = debugVolumeColor.toCssColorString();
  }

  var aabBoxMaterial = new THREE.LineBasicMaterial({
    color: debugVolumeColor || 'cyan',
    transparent: true
  });
  aabBoxMaterial._debugVolumeColor = debugVolumeColor;
  aabBoxMaterial.allowPick = true;
  geometry = _GeometryUtils["default"].toBufferGeometry3js(geometry);
  var debugVolume = new THREE.LineSegments(geometry, aabBoxMaterial);
  debugVolume.pickObject = {
    id: debugVolume,
    mesh: debugVolume,
    primitive: primitive
  };
  debugVolume.up.copy(primitive.root.up);
  debugVolume.frustumCulled = false;
  debugVolume.isDebugVolume = true;
  return debugVolume;
}

var sizeOfUint32 = 4;
var scratchTranslationRtc;

var CESIUM_RTC_MODELVIEW = function CESIUM_RTC_MODELVIEW(uniformState, model) {
  // CESIUM_RTC extension
  var _Cesium2 = Cesium,
      Matrix4 = _Cesium2.Matrix4,
      defined = _Cesium2.defined,
      Cartesian3 = _Cesium2.Cartesian3;
  var mvRtc = new Matrix4();
  if (!scratchTranslationRtc) scratchTranslationRtc = new Matrix4();
  return function () {
    if (defined(model._rtcCenter)) {
      Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);
      Cartesian3.add(scratchTranslationRtc, model._rtcCenter, scratchTranslationRtc);
      Matrix4.multiplyByPoint(uniformState.view, scratchTranslationRtc, scratchTranslationRtc);
      return Matrix4.setTranslation(uniformState.modelView, scratchTranslationRtc, mvRtc);
    }

    return uniformState.modelView;
  };
};

var _cacheMeshVisModelNormalMatrix;

var _cacheDracoLoaders = {};

function getDracoLoader(dracoDecoderPath) {
  var dracoLoader = _cacheDracoLoaders[dracoDecoderPath];

  if (!dracoLoader) {
    dracoLoader = new _DRACOLoader.DRACOLoader();
    _cacheDracoLoaders[dracoDecoderPath] = dracoLoader;
    dracoLoader.setDecoderPath(dracoDecoderPath);
    dracoLoader.preload();
  }

  return dracoLoader;
}

var MeshVisModel = /*#__PURE__*/function (_IRenderable) {
  (0, _inherits2["default"])(MeshVisModel, _IRenderable);

  var _super = _createSuper(MeshVisModel);

  function MeshVisModel(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, MeshVisModel);
    _this = _super.call(this);
    var _Cesium3 = Cesium,
        when = _Cesium3.when,
        Matrix4 = _Cesium3.Matrix4,
        Axis = _Cesium3.Axis,
        defaultValue = _Cesium3.defaultValue,
        Event = _Cesium3.Event;
    _this.ready = false;
    _this.readyPromise = when.defer();
    _this.translucent = defaultValue(options.translucent, false);
    _this._modelMatrix = options.modelMatrix || Matrix4.IDENTITY.clone();
    _this._upAxis = typeof options.upAxis == 'undefined' ? null : options.upAxis;
    _this.forwardAxis = options.forwardAxis || Axis.X;
    _this.cull = defaultValue(options.cull, true);
    _this._show = defaultValue(options.show, true);
    _this._requestType = options.requestType;
    _this.pickObject = options.pickObject;
    _this.manager = options.manager;
    _this.loader = options.loader;
    _this.dracoDecoderPath = options.dracoDecoderPath;
    _this.url = options.url;
    _this.basePath = options.basePath;
    _this._instances = options.instances;
    _this._instancedAttributes = options.instancedAttributes;
    _this._boundingSphere = null;
    _this._boundingSphereWC = null;
    _this.boundingSphere = options.boundingSphere;
    _this._boundingBox = null;
    _this._boundingBoxWC = null;
    _this.boundingBox = options.boundingBox;
    _this.debugVolume = options.debugVolume;
    _this.showDebugVolume = options.showDebugVolume;
    _this.debugVolumeOnly = options.debugVolumeOnly;
    _this.debugVolumeColor = options.debugVolumeColor;
    _this._lazyLoad = options.lazyLoad;
    _this._options = options;
    _this.editable = defaultValue(options.editable, false);
    _this.castShadow = defaultValue(options.castShadow, true);
    _this.receiveShadow = defaultValue(options.receiveShadow, true);
    _this.preInitialize = defaultValue(options.preInitialize, false);
    _this.overrideTextureEncoding = options.overrideTextureEncoding;
    _this.minRange = options.minRange || 4;
    _this.rangeMode = 'PIXEL_ON_SCREEN'; //PIXEL_ON_SCREEN|DISTANCE_TO_CAMERA

    _this._lods = [];
    _this._lodNeedsUpdate = false;
    _this.onModelLoaded = new Event();
    _this.onLoadProgress = new Event();
    _this.onInitInitialized = new Event();
    _this.onInitProgress = new Event();

    if (options.lods && options.lods.length > 0) {
      options.lods.forEach(function (lod) {
        _this.addLod(lod.maxRange, lod.simplifyFactor, lod.simplifyOptions);
      });
    }

    if (!MeshVisModel._loadTaskList) {
      MeshVisModel._loadTaskList = new _TaskList.TaskList(10, 'load');
    }

    if (!_this._lazyLoad) {
      _this.load(options);
    } else if (!_this.boundingSphere) {
      throw new Error('When lazyLoad is true, boundingSphere is required.');
    }

    _this.createDebugVolume();

    return _this;
  }

  (0, _createClass2["default"])(MeshVisModel, [{
    key: "upAxis",
    get: function get() {
      return this._upAxis;
    },
    set: function set(val) {
      if (this._upAxis != val) {
        var _Cesium4 = Cesium,
            Cartesian3 = _Cesium4.Cartesian3,
            Axis = _Cesium4.Axis;
        this._upAxis = val;
        if (this._upAxis == null) return;
        var up = new Cartesian3(0, 1, 0);

        if (val == Axis.Z) {
          up = new Cartesian3(0, 0, 1);
        } else if (val == Axis.X) {
          up = new Cartesian3(1, 0, 0);
        }

        this.traverse(function (obj) {
          obj.up.set(up.x, up.y, up.z);
        });
        this.modelMatrixNeedsUpdate = true;
      }
    }
  }, {
    key: "getMagic",
    value: function getMagic(uint8Array) {
      var magic = [];

      for (var i = 0; i < sizeOfUint32; i++) {
        magic.push(uint8Array[i]);
      }

      magic = String.fromCharCode.apply(null, magic);
      return magic;
    }
  }, {
    key: "traverse",
    value: function traverse(callback) {
      if (!this.root || !callback) return;
      this.root.traverse(callback);
    }
  }, {
    key: "traverseGeometry",
    value: function traverseGeometry(callback) {
      if (!callback) return;
      var cache = {};
      this.traverse(function (obj) {
        var geometry = obj.geometry;

        if (geometry && !cache[geometry.uuid]) {
          cache[geometry.uuid] = true;
          callback(geometry);
        }
      });
    }
  }, {
    key: "traverseMaterial",
    value: function traverseMaterial(callback) {
      if (!callback) return;
      var cache = {};
      this.traverse(function (obj) {
        var material = obj.material;
        if (!material) return;

        if (Array.isArray(material)) {
          material.forEach(function (matN) {
            if (!cache[matN.uuid]) return;
            cache[matN.uuid] = true;
            callback(matN);
          });
        } else if (!cache[material.uuid]) {
          cache[material.uuid] = true;
          callback(material);
        }
      });
    }
  }, {
    key: "traverseTexture",
    value: function traverseTexture(callback) {
      if (typeof callback !== 'function') return;
      var cache = {};
      this.traverseMaterial(function (material) {
        for (var key in material) {
          if (Object.hasOwnProperty.call(material, key)) {
            var map = material[key];

            if (map && map.isTexture && !cache[map.uuid]) {
              cache[map.uuid];
              callback(map);
            }
          }
        }
      });
    }
  }, {
    key: "load",
    value: function load(options) {
      var _this2 = this;

      var _Cesium5 = Cesium,
          defaultValue = _Cesium5.defaultValue,
          Resource = _Cesium5.Resource;
      options = options || this._options;
      var manager = options.manager || this.manager;
      var dracoDecoderPath = options.dracoDecoderPath || this.dracoDecoderPath;
      var gltfBuffer = options.gltf || options.buffer;
      var magic;

      if (typeof options.url == 'string') {
        var ext = _Path["default"].GetExtension(options.url).toLowerCase();

        if (ext) {
          magic = ext.slice(1);
        }
      }

      if (gltfBuffer) {
        if (gltfBuffer instanceof ArrayBuffer) {
          gltfBuffer = new Uint8Array(gltfBuffer);
        } else if (gltfBuffer instanceof Uint8Array) {
          gltfBuffer = gltfBuffer.slice();
        }

        if (!magic) magic = this.getMagic(gltfBuffer);
      }

      var loader = options.loader || this.loader;

      if (!loader) {
        switch (magic) {
          case 'osgb':
          case 'osgt':
          case 'osg':
          case 'osgjson':
            loader = new _OSGLoader["default"](manager);
            break;

          case 'vism':
            loader = new _VISMLoader["default"](manager);
            break;

          default:
            loader = new _GLTFLoader.GLTFLoader(manager);

            if (dracoDecoderPath && typeof dracoDecoderPath == 'string') {
              var dracoLoader = getDracoLoader(dracoDecoderPath);
              loader.setDRACOLoader(dracoLoader);
            }

            var ddsLoader = new _DDSLoader.DDSLoader(manager);
            loader.setDDSLoader(ddsLoader);
            break;
        }
      }

      if (magic == 'vism' && !loader.dracoLoader && dracoDecoderPath && typeof dracoDecoderPath == 'string') {
        var dracoLoader = getDracoLoader(dracoDecoderPath);
        loader.setDRACOLoader(dracoLoader);
      }

      var path = this.basePath || this.url;

      if (path) {
        if (path instanceof Resource) {
          path = path.url;
        }

        path = THREE.LoaderUtils.extractUrlBase(path);
      }

      if (gltfBuffer) {
        if (magic == 'b3dm') {
          var b3dm = _MeshVisModelUtil2["default"].parseB3DM(gltfBuffer.buffer);

          gltfBuffer = b3dm.gltfView;
          delete b3dm.gltfView;
          this.b3dmHeader = b3dm;
        }

        loader.parse(gltfBuffer, path, function (model) {
          _this2.onload(model);
        }, function (e) {
          console.error(e);

          _this2.readyPromise.reject(e);
        }, {
          loadTexture: defaultValue(options.preloadTexture, true)
        });
      } else if (typeof options.url == 'string') {
        var args = magic == 'x' ? [options.url, options] : options.url;
        loader.load(args, function (model) {
          _this2.onload(model);
        }, function (evt) {
          _this2.onLoadProgress.raiseEvent(evt);
        }, function (e) {
          console.error(e);

          _this2.readyPromise.reject('Failed to load model ' + _this2.url + ":" + e);
        }, magic == 'b3dm' ? function (arrayBuffer) {
          var b3dm = _MeshVisModelUtil2["default"].parseB3DM(arrayBuffer);

          var gltfView = b3dm.gltfView;
          delete b3dm.gltfView;
          _this2.b3dmHeader = b3dm;
          return gltfView;
        } : null, {
          loadTexture: defaultValue(options.preloadTexture, true)
        });
      }

      return this.readyPromise;
    }
  }, {
    key: "onload",
    value: function onload(model) {
      var _this3 = this;

      var _Cesium6 = Cesium,
          Axis = _Cesium6.Axis,
          Cartesian3 = _Cesium6.Cartesian3,
          RequestType = _Cesium6.RequestType,
          defined = _Cesium6.defined;
      this._model3js = model;
      var scene = model.scene || model.mesh || model;

      if (model.models) {
        scene = new THREE.Object3D();
        model.models.forEach(function (obj3d) {
          scene.add(obj3d);
        });
        model.scene = scene;
      }

      this.modelScene = scene;
      this.modelScene.visible = this._show;

      if (this.b3dmHeader && !model.CESIUM_RTC) {
        model.CESIUM_RTC = this.b3dmHeader.CESIUM_RTC;
      }

      if (this._requestType == RequestType.TILES3D || model.CESIUM_RTC) {
        //CESIUM_RTC extension
        var cesiumRtcModelViewUniform;
        var uniformMapLoadedCallback;

        if (model.CESIUM_RTC) {
          model._rtcCenter = Cartesian3.fromArray(model.CESIUM_RTC);

          uniformMapLoadedCallback = function uniformMapLoadedCallback(uniformMap, frameState, mesh) {
            if (!cesiumRtcModelViewUniform) {
              cesiumRtcModelViewUniform = CESIUM_RTC_MODELVIEW(frameState.context.uniformState, model);
            }

            uniformMap.modelView = cesiumRtcModelViewUniform;
            uniformMap.u_modelView = cesiumRtcModelViewUniform;
            uniformMap.modelViewMatrix = cesiumRtcModelViewUniform;
            uniformMap.u_modelViewMatrix = cesiumRtcModelViewUniform;
          };
        }

        var up = new Cartesian3(0, 0, 1);

        if (this.upAxis == Axis.Y) {
          up = new Cartesian3(0, 1, 0);
        }

        Object3D.traverse(scene, function (node) {
          node.up.set(up.x, up.y, up.z);
          node.frustumCulled = false;

          if (node.isMesh) {
            //CESIUM_RTC extension
            if (model.CESIUM_RTC) node.uniformMapLoadedCallback = uniformMapLoadedCallback;
            if (_this3.pickObject) node.pickObject = _this3.pickObject;
          }
        });
        scene.updateMatrixWorld();
        this.computeModelMatrix();
      }

      if (this._requestType != RequestType.TILES3D) {
        var _up; //= new Cartesian3(0, 1, 0);


        if (this.upAxis == Axis.Z) {
          _up = new Cartesian3(0, 0, 1);
        } else if (this.upAxis == Axis.X) {
          _up = new Cartesian3(1, 0, 0);
        } else if (this.upAxis == Axis.Y) {
          _up = new Cartesian3(0, 1, 0);
        }

        var needsOverrideTextureEncoding = defined(this.overrideTextureEncoding);
        scene.traverse(function (node) {
          node.frustumCulled = _this3.cull;
          _up && node.up.set(_up.x, _up.y, _up.z);

          if (node.isMesh) {
            var pickObjects = node.pickObjects = [];
            var materials = Array.isArray(node.material) ? node.material : [node.material];
            materials.forEach(function (material, materialIndex) {
              if (material.transparent && _this3.translucent) material.translucent = true;

              if (needsOverrideTextureEncoding && material.map) {
                material.map.encoding = _this3.overrideTextureEncoding;
              }

              pickObjects.push({
                id: node,
                mesh: node,
                primitive: _this3,
                material: material,
                materialIndex: materialIndex
              });
            });
          }
        });
        this.onModelLoaded.raiseEvent(this);
        this.createBoudingVolume();
        this.updateBoudingVolume();
      }

      scene.instances = this.instances;
      scene.instancedAttributes = this.instancedAttributes;
      this.modelMatrixNeedsUpdate = true;
      this.ready = true;
      this.readyPromise.resolve(this);
    }
  }, {
    key: "createBoudingVolume",
    value: function createBoudingVolume(force) {
      if (!this.root || this.boundingSphere && !force) return;
      var model = this.root;
      var vertices = [];
      model.updateMatrixWorld();
      model.traverse(function (object) {
        var geometry = object.geometry;
        if (!geometry) return;

        if (!geometry.boundingBox) {
          geometry.computeBoundingBox();
        }

        var boundingBox = geometry.boundingBox.clone();
        boundingBox.applyMatrix4(object.matrixWorld);
        vertices.push(boundingBox.min, boundingBox.max);
      });
      var _Cesium7 = Cesium,
          BoundingSphere = _Cesium7.BoundingSphere,
          AxisAlignedBoundingBox = _Cesium7.AxisAlignedBoundingBox;
      var _THREE = THREE,
          Box3 = _THREE.Box3,
          Vector3 = _THREE.Vector3;
      var boundingBox = AxisAlignedBoundingBox.fromPoints(vertices);
      var bs = BoundingSphere.fromPoints(vertices);
      vertices.splice(0);
      this.boundingSphere = bs;
      this.boundingBox = boundingBox;
      this.boundingBox3js = new Box3(new Vector3().copy(boundingBox.minimum), new Vector3().copy(boundingBox.maximum));
      this.boundingBoxWC3js = new Box3().copy(this.boundingBox3js);
      this.modelMatrixNeedsUpdate = true;
      this.createDebugVolume();
    }
  }, {
    key: "updateBoudingVolume",
    value: function updateBoudingVolume() {
      var upAxis = this.upAxis,
          root = this.root,
          visualizer = this.visualizer,
          boundingSphere = this.boundingSphere,
          boundingSphereWC = this.boundingSphereWC,
          boundingBox = this.boundingBox,
          boundingBoxWC = this.boundingBoxWC;
      if (!boundingSphere || !visualizer) return;
      var _Cesium8 = Cesium,
          Axis = _Cesium8.Axis,
          Matrix4 = _Cesium8.Matrix4;
      var _actualModelMatrixYup = visualizer._actualModelMatrixYup,
          _actualModelMatrixXup = visualizer._actualModelMatrixXup,
          _actualModelMatrix = visualizer._actualModelMatrix;

      if (this.modelMatrixNeedsUpdate != false || visualizer.modelMatrixNeedsUpdate) {
        var modelMatrix;

        if (upAxis != null) {
          if (upAxis == Axis.Y) {
            modelMatrix = _actualModelMatrixYup;
          } else if (upAxis == Axis.X) {
            modelMatrix = _actualModelMatrixXup;
          } else if (upAxis == Axis.Z) {
            modelMatrix = _actualModelMatrix;
          }
        } else {
          var up = root.up;

          if (up.y) {
            modelMatrix = _actualModelMatrixYup;
          } else if (up.x) {
            modelMatrix = _actualModelMatrixXup;
          } else if (up.z) {
            modelMatrix = _actualModelMatrix;
          }
        }

        this.modelMatrix = modelMatrix;
        if (!root.modelMatrix) root.modelMatrix = new Matrix4();
        var rootModelMatrix = root.modelMatrix;
        Matrix4.multiply(modelMatrix, root.matrixWorld.elements, rootModelMatrix);
        var center = boundingSphereWC.center;
        Matrix4.multiplyByPoint(rootModelMatrix, boundingSphere.center, center);
        boundingSphereWC.radius = boundingSphere.radius * Matrix4.getMaximumScale(rootModelMatrix);
        center = boundingBoxWC.center;
        Matrix4.multiplyByPoint(rootModelMatrix, boundingBox.center, center);
      }
    }
    /**
     * @private
     */

  }, {
    key: "createDebugVolume",
    value: function createDebugVolume() {
      var _this4 = this;

      if (this.debugVolume && this.boundingBox) {
        var visualizer = this.visualizer;

        if (this.debugVolume.isMesh) {
          // this.debugVolume.destroy();
          visualizer && visualizer.remove(debugVolume, true);
          (0, _releaseResources["default"])(debugVolume);
          this.debugVolume = true;
        }

        this.debugVolume = _createDebugVolume(this.boundingBox, this, this.debugVolumeColor);
        this.root.traverse(function (object) {
          if (object.isDebugVolume) return;

          if (object.isMesh && object.geometry) {
            var onMeshDispose = function onMeshDispose() {
              // debugVolume.destroy();
              visualizer && visualizer.remove(debugVolume, true);
              (0, _releaseResources["default"])(debugVolume);
              delete object.__debugVolume;
              object.removeEventListener('dispose', onMeshDispose);
            };

            var geometry = object.geometry;

            if (!geometry.boundingBox) {
              geometry.computeBoundingBox();
            }

            var boundingBox = boundingBox = geometry.boundingBox.clone().applyMatrix4(object.matrixWorld);
            boundingBox = Cesium.AxisAlignedBoundingBox.fromPoints([boundingBox.min, boundingBox.max]);

            var debugVolume = _createDebugVolume(boundingBox, _this4, _this4.debugVolumeColor);

            object.addEventListener('dispose', onMeshDispose);
            object.__debugVolume = debugVolume;
          }
        });
      }
    }
    /**
     *  
     * @param {Cesium.FrameState} frameState  
     * @returns {Number}  
     * @private
     */

  }, {
    key: "computeRange",
    value: function computeRange(frameState, progressiveResolutionHeightFraction) {
      this._distanceToCamera = frameState.camera.distanceToBoundingSphere(this._boundingSphereWC);
      var distance = Math.max(this._distanceToCamera, Cesium.Math.EPSILON7);

      if (this.rangeMode == 'PIXEL_ON_SCREEN') {
        //in pixels
        var geometricError = this._boundingSphereWC.radius;

        var range = _RendererUtils["default"].computeRange(distance, geometricError, frameState, progressiveResolutionHeightFraction);

        return range;
      } else {
        //in meters
        return distance;
      }
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @private
     */

  }, {
    key: "computeVisibility",
    value: function computeVisibility(frameState) {
      if (this.boundingSphere) {
        this.range = this.computeRange(frameState);
        this.visibility = this.visible = true;

        if (this.range < this.minRange) {
          this.visibility = this.visible = false;
        } else {
          var visibility; // if (this._boundingBoxWC) {
          //     visibility = frameState.cullingVolume.computeVisibility(this._boundingBoxWC);
          // } else {

          visibility = frameState.cullingVolume.computeVisibility(this._boundingSphereWC); // }

          if (visibility == -1) {
            this.visibility = this.visible = false;
          } else {
            this.visibility = this.visible = true;
          }
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "createOrUpdateLod",
    value: function createOrUpdateLod() {
      var _this5 = this;

      if (this._lodNeedsUpdate && this.root) {
        this._lods.sort(function (a, b) {
          return a.maxRange - b.maxRange;
        });

        this._lods.forEach(function (lod) {
          if (lod.root) return;
          var options = lod.simplifyOptions;

          if (options.simplifyFactor >= 1) {
            lod.root = _this5.root;
            return;
          }

          var modifiedRoot = _this5.root.clone(true);

          modifiedRoot.traverse(function (node) {
            node.instances = _this5.instances;
            node.instancedAttributes = _this5.instancedAttributes;
            node.frustumCulled = false;

            if (node.isMesh) {
              var mesh = node;
              var geometry = mesh.geometry;
              var srcCount = geometry.attributes.position.count;
              var target_count = lod.simplifyFactor * srcCount;
              mesh.geometry = simplify_three(geometry, target_count, options);

              if (options.resampleTexture) {
                var material = mesh.material.clone();

                for (var name in material) {
                  var texture = material[name];

                  if (name != 'lightMap' && texture && texture.isTexture) {
                    material[name] = _TextureUtils["default"].resampleTexture(texture.clone(), lod.simplifyFactor, options.forcePowerOfTwo);
                  }
                }

                mesh.material = material;
              }
            }
          });
          lod.root = modifiedRoot;
        });

        this._lodNeedsUpdate = false;
      }
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @param {Mesh3D.MeshVisualizer} visualizer 
     */

  }, {
    key: "initializeCommands",
    value: function initializeCommands(frameState, visualizer) {
      var _this6 = this;

      this.commandInitializing = true;
      var renderer = visualizer.renderer;

      var currentWebglRenderState = renderer._webglRenderStates.get(visualizer, frameState.camera);

      var context = frameState.context;
      var webglRenderItems = renderer._webglRenderItems;
      var objects = [],
          batches = [objects],
          batchSize = 10,
          currentBatchCount = 0;
      this.root.updateMatrixWorld();
      this.root.traverse(function (object) {
        if (object.isMesh || object.isLine || object.isPoints || object.isSprite) {
          objects.push(object);

          var geometry = _WebGLGeometries["default"].get(object.geometry);

          var materialIndicesUsed = geometry.materialIndicesUsed;
          currentBatchCount += materialIndicesUsed ? materialIndicesUsed.length : 1;

          if (currentBatchCount > batchSize) {
            objects = [];
            batches.push(objects);
            currentBatchCount = 0;
          }
        }
      });
      var worker = new _GenericWorker["default"](batches, function (batch) {
        for (var i = 0; i < batch.length; i++) {
          var object = batch[i];
          visualizer.computeModelMatrix(object, frameState);
          visualizer.computeObjectVisibility(object, frameState, true);
          var renderItems = webglRenderItems.getAndUpdate(object, frameState, false, currentWebglRenderState);
          if (!renderItems) continue;

          for (var h = 0; h < renderItems.length; h++) {
            var renderItem = renderItems[h];
            var drawCommand = renderItem.drawCommand;
            drawCommand.framebuffer = visualizer.defaultFramebuffer;
            drawCommand.execute(context);
            drawCommand.framebuffer = undefined;
            renderItem.loaded = true;
          }
        }
      });
      return worker.run(function (progress, currentObject, loaded, total) {
        _this6.onInitProgress.raiseEvent({
          progress: progress,
          message: 'Initializing drawCommands',
          loaded: loaded,
          total: total
        });
      }).then(function () {
        _this6.commandInitializing = false;
        _this6.commandInitialized = true;

        _this6.onInitInitialized.raiseEvent(_this6);
      });
    }
    /**
     * 
     * @param {Cesium.FrameState} frameState 
     * @param {Object3D[]} renderList 
     * @param {THREE.Camera}camera3js
     * @override IRenderable.prototype.render
     * @private
     */

  }, {
    key: "render",
    value: function render(frameState, renderList, camera3js) {
      var _this7 = this;

      if (!this.root || !this.visualizer) return;

      if (this.preInitialize) {
        if (this.commandInitializing) return;

        if (!this.commandInitialized) {
          this.initializeCommands(frameState, this.visualizer);
          return;
        }
      }

      var cacheRenderList = this._cacheRenderList || [];
      this._cacheRenderList = cacheRenderList;

      if (frameState.frameNumber != this.frameNumber) {
        cacheRenderList.splice(0);
        var editable = this.editable;
        var castShadow = this.castShadow;
        var receiveShadow = this.receiveShadow;
        var root = this.root;

        if (editable != root._editable || castShadow != root._castShadow || receiveShadow != root._receiveShadow) {
          root._editable = editable;
          root._castShadow = castShadow;
          root._receiveShadow = receiveShadow;
          root.traverse(function (object) {
            var objectMaterial = object.material;
            if (objectMaterial == undefined) return;
            object.castShadow = castShadow;
            object.receiveShadow = receiveShadow;
            var materials = Array.isArray(objectMaterial) ? objectMaterial : [objectMaterial];
            materials.forEach(function (material) {
              material.autoRefresh = editable;
            });
          });
        }

        if (this.editable) root.updateMatrixWorld();
        this.updateBoudingVolume();
        this.computeVisibility(frameState, camera3js);
        if (!this.visible) return;
        var loadTaskList = MeshVisModel._loadTaskList;

        if (this._lazyLoad && !this.root && !this._isLazyLoading) {
          this._isLazyLoading = true;
          this.tileId = Cesium.createGuid();
          loadTaskList.add(this);
        }

        if (!loadTaskList.frameNumber || loadTaskList.frameNumber != frameState.frameNumber) {
          loadTaskList.frameNumber = frameState.frameNumber;
          loadTaskList.update();
        }

        if (this.root && this.show && !this.debugVolumeOnly) {
          var objectToRender = null;

          if (this._lods.length > 0) {
            this.createOrUpdateLod();

            for (var i = 0; i < this._lods.length; i++) {
              var lod = this._lods[i];

              if (this.range <= lod.maxRange) {
                objectToRender = lod.root;
                break;
              }
            }
          }

          objectToRender = objectToRender || this.root;
          cacheRenderList.push(objectToRender);
        }

        if (this.debugVolume && this.showDebugVolume) {
          cacheRenderList.push(this.debugVolume);
          this.root.traverse(function (object) {
            var debugVolume = object.__debugVolume;
            if (!debugVolume) return;
            var debugMaterial = debugVolume.material;
            var debugVolumeColor = _this7.debugVolumeColor;

            if (debugMaterial._debugVolumeColor != debugVolumeColor) {
              debugMaterial._debugVolumeColor = debugVolumeColor;

              if (debugVolumeColor instanceof Cesium.Color) {
                debugVolumeColor = debugVolumeColor.toCssColorString();
              }

              debugMaterial.color.set(debugVolumeColor);
            }

            cacheRenderList.push(debugVolume);
          });
        }

        if (this.root) {
          this.modelMatrixNeedsUpdate = false;
        }
      }

      cacheRenderList.forEach(function (item) {
        renderList.push(item);
      });
    }
    /**
     *  for cesium3dtiles
     * @param {Cesium.FrameState} frameState 
     * @private
     * @override Cesium.Primitive.prototype.update
     */

  }, {
    key: "update",
    value: function update(frameState) {
      if (this._requestType == Cesium.RequestType.TILES3D || this.model3js && this.model3js.CESIUM_RTC) {
        this.computeModelMatrix();
      }
    } //for cesium3dtile

  }, {
    key: "computeModelMatrix",
    value: function computeModelMatrix() {
      var _this8 = this;

      if (!this._model3js) return;
      var _Cesium9 = Cesium,
          Axis = _Cesium9.Axis,
          Matrix4 = _Cesium9.Matrix4;
      var computedModelMatrix = this._computedModelMatrix;

      if (!computedModelMatrix) {
        computedModelMatrix = new Matrix4();
        this._computedModelMatrix = computedModelMatrix;
      }

      if (this.modelMatrixNeedsUpdate) {
        if (this.upAxis === Axis.Y) {
          Matrix4.multiplyTransformation(this.modelMatrix, Axis.Y_UP_TO_Z_UP, computedModelMatrix);
        } else if (this.upAxis === Axis.X) {
          Matrix4.multiplyTransformation(this.modelMatrix, Axis.X_UP_TO_Z_UP, computedModelMatrix);
        }

        ;

        if (this.forwardAxis == Axis.Z) {
          // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.
          Matrix4.multiplyTransformation(this.modelMatrix, Axis.Z_UP_TO_X_UP, computedModelMatrix);
        }

        this.modelMatrixNeedsUpdate = false;
      }

      var scene = this.modelScene;
      Object3D.traverse(scene, function (node) {
        if (node.isMesh) {
          node.frustumCulled = _this8.cull;
          node.modelMatrix = Matrix4.multiply(computedModelMatrix, node.matrixWorld.elements, node.modelMatrix || new Cesium.Matrix4());
        }

        node.matrixAutoUpdate = false;
        node.modelMatrixNeedsUpdate = false;
      });
      scene.modelMatrixNeedsUpdate = false;
      scene.matrixAutoUpdate = false;
    } //for batchtable

  }, {
    key: "updateCommands",
    value: function updateCommands(batchId, color) {}
  }, {
    key: "addLod",
    value: function addLod(maxRange, simplifyFactor, simplifyOptions) {
      simplifyOptions = simplifyOptions || {};
      simplifyOptions = Object.assign({
        agressiveness: 4,
        update: 5,
        resampleTexture: false,
        forcePowerOfTwo: false
      }, simplifyOptions);
      var lod = {
        maxRange: maxRange,
        simplifyFactor: simplifyFactor,
        simplifyOptions: simplifyOptions
      };

      this._lods.push(lod);

      this._lodNeedsUpdate = true;
      return lod;
    }
  }, {
    key: "clearLods",
    value: function clearLods() {
      this._lods.forEach(function (lod) {
        if (lod.root) {
          (0, _releaseResources["default"])(lod.root);
          lod.root = null;
        }
      });

      return this._lods.splice();
    }
  }, {
    key: "getNodeByName",
    value: function getNodeByName(name) {
      if (this.ready) {
        var result;
        this.root.traverse(function (node) {
          if (result) return;
          if (node.name == name) result = node;
        });
        return result;
      }
    }
  }, {
    key: "getObjectByName",
    value: function getObjectByName(name) {
      return this.getNodeByName(name);
    }
  }, {
    key: "exportGLTF",
    value: function exportGLTF(options) {
      options = options || {};

      if (!options.animations && this.model3js.animations) {
        options.animations = this.model3js.animations;
      }

      return _MeshVisModelUtil2["default"].exportGLTF(this.root, options);
    }
  }, {
    key: "exportB3DM",
    value: function exportB3DM(options) {
      options = options || {};

      if (!options.animations && this.animations) {
        options.animations = this.animations;
      }

      return _MeshVisModelUtil2["default"].exportB3DM(this.root, options);
    }
  }, {
    key: "exportVISM",
    value: function exportVISM(options) {
      options = options || {};

      if (!options.animations && this.animations) {
        options.animations = this.animations;
      }

      return _MeshVisModelUtil2["default"].exportVISM(this.root, options);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var visualizer = this.visualizer,
          debugVolume = this.debugVolume,
          _model3js = this._model3js;

      if (_model3js) {
        var scene = this.root;
        visualizer && visualizer.remove(scene, true);
        (0, _releaseResources["default"])(scene);
        this._model3js = null;
        this.modelScene = null;
      }

      if (debugVolume) {
        visualizer && visualizer.remove(debugVolume, true);
        (0, _releaseResources["default"])(debugVolume);
        this.debugVolume = null;
      }

      this.loader = null;
      this.visualizer = null;
      this.manager = null;
      this._boundingBox = null;
      this._boundingBoxWC = null;
      this._boundingSphere = null;
      this._boundingSphereWC = null;
      this._instances = null;
      this._instancedAttributes = null;
      this._cacheRenderList && this._cacheRenderList.splice(0);
      this._cacheRenderList = null;
      Cesium.destroyObject(this);
    }
  }]);
  return MeshVisModel;
}(_IRenderable2["default"]);

Object.defineProperties(MeshVisModel.prototype, {
  instances: {
    get: function get() {
      return this._instances;
    }
  },
  instancedAttributes: {
    get: function get() {
      return this._instancedAttributes;
    }
  },

  /**
   *  
   * @private
   */
  modelMatrix: {
    set: function set(val) {
      var Matrix4 = Cesium.Matrix4;
      if (!this._model3js) this.modelMatrixNeedsUpdate = true;
      if (val.elements) val = val.elements;
      if (Matrix4.equals(val, this._modelMatrix)) return;
      this._modelMatrix = Matrix4.clone(val, this._modelMatrix);
      this.modelMatrixNeedsUpdate = true;
    },
    get: function get() {
      return this._modelMatrix;
    }
  },
  show: {
    set: function set(val) {
      this._show = val;
      if (this.modelScene) this.modelScene.visible = val;
    },
    get: function get() {
      return this._show;
    }
  },
  model3js: {
    get: function get() {
      return this._model3js;
    }
  },
  root: {
    get: function get() {
      return this._model3js && (this._model3js.scene || this._model3js);
    }
  },
  gltf: {
    get: function get() {
      if (this.model3js && this.parser) {
        return this.model3js.parser.json;
      }

      return null;
    }
  },
  osg: {
    get: function get() {
      if (this.model3js && this.model3js.osgRoot) return this.model3js.osgRoot;
      return null;
    }
  },
  animations: {
    get: function get() {
      return this.model3js ? this.model3js.animations : [];
    }
  },
  boundingSphere: {
    set: function set(boundingSphere) {
      if (boundingSphere) {
        this._boundingSphere = boundingSphere;
        this._boundingSphereWC = Cesium.BoundingSphere.clone(boundingSphere);
      }
    },
    get: function get() {
      return this._boundingSphere;
    }
  },
  boundingSphereWC: {
    get: function get() {
      return this._boundingSphereWC;
    }
  },
  boundingBox: {
    get: function get() {
      return this._boundingBox;
    },
    set: function set(boundingBox) {
      if (boundingBox) {
        this._boundingBox = boundingBox;
        this._boundingBoxWC = Cesium.AxisAlignedBoundingBox.clone(this.boundingBox);
      }
    }
  },
  boundingBoxWC: {
    get: function get() {
      return this._boundingBoxWC;
    }
  }
});
var _MeshVisModelUtil = _MeshVisModelUtil2["default"];
MeshVisModel.exportGLTF = _MeshVisModelUtil.exportGLTF;
MeshVisModel.exportB3DM = _MeshVisModelUtil.exportB3DM;
MeshVisModel.parseB3DM = _MeshVisModelUtil.parseB3DM;
MeshVisModel.exportVISM = _MeshVisModelUtil.exportVISM;
MeshVisModel.prototype.type = 'MeshVisModel';
MeshVisModel.prototype.isMeshVisModel = true;
var _default = MeshVisModel;
exports["default"] = _default;

},{"M_132":2,"D_875":4,"M_880":6,"._876":17,"m_879":22,"h_872":189,"s_871":193,"3_874":87,"M_869":92,"m_868":93,"o_867":94,"C_877":186,"-_873":181,"e_870":182,"o_878":184,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],181:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _GLTFExporter = require("3_885");

var _VISMExporter = _interopRequireDefault(require("D_886"));

function createColorChangedCallback(model) {
  return function (batchId, color) {
    model.updateCommands(batchId, color);
  };
}

var sizeOfUint32 = 4;

var MeshVisModelUtil = /*#__PURE__*/function () {
  function MeshVisModelUtil() {
    (0, _classCallCheck2["default"])(this, MeshVisModelUtil);
  }

  (0, _createClass2["default"])(MeshVisModelUtil, null, [{
    key: "exportGLTF",
    value:
    /**
     * 
     * @param {THREE.Group|THREE.Scene} input 
     * @param {{
            binary: boolean,
            trs: bool,
            onlyVisible: boolean,
            truncateDrawRange: boolean,
            embedImages: boolean,
            maxTextureSize: number,
            animations: THREE.AnimationClip[],
            forceIndices: boolean,
            forcePowerOfTwoTextures: boolean,
            includeCustomExtensions: boolean,
            assetSrcs: { [key: string]: string }
     * }} [options] 
     *@returns {Promise<object|ArrayBuffer>}
     */
    function exportGLTF(input, options) {
      return new Promise(function (resolve, reject) {
        try {
          var gltfExporter = new _GLTFExporter.GLTFExporter();
          options = options || {};
          options = Object.assign({
            embedImages: false,
            trs: false,
            //document.getElementById('option_trs').checked,
            onlyVisible: false,
            //document.getElementById('option_visible').checked,
            // truncateDrawRange: document.getElementById('option_drawrange').checked,
            binary: false,
            // document.getElementById('option_binary').checked,
            //forceIndices: document.getElementById('option_forceindices').checked,
            //forcePowerOfTwoTextures: document.getElementById('option_forcepot').checked,
            maxTextureSize: Infinity //Number(document.getElementById('option_maxsize').value) || Infinity // To prevent NaN value

          }, options);
          gltfExporter.parse(input, function (result) {
            resolve(result);
          }, options);
        } catch (e) {
          reject(e);
        }
      });
    }
    /**
     * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
     *
     * @param {Integer} bufferSize The size the original buffer.
     * @returns {Integer} new buffer size with required padding.
     *
     */

  }, {
    key: "getPaddedBufferSize",
    value: function getPaddedBufferSize(bufferSize) {
      return Math.ceil(bufferSize / 4) * 4;
    }
    /**
     * Returns a buffer aligned to 4-byte boundary.
     *
     * @param {Uint8Array} buffer Buffer to pad
     * @param {Integer} paddingByte (Optional)
     * @returns {Uint8Array} The same buffer if it's already aligned to 4-byte boundary or a new buffer
     */

  }, {
    key: "getPaddedBuffer",
    value: function getPaddedBuffer(buffer, paddingByte) {
      paddingByte = paddingByte || 0;
      var paddedLength = this.getPaddedBufferSize(buffer.byteLength);

      if (paddedLength !== buffer.byteLength) {
        var array = new Uint8Array(paddedLength);
        array.set(buffer); //new Uint8Array(arrayBuffer));

        if (paddingByte !== 0) {
          for (var i = buffer.byteLength; i < paddedLength; i++) {
            array[i] = paddingByte;
          }
        }

        return array;
      }

      return buffer;
    }
    /**
     * 
     * @param {THREE.Group|THREE.Scene} input 
     * @param {{
        trs: bool,
        onlyVisible: boolean,
        truncateDrawRange: boolean,
        embedImages: boolean,
        maxTextureSize: number,
        animations: THREE.AnimationClip[],
        forceIndices: boolean,
        forcePowerOfTwoTextures: boolean,
        includeCustomExtensions: boolean,
        assetSrcs: { [key: string]: string },
        featureTableJson?:object,
        featureTableBinary?:Uint8Array,
        batchTableJson?:object,
        batchTableBinary?:Uint8Array,
        properties?:object
    * }} [options] 
    * @returns {Promise<Uint8Array>}
    */

  }, {
    key: "exportB3DM",
    value: function exportB3DM(input, options) {
      var properties = options.properties;
      var featureTableJson = options.featureTableJson ? options.featureTableJson : {
        BATCH_LENGTH: 0
      }; //valid batchTableJson

      var batchTableJson = options.batchTableJson;

      if (batchTableJson && featureTableJson.BATCH_LENGTH && properties) {
        var batchPropertyNames = Object.keys(batchTableJson);
        var propertyNames = Object.keys(properties);
        var eq = batchPropertyNames.length == propertyNames.length;
        eq = eq && batchPropertyNames.length == featureTableJson.BATCH_LENGTH;

        if (eq) {
          for (var i = 0; i < propertyNames.length; i++) {
            var name = propertyNames[i];

            if (batchPropertyNames.indexOf(name) == -1) {
              eq = false;
              break;
            }
          }
        }

        if (!eq) {
          console.warn('batchTableJson&featureTableJson.BATCH_LENGTH&properties donot have same length');
        } else {
          batchTableJson = null;
          featureTableJson.BATCH_LENGTH = 0;
        }
      } else if (featureTableJson.BATCH_LENGTH || batchTableJson && Object.keys(batchTableJson) > 0 || properties && Object.keys(properties) > 0) {
        console.warn('batchTableJson&featureTableJson.BATCH_LENGTH&properties donot have same length');
      }

      featureTableJson = JSON.stringify(featureTableJson);
      var featureTableJsonBuffer = new Uint8Array(featureTableJson.length);

      for (var _i = 0; _i < featureTableJson.length; _i++) {
        featureTableJsonBuffer[_i] = featureTableJson.charCodeAt(_i);
      }

      featureTableJsonBuffer = this.getPaddedBuffer(featureTableJsonBuffer, " ".charCodeAt(0)); //" "

      var featureTableBinary = new Uint8Array(0);

      if (options.featureTableBinary) {
        featureTableBinary = this.getPaddedBuffer(options.featureTableBinary);
      }

      var batchTableJsonBuffer = new Uint8Array(0);
      var batchTableBinary = new Uint8Array(0);

      if (batchTableJson) {
        batchTableJson = JSON.stringify(batchTableJson);
        var batchTableJsonBuffer = new Uint8Array(batchTableJson.length);

        for (var _i2 = 0; _i2 < batchTableJson.length; _i2++) {
          batchTableJsonBuffer[_i2] = batchTableJson.charCodeAt(_i2);
        }

        batchTableJsonBuffer = this.getPaddedBuffer(batchTableJsonBuffer, " ".charCodeAt(0));

        if (options.batchTableBinary) {
          batchTableBinary = this.getPaddedBuffer(options.batchTableBinary);
        }
      } // magic	4-byte ANSI string	"b3dm". This can be used to identify the content as a Batched 3D Model tile.
      // version	uint32	The version of the Batched 3D Model format. It is currently 1.
      // byteLength	uint32	The length of the entire tile, including the header, in bytes.
      // featureTableJSONByteLength	uint32	The length of the Feature Table JSON section in bytes.
      // featureTableBinaryByteLength	uint32	The length of the Feature Table binary section in bytes.
      // batchTableJSONByteLength	uint32	The length of the Batch Table JSON section in bytes. Zero indicates there is no Batch Table.
      // batchTableBinaryByteLength	uint32	The length of the Batch Table binary section in bytes. If batchTableJSONByteLength is zero, this will also be zero.
      //[featureTableJson]
      //[featureTableBinary]
      //[batchTableJson]
      //[batchTableBinary]


      var header = {
        magic: 'b3dm',
        version: 1,
        byteLength: 0,
        featureTableJSONByteLength: featureTableJsonBuffer.length,
        featureTableBinaryByteLength: featureTableBinary.length,
        batchTableJSONByteLength: batchTableJsonBuffer.length,
        batchTableBinaryByteLength: batchTableBinary.length
      },
          headLength = 28;
      options = options || {};
      options.binary = true;
      return this.exportGLTF(input, options).then(function (glb) {
        header.byteLength = glb.byteLength + headLength + header.featureTableJSONByteLength + header.featureTableBinaryByteLength + header.batchTableJSONByteLength + header.batchTableBinaryByteLength;
        var byteOffset = 0,
            b3dmBuffer = new Uint8Array(header.byteLength);
        var dv = new DataView(b3dmBuffer.buffer); //write header

        for (var _i3 = 0; _i3 < header.magic.length; _i3++) {
          dv.setUint8(byteOffset, header.magic.charCodeAt(_i3));
          byteOffset++;
        }

        dv.setUint32(byteOffset, header.version, true);
        byteOffset += sizeOfUint32;
        dv.setUint32(byteOffset, header.byteLength, true);
        byteOffset += sizeOfUint32;
        dv.setUint32(byteOffset, header.featureTableJSONByteLength, true);
        byteOffset += sizeOfUint32;
        dv.setUint32(byteOffset, header.featureTableBinaryByteLength, true);
        byteOffset += sizeOfUint32;
        dv.setUint32(byteOffset, header.batchTableJSONByteLength, true);
        byteOffset += sizeOfUint32;
        dv.setUint32(byteOffset, header.batchTableBinaryByteLength, true);
        byteOffset += sizeOfUint32; //write featureTableJson

        b3dmBuffer.set(featureTableJsonBuffer, byteOffset);
        byteOffset += featureTableJsonBuffer.length; //write batchTableJson

        b3dmBuffer.set(batchTableJsonBuffer, byteOffset);
        byteOffset += batchTableJsonBuffer.length; //write glb

        glb = new Uint8Array(glb);
        b3dmBuffer.set(glb, byteOffset);
        return b3dmBuffer;
      });
    }
    /**
     * 
     * @param {ArrayBuffer} arrayBuffer 
     * @param {number}[byteOffset=0]
     */

  }, {
    key: "parseB3DM",
    value: function parseB3DM(arrayBuffer, byteOffset) {
      var _Cesium = Cesium,
          defaultValue = _Cesium.defaultValue,
          getStringFromTypedArray = _Cesium.getStringFromTypedArray,
          Cesium3DTileFeatureTable = _Cesium.Cesium3DTileFeatureTable,
          ComponentDatatype = _Cesium.ComponentDatatype;
      var byteStart = defaultValue(byteOffset, 0);
      byteOffset = byteStart;
      var uint8Array = new Uint8Array(arrayBuffer);
      var view = new DataView(arrayBuffer);
      var magic = getStringFromTypedArray(uint8Array, byteOffset, 4);

      if (magic != 'b3dm') {
        throw new Error('not b3dm');
      }

      byteOffset += sizeOfUint32; // Skip magic

      var version = view.getUint32(byteOffset, true);

      if (version !== 1) {
        throw new Error("Only Batched 3D Model version 1 is supported.  Version " + version + " is not.");
      }

      byteOffset += sizeOfUint32;
      var byteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32;
      var featureTableJsonByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32;
      var featureTableBinaryByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32;
      var batchTableJsonByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32;
      var batchTableBinaryByteLength = view.getUint32(byteOffset, true);
      byteOffset += sizeOfUint32;
      var batchLength; // Legacy header #1: [batchLength] [batchTableByteLength]
      // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]
      // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]
      // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.
      // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table JSON will exceed this length.
      // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead

      if (batchTableJsonByteLength >= 570425344) {
        // First legacy check
        byteOffset -= sizeOfUint32 * 2;
        batchLength = featureTableJsonByteLength;
        batchTableJsonByteLength = featureTableBinaryByteLength;
        batchTableBinaryByteLength = 0;
        featureTableJsonByteLength = 0;
        featureTableBinaryByteLength = 0;
        console.warn("b3dm-legacy-header", "This b3dm header is using the legacy format [batchLength] [batchTableByteLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Batched3DModel.");
      } else if (batchTableBinaryByteLength >= 570425344) {
        // Second legacy check
        byteOffset -= sizeOfUint32;
        batchLength = batchTableJsonByteLength;
        batchTableJsonByteLength = featureTableJsonByteLength;
        batchTableBinaryByteLength = featureTableBinaryByteLength;
        featureTableJsonByteLength = 0;
        featureTableBinaryByteLength = 0;
        console.warn("b3dm-legacy-header", "This b3dm header is using the legacy format [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/Batched3DModel.");
      }

      var featureTableJson;

      if (featureTableJsonByteLength === 0) {
        featureTableJson = {
          BATCH_LENGTH: defaultValue(batchLength, 0)
        };
      } else {
        var featureTableString = getStringFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);
        featureTableJson = JSON.parse(featureTableString);
        byteOffset += featureTableJsonByteLength;
      }

      var featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
      byteOffset += featureTableBinaryByteLength;
      var featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);
      batchLength = featureTable.getGlobalProperty("BATCH_LENGTH");
      featureTable.featuresLength = batchLength;
      var rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", ComponentDatatype.FLOAT, 3);
      var batchTableJson;
      var batchTableBinary;

      if (batchTableJsonByteLength > 0) {
        // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the
        // arraybuffer/string compressed in memory and then decompress it when it is first accessed.
        //
        // We could also make another request for it, but that would make the property set/get
        // API async, and would double the number of numbers in some cases.
        var batchTableString = getStringFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);
        batchTableJson = JSON.parse(batchTableString);
        byteOffset += batchTableJsonByteLength;

        if (batchTableBinaryByteLength > 0) {
          // Has a batch table binary
          batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength); // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed

          batchTableBinary = new Uint8Array(batchTableBinary);
          byteOffset += batchTableBinaryByteLength;
        }
      } // var colorChangedCallback;
      // if (Cesium.defined(tileset.classificationType)) {
      //     colorChangedCallback = createColorChangedCallback(this);
      // }


      var batchTable = {
        // var batchTable = new Cesium.Cesium3DTileBatchTable(
        // this,
        batchLength: batchLength,
        batchTableJson: batchTableJson,
        batchTableBinary: batchTableBinary
      }; //     ,colorChangedCallback
      // );
      // this._batchTable = batchTable;

      var gltfByteLength = byteStart + byteLength - byteOffset;

      if (gltfByteLength === 0) {
        throw new Error("glTF byte length must be greater than 0.");
      }

      var gltfView;

      if (byteOffset % 4 === 0) {
        gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);
      } else {
        // Create a copy of the glb so that it is 4-byte aligned
        console.warn("b3dm-glb-unaligned", "The embedded glb is not aligned to a 4-byte boundary.");
        gltfView = new Uint8Array(uint8Array.subarray(byteOffset, byteOffset + gltfByteLength));
      }

      return {
        gltfView: gltfView,
        featureTable: featureTable,
        batchTable: batchTable,
        CESIUM_RTC: rtcCenter
      };
    }
    /**
     * 
     * @param {THREE.Group|THREE.Scene} input  
     * @param {object} [options] 
     * @param {object} [options.assetSrcs]
     * @param {object} [options.imageCache]
     * @param {boolean} [options.embedImages]
     * @param {boolean} [options.binary]
     * @param {boolean} [options.forceIndices]
     * @param {boolean} [options.removeUv2]
     * @param {boolean} [options.removeUv3]
     * @param {boolean} [options.removeNormal]
     * @param {boolean} [options.dracoEncode]  
     * @param {number} [options.dracoMinVertexCount=300]  
     * @param {(base64:string,index:number)=>string} [options.exportDataURL]
     */

  }, {
    key: "exportVISM",
    value: function exportVISM(input, options) {
      options = options || {};
      var exporter = new _VISMExporter["default"](options);
      return exporter.parse(input, input.animations || options.animations);
    }
  }]);
  return MeshVisModelUtil;
}();

exports["default"] = MeshVisModelUtil;

},{"3_885":90,"D_886":183,"e_1":235,"s_2":236,"M_0":241}],182:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _defineProperty2 = _interopRequireDefault(require("e_45"));

var Osg = _interopRequireWildcard(require("h_894"));

var _esExtends = _interopRequireDefault(require("-_895"));

var _parseOsg = require("3_896");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, DoubleSide, FileLoader, FrontSide, Group, LinearFilter, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipMapLinearFilter, Loader, LoaderUtils, // Material,
// Math as _Math,
// _Math,
// Matrix4,
Mesh, MeshBasicMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MirroredRepeatWrapping, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, // Object3D, 
RGBAFormat, RGBFormat, RepeatWrapping, TextureLoader, // Vector2,
// Vector3, 
// sRGBEncoding,
Texture, // ShaderMaterial
VertexColors;
var isNodeEnv = typeof Blob == 'undefined' || typeof Image == 'undefined' || typeof Document == 'undefined' || typeof window == 'undefined';
var initDeps$OSGLoaderDone = false;
var isCreateImageBitmapSupported = false;

function initDeps$OSGLoader() {
  if (initDeps$OSGLoaderDone) return;
  initDeps$OSGLoaderDone = true;
  var _THREE = THREE;
  BufferAttribute = _THREE.BufferAttribute, BufferGeometry = _THREE.BufferGeometry, ClampToEdgeWrapping = 1001, Color = _THREE.Color, DoubleSide = 2, FileLoader = _THREE.FileLoader, FrontSide = 0, Group = _THREE.Group, LinearFilter = 1006, LinearMipMapLinearFilter = 1008, LinearMipMapNearestFilter = 1007, Loader = _THREE.Loader, LoaderUtils = _THREE.LoaderUtils, // Material = _THREE.Material,
  // Math as _Math,
  // _Math = _THREE.Math,
  // Matrix4 = _THREE.Matrix4,
  Mesh = _THREE.Mesh, MeshBasicMaterial = _THREE.MeshBasicMaterial, MeshPhongMaterial = _THREE.MeshPhongMaterial, MeshPhysicalMaterial = _THREE.MeshPhysicalMaterial, MeshStandardMaterial = _THREE.MeshStandardMaterial, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipMapLinearFilter = 1005, NearestMipMapNearestFilter = 1004, // Object3D = _THREE.Object3D, 
  RGBAFormat = 1023, RGBFormat = 1022, RepeatWrapping = 1000, TextureLoader = _THREE.TextureLoader, // Vector2 = _THREE.Vector2,
  // Vector3 = _THREE.Vector3,
  // sRGBEncoding = 3001,
  Texture = _THREE.Texture, // ShaderMaterial = _THREE.ShaderMaterial;
  VertexColors = _THREE.VertexColors;
  isCreateImageBitmapSupported = typeof createImageBitmap != 'undefined';
}

var _OSGLoader;

var OSGLoader = function OSGLoader(manager) {
  initDeps$OSGLoader();

  if (!_OSGLoader) {
    var _wrappingMap, _filterMap;

    var GLEnum = Osg.GLEnum;
    var wrappingMap = (_wrappingMap = {}, (0, _defineProperty2["default"])(_wrappingMap, GLEnum.MIRROR, MirroredRepeatWrapping), (0, _defineProperty2["default"])(_wrappingMap, GLEnum.CLAMP_TO_EDGE, ClampToEdgeWrapping), (0, _defineProperty2["default"])(_wrappingMap, GLEnum.REPEAT, RepeatWrapping), _wrappingMap);
    var filterMap = (_filterMap = {}, (0, _defineProperty2["default"])(_filterMap, GLEnum.LINEAR, LinearFilter), (0, _defineProperty2["default"])(_filterMap, GLEnum.LINEAR_MIPMAP_LINEAR, LinearMipMapLinearFilter), (0, _defineProperty2["default"])(_filterMap, GLEnum.LINEAR_MIPMAP_NEAREST, LinearMipMapNearestFilter), (0, _defineProperty2["default"])(_filterMap, GLEnum.NEAREST, NearestFilter), (0, _defineProperty2["default"])(_filterMap, GLEnum.NEAREST_MIPMAP_LINEAR, NearestMipMapLinearFilter), (0, _defineProperty2["default"])(_filterMap, GLEnum.NEAREST_MIPMAP_NEAREST, NearestMipMapNearestFilter), _filterMap);
    var _OSGLoaderPrototype_ = {
      load: function load(url, onLoad, onProgress, onError, options) {
        var _this = this;

        this.options = Object.assign({
          loadTexture: true
        }, options);
        var scope = this;
        var resourcePath;

        if (this.resourcePath !== '') {
          resourcePath = this.resourcePath;
        } else if (this.path !== '') {
          resourcePath = this.path;
        } else {
          resourcePath = LoaderUtils.extractUrlBase(url);
        } // Tells the LoadingManager to track an extra item, which resolves after
        // the model is fully loaded. This means the count of items loaded will
        // be incorrect, but ensures manager.onLoad() does not fire early.


        scope.manager.itemStart(url);

        var _onError = function _onError(e) {
          if (onError) {
            onError(e);
          } else {
            console.trace(e);
            console.error(e);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        };

        var loader = new FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');

        if (scope.crossOrigin === 'use-credentials') {
          loader.setWithCredentials(true);
        }

        loader.load(url, function (data) {
          try {
            var ext = url.substr(url.lastIndexOf('.') + 1);

            if (ext == 'osgjson') {
              if (typeof data != 'string') {
                data = LoaderUtils.decodeText(data);
              }

              data = JSON.parse(data);
              data = (0, _parseOsg.parseOsg)(data, resourcePath, _this.options.loadTexture, _this.manager, _this.options.imageCache, _this.options.textureCache, false);

              if (data.then) {
                return data.then(onLoad);
              }

              return onLoad(data);
            }

            scope.parse(data, resourcePath, function (osgb) {
              onLoad(osgb);
            }, _onError, _this.options);
            scope.manager.itemEnd(url);
          } catch (e) {
            _onError(e);
          }
        }, onProgress, _onError);
      },
      parse: function parse(data, path, onLoad, onError, options) {
        this.options = Object.assign({
          loadTexture: true
        }, options); // try {

        var root;

        if (data instanceof ArrayBuffer || data.buffer && data.buffer instanceof ArrayBuffer) {
          root = Osg.readBuffer(data);

          if (root == false) {
            var obj = (0, _parseOsg.parseOsg)(data, path, this.options.loadTexture, this.manager, this.options.imageCache, this.options.textureCache, false);

            if (obj.then) {
              return obj.then(onLoad);
            }

            return onLoad(obj);
          }
        } else {
          root = data;
        } // console.log('osg', root);


        var texturesByUri = {};
        this.parseObject(root, path, texturesByUri, options).then(function (obj) {
          // obj.osgRoot = root; 
          // var urls = Object.keys(texturesByUri)
          // if (urls.length > 1) {
          //     debugger
          // }
          // obj.texturesByUri = texturesByUri
          onLoad(obj);
        })["catch"](function (e) {
          if (onError) onError;
        }); // } catch (e) {
        //     console.error(e);
        //     if (onError) onError(e)
        // }
      },
      setRGBLoader: function setRGBLoader(rgbLoader) {
        this.rgbLoader = rgbLoader;
        return this;
      },
      setTGALoader: function setTGALoader(tgaLoader) {
        this.tgaLoader = tgaLoader;
        return this;
      },
      setBMPLoader: function setBMPLoader(bmpLoader) {
        this.bmpLoader = bmpLoader;
        return this;
      },

      /**
       * 
       * @param {Osg.Node|Osg.Group|Osg.Geode|Osg.LOD|Osg.PagedLOD} node
       * @param {string} path
       * @param {object} texturesByUri
       * @param {object} options
       * @param {boolean} [options.loadTexture=true]
       * @param {'basic'|'phong'|'standard'|'physical'}[materialType='basic']
       * @returns {Promise<THREE.Group>} 
       */
      parseObject: function parseObject(node, path, texturesByUri, options) {
        if (!this.options && options) {
          options = options || {};
          this.options = Object.assign({
            loadTexture: true,
            materialType: 'basic'
          }, options);
        }

        var materialType = this.options.materialType;

        switch (node.Type) {
          case 'Osg::Geode':
          case 'Osg::Group':
          case 'Osg::Node':
          case 'Osg::MatrixTransform':
            return this.parseNode(node, path, texturesByUri, materialType);

          case 'Osg::PagedLOD':
            return this.parsePagedLOD(node, path, texturesByUri, materialType);

          case 'Osg::Geometry':
            return this.pareseGeometry(node, path, texturesByUri, materialType);

          default:
            break;
        }
      },

      /**
       * 
       * @param {Osg.PagedLOD} pagedLOD 
       * @param {string} path
       * @param {object} texturesByUri
       * @param {'basic'|'phong'|'standard'|'physical'}[materialType]
       * @returns {Promise<THREE.Group>}
       */
      parsePagedLOD: function parsePagedLOD(pagedLOD, path, texturesByUri, materialType) {
        var _this2 = this;

        var group = new Group();
        group.name = pagedLOD.Name; // group.userData = {
        //     CenterMode: Osg.EnumToString(Osg.CenterMode, pagedLOD.CenterMode),
        //     RangeMode: Osg.EnumToString(Osg.RangeMode, pagedLOD.RangeMode),
        //     RangeList: pagedLOD.RangeList,
        //     RangeDataList: pagedLOD.RangeDataList,
        //     PriorityOffset: pagedLOD.PriorityOffset,
        //     PriorityScale: pagedLOD.PriorityScale,
        //     ResourcePath: path,
        //     UserCenter: pagedLOD.UserCenter
        // };

        var promises = pagedLOD.Children.map(function (Child) {
          return _this2.parseObject(Child, path, texturesByUri);
        });
        group.up.set(0, 0, 1);
        group.frustumCulled = false;
        return Promise.all(promises).then(function (nodes) {
          nodes.forEach(function (node) {
            group.add(node);
          });
          return group;
        });
      },

      /**
       * 
       * @param {Osg.Node} node 
       * @param {string} path
       * @param {object} texturesByUri
       * @returns {Promise<THREE.Group>}
       */
      parseNode: function parseNode(node, path, texturesByUri) {
        var _this3 = this;

        var group = new Group();
        group.name = node.Name;
        var promises = [];

        if (node.Children) {
          node.Children.forEach(function (Child) {
            var promise = _this3.parseObject(Child, path, texturesByUri);

            promises.push(promise);
          });
        } // else {
        //     console.log(node);
        // }


        group.up.set(0, 0, 1);
        group.frustumCulled = false;
        return Promise.all(promises).then(function (nodes) {
          nodes.forEach(function (node) {
            group.add(node);
          });
          return group;
        });
      },

      /**
       * 
       * @param {Osg.Geometry} geometry 
       * @param {string} path 
       * @param {object}texturesByUri
       * @param {'basic'|'phong'|'standard'|'physical'}[materialType]
       * @returns {Promise<THREE.BufferGeometry>}
       */
      pareseGeometry: function pareseGeometry(geometry, path, texturesByUri, materialType) {
        var _this4 = this;

        var group = new Group();
        group.name = geometry.Name;
        group.up.set(0, 0, 1);
        group.frustumCulled = false;
        var vertexArray = geometry.VertexArray;
        var normalArray = geometry.NormalArray;
        var colorArray = geometry.ColorArray;
        var uvs = geometry.TexCoordArray;
        var color,
            opacity = 1;
        var positionAttribute, normalAttribute, colorAttribute;
        positionAttribute = new BufferAttribute(vertexArray.Value, vertexArray.ItemSize);

        if (colorArray) {
          if (colorArray.Binding == Osg.AttributeBinding.BIND_PER_VERTEX) {
            colorAttribute = new BufferAttribute(colorArray.Value, colorArray.ItemSize);
          } else {
            color = new Color().fromArray(colorArray.Value);
            opacity = colorArray[3];
          }
        }

        if (normalArray) {
          normalAttribute = new BufferAttribute(normalArray.Value, normalArray.ItemSize, normalArray.Normalize);
        }

        var stateSet = geometry.StateSet;
        var promises = geometry.PrimitiveSetList.map(function (primitiveSet, id) {
          var uv = uvs[id];

          var materialPromise = _this4.parseMaterial(stateSet, path, texturesByUri, materialType);

          return materialPromise.then(function (material) {
            var bufferGeometry = new BufferGeometry();
            bufferGeometry.setAttribute('position', positionAttribute); // bufferGeometry.computeBoundingSphere();

            if (uv) {
              bufferGeometry.setAttribute('uv', new BufferAttribute(uv.Value, uv.ItemSize));
            }

            if (colorAttribute) {
              bufferGeometry.setAttribute('color', colorAttribute);
              material.vertexColors = VertexColors;
            } else if (color) {
              material.color = color; // material.opacity = opacity; 
            }

            if (primitiveSet.Indices) {
              var indices = primitiveSet.Indices.Value;

              if (primitiveSet.Mode == Osg.PrimitiveMode.GL_QUADS) {
                var newIndices = [];

                for (var i = 0; i < indices.length; i += 4) {
                  var i0 = indices[i],
                      i1 = indices[i + 1],
                      i2 = indices[i + 2],
                      i3 = indices[i + 3];
                  newIndices.push(i0, i1, i3, i1, i2, i3);
                }

                indices = new indices.constructor(newIndices);
              } else {
                bufferGeometry.GeometryMode = primitiveSet.Mode;
              }

              bufferGeometry.setIndex(new BufferAttribute(indices, 1));
            } else {
              bufferGeometry.addGroup(primitiveSet.First, primitiveSet.Count);
              bufferGeometry.GeometryMode = primitiveSet.Mode;
            }

            if (normalAttribute) {
              bufferGeometry.setAttribute('normal', normalAttribute);
            } else if (_this4.options.materialType != 'basic') {
              bufferGeometry.computeVertexNormals();
            }
            /**
             * @type {THREE.Mesh}
             */


            var mesh = new Mesh(bufferGeometry, material);
            mesh.vertexColors = !!colorAttribute;
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            mesh.up.set(0, 0, 1);
            mesh.frustumCulled = false;
            group.add(mesh);
          });
        });
        return Promise.all(promises).then(function () {
          return group;
        });
      },

      /**
      * 
      * @param {Osg.StateSet} stateSet 
      * @param {string} path 
      * @param {object}texturesByUri
      * @param {'basic'|'phong'|'standard'|'physical'}[type='basic']
      * @returns {Promise<THREE.Material>}
      */
      parseMaterial: function parseMaterial(stateSet, path, texturesByUri, type) {
        var _this5 = this;

        return new Promise(function (resolve, reject) {
          var material;

          switch (type) {
            case 'phong':
              material = new MeshPhongMaterial();
              break;

            case 'standard':
              material = new MeshStandardMaterial();
              break;

            case 'physical':
              material = new MeshPhysicalMaterial();
              break;

            default:
              material = new MeshBasicMaterial();
              break;
          }

          material.side = DoubleSide;

          if (!stateSet) {
            resolve(material);
            return;
          }

          var renderingHint = stateSet.RenderingHint;

          if (renderingHint != undefined && renderingHint != null) {
            material.transparent = renderingHint == Osg.RenderingHint.TRANSPARENT_BIN;
          }

          var attributeList = stateSet.AttributeList;
          var modelList = stateSet.ModeList;
          var textureAttributeList = stateSet.TextureAttributeList; //

          if (attributeList) {
            attributeList.forEach(function (attribute) {
              var key = attribute.key,
                  value = attribute.value;
              var stateAttribute = value.StateAttribute;

              switch (key.type) {
                case 'Osg::Material':
                  _this5.setMaterialAttribute(material, stateAttribute);

                  break;

                case 'Osg::StateAttribute':
                  break;

                case 'Osg::ShadeModel':
                  material.flatShading = stateAttribute.Mode == Osg.ShadeModelMode.ConstantsFLAT;
                  break;

                default:
                  break;
              }
            });
          } //


          if (modelList) {
            modelList.forEach(function (mode) {
              var key = mode.key,
                  value = mode.value;
              var keyName = Osg.EnumToString(Osg.GLEnum, key);

              switch (key) {
                case Osg.GLEnum.GL_DEPTH_TEST:
                  material.depthTest = value != Osg.StateAttributeValue.OFF;
                  break;

                case Osg.GLEnum.GL_BLEND:
                  material.blending = value != Osg.StateAttributeValue.OFF;
                  break;

                default:
                  break;
              }
            });
          } //


          var texturePromise;

          if (textureAttributeList && textureAttributeList.length > 0) {
            if (textureAttributeList.length > 1) {
              console.warn('only handle textureAttributeList[0]');
            }

            var texture = textureAttributeList[0].value.StateAttribute;
            texturePromise = _this5.parseTexture(texture, path, texturesByUri);
          }

          if (texturePromise) {
            texturePromise.then(function (texture) {
              material.map = texture;
              resolve(material);
            })["catch"](reject);
          } else {
            resolve(material);
          }
        });
      },

      /**
       * 
       * @param {THREE.MeshStandardMaterial} material 
       * @param {Osg.Material} attribute 
       */
      setMaterialAttribute: function setMaterialAttribute(material, attribute) {
        var emission = attribute.EmissionFront || attribute.EmissionBack;

        if (emission && material.emissive) {
          material.emissive = new Color().fromArray(emission);
          material.emissiveIntensity = emission[3];
          if (!attribute.EmissionFrontAndBack) console.warn('only support EmissionFrontAndBack=true');
        }

        var diffuse = attribute.DiffuseFront || attribute.DiffuseBack;

        if (diffuse) {
          material.color = new Color().fromArray(diffuse);
          material.opacity = diffuse[3];
          if (!attribute.DiffuseFrontAndBack) console.warn('only support DiffuseFrontAndBack=true');
        }

        var specular = attribute.SpecularFront || attribute.SpecularBack;

        if (specular) {
          material.specular = new Color().fromArray(specular); // material.specular = specular[3];

          if (!attribute.SpecularFrontAndBack) console.warn('only support SpecularFrontAndBack=true');
        }

        var shininess = attribute.ShininessFront || attribute.ShininessBack;

        if (shininess != undefined && shininess != null) {
          material.shininess = shininess; // material.specular = specular[3];

          if (!attribute.SpecularFrontAndBack) console.warn('only support SpecularFrontAndBack=true');
        }
      },
      resolveURL: function resolveURL(url, path) {
        // Invalid URL
        if (typeof url !== 'string' || url === '') return ''; // Host Relative URL

        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
          path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
        } // Absolute URL http://,https://,//


        if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

        if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

        if (/^blob:.*$/i.test(url)) return url; // Relative URL

        return (path + '/' + url).replace('//', '/');
      },
      getExtension: function getExtension(fname) {
        var start = fname.lastIndexOf(".");

        if (start >= 0) {
          return fname.substring(start, fname.length);
        }

        return "";
      },

      /**
       * 
       * @param {Osg.Texture2D} texture 
       * @param {string} path 
       * @param {object} texturesByUri
       * @returns {Promise<THREE.Texture>}
       */
      parseTexture: function parseTexture(texture, path, texturesByUri) {
        var _this6 = this;

        return new Promise(function (resolve, reject) {
          var image = texture.Image;
          if (!image) return;
          var fileName = image.Name;

          if (texturesByUri[fileName]) {
            resolve(texturesByUri[fileName]);
            return;
          }

          var isJPEG = fileName.search(/\.jpe?g($|\?)/i) > 0 || fileName.search(/^data\:image\/jpeg/) === 0;

          var ext = _this6.getExtension(fileName).toLowerCase();

          if (ext[0] == '.') ext = ext.slice(1);
          var imageUri, texture3js, isObjectURL;

          function onLoad() {
            texture3js.anisotropy = texture.MaxAnisotropy;
            texture3js.format = isJPEG ? RGBFormat : RGBAFormat;
            texture3js.wrapS = wrappingMap[texture.WrapS.value];
            texture3js.wrapT = wrappingMap[texture.WrapT.value];
            texture3js.magFilter = filterMap[texture.MagFilter.value];
            texture3js.minFilter = filterMap[texture.MinFilter.value];
            if (isObjectURL) URL.revokeObjectURL(imageUri);
            resolve(texture3js);
          }

          function onError(e) {
            reject(e);
          }

          if (image.ImageType == Osg.ImageType.IMAGE_EXTERNAL) {
            imageUri = _this6.resolveURL(fileName, path);

            if (isNodeEnv) {
              //nodejs  env
              imageUri = {
                src: fileName,
                fileName: imageUri
              };
            }
          } else if (image.ImageType == Osg.ImageType.IMAGE_INLINE_FILE) {
            if (ext == 'bmp' || ext == 'tga') {
              imageUri = texture.Image.Data;
            } else {
              var mimeType = 'image/' + ext;

              if (isNodeEnv || !_this6.options.loadTexture) {
                //nodejs  env
                imageUri = {
                  src: fileName,
                  //this.resolveURL(fileName, path),
                  fileName: _this6.resolveURL(fileName, path),
                  fileBuffer: image.Data
                };
              } else {
                var blob = new Blob([texture.Image.Data], {
                  type: mimeType
                });
                imageUri = blob;
              }
            }
          } else {
            texture3js = new DataTexture(image.Data, texture.TextureWidth, texture.TextureHeight);
            console.warn('image file ' + image.Name + '：unsupport imageType ' + Osg.EnumToString(Osg.ImageType, image.ImageType));
          }

          if (isNodeEnv || !_this6.options.loadTexture) {
            //nodejs
            if (!texture3js) texture3js = new Texture(imageUri);
            texturesByUri[fileName] = texture3js;
            onLoad();
          } else {
            //browser
            if (ext == 'dds') {
              texture3js = _this6.ddsLoader.load(imageUri, onLoad, null, onError);
            } else if (ext == 'rgb') {
              texture3js = _this6.rgbLoader.load(imageUri, onLoad, null, onError);
            } else if (ext == 'tga') {
              texture3js = _this6.tgaLoader.load(imageUri, onLoad, null, onError);
            } else if (ext == 'bmp') {
              texture3js = _this6.bmpLoader.load(imageUri, onLoad, null, onError);
            }

            if (!texture3js) {
              if (imageUri instanceof Blob) {
                if (isCreateImageBitmapSupported) {
                  createImageBitmap(imageUri, {
                    imageOrientation: "flipY",
                    premultiplyAlpha: "none"
                  }).then(function (img) {
                    texture3js.image = img;
                    onLoad();
                  })["catch"](onError);
                } else {
                  imageUri = URL.createObjectURL(imageUri);
                  var img = new Image();

                  img.onload = function () {
                    img.a_src = fileName;
                    texture3js.image = img;

                    try {
                      image.Data = null;
                      URL.revokeObjectURL(imageUri);
                      onLoad();
                    } catch (err) {
                      onError(err);
                    }

                    image = null;
                  };

                  img.onerror = onError;
                  img.src = imageUri;
                }

                texture3js = new Texture();
              } else {
                texture3js = new TextureLoader(_this6.manager).load(imageUri, onLoad, null, onError);
              }
            }

            texturesByUri[fileName] = texture3js;
          }
        });
      }
    };
    _OSGLoader = (0, _esExtends["default"])(Loader, {
      esConstructor: function esConstructor(c) {
        var _esCtor = /*#__PURE__*/function (_Loader) {
          (0, _inherits2["default"])(_esCtor, _Loader);

          var _super = _createSuper(_esCtor);

          function _esCtor(manager) {
            (0, _classCallCheck2["default"])(this, _esCtor);
            return _super.call(this, manager);
          }

          return _esCtor;
        }(Loader);

        return _esCtor;
      },
      constructor: function constructor() {},
      prototype: _OSGLoaderPrototype_
    });
  }

  return new _OSGLoader(manager);
};

var _default = OSGLoader;
exports["default"] = _default;

},{"-_895":198,"h_894":179,"3_896":185,"e_1":235,"e_45":237,"m_131":239,"C_129":240,"M_0":241,"o_130":242,"M_110":245}],183:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _index = require("o_900");

var _MeshVisModelUtil = _interopRequireDefault(require("-_873"));

var _DRACOExporter = require("M_902");

var _mergeBuffers = _interopRequireDefault(require("e_903"));

var _stringToArrayBuffer = _interopRequireDefault(require("s_904"));

var _ObjectUtil = require("h_905");

var _GenericWorker = _interopRequireDefault(require("h_872"));

var _GeometryUtils = _interopRequireDefault(require("M_132"));

function writeBuffer(array, buffers) {
  if (buffers.length == 0) {
    buffers.byteLength = 0;
  }

  var count = array.length;
  var byteOffset = buffers.byteLength;
  var buffer = array;
  if (!(buffer instanceof Uint8Array)) buffer = new Uint8Array(array.buffer);
  buffer = _MeshVisModelUtil["default"].getPaddedBuffer(buffer);
  var byteLength = buffer.byteLength;
  buffers.push(buffer);
  buffers.byteLength += byteLength;
  return {
    byteOffset: byteOffset,
    count: count
  };
}

var _canvas;

function getDataURLCallback(assetSrcs, imageFileNames) {
  return function getDataURL(image) {
    if (typeof image == 'string') return image;

    if (/^data:/i.test(image.src)) {
      return image.src;
    }

    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src;
    }

    var canvas;

    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else if (image instanceof HTMLImageElement && image.embedImages == false) {
      var src = image.src;
      if (!src.startsWith('blob:') || assetSrcs[src]) return src;
    }

    if (!canvas) {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = image.width;
      _canvas.height = image.height;

      var context = _canvas.getContext('2d');

      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }

      canvas = _canvas;
    }

    imageFileNames[image.uuid] = image.fileName;
    var embedFormat = image.embedFormat;

    if (embedFormat) {
      return canvas.toDataURL('image/' + embedFormat);
    }

    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  };
}

function setEmbedImages(material, embedImages) {
  if (Array.isArray(material)) {
    material.forEach(function (material) {
      setEmbedImages(material, embedImages);
    });
  } else {
    for (var key in material) {
      if (material.hasOwnProperty(key)) {
        var tex = material[key];

        if (tex && tex.isTexture && tex.image && typeof tex.image != 'string') {
          tex.image.embedImages = embedImages;
          tex.image.embedFormat = tex.format == 1023 ? 'png' : 'jpeg';
          tex.image.fileName = tex.imageFileName;
        }
      }
    }
  }
}

var _TypedArrayCtors = {
  Float64Array: Float64Array,
  Float32Array: Float32Array,
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array
};
/**
 * MeshVisModel exporter
 */

var VISMExporter = /*#__PURE__*/function () {
  /**
   * 
   * @param {object} [options] 
   * @param {object} [options.assetSrcs]
   * @param {object} [options.imageCache]
   * @param {boolean} [options.embedImages]
   * @param {boolean} [options.binary]
   * @param {boolean} [options.forceIndices]
   * @param {boolean} [options.removeUv2]
   * @param {boolean} [options.removeUv3]
   * @param {boolean} [options.removeNormal]
   * @param {boolean} [options.dracoEncode]  
   * @param {number} [options.dracoMinVertexCount=300]  
   * @param {(base64:string,index:number)=>string} [options.exportDataURL]
   * 
   */
  function VISMExporter(options) {
    (0, _classCallCheck2["default"])(this, VISMExporter);
    this.options = options || {};
  }

  (0, _createClass2["default"])(VISMExporter, [{
    key: "preProcess",
    value: function preProcess(scene) {
      var options = this.options;
      var binary = options.binary,
          embedImages = options.embedImages,
          forceIndices = options.forceIndices,
          removeUv2 = options.removeUv2,
          removeUv3 = options.removeUv3,
          removeNormal = options.removeNormal,
          dracoEncode = options.dracoEncode,
          dracoMinVertexCount = options.dracoMinVertexCount || 300;
      /**
       * @type {DRACOExporter} 
       * @private
       */

      var dracoExporter;

      if (binary && dracoEncode && typeof DracoEncoderModule != 'undefined') {
        dracoExporter = new _DRACOExporter.DRACOExporter();
        scene = scene.clone(true);
      }

      scene.traverse(function (obj) {
        if (!obj.material) return;
        setEmbedImages(obj.material, embedImages);
        if (!removeNormal && !dracoEncode && !forceIndices && !removeUv3) return;
        var geometry = obj.geometry = obj.geometry.clone();

        if (removeNormal) {
          delete geometry.attributes.normal;
        } else {
          if (geometry.attributes.normal && geometry.userData && geometry.userData.NormalBinding) {
            delete geometry.attributes.normal;
          }
        }

        var newGeometry = forceIndices && _GeometryUtils["default"].forceIndices(geometry, removeUv2, removeUv3);

        if (!newGeometry) {
          if (removeUv3) delete geometry.attributes.uv3;

          if (removeUv2) {
            delete geometry.attributes.uv2;

            if (obj.material.lightMap) {
              var material = obj.material.clone(true);
              material.lightMap = null;
              obj.material = material;
            }
          }
        } else {
          obj.geometry = newGeometry;
        }

        geometry = obj.geometry;
        geometry.userData = Object.assign({}, geometry.userData || {});
        delete geometry.userData.draco;
        var shouldDraco = !!dracoExporter;

        if (shouldDraco && geometry.attributes.position.count < dracoMinVertexCount) {
          shouldDraco = false;
        }

        if (shouldDraco) {
          if (geometry.attributes.position.count == 0) {
            debugger;
          }

          if (geometry.index && geometry.index.count == 0) {
            debugger;
          }

          geometry.userData.draco = dracoExporter.parse(geometry);

          if (!geometry.userData.draco) {
            debugger;
          }
        }
      });
      return scene;
    }
  }, {
    key: "parseGeometries",
    value: function parseGeometries(scene, meta, onProgress) {
      var library = meta.geometries;
      var gemetryMap = {},
          batch,
          batches = [],
          batchSize = 10;
      scene.traverse(function (obj) {
        if (!obj.geometry) return;
        var geometry = obj.geometry,
            uuid = geometry.uuid;
        if (gemetryMap[uuid]) return;

        if (batches.length == 0 || batch.length >= batchSize) {
          batch = [];
          batches.push(batch);
        }

        batch.push(geometry);
        gemetryMap[uuid] = true;
      });
      gemetryMap = null; //

      function workFunc(geometry) {
        var uuid = geometry.uuid;
        if (library[uuid]) return;
        library[uuid] = geometry.toJSON(meta);
      }

      var worker = new _GenericWorker["default"](batches, function (batch) {
        batch.forEach(workFunc);
      });
      return worker.run(onProgress);
    }
  }, {
    key: "parseMaterials",
    value: function parseMaterials(scene, meta, onProgress) {
      var library = meta.materials;
      var materialMap = {},
          batch,
          batches = [],
          batchSize = 10;
      scene.traverse(function (obj) {
        if (!obj.material) return;
        var objMaterial = obj.material;
        objMaterial = Array.isArray(objMaterial) ? objMaterial : [objMaterial];
        objMaterial.forEach(function (material) {
          var uuid = material.uuid;
          if (materialMap[uuid]) return;

          if (batches.length == 0 || batch.length >= batchSize) {
            batch = [];
            batches.push(batch);
          }

          batch.push(material);
          materialMap[uuid] = true;
        });
      });
      materialMap = null; //

      function workFunc(material) {
        var uuid = material.uuid;
        if (library[uuid]) return;
        library[uuid] = material.toJSON(meta);
      }

      var worker = new _GenericWorker["default"](batches, function (batch) {
        batch.forEach(workFunc);
      });
      return worker.run(onProgress);
    }
  }, {
    key: "parseAnimations",
    value: function parseAnimations(animations) {
      console.time('animations.toJSON');
      var animationsJson = [];

      if (animations) {
        animations.forEach(function (animation) {
          animationsJson.push(THREE.AnimationClip.toJSON(animation));
        });
      }

      console.timeEnd('animations.toJSON');
      return animationsJson;
    }
    /**
     * 
     * @param {THREE.Group|THREE.Scene} scene 
     * @param {THREE.AnimationClip[]}[animations]
     * @param {(currentProgress:number,totalProgress:number,message:string,e:{total:number,loaded:number})=>void}[onProgress]
     * @returns {Promise<ArrayBuffer>}  buffer
     */

  }, {
    key: "parse",
    value: function parse(scene, animations, onProgress) {
      var _this = this;

      var assetSrcs = this.options.assetSrcs || {},
          imageFileNames = {};
      THREE.ImageUtils.getDataURL = getDataURLCallback(assetSrcs, imageFileNames); // extract data from the cache hash
      // remove metadata on each item
      // and return as array

      function extractFromCache(cache) {
        var values = [];

        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }

        return values;
      }

      scene = this.preProcess(scene); //

      var progress = 1,
          e = {
        total: 100,
        loaded: 1
      };

      if (onProgress) {
        onProgress(0, progress, '预处理完成', e);
      } //


      var userData = scene.userData,
          cacheUserData;

      if (userData) {
        cacheUserData = Object.assign({}, userData);
        delete userData.uri;
        delete userData.assetSrcs;
      } //


      var sceneJson = {
        metadata: {
          version: 4.5,
          type: 'Object',
          generator: 'Object3D.toJSON,VISMExporter'
        }
      };
      var meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {}
      };
      return this.parseGeometries(scene, meta, function (currProgress) {
        e.loaded = 1 + 0.5 * currProgress;

        if (onProgress) {
          progress = 100 * e.loaded / e.total;
          onProgress(currProgress, progress, '导出几何体', e);
        }
      }).then(function () {
        e.loaded = 51;

        if (onProgress) {
          progress = e.loaded / e.total;
          onProgress(100, progress, '导出几何体', e);
        }

        return _this.parseMaterials(scene, meta, function (currProgress) {
          e.loaded = 51 + 0.48 * currProgress;

          if (onProgress) {
            progress = 100 * e.loaded / e.total;
            onProgress(currProgress, progress, '导出材质', e);
          }
        });
      }).then(function () {
        e.loaded = 99;

        if (onProgress) {
          progress = e.loaded / e.total;
          onProgress(100, progress, '导出材质', e);
        }

        console.time('scene.toJSON');
        sceneJson.object = scene.toJSON(meta).object; //

        var geometries = extractFromCache(meta.geometries);
        var materials = extractFromCache(meta.materials);
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        var shapes = extractFromCache(meta.shapes);
        var skeletons = extractFromCache(meta.skeletons);
        if (geometries.length > 0) sceneJson.geometries = geometries;
        if (materials.length > 0) sceneJson.materials = materials;
        if (textures.length > 0) sceneJson.textures = textures;
        if (images.length > 0) sceneJson.images = images;
        if (shapes.length > 0) sceneJson.shapes = shapes;
        if (skeletons.length > 0) sceneJson.skeletons = skeletons; //

        scene.userData = cacheUserData;
        console.timeEnd('scene.toJSON');

        var animationsJson = _this.parseAnimations(animations);

        var contentJson = {
          scene: sceneJson,
          animations: animationsJson
        };

        var buffer = _this.generateBuffer(contentJson, imageFileNames);

        if (onProgress) {
          setTimeout(function () {
            e.loaded = 100;
            progress = 100;
            onProgress(100, progress, '导出完成', e);
          }, 10);
        }

        return buffer;
      });
    }
  }, {
    key: "postProcessImages",
    value: function postProcessImages(images, buffer, imageFileNames) {
      var options = this.options,
          binary = options.binary,
          embedImages = options.embedImages,
          assetSrcs = options.assetSrcs || {},
          imageCache = options.imageCache || {},
          exportDataURL = options.exportDataURL;

      for (var i = 0; i < images.length; i++) {
        var img = images[i];

        if (!embedImages) {
          if (imageCache[img.uuid]) {
            img.url = imageCache[img.uuid];
            continue;
          }

          if (assetSrcs[img.url]) {
            //img
            img.url = assetSrcs[img.url];
          } else if (typeof exportDataURL == 'function') {
            //canvas
            img.url = exportDataURL(img.url, i, imageFileNames[img.uuid]);
          }

          imageCache[img.uuid] = img.url;
        } else if (binary) {
          //write image
          var mimeType = 'image/jpeg';
          if (/image\/png/.test(img.url)) mimeType = 'image/png';
          var imgBase64 = img.url.replace(/data:image\/(png|jpeg);base64,/i, '');
          var imgBuffer = (0, _index.toByteArray)(imgBase64);
          img.buffer = writeBuffer(imgBuffer, buffer);
          img.mimeType = mimeType;
          delete img.url;
        }
      }
    }
  }, {
    key: "postProcessGeometries",
    value: function postProcessGeometries(geometries, buffer) {
      for (var i = 0; i < geometries.length; i++) {
        var g = geometries[i],
            data = g.data,
            userData = g.userData;

        if (userData && userData.draco) {
          var dracoBuffer = userData.draco;
          userData.draco = writeBuffer(dracoBuffer, buffer);
          delete g.data;
        } else {
          var atts = data.attributes;

          for (var key in atts) {
            if (atts.hasOwnProperty(key) && atts[key]) {
              var att = atts[key];
              var TypedArrayCtor = _TypedArrayCtors[att.type];
              att.array = new TypedArrayCtor(att.array);
              att.array = writeBuffer(att.array, buffer);
            }
          }

          if (data.index) {
            var _att = data.index;
            var _TypedArrayCtor = _TypedArrayCtors[_att.type];
            _att.array = new _TypedArrayCtor(_att.array);
            _att.array = writeBuffer(_att.array, buffer);
          }
        }
      }
    }
  }, {
    key: "postProcessAnimations",
    value: function postProcessAnimations(animations, buffer) {
      animations.forEach(function (animation) {
        animation.tracks.forEach(function (track) {
          var times = new Float32Array(track.times);
          var values = new Float32Array(track.values);
          track.times = writeBuffer(times, buffer);
          track.values = writeBuffer(values, buffer);
        });
      });
    }
    /**
     * 
     * @param {Object} contentJson 
     * @returns {ArrayBuffer}
     */

  }, {
    key: "generateBuffer",
    value: function generateBuffer(contentJson, imageFileNames) {
      var binary = this.options.binary,
          scene = contentJson.scene,
          images = scene.images,
          geometries = scene.geometries,
          animations = contentJson.animations;
      Object3D.traverse(scene.object, function (obj) {
        var userData = obj.userData;

        if (userData) {
          userData = Object.assign({}, userData);
          obj.userData = userData;
          delete userData.transformData;
        }

        if (!userData || JSON.stringify(userData) == '{}') {
          delete obj.userData;
        }
      });
      var magic = 'vism',
          headerOffset = 8,
          buffer = [];
      console.time('binary');

      if (binary) {
        this.postProcessGeometries(geometries, buffer);
        this.postProcessAnimations(animations, buffer);
      }

      console.timeEnd('binary');
      console.time('binary images');

      if (images) {
        this.postProcessImages(images, buffer, imageFileNames);
      }

      console.timeEnd('binary images');
      console.time('encodeObject');
      contentJson = (0, _ObjectUtil.encodeObject)(contentJson);
      console.timeEnd('encodeObject');
      console.time('JSON.stringify');
      contentJson = JSON.stringify(contentJson);
      console.timeEnd('JSON.stringify');

      if (binary) {
        console.time('write');
        var jsonBodyBuffer = (0, _stringToArrayBuffer["default"])(contentJson);
        jsonBodyBuffer = new Uint8Array(jsonBodyBuffer);
        var headerLength = headerOffset + jsonBodyBuffer.length;
        var headerBuffer = new Uint8Array(headerLength);

        for (var i = 0; i < 4; i++) {
          headerBuffer[i] = magic.charCodeAt(i);
        }

        for (var _i = headerOffset, j = 0; _i < headerLength; _i++, j++) {
          headerBuffer[_i] = jsonBodyBuffer[j];
        }

        jsonBodyBuffer = null;
        headerBuffer = _MeshVisModelUtil["default"].getPaddedBuffer(headerBuffer, " ".charCodeAt(0));
        headerLength = headerBuffer.length;
        var headerDV = new DataView(headerBuffer.buffer);
        headerDV.setUint32(4, headerLength);
        buffer.unshift(headerBuffer);
        buffer = (0, _mergeBuffers["default"])(buffer);
        console.timeEnd('write');
        return buffer;
      } else {
        magic = 'json    '; //

        return buffer = (0, _stringToArrayBuffer["default"])(magic + contentJson);
      }
    }
  }]);
  return VISMExporter;
}();

exports["default"] = VISMExporter;

},{"o_900":218,"M_132":2,"h_872":189,"h_905":192,"e_903":203,"s_904":206,"M_902":89,"-_873":181,"e_1":235,"s_2":236,"M_0":241}],184:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("o_900");

var _DRACOLoader = require("m_868");

var _GenericWorker = _interopRequireDefault(require("h_872"));

var _MathUtils = _interopRequireDefault(require("m_912"));

var _ObjectUtil = require("h_905");

var _sizeOfUint32 = 4;

var _VISMLoader_proto_;

var _cacheVISMLoaderDracoLoaders = {};

function getVISMLoaderDracoLoader(dracoDecoderPath) {
  var dracoLoader = _cacheVISMLoaderDracoLoaders[dracoDecoderPath];

  if (!dracoLoader) {
    dracoLoader = new _DRACOLoader.DRACOLoader();
    _cacheVISMLoaderDracoLoaders[dracoDecoderPath] = dracoLoader;
    dracoLoader.setDecoderPath(dracoDecoderPath);
    dracoLoader.preload();
  }

  return dracoLoader;
}
/**
 * MeshVisModel Loader
 * @constructor
 */


function VISMLoader(manager) {
  var _THREE = THREE,
      ObjectLoader = _THREE.ObjectLoader;

  if (!_VISMLoader_proto_) {
    var _TypedArrayCtors = {
      Float64Array: Float64Array,
      Float32Array: Float32Array,
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray: Uint8ClampedArray,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array
    };
    _VISMLoader_proto_ = {
      load: function load(url, onLoad, onProgress, onError, options) {
        this.options = Object.assign({
          loadTexture: true
        }, options);
        var scope = this;

        var resourcePath = _THREE.LoaderUtils.extractUrlBase(url);

        this.resourcePath = resourcePath;
        url = scope.manager.resolveURL(url); // Tells the LoadingManager to track an extra item, which resolves after
        // the model is fully loaded. This means the count of items loaded will
        // be incorrect, but ensures manager.onLoad() does not fire early.

        scope.manager.itemStart(url);

        var _onError = function _onError(e) {
          if (onError) {
            onError(e);
          } else {
            console.trace(e);
            console.error(e);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        };

        var loader = new _THREE.FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');

        if (scope.crossOrigin === 'use-credentials') {
          loader.setWithCredentials(true);
        }

        loader.load(url, function (data) {
          try {
            scope.parse(data, function (scene) {
              scene._memorySize = data.byteLength;
              onLoad(scene);
            }, _onError, options);
            scope.manager.itemEnd(url);
          } catch (e) {
            _onError(e);
          }
        }, onProgress, _onError);
      },
      setDracoDecoderPath: function setDracoDecoderPath(dracoDecoderPath) {
        if (!this.dracoLoader) {
          this.dracoLoader = getVISMLoaderDracoLoader(dracoDecoderPath);
        } else if (this.dracoDecoderPath != dracoDecoderPath) {
          this.dracoDecoderPath = dracoDecoderPath;
          this.dracoLoader.setDecoderPath(dracoDecoderPath);
          this.dracoLoader.preload();
        }
      },
      setDRACOLoader: function setDRACOLoader(dracoLoader) {
        this.dracoLoader = dracoLoader;

        if (this.dracoDecoderPath) {
          this.dracoLoader.preload();
          this.dracoLoader.setDecoderPath(this.dracoDecoderPath);
        }
      },
      parse: function parse(data, onLoad, onError, options) {
        options = options || {};
        options.imageCache = options.imageCache || {};
        options.textureCache = options.textureCache || {};
        this._preloadTexture = typeof options.loadTexture == 'boolean' ? options.loadTexture : true;

        if (data instanceof ArrayBuffer) {
          data = new Uint8Array(data);
        }

        var magic = this.getMagic(data);

        if (magic != 'vism' && magic != 'json') {
          onError(new Error('Invalid magic  :' + magic));
        } else {
          var headerLength = data.buffer.byteLength;
          var headerOffset = 8;
          var jsonBody, binBuffer;

          try {
            if (magic == 'vism') {
              headerLength = this.getHeaderLength(data);
              jsonBody = data.buffer.slice(headerOffset, headerLength);
              binBuffer = data.buffer.slice(headerLength);
              jsonBody = _THREE.LoaderUtils.decodeText(jsonBody);
              data = JSON.parse(jsonBody);
            } else {
              //json
              jsonBody = data.buffer.slice(headerOffset, headerLength);
              jsonBody = _THREE.LoaderUtils.decodeText(jsonBody);
              data = JSON.parse(jsonBody);
            } // console.log(jsonBody);


            (0, _ObjectUtil.decodeObject)(data);
            if (data.animations) this._parseAnimations(data.animations, binBuffer);
            return this._parse(data.scene || data, binBuffer, function (model) {
              model.traverse(function (obj) {
                if (!obj.geometry) return;
                var geometry = obj.geometry;
                var userData = geometry.userData;

                if (userData && userData.draco) {
                  debugger;
                }
              });

              if (data.scene) {
                data.scene = model;
                model = data;
              }

              if (onLoad) onLoad(model);
              return model;
            }, function (err) {
              onError(err);
            });
          } catch (err) {
            // console.log(jsonBody);
            onError(err);
          }
        }
      },
      _parseAnimations: function _parseAnimations(json, buffer) {
        for (var i = 0; i < json.length; i++) {
          var animation = json[i],
              tracks = animation.tracks;

          for (var j = 0; j < tracks.length; j++) {
            var track = tracks[j],
                times = track.times,
                values = track.values;
            var count = times.count,
                byteOffset = times.byteOffset;

            if (count) {
              track.times = new Float32Array(buffer, byteOffset, count);
            }

            count = values.count, byteOffset = values.byteOffset;

            if (count) {
              track.values = new Float32Array(buffer, byteOffset, count);
            }
          }
        }
      },
      _parse: function _parse(json, buffer, onLoad, onError) {
        var scope = this;
        var shapes = scope.parseShapes(json.shapes);
        var geometries = scope.parseGeometries(json.geometries, shapes, buffer);

        function onGeometriesLoad(geometries) {
          return scope.parseImages(json.images, buffer).then(function (images) {
            var textures = scope.parseTextures(json.textures, images);
            var materials = scope.parseMaterials(json.materials, textures);
            var object = scope.parseObject(json.object, geometries, materials);

            if (json.animations) {
              object.animations = scope.parseAnimations(json.animations);
            }

            if (onLoad !== undefined) onLoad(object);
            return object;
          });
        }

        if (geometries.then) {
          return geometries.then(onGeometriesLoad)["catch"](onError);
        } else {
          return onGeometriesLoad(geometries)["catch"](onError);
        }
      },
      getHeaderLength: function getHeaderLength(uint8Array) {
        var dv = new DataView(uint8Array.buffer);
        var v = dv.getUint32(_sizeOfUint32);
        return v;
      },
      getMagic: function getMagic(uint8Array) {
        var magic = [];

        for (var i = 0; i < _sizeOfUint32; i++) {
          magic.push(uint8Array[i]);
        }

        magic = String.fromCharCode.apply(null, magic);
        return magic;
      },
      parseImages: function parseImages(json, buffer) {
        var scope = this;
        var images = {};
        var loader,
            imageCache = scope.options.imageCache || {},
            preloadTexture = scope._preloadTexture;

        if (json !== undefined && json.length > 0) {
          var workFunc = function workFunc(image) {
            if (imageCache[image.uuid]) {
              images[image.uuid] = imageCache[image.uuid];
              return;
            }

            var url = image.url;

            if (Array.isArray(url)) {
              // load array of images e.g CubeTexture
              images[image.uuid] = [];
              var subWorker = new _GenericWorker["default"](url, function (currentUrl) {
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;

                if (preloadTexture) {
                  return new Promise(function (resolve, reject) {
                    var img = loader.load(path, resolve, undefined, reject);
                    images[image.uuid].push(img);
                  });
                } else {
                  images[image.uuid].push(path);
                }
              });
              return subWorker.run();
            } else {
              if (image.buffer) {
                var _image$buffer = image.buffer,
                    byteOffset = _image$buffer.byteOffset,
                    count = _image$buffer.count;
                var imgBuffer = new Uint8Array(buffer, byteOffset, count);
                url = 'data:' + image.mimeType + ';base64,' + (0, _index.fromByteArray)(imgBuffer);
              } else {
                url = image.url;
              } // load single image


              var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;

              if (preloadTexture) {
                return new Promise(function (resolve, reject) {
                  var img = loader.load(path, resolve, undefined, reject);
                  images[image.uuid] = img;
                  img.uuid = image.uuid;
                });
              } else {
                images[image.uuid] = path;
              }

              imageCache[image.uuid] = images[image.uuid];
            }
          };

          var _manager = scope.manager || new _THREE.LoadingManager();

          loader = new _THREE.ImageLoader(_manager);
          loader.setCrossOrigin(scope.crossOrigin);
          var batchSize = 200,
              batch = [],
              batches = [],
              imageMap = {};
          json.forEach(function (image) {
            if (imageCache[image.uuid]) {
              images[image.uuid] = imageCache[image.uuid];
              return;
            }

            if (imageMap[image.uuid]) return;
            imageMap[image.uuid] = true;

            if (batches.length == 0 || batch.length >= batchSize) {
              batch = [];
              batches.push(batch);
            }

            batch.push(image);
          });
          imageMap = null;
          var worker = new _GenericWorker["default"](batches, function (batch) {
            var pendings = batch.map(workFunc);
            return Promise.all(pendings);
          });
          return worker.run().then(function () {
            return images;
          });
        }

        return Promise.resolve(images);
      },
      parseAttributeArray: function parseAttributeArray(att, buffer) {
        if (!buffer) return;
        var _att$array = att.array,
            byteOffset = _att$array.byteOffset,
            count = _att$array.count;
        var TypedArrayCtor = _TypedArrayCtors[att.type];
        att.array = new TypedArrayCtor(buffer, byteOffset, count);
      },
      parseDracoGeometries: function parseDracoGeometries(json, buffer) {
        var _this = this;

        json = json.filter(function (g) {
          try {
            if (!_this.isBufferGeometry(g)) return g;
          } catch (err) {
            debugger;
          }
        });

        if (json.length > 0) {
          /**
          * @type {DRACOLoader}
          */
          var dracoLoader = this.dracoLoader,
              taskConfig = {
            attributeIDs: dracoLoader.defaultAttributeIDs,
            attributeTypes: dracoLoader.defaultAttributeTypes,
            useUniqueIDs: false
          },
              pendings = [];
          json.forEach(function (g) {
            var userData = g.userData;
            var _userData$draco = userData.draco,
                byteOffset = _userData$draco.byteOffset,
                count = _userData$draco.count;
            var dracoBuffer = new Uint8Array(buffer, byteOffset, count);
            dracoBuffer = dracoBuffer.slice().buffer;
            var pending = dracoLoader.decodeGeometry(dracoBuffer, taskConfig);
            pendings.push(pending);
          });
          return Promise.all(pendings).then(function (geometryList) {
            var geometries = {};
            geometryList.forEach(function (geometry, index) {
              var g = json[index];
              geometry.name = g.name;
              geometry.userData = g.userData;
              geometry.uuid = g.uuid;
              delete g.userData.draco;
              var atts = geometry.attributes;

              if (!atts.normal && g.userData && g.userData.NormalBinding) {
                var vCount = geometry.index ? 3 * (_MathUtils["default"].minmax(geometry.index.array).max + 1) : atts.position.array.length;
                var normalArray = g.userData.NormalArray;
                var arr = new Float32Array(vCount * 3);

                for (var i = 0; i < arr.length; i += 3) {
                  arr[i] = normalArray[0];
                  arr[i + 1] = normalArray[1];
                  arr[i + 2] = normalArray[2];
                }

                var normal = new _THREE.BufferAttribute(arr, 3, false);
                geometry.setAttribute('normal', normal);
              }

              geometries[geometry.uuid] = geometry;
            });
            return geometries;
          });
        } else {
          return Promise.resolve({});
        }
      },
      isBufferGeometry: function isBufferGeometry(g) {
        var isBufferGeometry = !!g.data;
        if (!isBufferGeometry) return false;
        var data = g.data,
            atts = data.attributes;

        for (var key in atts) {
          if (atts.hasOwnProperty(key) && atts[key]) {
            var att = atts[key];

            if (!att.array) {
              isBufferGeometry = false;
              break;
            }
          }
        }

        return isBufferGeometry;
      },
      parseBufferGeometries: function parseBufferGeometries(json, shapes, buffer) {
        var _this2 = this;

        var scope = this;
        var batches = [],
            batch,
            batchSize = 500,
            geometries = [];

        for (var i = 0; i < json.length; i++) {
          var g = json[i];
          if (!this.isBufferGeometry(g)) continue;

          if (batches.length == 0 || batch.length >= batchSize) {
            batch = [];
            batches.push(batch);
          }

          geometries.push(g);
          batch.push(g);
        }

        if (batches.length == 0) return Promise.resolve({});

        function workFunc(g) {
          var data = g.data,
              atts = data.attributes;

          for (var key in atts) {
            if (atts.hasOwnProperty(key) && atts[key]) {
              var att = atts[key];
              scope.parseAttributeArray(att, buffer);
            }
          }

          if (data.index) {
            var _att = data.index;
            scope.parseAttributeArray(_att, buffer);
          }

          if (!atts.normal && g.userData && g.userData.NormalBinding) {
            var vCount = data.index ? 3 * (_MathUtils["default"].minmax(data.index.array).max + 1) : atts.position.array.length;
            var normalArray = g.userData.NormalArray;
            var arr = new Float32Array(vCount);

            for (var _i = 0; _i < arr.length; _i += 3) {
              arr[_i] = normalArray[0];
              arr[_i + 1] = normalArray[1];
              arr[_i + 2] = normalArray[2];
            }

            atts.normal = {
              type: 'Float32Array',
              itemSize: 3,
              normalize: false,
              array: arr
            };
          }
        }

        var worker = new _GenericWorker["default"](batches, function (batch) {
          batch.forEach(workFunc);
        });
        return worker.run().then(function () {
          geometries = ObjectLoader.prototype.parseGeometries.call(_this2, geometries, shapes);
          return geometries;
        });
      },
      parseGeometries: function parseGeometries(json, shapes, buffer) {
        var pendings = [this.parseDracoGeometries(json, buffer), this.parseBufferGeometries(json, shapes, buffer)];
        return Promise.all(pendings).then(function (arr) {
          var geometries = Object.assign({}, arr[0], arr[1]);
          return geometries;
        });
      }
    };
  }

  var loader = new ObjectLoader(manager);
  Object.assign(loader, _VISMLoader_proto_);
  return loader;
}

var _default = VISMLoader;
exports["default"] = _default;

},{"o_900":218,"h_872":189,"m_912":191,"h_905":192,"m_868":93,"M_0":241}],185:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.osgToJSON = osgToJSON;
exports.readOsg = readOsg;
exports.parseOsg = parseOsg;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _index = require("o_900");

// import * as THREE from '../../lib/three/three.module.js';
// reader 
var osgInput;

var OsgInput = /*#__PURE__*/function () {
  function OsgInput(text) {
    (0, _classCallCheck2["default"])(this, OsgInput);
    this.text = text;
    this.cacheRow = null;
    this.totalLength = text.length;
  }

  (0, _createClass2["default"])(OsgInput, [{
    key: "length",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "nextRow",
    value: function nextRow(preRead) {
      var m = /\r?\n+/.exec(this.text);

      if (m) {
        if (this.cacheRow) {
          var row = this.cacheRow;
          this.cacheRow = null;
        } else {
          var row = this.text.substr(0, m.index);
          this.text = this.text.substr(m.index + m[0].length);

          if (preRead) {
            this.cacheRow = row;
          }

          if (this.onProgress) {
            this.onProgress(this.totalLength - this.length, this.totalLength);
          }
        }

        return row;
      } else {
        return this.text;
      }
    }
  }, {
    key: "nextBlock",
    value: function nextBlock() {
      var m = /}\r?\n+/.exec(this.text);

      if (m) {
        var block = this.text.substr(0, m.index);
        this.text = this.text.substr(m.index + m[0].length);

        if (this.onProgress) {
          this.onProgress(this.totalLength - this.length, this.totalLength);
        }

        return block;
      } else {
        return this.text;
      }
    }
  }, {
    key: "onProgress",
    value: function onProgress(readLength, totalLength) {}
  }]);
  return OsgInput;
}();

function trim(input) {
  var output = "";
  var start = 0,
      end = input.length;

  while (/(\s|\t)+/g.test(input[start]) && start < input.length) {
    start++;
  }

  var ch = input[end - 1];

  while (/(\s|\t)+/g.test(ch) && end > 0) {
    end--;
    ch = input[end - 1];
  }

  output = input.substring(start, end);
  return output;
}

function parseProperty(row) {
  var m = /\s+/.exec(row);
  var name = '',
      value = row,
      dataType = null;
  var dataType = value[0];

  if (m) {
    name = row.substr(0, m.index);
    value = row.substr(m.index + m.length);
    dataType = value[value.length - 1];
    return {
      name: name,
      dataType: dataType,
      value: value,
      row: row
    };
  } else if (row == "}") {
    dataType = "}";
    return {
      name: name,
      dataType: dataType,
      value: value,
      row: row
    };
  }
}

function readProperty() {
  var row = osgInput.nextRow();
  row = trim(row);
  return parseProperty(row);
}

var _osgDataType_Ctors = {
  Vec2Array: Float32Array,
  Vec3Array: Float32Array,
  Vec4Array: Float32Array,
  UByteArray: Uint8Array,
  ByteArray: Int8Array,
  UShortArray: Uint16Array,
  ShortArray: Int16Array,
  UIntArray: Uint32Array,
  IntArray: Int32Array
};

function readNumberAray(dataType) {
  var block = osgInput.nextBlock();
  block = trim(block);
  block = '[' + block.replace(/(\s|\t)+/g, ',') + ']';
  var arr = JSON.parse(block);
  var TypeCtor = _osgDataType_Ctors[dataType];
  if (!TypeCtor) TypeCtor = Float32Array;
  arr = new TypeCtor(arr);
  return arr;
}

function readChilren(num_children) {
  var children = new Array(num_children);

  for (var index = 0; index < num_children; index++) {
    children[index] = readObject();
  }

  return children;
} // textureUnit PrimitiveSets VertexArray TexCoordArray NormalArray


function readPrimitiveSet() {
  var row = osgInput.nextRow();
  var description = trim(row).split(/\s+/);
  var primitiveSet = {
    DrawFunc: description[0],
    Mode: description[1],
    First: parseInt(description[2]),
    Count: parseInt(description[3]),
    Indices: null
  };

  if (primitiveSet.DrawFunc != 'DrawArrays') {
    primitiveSet.Indices = readNumberAray();
  } // Indices?: OsgArray
  // Mode: PrimitiveMode
  // NumInstances: number
  // Binding: null;
  // Normalize: boolean;
  // First?: number;
  // Count?: number


  return primitiveSet;
}

function readPrimitiveSets(property) {
  var primitiveSets = [];

  do {
    var row = osgInput.nextRow();
    var primitiveSet = readPrimitiveSet();
    primitiveSets.push(primitiveSet);
    row = osgInput.nextRow();
    row = trim(row);
    property = parseProperty(row);

    if (property.name != 'PrimitiveSets') {
      break;
    }
  } while (true);

  return primitiveSets;
}

function readTextureUnits(property) {
  var textureUnits = [];

  do {
    var textureUnit = readObject();
    textureUnits.push(textureUnit);
    var row = trim(osgInput.nextRow(true));
    property = parseProperty(row);

    if (property.name != 'textureUnit') {
      break;
    }

    row = osgInput.nextRow();
  } while (true);

  return textureUnits;
} // VertexArray TexCoordArray NormalArray


var osgArrays = {},
    _osgDataType_To_ItemSize = {
  Vec3Array: 3,
  Vec2Array: 2,
  Vec4Array: 2,
  UShortArray: 1,
  ShortArray: 1,
  IntArray: 1,
  UIntArray: 1
};

function readOsgArray(property, indicesName) {
  // VertexArray Vec3Array 186
  // NormalArray Vec3Array 1
  //TexCoordArray 0 Vec2Array 186
  //indicesName:
  //  VertexIndices
  //  TexCoordIndices
  var typeName = property.name;
  var arrays = [];
  var description,
      offset = 0;

  do {
    description = property.value.split(/\s+/);
    if (description.length == 3) offset = 1;else offset = 0;
    var array = {
      dataType: description[offset],
      count: parseInt(description[offset + 1]),
      value: null,
      Type: "Osg::Array"
    };

    if (description[1] == "UniqueID") {
      //0 UniqueID Vec2Array_11 Vec2Array 168
      array.UniqueID = description[2];
      array.dataType = description[3];
      array.count = parseInt(description[4]);
    }

    if (array.dataType == 'Use') {
      var uniqueID = description[2];
      array = osgArrays[uniqueID];
    } else {
      osgInput.nextRow(); //skip '{'

      array.value = readNumberAray(array.dataType);

      if (array.UniqueID) {
        osgArrays[array.UniqueID] = array;
      }
    }

    arrays.push(array);
    property = parseProperty(trim(osgInput.nextRow(true))); //read indices

    if (indicesName && property.name == indicesName) {
      osgInput.nextRow(true); //skip descriptor

      var indicesArr = readOsgArray(property);
      var indices = indicesArr[0];
      var itemSize = _osgDataType_To_ItemSize[array.dataType];
      var newValues = new array.value.constructor(indices.count * itemSize);

      for (var i = 0; i < indices.count; i++) {
        var srcIndex = indices.value[i];
        var srcStart = itemSize * srcIndex;
        var dstStart = itemSize * i;

        for (var j = 0; j < itemSize; j++) {
          var val = array.value[srcStart + j];
          newValues[dstStart + j] = val;
        }
      }

      array.value = newValues;
      array.count = indices.count; //try reading next block

      var cacheRow = osgInput.nextRow(true);
      property = parseProperty(trim(cacheRow));

      if (property.name != typeName) {
        osgInput.cacheRow = cacheRow;
      }
    }

    if (property.name != typeName) {
      break;
    }

    if (array.dataType != 'Use') {
      osgInput.nextRow(); //skip '{'
    }
  } while (true);

  return arrays;
}

function readObject() {
  var obj = {},
      indicesNameMap = {
    VertexArray: 'VertexIndices',
    TexCoordArray: 'TexCoordIndices'
  };
  var property = readProperty();
  if (!property) debugger;
  var dataType = property.dataType;
  var name = property.name;
  var value = property.value.replace(/\"/g, '');

  if (name == 'Matrix') {
    return readNumberAray();
  } else if (dataType == '{') {
    obj = readObject();
    obj.Type = 'Osg::' + name;
  } else {
    obj[name] = trim(value);

    while (osgInput.length > 0) {
      property = readProperty();
      if (!property) break;
      dataType = property.dataType;
      name = property.name;
      value = property.value;

      if (name == 'Matrix') {
        obj[name] = readNumberAray();
      } else if (name == 'PrimitiveSets') {
        obj[name] = readPrimitiveSets(property);
      } else if (name == 'textureUnit') {
        obj[name] = readTextureUnits(property);
      } else if (name == 'VertexArray' || name == 'TexCoordArray' || name == 'NormalArray' || name == 'ColorArray') {
        obj[name] = readOsgArray(property, indicesNameMap[name]);
      } else if (dataType == '{') {
        obj[name] = readObject();
        obj[name].Type = "Osg::" + name;
      } else if (dataType == '}') {
        break;
      } else if (name == 'num_children' || name == 'num_drawables') {
        value = parseInt(value);
        obj[name] = value;
        obj.children = readChilren(value);
      } else {
        value = value.replace(/\"/g, '');
        obj[name] = value;
      }
    }
  }

  return obj;
} //parser


function parseColor(str) {
  var color = str.replace(/\s+/g, ',');
  color = JSON.parse('[' + color + ']');
  return color;
}

var magFilterMap, wrapMap;

function parseTexture(textureUnit, path, texturesByUri, texturesByID) {
  if (!textureUnit) return;
  var _THREE = THREE,
      LinearFilter = 1006,
      NearestFilter = 1003;

  if (!magFilterMap) {
    magFilterMap = {
      'LINEAR': LinearFilter,
      'LINEAR_MIPMAP_LINEAR': 1008,
      'LINEAR_MIPMAP_NEAREST': 1007,
      'NEAREST': NearestFilter,
      'NEAREST_MIPMAP_LINEAR': 1005,
      'NEAREST_MIPMAP_NEAREST': 1004
    };
    wrapMap = {
      "CLAMP_TO_EDGE": 1001,
      "REPEAT": 1000,
      "MIRRORED": 1002
    };
  }

  return textureUnit.map(function (textureUnit) {
    if (textureUnit.Use) {
      return texturesByID[textureUnit.Use];
    } else {
      var textureParams = textureUnit.Texture2D;
      var uniqueID = textureParams.UniqueID;
      var c = path[path.length - 1] == '/' ? '' : '/';
      var file = textureParams.file;
      var uri = path + c + file.replace(/"/g, '').replace(/(\/|\\)+/g, '/');
      var texture = texturesByUri[uri];

      if (!texture) {
        var texture = new _THREE.Texture(uri);
        var isJPEG = file.search(/\.jpe?g($|\?)/i) > 0 || file.search(/^data\:image\/jpeg/) === 0;
        texture.format = isJPEG ? 1022 : 1023;
        texture.magFilter = magFilterMap[textureParams.mag_filter];
        texture.anisotropy = parseInt(textureParams.maxAnisotropy);
        var minFilter = magFilterMap[textureParams.min_filter];
        texture.minFilter = minFilter;
        if (minFilter == LinearFilter || minFilter == NearestFilter) texture.generateMipmaps = false;
        texture.wrapS = wrapMap[textureParams.wrap_s];
        texture.wrapT = wrapMap[textureParams.wrap_t];
        texturesByUri[uri] = texture;
        texturesByUri.count = texturesByUri.count ? texturesByUri.count + 1 : 1;
      }

      texturesByID[uniqueID] = texture;
      return texture;
    }
  });
}

var osg_depthFuncMap, osg_factorMap, osg_equationMap;
var materials = {};

function parseMaterial(stateSet, textures) {
  var _THREE = THREE;

  if (!osg_depthFuncMap) {
    osg_depthFuncMap = {
      NEVER: 0,
      ALWAYS: 1,
      LESS: 2,
      LEQUAL: 3,
      EQUAL: 4,
      GEQUAL: 5,
      GREATER: 6,
      NOTEQUAL: 7
    };
  }

  if (!osg_factorMap) {
    osg_factorMap = {
      ZERO: 200,
      ONE: 201,
      SRC_COLOR: 202,
      SRC_ALPHA: 204,
      SRC_ALPHA_SATURATE: 210,
      DST_COLOR: 208,
      DST_ALPHA: 206,
      ONE_MINUS_SRC_COLOR: 203,
      ONE_MINUS_SRC_ALPHA: 205,
      ONE_MINUS_DST_COLOR: 209,
      ONE_MINUS_DST_ALPHA: 207
    };
  }

  if (!osg_equationMap) {
    osg_equationMap = {
      FUNC_ADD: 100,
      FUNC_SUBTRACT: 101,
      FUNC_REVERSE_SUBTRACT: 102,
      MIN: 103,
      MAX: 104
    };
  }

  var parameters = stateSet.Material;
  var uniqueID;

  if (parameters.UniqueID || parameters.uniqueID) {
    uniqueID = parameters.UniqueID || parameters.uniqueID;

    if (materials[uniqueID]) {
      return materials[uniqueID];
    }
  }

  var material = new _THREE.MeshPhongMaterial({
    side: 2
  });
  material.name = parameters.name;
  if (parameters.ColorMode == 'ON') material.vertexColors = _THREE.VertexColors;
  var diffuseColor = parseColor(parameters.diffuseColor);
  material.color = new _THREE.Color().fromArray(diffuseColor);
  var emissive = parseColor(parameters.emissionColor);
  material.emissive = new _THREE.Color().fromArray(emissive);
  material.emissiveIntensity = emissive[3];
  material.shininess = parseFloat(parameters.shininess);
  var specular = parseColor(parameters.specularColor);
  material.specular = new _THREE.Color().fromArray(specular);

  if (uniqueID) {
    material.userData.uniqueID = uniqueID;
    materials[uniqueID] = material;
  }

  if (stateSet.rendering_hint == 'TRANSPARENT_BIN') {
    material.transparent = true; // material.alphaTest = 0;
    // material.premultipliedAlpha = true;
    // material.depthWrite = false;
  }

  if (stateSet.BlendFunc) {
    var blendFunc = stateSet.BlendFunc; // material.blending = 5;
    // material.blending = 2
    // material.blendSrc = osg_factorMap[blendFunc.source];
    // material.blendSrcAlpha =osg_factorMap[blendFunc.source];// osg_factorMap[blendFunc.sourceAlpha||'ZERO'];
    // material.blendDst = osg_factorMap[blendFunc.destination];
    // material.blendDstAlpha = osg_factorMap[blendFunc.destination]//osg_factorMap[blendFunc.destinationAlpha||'ZERO'];
    // material.premultipliedAlpha=true;
    // source SRC_ALPHA
    // destination ONE_MINUS_SRC_ALPHA
    // functionSourceRgb: gl.SRC_ALPHA,
    // functionSourceAlpha: gl.ONE,
    // functionDestinationRgb: gl.ONE_MINUS_SRC_ALPHA,
    // functionDestinationAlpha: gl.ONE_MINUS_SRC_ALPHA
    // return {
    //     enabled: material.blending == 0,
    //     // color: //Color
    //     equationRgb: equationToGL[material.blendEquation],
    //     equationAlpha: equationToGL[material.blendEquationAlpha],
    //     functionSourceRgb: factorToGL[material.blendSrc],
    //     functionSourceAlpha: factorToGL[material.blendSrcAlpha],
    //     functionDestinationRgb: factorToGL[material.blendDst],
    //     functionDestinationAlpha: factorToGL[material.blendDstAlpha]
    // }
  }

  if (stateSet.GL_CULL_FACE == 'ON') {
    material.side = 0;
  }

  if (textures && textures.length > 0) {
    material.map = textures[0];

    if (textures.length > 1) {
      /**
       * @type {THREE.Texture}
       * @private
       */
      var lightMap = textures[1]; // lightMap.format = 1022;

      lightMap.minFilter = 1006;
      material.lightMap = lightMap;
    }

    if (textures.length > 2 && textures[2] != material.map) {
      material.alphaMap = textures[2];
    }

    if (material.alphaMap || material.map.format == 1023 || material.opacity < 1) {
      material.depthWrite = !material.transparent;
    }
  }

  return material;
}

function parseOsgArray(parameters) {
  var itemSize = 3;

  switch (parameters.dataType) {
    case "Vec3fArray":
    case "Vec3dArray":
    case "Vec3DArray":
    case "Vec3Array":
      itemSize = 3;
      break;

    case "Vec2fArray":
    case "Vec2dArray":
    case "Vec2DArray":
    case "Vec2Array":
      itemSize = 2;
      break;

    case "Vec4fArray":
    case "Vec4dArray":
    case "Vec4DArray":
    case "Vec4Array":
      itemSize = 4;
      break;

    default:
      break;
  }

  var array = parameters.value;

  if (typeof array == 'string') {
    array = new Float32Array((0, _index.toByteArray)(array).buffer);
  }

  var attribute = new THREE.BufferAttribute(array, itemSize, parameters.normalize || parameters.Normalize);
  return attribute;
}

function parseGeometry(parameters, path, texturesByUri, texturesByID) {
  var _THREE = THREE;
  var textures = parseTexture(parameters.StateSet.textureUnit, path, texturesByUri, texturesByID);
  var material = parseMaterial(parameters.StateSet, textures);
  var geometry = new _THREE.BufferGeometry();
  parameters.PrimitiveSets.forEach(function (primitiveSet) {
    if (primitiveSet.DrawFunc == "DrawArrays") {
      geometry.addGroup(primitiveSet.First, primitiveSet.Count);
    } else {
      geometry.setIndex(primitiveSet.Indices);
    }
  });

  if (parameters.ColorArray) {
    var colorArray = parameters.ColorArray[0];
    var colorAttribute = parseOsgArray(colorArray);

    if (parameters.ColorBinding == 'OVERALL') {
      material.color = new _THREE.Color().fromArray(colorAttribute.value || colorAttribute.array || colorAttribute);
    } else if (colorAttribute && (!material.map || material.vertexColors)) {
      geometry.setAttribute('color', colorAttribute);
    }
  }

  var vertexArray = parameters.VertexArray[0];
  var posAttribute = parseOsgArray(vertexArray);
  geometry.setAttribute('position', posAttribute);

  if (parameters.TexCoordArray) {
    parameters.TexCoordArray.forEach(function (texCoordArray, index) {
      var uvAttribute = parseOsgArray(texCoordArray);

      if (index == 0) {
        geometry.setAttribute('uv', uvAttribute);
      } else {
        geometry.setAttribute('uv' + (index + 1), uvAttribute);
      }
    });
  }

  if (parameters.NormalArray) {
    var normalArray = parameters.NormalArray[0];
    normalArray = parseOsgArray(normalArray);

    if (parameters.NormalBinding == 'OVERALL') {
      var arr = new Float32Array(posAttribute.count * normalArray.itemSize);

      for (var i = 0; i < arr.length; i += normalArray.itemSize) {
        for (var j = 0; j < normalArray.itemSize; j++) {
          arr[i + j] = normalArray.array[j];
        }
      }

      var normalAttribute = new _THREE.BufferAttribute(arr, normalArray.itemSize, normalArray.normalize);
      geometry.userData = geometry.userData || {};
      geometry.userData.NormalBinding = 'OVERALL';
      geometry.userData.NormalArray = normalArray.array;
      geometry.setAttribute('normal', normalAttribute); // debugger
    } else if (parameters.NormalBinding == 'PER_PRIMITIVE') {
      var itemSize = normalArray.itemSize;

      var _arr = new Float32Array(posAttribute.count * itemSize);

      var primiticeCount = normalArray.count,
          vCount = 3;
      var _i = 0;

      for (var primiveIndex = 0; primiveIndex < primiticeCount; primiveIndex++) {
        var srcStart = primiveIndex * itemSize;

        for (var vi = 0; vi < vCount; vi++) {
          var index = geometry.index ? geometry.index.array[_i] : _i;
          var dstStart = index * itemSize;

          for (var _j = 0; _j < itemSize; _j++) {
            _arr[dstStart + _j] = normalArray.array[srcStart + _j];
          }

          _i++;
        }
      }

      var normalAttribute = new _THREE.BufferAttribute(_arr, normalArray.itemSize, normalArray.normalize);
      geometry.setAttribute('normal', normalAttribute);
    } else {
      var normalAttribute = normalArray;
      geometry.setAttribute('normal', normalAttribute);
    }
  }

  var obj = new _THREE.Mesh(geometry, material);
  obj.name = parameters.name; // obj.up.set(0, 0, 1);

  return obj;
}
/**
 * 
 * @param {object} parameters 
 * @param {"Osg::Material"|"Osg::Texture2D"|"Osg::StateSet"|"Osg::MatrixTransform"|"Osg::Geode"|"Osg::Group"|"Osg::Geometry"|"Osg::Node"} parameters.Type
 * @returns {THREE.Group}
 */


function parseObject(parameters, path, texturesByUri, texturesByID) {
  var obj = new THREE.Group(); // obj.up.set(0, 0, 1);

  switch (parameters.Type) {
    case 'Osg::Geode':
    case "Osg::Group":
    case "Osg::Node":
    case "Osg::MatrixTransform":
      if (parameters.referenceFrame && parameters.referenceFrame != "RELATIVE") {
        console.warn('unsupport ReferenceFrame' + parameters.referenceFrame + ". use RELATIVE ReferenceFrame");
      }

      if (parameters.Matrix) {
        obj.matrix.fromArray(parameters.Matrix);
        obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
        obj.matrix.identity();
      }

      parameters.children.forEach(function (child) {
        obj.add(parseObject(child, path, texturesByUri, texturesByID));
      });
      break;

    case 'Osg::Geometry':
      obj = parseGeometry(parameters, path, texturesByUri, texturesByID);
      break;

    default:
      throw new Error('unsupport osg dataType ' + parameters.Type + ' ');
  }

  if (obj) obj.Name = parameters.name;
  return obj;
}

var imgLoader;

function loadTextureImage(texture, imageCache) {
  return new Promise(function (resolve, reject) {
    var url = texture.image;

    if (typeof url != 'string') {
      resolve(texture.image);
    } else if (imageCache && imageCache[url]) {
      texture.image = imageCache[url];
      resolve(texture.image);
    } else {
      var img = imgLoader.load(url, resolve, reject);
      img._srcUrl = url;
      img.uuid = THREE.Math.generateUUID();
      texture.image = img;
      if (imageCache) imageCache[url] = img;
    }
  });
}

function traverseOsgJson(node, callback) {
  if (node) callback(node);

  if (node.children) {
    node.children.forEach(function (node) {
      traverseOsgJson(node, callback);
    });
  }
}
/**
 * 
 * @param {object} osg 
 * @returns {object}
 */


function osgToJSON(osg) {
  traverseOsgJson(osg, function (node) {
    if (node.Type == 'Osg::Geometry') {
      for (var name in node) {
        if (node.hasOwnProperty(name) && (name == 'VertexArray' || name == 'TexCoordArray' || name == 'NormalArray' || name == 'ColorArray')) {
          var osgArray = node[name];

          if (Array.isArray(osgArray)) {
            osgArray.forEach(function (array) {
              if (typeof array.value != 'string') {
                if (typeof Buffer != 'undefined') {
                  array.value = Buffer.from(array.value.buffer).toString('base64');
                } else {
                  array.value = (0, _index.fromByteArray)(new Uint8Array(array.value.buffer));
                }
              }
            });
          } else {
            if (typeof osgArray.value != 'string') {
              if (typeof Buffer != 'undefined') {
                osgArray.value = Buffer.from(osgArray.value.buffer).toString('base64');
              } else {
                osgArray.value = (0, _index.fromByteArray)(new Uint8Array(osgArray.value.buffer));
              } // osgArray.value = Buffer.from(osgArray.value.buffer).toString('base64');

            }
          }
        }
      }

      node.PrimitiveSets.forEach(function (primitiveSet) {
        if (primitiveSet.Indices) {
          primitiveSet.Indices = Buffer.from(primitiveSet.Indices).toString('base64');
        }
      });
    }

    if (node.Matrix) {
      node.Matrix = Array.from(node.Matrix);
    }
  });
  return osg;
}
/**
 * 
 * @param {string} text
 * @param {(readLength,totalLength)=>void} [onProgress]
 * @returns {object}
 */


function readOsg(text, onProgress) {
  osgInput = new OsgInput(text);
  osgInput.onProgress = onProgress;
  var obj = readObject();
  return obj;
}
/**
 * 
 * @param {string|Uin8Array|ArrayBuffer} osg 
 * @param {string} path  
 * @param {boolean}[preloadTexture] 
 * @param {THREE.LoadingManager}[manager] 
 * @param {object}[imageCache]
 * @param {object}[textureCache]
 * @param {boolean}[debug]
 * @returns {Promise<THREE.Group>}
 */


function parseOsg(osg, path, preloadTexture, manager, imageCache, textureCache, debug) {
  var _THREE = THREE; // textureCache = null;

  var texturesByUri = textureCache || {};
  var texturesByID = {};
  osgArrays = {};
  materials = {};
  imageCache = imageCache || {};
  if (debug) console.time('readOsg');

  if (typeof osg == 'string') {
    osg = readOsg(osg);
  } else if (osg instanceof Uint8Array) {
    osg = _THREE.LoaderUtils.decodeText(osg);
    osg = readOsg(osg);
  } else if (osg instanceof ArrayBuffer) {
    osg = new Uint8Array(osg);
    osg = _THREE.LoaderUtils.decodeText(osg);
    osg = readOsg(osg);
  }

  if (debug) {
    console.timeEnd('readOsg');
  }

  if (debug) console.time('parseObject');
  var obj = parseObject(osg, path, texturesByUri, texturesByID);
  obj.osgRoot = osg;
  if (debug) console.timeEnd('parseObject');
  var textureKeys = Object.keys(texturesByID);

  if (preloadTexture && textureKeys.length > 0) {
    var pending = [];
    imgLoader = new _THREE.ImageLoader(manager);

    for (var id in texturesByID) {
      if (texturesByID.hasOwnProperty(id)) {
        var texture = texturesByID[id];
        pending.push(loadTextureImage(texture, imageCache));
      }
    }

    if (!textureCache) texturesByUri = {};
    texturesByID = {};
    osgArrays = {};
    materials = {};
    return Promise.all(pending).then(function () {
      return obj;
    });
  } else {
    if (!textureCache) texturesByUri = {};
    texturesByID = {};
    osgArrays = {};
    materials = {};
  }

  return obj;
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"o_900":218,"e_1":235,"s_2":236,"M_0":241,"buffer":248}],186:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = releaseResources;

/**
 * 
 * @param {THREE.Object3D} scene 
 */
function releaseResources(scene) {
  if (!scene || !scene.traverse) return;
  scene.traverse(function (node) {
    if (node.isDestroyed && node.isDestroyed()) return; //runtime's meshes

    if (node.destroy) {
      node.pickObject && delete node.pickObject;
      node.pickId && delete node.pickId;
      node.destroy();
      return;
    } //three.js`s objects


    if (!node.isScene && node.dispose) {
      node.dispose();
    }

    if (node.dispatchEvent) node.dispatchEvent({
      type: 'dispose'
    }, node);
    node.pickObject && delete node.pickObject;
    node.pickId && delete node.pickId;

    if (node._actualMesh) {
      if (!node._actualMesh.isDestroyed) node._actualMesh.destroy();
      delete node._actualMesh.mesh3js;
      delete node._actualMesh;
    }

    if (node.geometry) {
      node.geometry.dispose();
      var attrs = node.geometry.attributes;

      for (var key in attrs) {
        if (attrs.hasOwnProperty(key) && attrs[key]) {
          var att = attrs[key];
          delete att.array;
          attrs[key];
        }
      }

      delete node.geometry.attributes;
      delete node.geometry;
    }

    if (node.material) {
      if (Array.isArray(node.material)) {
        node.material.forEach(function (mtl) {
          mtl.dispose();
        });
      } else {
        node.material.dispose();
      }

      delete node.material;
    }
  });
}

},{}],187:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VISMLoader", {
  enumerable: true,
  get: function get() {
    return _VISMLoader["default"];
  }
});
Object.defineProperty(exports, "VISMExporter", {
  enumerable: true,
  get: function get() {
    return _VISMExporter["default"];
  }
});
Object.defineProperty(exports, "OSGLoader", {
  enumerable: true,
  get: function get() {
    return _OSGLoader["default"];
  }
});
Object.defineProperty(exports, "GLTFLoader", {
  enumerable: true,
  get: function get() {
    return _GLTFLoader.GLTFLoader;
  }
});
Object.defineProperty(exports, "DDSLoader", {
  enumerable: true,
  get: function get() {
    return _DDSLoader.DDSLoader;
  }
});
Object.defineProperty(exports, "TGALoader", {
  enumerable: true,
  get: function get() {
    return _TGALoader.TGALoader;
  }
});
Object.defineProperty(exports, "BMPLoader", {
  enumerable: true,
  get: function get() {
    return _BMPLoader.BMPLoader;
  }
});
Object.defineProperty(exports, "DRACOLoader", {
  enumerable: true,
  get: function get() {
    return _DRACOLoader.DRACOLoader;
  }
});
Object.defineProperty(exports, "RGBELoader", {
  enumerable: true,
  get: function get() {
    return _RGBELoader.RGBELoader;
  }
});
Object.defineProperty(exports, "BmpDecoder", {
  enumerable: true,
  get: function get() {
    return _decoder.BmpDecoder;
  }
});
Object.defineProperty(exports, "DRACOExporter", {
  enumerable: true,
  get: function get() {
    return _DRACOExporter.DRACOExporter;
  }
});
Object.defineProperty(exports, "GLTFExporter", {
  enumerable: true,
  get: function get() {
    return _GLTFExporter.GLTFExporter;
  }
});
Object.defineProperty(exports, "MeshVisModel", {
  enumerable: true,
  get: function get() {
    return _MeshVisModel["default"];
  }
});
Object.defineProperty(exports, "MeshVisModelUtil", {
  enumerable: true,
  get: function get() {
    return _MeshVisModelUtil["default"];
  }
});
Object.defineProperty(exports, "PagedLOD", {
  enumerable: true,
  get: function get() {
    return _PagedLOD["default"];
  }
});
Object.defineProperty(exports, "QuadtreeLOD", {
  enumerable: true,
  get: function get() {
    return _QuadtreeLOD["default"];
  }
});
Object.defineProperty(exports, "QuadtreeLODUtil", {
  enumerable: true,
  get: function get() {
    return _QuadtreeLODUtil["default"];
  }
});
Object.defineProperty(exports, "QuadtreeNode", {
  enumerable: true,
  get: function get() {
    return _QuadtreeNode["default"];
  }
});
Object.defineProperty(exports, "QuatreeContentSet", {
  enumerable: true,
  get: function get() {
    return _QuatreeContentSet["default"];
  }
});
Object.defineProperty(exports, "releaseResources", {
  enumerable: true,
  get: function get() {
    return _releaseResources["default"];
  }
});
Object.defineProperty(exports, "BuildingVector3DLoader", {
  enumerable: true,
  get: function get() {
    return _BuildingVector3DLoader["default"];
  }
});
Object.defineProperty(exports, "parseOsg", {
  enumerable: true,
  get: function get() {
    return _parseOsg.parseOsg;
  }
});
Object.defineProperty(exports, "readOsg", {
  enumerable: true,
  get: function get() {
    return _parseOsg.readOsg;
  }
});
Object.defineProperty(exports, "CameraHelper", {
  enumerable: true,
  get: function get() {
    return _CameraHelper["default"];
  }
});
Object.defineProperty(exports, "Cesium3DTileExtension", {
  enumerable: true,
  get: function get() {
    return _Cesium3DTileExtension["default"];
  }
});
exports.LODUtils = exports.Osg = void 0;

var _VISMLoader = _interopRequireDefault(require("._920"));

var _VISMExporter = _interopRequireDefault(require("C_921"));

var _OSGLoader = _interopRequireDefault(require("o_922"));

var Osg = _interopRequireWildcard(require("m_923"));

exports.Osg = Osg;

var _GLTFLoader = require("M_924");

var _DDSLoader = require("e_925");

var _TGALoader = require("s_926");

var _BMPLoader = require("h_927");

var _DRACOLoader = require("-_928");

var _RGBELoader = require("3_929");

var _decoder = require("D_930");

var _DRACOExporter = require("._931");

var _GLTFExporter = require("C_932");

var _MeshVisModel = _interopRequireDefault(require("o_933"));

var _MeshVisModelUtil = _interopRequireDefault(require("m_934"));

var _PagedLOD = _interopRequireDefault(require("M_935"));

var _QuadtreeLOD = _interopRequireDefault(require("e_936"));

var _QuadtreeLODUtil = _interopRequireDefault(require("s_937"));

var _QuadtreeNode = _interopRequireDefault(require("h_938"));

var _QuatreeContentSet = _interopRequireDefault(require("-_939"));

var _releaseResources = _interopRequireDefault(require("3_940"));

var _BuildingVector3DLoader = _interopRequireDefault(require("D_941"));

var LODUtils = _interopRequireWildcard(require("._942"));

exports.LODUtils = LODUtils;

var _parseOsg = require("C_943");

var _CameraHelper = _interopRequireDefault(require("o_944"));

var _Cesium3DTileExtension = _interopRequireDefault(require("m_945"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"m_945":73,"D_941":75,"o_944":76,"._942":79,"M_935":80,"e_936":83,"s_937":84,"h_938":85,"-_939":86,"D_930":88,"._931":89,"C_932":90,"h_927":91,"e_925":92,"-_928":93,"M_924":94,"3_929":95,"s_926":96,"m_923":179,"o_933":180,"m_934":181,"o_922":182,"C_921":183,"._920":184,"C_943":185,"3_940":186,"M_0":241,"M_110":245}],188:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPaddedBufferSize = getPaddedBufferSize;
exports.getPaddedBuffer = getPaddedBuffer;

/**
 * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
 * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
 *
 * @param {Integer} bufferSize The size the original buffer.
 * @returns {Integer} new buffer size with required padding.
 *
 */
function getPaddedBufferSize(bufferSize) {
  return Math.ceil(bufferSize / 4) * 4;
}
/**
 * Returns a buffer aligned to 4-byte boundary.
 *
 * @param {Uint8Array} buffer Buffer to pad
 * @param {Integer} paddingByte (Optional)
 * @returns {Uint8Array} The same buffer if it's already aligned to 4-byte boundary or a new buffer
 */


function getPaddedBuffer(buffer, paddingByte) {
  paddingByte = paddingByte || 0;
  var paddedLength = this.getPaddedBufferSize(buffer.byteLength);

  if (paddedLength !== buffer.byteLength) {
    var array = new Uint8Array(paddedLength);
    array.set(buffer); //new Uint8Array(arrayBuffer));

    if (paddingByte !== 0) {
      for (var i = buffer.byteLength; i < paddedLength; i++) {
        array[i] = paddingByte;
      }
    }

    return array;
  }

  return buffer;
}

},{}],189:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

/**
 * 通用线程工具，在主线程中实现异步执行耗费时间较长的任务队列，避免界面假死，同时可以监控任务执行进度。应用：可以用于代替耗费时间较长的for循环
* @example
    let dataList=[];

    function workFunc(data,index){
        //do something here
    }

    //1.for
    for(let index=0;index<dataList.length;index++){
        let data=dataList[index];
        workFunc(data,index);
    }

    //2.Use GenericWorker instead

    let worker=new GenericWorker(dataList,workFunc);
    worker.run((progress,currentData)=>{
        //update progress ui here
    }).then(()=>{
        //done
    }).catch(err=>{
        //error
    });
 */
var GenericWorker = /*#__PURE__*/function () {
  /**
   *  通用线程工具，在主线程中实现异步执行耗费时间较长的任务队列，避免界面假死，同时可以监控任务执行进度。应用：可以用于代替耗费时间较长的for循环
   * @param {Array} dataList 
   * @param {(data:any,index:number)=>Promise<any>} workFunc 
   * @example
      let dataList=[];
      
      function workFunc(data,index){
          //do something here
      }
       //for
      for(let index=0;index<dataList.length;index++){
        let data=dataList[index];
        workFunc(data,index);
      }
       //GenericWorker
       let worker=new GenericWorker(dataList,workFunc);
      worker.run((progress,currentData)=>{
          //update progress ui here
      }).then(()=>{
          //done
      }).catch(err=>{
          //error
      });
   */
  function GenericWorker(dataList, workFunc) {
    (0, _classCallCheck2["default"])(this, GenericWorker);

    if (!dataList || !dataList.length) {
      throw new Error('dataList is required');
    }

    if (typeof workFunc != 'function') {
      throw new Error('workFunc is required');
    }

    this.dataList = dataList;
    this.workFunc = workFunc;
  }

  (0, _createClass2["default"])(GenericWorker, [{
    key: "run",
    value: function run(onProgress) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var taskCount = _this.dataList.length,
            taskIndex = 0;
        var resultList = [];

        var next = function next() {
          try {
            if (_this.dataList.length == 0) {
              if (onProgress) onProgress(100, null);
              resolve(resultList);
            } else {
              var loaded = taskCount - _this.dataList.length;
              var progress = 100 * loaded / taskCount;

              var currentData = _this.dataList.shift();

              if (onProgress) onProgress(progress, currentData, loaded, taskCount);

              var promises = _this.workFunc(currentData, taskIndex);

              var isArray = Array.isArray(promises);
              if (!isArray) promises = [promises];
              Promise.all(promises).then(function (result) {
                if (isArray || !result) resultList.push(result);else resultList.push(result[0]);
                taskIndex++;
                requestAnimationFrame(next);
              })["catch"](function (err) {
                resultList.splice(0);
                reject(err);
              });
            }
          } catch (err) {
            resultList.splice(0);
            reject(err);
          }
        };

        next();
      });
    }
  }]);
  return GenericWorker;
}();

exports["default"] = GenericWorker;

},{"e_1":235,"s_2":236,"M_0":241}],190:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _Path = _interopRequireDefault(require("D_952"));

var _GenericWorker = _interopRequireDefault(require("._953"));

// import { MaxRectsPacker, Rectangle, Bin } from "../../App/Mesh3DV/lib/maxrects-packer/dist/maxrects-packer.js";
var ImageUtils = /*#__PURE__*/function () {
  function ImageUtils() {
    (0, _classCallCheck2["default"])(this, ImageUtils);
  }

  (0, _createClass2["default"])(ImageUtils, null, [{
    key: "layoutMap",
    value:
    /**
     * Based on MaxRectsPacker: https://www.npmjs.com/package/maxrects-packer
     * @param {{width:number,height:number}[]} maps 
     * @param {boolean} [forcePowerOfTwo=false] 
     * @returns {{rects:{id:number,x:number,y:number,rot:number,width:number,height:number,image:CanvasImageSource}[],width:number,height:number}[]}
     */
    function layoutMap(maps, forcePowerOfTwo) {
      if (typeof MaxRectsPacker == 'undefined') {
        throw new Error('MaxRectsPacker is required. https://www.npmjs.com/package/maxrects-packer');
      }

      var input = [];
      maps.forEach(function (map, id) {
        input.push({
          width: map.width,
          height: map.height,
          image: map,
          id: id
        });
      });
      var options = {
        smart: true,
        pot: forcePowerOfTwo != undefined ? forcePowerOfTwo : true,
        square: false,
        allowRotation: false,
        tag: false,
        border: 0 // logic:MaxRectsPacker.PACKING_LOGIC.MAX_AREA

      }; // Set packing options

      var packer = new MaxRectsPacker.MaxRectsPacker(4096 * 2, 4096 * 2, 0, options); // width, height, padding, options

      packer.addArray(input); // Start packing with input array  

      return packer.bins;
    }
    /**
     * 
     * @param {{rects:{id:number,x:number,y:number,rot:number,width:number,height:number,image:CanvasImageSource}[],width:number,height:number}} packedBin 
     * @returns {HTMLCanvasElement}
     */

  }, {
    key: "drawPackedMap",
    value: function drawPackedMap(packedBin, bgColor) {
      var rects = packedBin.rects,
          width = packedBin.width,
          height = packedBin.height;
      var cv = document.createElement('canvas');
      cv.width = width;
      cv.height = height;
      var ctx = cv.getContext('2d');

      if (bgColor) {
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, width, height);
      }

      for (var i = 0; i < rects.length; i++) {
        var rect = rects[i];
        ctx.drawImage(rect.image, rect.x, rect.y);
      }

      return cv;
    }
    /**
     * 
     * @param {CanvasImageSource} map 
     * @param {number[]} uvBox 
     * @param {boolean} [flipY=false] 
     * @param {boolean} [forceClip=false] 
     * @returns {HTMLCanvasElement}
     */

  }, {
    key: "clipMap",
    value: function clipMap(map, uvBox, flipY, forceClip) {
      var sw = map.width,
          sh = map.height;
      var w = parseInt(sw * (uvBox[2] - uvBox[0]));
      var h = parseInt(sh * (uvBox[3] - uvBox[1]));
      if (w == map.width && h == map.height && !forceClip) return map;
      var cv = document.createElement('canvas');
      cv.width = w;
      cv.height = h;
      var ctx = cv.getContext('2d');
      var x = uvBox[0] * sw,
          y = uvBox[1] * sh;

      if (flipY) {
        y = map.height - y - h;
      }

      ctx.drawImage(map, -x, -y);
      return cv;
    }
    /**
     * 
     * @param {HTMLImageElement|HTMLCanvasElement} img 
     * @param {number} angle in degrees
     * @returns {HTMLCanvasElement}
     */

  }, {
    key: "rotate",
    value: function rotate(img, angle) {
      var c = document.createElement("canvas");
      c.width = img.width;
      c.height = img.height;
      var ctx = c.getContext("2d");
      ctx.translate(c.width / 2, c.height / 2);
      ctx.rotate(angle * Math.PI / 180);
      ctx.translate(-c.width / 2, -c.height / 2);
      ctx.drawImage(img, 0, 0);
      return c;
    }
    /**
     * 
     * @param {HTMLImageElement|HTMLCanvasElement} img 
     * @param {string} text 
     * @param {object} [options] 
     * @param {string} [options.font] 
     * @param {string} [options.color]
     * @param {number} [options.x]
     * @param {number} [options.y]
     * @returns {HTMLCanvasElement}
     */

  }, {
    key: "drawText",
    value: function drawText(img, text, options) {
      options = options || {};
      var cv = document.createElement('canvas');
      cv.width = img.width;
      cv.height = img.height;
      var x = typeof options.x == 'number' ? options.x : cv.width / 2,
          y = typeof options.y == 'number' ? options.y : cv.height / 2;
      var ctx = cv.getContext('2d');
      ctx.drawImage(img, 0, 0);
      ctx.fillStyle = options.color;
      ctx.font = options.font;
      ctx.fillText(text, x, y);
      return cv;
    }
    /**
     * 
     * @param {string} atlasImgUrl 
     * @param {(images:HTMLImageElement[])=>void} onLoad 
     */

  }, {
    key: "getTexturesFromAtlasFile",
    value: function getTexturesFromAtlasFile(atlasImgUrl, onLoad) {
      var textures = [];
      var imageObj = new Image();

      imageObj.onload = function () {
        var canvas, context;
        var tileWidth = imageObj.height,
            tilesNum = imageObj.width / tileWidth;

        for (var i = 0; i < tilesNum; i++) {
          canvas = document.createElement('canvas');
          context = canvas.getContext('2d');
          canvas.height = tileWidth;
          canvas.width = tileWidth;
          context.drawImage(imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth); // textures[i].image = canvas;
          // textures[i].needsUpdate = true;

          textures[i] = canvas;
        }

        if (onLoad) onLoad(textures);
      };

      imageObj.src = atlasImgUrl;
      return textures;
    }
    /**
     * 
     * @param {string[]} urls 
     * @param {string[]} names 
     * @param {({
     * positiveX:HTMLImageElement
     * negativeX:HTMLImageElement
     * positiveY:HTMLImageElement
     * negativeY:HTMLImageElement
     * positiveZ:HTMLImageElement
     * negativeZ:HTMLImageElement
     * })=>void} onLoad 
     * @param {(msg:string)=>void} onError 
     */

  }, {
    key: "getCubemapSources",
    value: function getCubemapSources(urls, names, onLoad, onError) {
      var images = urls;

      if (!images.length) {
        onError('未找到任何图片');
      } else {
        var props = ['positiveX', 'negativeX', 'positiveY', 'negativeY', 'positiveZ', 'negativeZ'];

        if (images.length == 1) {
          this.getTexturesFromAtlasFile(images[0], function (images) {
            if (images.length == 1) {
              var sources = {};
              props.forEach(function (prop, i) {
                sources[prop] = images[0];
              });
              onLoad(sources);
            } else if (images.length < 6) {
              onError('单张图片的宽度必须大于等于高度的6倍');
            } else {
              var _sources = {};
              images.forEach(function (img, i) {
                _sources[props[i]] = img;
              });
              onLoad(_sources);
            }
          });
        } else if (images.length < 6) {
          onError('图片数量必须等于6');
        } else {
          var sources = {};
          images.forEach(function (img, i) {
            var name = _Path["default"].ChangeExtension(names[i], '').toLowerCase();

            if (/(nx|negx)/.test(name)) {
              sources.negativeX = img;
            } else if (/(px|posx)/.test(name)) {
              sources.positiveX = img;
            } else if (/(ny|negy)/.test(name)) {
              sources.negativeY = img;
            } else if (/(py|posy)/.test(name)) {
              sources.positiveY = img;
            } else if (/(nz|negz)/.test(name)) {
              sources.negativeZ = img;
            } else if (/(pz|posz)/.test(name)) {
              sources.positiveZ = img;
            }
          });

          if (!sources.positiveX) {
            onError('找不到【左面】贴图，请确认包含命名为“px.<文件扩展名>”的图片');
            return;
          }

          if (!sources.negativeX) {
            onError('找不到【右面】贴图，请确认包含命名为“nx.<文件扩展名>”的图片');
            return;
          }

          if (!sources.negativeZ) {
            onError('找不到【前面】贴图，请确认包含命名为“nz.<文件扩展名>”的图片');
            return;
          }

          if (!sources.positiveZ) {
            onError('找不到【后面】贴图，请确认包含命名为“pz.<文件扩展名>”的图片');
            return;
          }

          if (!sources.positiveY) {
            onError('找不到【上面】贴图，请确认包含命名为“py.<文件扩展名>”的图片');
            return;
          }

          if (!sources.negativeY) {
            onError('找不到【下面】贴图，请确认包含命名为“ny.<文件扩展名>”的图片');
            return;
          }

          new _GenericWorker["default"](props.slice(), function (prop) {
            return new Promise(function (resolve, reject) {
              var img = new Image();
              img.crossOrigin = '';

              img.onload = function () {
                resolve(img);
              };

              img.onerror = reject;
              img.src = sources[prop];
            });
          }).run().then(function (images) {
            for (var i = 0; i < props.length; i++) {
              var prop = props[i],
                  img = images[i];
              sources[prop] = img;
            }

            onLoad(sources);
          });
        }
      }
    }
  }]);
  return ImageUtils;
}();

exports["default"] = ImageUtils;

},{"._953":189,"D_952":193,"e_1":235,"s_2":236,"M_0":241}],191:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

// var angleBetweenScratch = new Cartesian2(), angleBetweenScratch2 = new Cartesian2();
// const DEGREES_PER_RADIAN = 180.0 / Math.PI;
var MathUtils = /*#__PURE__*/function () {
  function MathUtils() {
    (0, _classCallCheck2["default"])(this, MathUtils);
  }

  (0, _createClass2["default"])(MathUtils, null, [{
    key: "add",
    value: function add(arg1, arg2) {
      var r1, r2, m;

      try {
        r1 = arg1.toString().split(".")[1].length;
        r2 = arg2.toString().split(".")[1].length;
      } catch (e) {
        r1 = 0;
        r2 = 0;
      }

      m = Math.pow(10, Math.max(r1, r2));
      return (arg1 * m + arg2 * m) / m;
    }
  }, {
    key: "sub",
    value: function sub(arg1, arg2) {
      return this.add(arg1, -arg2);
    }
  }, {
    key: "mul",
    value: function mul(arg1, arg2) {
      var r1, r2, m;

      try {
        //取小数位长度
        r1 = arg1.toString().split(".")[1].length;
        r2 = arg2.toString().split(".")[1].length;
      } catch (e) {
        r1 = 0;
        r2 = 0;
      }

      m = Math.pow(10, Math.max(r1, r2)); //计算因子

      return arg1 * m * (arg2 * m) / (m * m);
    }
  }, {
    key: "div",
    value: function div(arg1, arg2) {
      if (arg2 == 0) return 0;
      var t1 = 0,
          t2 = 0,
          r1,
          r2;

      try {
        t1 = arg1.toString().split(".")[1].length;
        t2 = arg2.toString().split(".")[1].length;
      } catch (e) {} // with (Math) {


      r1 = Number(arg1.toString().replace(".", ""));
      r2 = Number(arg2.toString().replace(".", "")); // }

      return r1 / r2 * Math.pow(10, t2 - t1);
    }
    /**
     * 
     * @param {number[]} arr 
     * @param {number} [offset=0]
     * @param {number} [stride=1]  
     * @returns {{min:number,max:number}} {min,max}
     */

  }, {
    key: "minmax",
    value: function minmax(arr, offset, stride) {
      offset = offset || 0;
      stride = stride || 1;
      var min = Number.MAX_VALUE,
          max = -Number.MAX_VALUE;

      for (var i = offset; i < arr.length; i += stride) {
        var v = arr[i];
        if (isNaN(v) || v == Infinity || v == -Infinity) continue;
        min = Math.min(min, v);
        max = Math.max(max, v);
      }

      return {
        min: min,
        max: max
      };
    }
    /**
     * 
     * @param {Cesium.Cartesian2} p1 
     * @param {Cesium.Cartesian2} p2 
     * @param {Cesium.Cartesian2} p3 
     * @param {Cesium.Cartesian2} p4 
     * @param {Cesium.Cartesian2} crossPoint 
     * @returns {number}
     * @example
     * p1    p3
     *   \   /
     *    \ /
     *  crossPoint
     *    / \
     *   /   \
     *  p4   p2
     * 
     */

  }, {
    key: "findCrossPoint",
    value: function findCrossPoint(p1, p2, p3, p4, crossPoint, onSegments) {
      //****************************************************************************************
      //  求二条直线的交点的公式
      //  有如下方程 (x-x1)/(y-y1) = (x2-x1)/(y2-y1) ==> a1*x+b1*y=c1
      //            (x-x3)/(y-y3) = (x4-x3)/(y4-y3) ==> a2*x+b2*y=c2
      //  则交点为
      //                x= | c1 b1|  / | a1 b1 |      y= | a1 c1| / | a1 b1 |
      //                   | c2 b2|  / | a2 b2 |         | a2 c2| / | a2 b2 |
      //
      //   a1= y2-y1
      //   b1= x1-x2
      //   c1= x1*y2-x2*y1
      //   a2= y4-y3
      //   b2= x3-x4
      //   c2= x3*y4-x4*y3
      // if (typeof Decimal != 'undefined') {
      //     var x1 = Decimal(p1.x), x2 = Decimal(p2.x), x3 = Decimal(p3.x), x4 = Decimal(p4.x);
      //     var y1 = Decimal(p1.y), y2 = Decimal(p2.y), y3 = Decimal(p3.y), y4 = Decimal(p4.y);
      //     var a1 = y2.sub(y1)
      //     var b1 = x1.sub(x2)
      //     var c1 = x1.mul(y2).sub(x2.mul(y1))
      //     var a2 = y4.sub(y3)
      //     var b2 = x3.sub(x4)
      //     var c2 = x3.mul(y4).sub(x4.mul(y3))
      //     var det = a1.mul(b2).sub(a2.mul(b1));
      //     if (det.equals(0)) {
      //         return 0;
      //     }
      //     var x = (c1.mul(b2).sub(c2.mul(b1))).div(det);
      //     var y = (a1.mul(c2).sub(a2.mul(c1))).div(det);
      //     crossPoint.x = x.toNumber();
      //     crossPoint.y = y.toNumber();
      //     if (!onSegments) {
      //         return det.toNumber();
      //     }
      //     // Now this is cross point of lines
      //     // Do we need the cross Point of segments(need to judge x,y within 4 endpoints)
      //     // 是否要判断线段相交 
      //     if ( x.sub( x1.add(x2).div(2.) ).abs().lessThanOrEqualTo( ( x2.sub(x1) ).abs().div(2.) ) &&
      //          y.sub( y1.add(y2).div(2.) ).abs().lessThanOrEqualTo( ( y2.sub(y1) ).abs().div(2.) ) &&
      //          x.sub( x3.add(x4).div(2.) ).abs().lessThanOrEqualTo( ( x4.sub(x3) ).abs().div(2.) ) &&
      //          y.sub( y3.add(y4).div(2.) ).abs().lessThanOrEqualTo( ( y4.sub(y3) ).abs().div(2.) )) {
      //         return det.toNumber();
      //     } else {
      //         return 0;
      //     }
      // } else {
      var x1 = p1.x,
          x2 = p2.x,
          x3 = p3.x,
          x4 = p4.x;
      var y1 = p1.y,
          y2 = p2.y,
          y3 = p3.y,
          y4 = p4.y;
      var a1 = y2 - y1;
      var b1 = x1 - x2;
      var c1 = x1 * y2 - x2 * y1;
      var a2 = y4 - y3;
      var b2 = x3 - x4;
      var c2 = x3 * y4 - x4 * y3;
      var det = a1 * b2 - a2 * b1;

      if (det == 0) {
        return det;
      }

      crossPoint.x = (c1 * b2 - c2 * b1) / det;
      crossPoint.y = (a1 * c2 - a2 * c1) / det;

      if (!onSegments) {
        return det;
      }

      var abs = Math.abs; // Now this is cross point of lines
      // Do we need the cross Point of segments(need to judge x,y within 4 endpoints)
      // 是否要判断线段相交 

      if (abs(crossPoint.x - (x1 + x2) / 2.) <= abs(x2 - x1) / 2. && abs(crossPoint.y - (y1 + y2) / 2.) <= abs(y2 - y1) / 2. && abs(crossPoint.x - (x3 + x4) / 2.) <= abs(x4 - x3) / 2. && abs(crossPoint.y - (y3 + y4) / 2.) <= abs(y4 - y3) / 2.) {
        return det;
      } else {
        return 0;
      } // }

    }
  }, {
    key: "getDigits",
    value: function getDigits(num) {
      var str = num.toString().split('.')[1];
      return str ? str.length : 0;
    }
  }, {
    key: "clampToLine",
    value: function clampToLine(q, p1, p2) {
      var Cartesian2 = Cesium.Cartesian2;
      var v1 = Cartesian2.subtract(q, p1, new Cartesian2());
      var v2 = Cartesian2.subtract(p2, p1, new Cartesian2());
      var det = v1.x * v2.y - v2.x * v1.y;
      if (Math.abs(det) < 1e-16) return q;
      var d = Cartesian2.magnitude(v1);
      var angle = Cartesian2.angleBetween(v1, v2);
      if (angle < 1e-16) return q; // d = Math.cos(angle) * d;

      Cartesian2.normalize(v2, v2);
      Cartesian2.multiplyByScalar(v2, d, v2);
      return Cartesian2.add(p1, v2, q);
    }
  }, {
    key: "distanceToSegment",
    value: function distanceToSegment(q, p1, p2) {
      var Cartesian2 = Cesium.Cartesian2,
          _Math = Cesium.Math;
      var v1 = Cartesian2.subtract(q, p1, new Cartesian2());
      var v2 = Cartesian2.subtract(p2, p1, new Cartesian2());
      var d = Cartesian2.magnitude(v1);
      if (Math.abs(d) <= 1e-16) return d;
      var angle = Cartesian2.angleBetween(v1, v2);
      d = Math.sin(angle) * d;
      return d;
    }
    /**
     * 
     * @param {{x:number,y:number}} a 
     * @param {{x:number,y:number}} b 
     * @param {{x:number,y:number}} c 
     * @returns {{x:number,y:number,r:number,r2:number}} {x:number,y:number,r:number,r2:number}
     */

  }, {
    key: "circumcircle",
    value: function circumcircle(a, b, c) {
      var A = b.x - a.x;
      var B = b.y - a.y;
      var C = c.x - a.x;
      var D = c.y - a.y;
      var E = A * (a.x + b.x) + B * (a.y + b.y);
      var F = C * (a.x + c.x) + D * (a.y + c.y);
      var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
      var dx;
      var dy; // If the points of the triangle are collinear, then just find the
      // extremes and use the midpoint as the center of the circumcircle.

      var x = (D * E - B * F) / G;
      var y = (A * F - C * E) / G;
      dx = x - a.x;
      dy = y - a.y;
      var r2 = dx * dx + dy * dy;
      var r = Math.sqrt(r2);
      return {
        x: x,
        y: y,
        r: r,
        r2: r2
      };
    }
    /**
     * 判断q点是否在p1,p2线段上（误差用qp1与p2q的夹角表示，默认误差为1度）
     * @param {{x:number,y:number}} q 
     * @param {{x:number,y:number}} p1 
     * @param {{x:number,y:number}} p2 
     * @param {number}[epsilon=1e-6]
     * @param {number}[epsilonAngle=1] in deg
     * @returns {boolean}
     */

  }, {
    key: "pointOnSegment",
    value: function pointOnSegment(q, p1, p2, epsilon, epsilonAngle) {
      var min = Math.min,
          max = Math.max,
          abs = Math.abs;
      epsilon = epsilon == undefined || epsilon == null ? 1e-8 : epsilon;
      epsilonAngle = epsilonAngle == undefined || epsilonAngle == null ? 1 : epsilonAngle;
      var minX = min(p1.x, p2.x),
          maxX = max(p1.x, p2.x);
      var minY = min(p1.y, p2.y),
          maxY = max(p1.y, p2.y); //保证Q点坐标在P1P2之间

      if (minX - epsilon <= q.x && q.x <= maxX + epsilon && minY - epsilon <= q.y && q.y <= maxY + epsilon) {
        //叉乘
        var Cartesian2 = Cesium.Cartesian2,
            _Math = Cesium.Math;
        var v1 = Cartesian2.subtract(q, p1, new Cartesian2());
        var v2 = Cartesian2.subtract(p2, p1, new Cartesian2());
        var a = v1.x * v2.y,
            b = v2.x * v1.y,
            delt = abs(a - b);
        if (delt < 1e-16) return true;
        var angle = Cartesian2.angleBetween(v1, v2);
        angle = _Math.toDegrees(angle);
        return angle <= epsilonAngle;
      }

      return false;
    }
    /**
     * 
     * @param {{x:number,y:number}} point 
     * @param {{x:number,y:number}[]} vs 
     * @returns {boolean}
     */

  }, {
    key: "pointInPolygon",
    value: function pointInPolygon(point, vs) {
      var l = vs.length;
      var x = point.x,
          y = point.y;
      var inside = false;

      for (var i = 0, j = l - 1; i < l; j = i++) {
        var xi = vs[i].x,
            yi = vs[i].y;
        var xj = vs[j].x,
            yj = vs[j].y;
        var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }

      return inside;
    }
  }, {
    key: "pointOnTriangle",
    value: function pointOnTriangle(p, p1, p2, p3) {
      var onTriangle = MathUtils.pointOnSegment(p, p1, p2);
      if (!onTriangle) return false;
      onTriangle = MathUtils.pointOnSegment(p, p1, p3);
      if (!onTriangle) return false;
      onTriangle = MathUtils.pointOnSegment(p, p2, p3);
      return onTriangle;
    }
  }]);
  return MathUtils;
}();

exports["default"] = MathUtils;

},{"e_1":235,"s_2":236,"M_0":241}],192:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeObjectValues = encodeObjectValues;
exports.encodeObject = encodeObject;
exports.decodeObject = decodeObject;
exports.encodeGeojsonCoords = encodeGeojsonCoords;
exports.decodeGeojsonCoords = decodeGeojsonCoords;
exports.encodeGeojson = encodeGeojson;
exports.decodeGeojson = decodeGeojson;
exports.decodeGeojsonCoordsAsync = decodeGeojsonCoordsAsync;
exports.decodeGeojsonAsync = decodeGeojsonAsync;

var _typeof2 = _interopRequireDefault(require("M_110"));

var _index = require("s_959");

var _GenericWorker = _interopRequireDefault(require("._953"));

var _isTypedArray = _interopRequireDefault(require("-_961"));

var _mergeBuffers = _interopRequireDefault(require("3_962"));

/* 
 提供一组对json对象进行编码和解码的方法，用于压缩json对象大小
*/
function storeString(str, strMap, strDic) {
  var code = strDic.length;

  if (strMap.has(str)) {
    code = strMap.get(str);
  } else {
    strMap.set(str, code);
    strDic.push(str);
  }

  return code;
}

function encodeObjectValues(obj, strMap, strDic) {
  for (var code in obj) {
    if (obj.hasOwnProperty(code)) {
      if (!Object.isExtensible(obj)) {
        debugger;
        continue;
      }

      var val = obj[code];
      var name = strDic[code];
      var newCode = strDic.length.toString();

      if (typeof val == 'string' && val.length > newCode.length || name == 'color' || name == 'matrix') {
        if (name == 'matrix') {
          val = val.join(',');
        }

        if (strMap.has(val)) {
          val = '$' + strMap.get(val);
        } else {
          val = '$' + storeString(val, strMap, strDic);
        }
      } else if (Array.isArray(val)) {
        for (var i = 0; i < val.length; i++) {
          var v = val[i];

          if ((0, _typeof2["default"])(v) == 'object') {
            encodeObjectValues(v, strMap, strDic);
          }
        }
      } else if ((0, _typeof2["default"])(val) == 'object') {
        encodeObjectValues(val, strMap, strDic);
      }

      obj[code] = val;
    }
  }
}

function encodeArrayTypeValue(arr, strMap, strDic) {
  for (var i = 0; i < arr.length; i++) {
    var v = arr[i];

    if (Array.isArray(v)) {
      if (typeof v[0] == 'number') continue;
      encodeArrayTypeValue(v, strMap, strDic);
    } else if ((0, _typeof2["default"])(v) == 'object') {
      encodeObject(v, strMap, strDic);
    }
  }
}

function decodeArrayTypeValue(arr, codeBook) {
  for (var i = 0; i < arr.length; i++) {
    var v = arr[i];

    if (Array.isArray(v)) {
      if (typeof v[0] == 'number') continue;
      decodeArrayTypeValue(v, codeBook);
    } else if ((0, _typeof2["default"])(v) == 'object') {
      decodeObject(v, codeBook);
    }
  }
}
/**
 * 
 * @param {object} obj  
 * @returns {object}
 */


function encodeObject(obj, strMap, strDic) {
  var release = false;

  if (!strMap) {
    strMap = new Map();
    strDic = [];
    release = true;
  }

  for (var name in obj) {
    if (obj.hasOwnProperty(name)) {
      var val = obj[name];

      if ((0, _isTypedArray["default"])(val)) {
        val = Array.from(val);
      } else if (Array.isArray(val)) {
        encodeArrayTypeValue(val, strMap, strDic);
      } else if ((0, _typeof2["default"])(val) == 'object') {
        encodeObject(val, strMap, strDic);
      } else if (name == 'type' || name == 'uuid') {
        val = storeString(val, strMap, strDic);
      }

      var code = storeString(name, strMap, strDic);
      obj[code] = val;
      delete obj[name];
    }
  }

  if (release) {
    encodeObjectValues(obj, strMap, strDic);
    obj.codeBook = strDic;
    strMap.clear();
  }

  return obj;
}

function decodeObject(obj, codeBook) {
  if (!codeBook) {
    codeBook = obj.codeBook;
    delete obj.codeBook;
  }

  for (var code in obj) {
    if (obj.hasOwnProperty(code)) {
      var val = obj[code];
      var name = codeBook[code];

      if (name == 'uuid' || name == 'type') {
        val = codeBook[val];
      } else if (typeof val == 'string' && val[0] == '$') {
        val = codeBook[val.slice(1)];

        if (name == 'matrix') {
          val = JSON.parse('[' + val + ']');
        } else if (Array.isArray(val)) {
          decodeArrayTypeValue(val, codeBook);
        } else if ((0, _typeof2["default"])(val) == 'object') {
          decodeObject(val, codeBook);
        }
      } else if (Array.isArray(val)) {
        decodeArrayTypeValue(val, codeBook);
      } else if ((0, _typeof2["default"])(val) == 'object') {
        decodeObject(val, codeBook);
      }

      obj[name || code] = val;
      if (name) delete obj[code];
    }
  }

  return obj;
}
/**
 * 
 * @param {Array} coordinates 
 * @param {ArrayBuffer} bufferList 
 */


function encodeGeojsonCoords(coordinates, bufferList) {
  if (typeof coordinates[0][0] == 'number') {
    if (bufferList.length == 0) {
      bufferList.byteLength = 0;
    }

    var count = coordinates.length,
        buffer = [];
    coordinates.forEach(function (coord) {
      buffer.push(coord[0], coord[1]);
    });
    buffer = new Float32Array(buffer).buffer;
    var byteLength = buffer.byteLength,
        byteOffset = bufferList.byteLength;
    bufferList.push(buffer);
    bufferList.byteLength += byteLength;
    return {
      byteOffset: byteOffset,
      count: count
    };
  } else {
    for (var i = 0; i < coordinates.length; i++) {
      coordinates[i] = encodeGeojsonCoords(coordinates[i], bufferList);
    }

    return coordinates;
  }
}
/**
 * 
 * @param {{byteOffset,count}[]} coordinates 
 * @param {Uint8Array|ArrayBuffer} buffer 
 */


function decodeGeojsonCoords(coordinates, buffer) {
  if (!coordinates) {
    debugger;
  }

  if (typeof coordinates.byteOffset == 'number') {
    var _coordinates = coordinates,
        byteOffset = _coordinates.byteOffset,
        count = _coordinates.count;
    var array = new Float32Array(buffer.buffer || buffer, byteOffset, count * 2);
    coordinates = [];

    for (var i = 0; i < array.length; i += 2) {
      coordinates.push([array[i], array[i + 1]]);
    }
  } else {
    for (var _i = 0; _i < coordinates.length; _i++) {
      coordinates[_i] = decodeGeojsonCoords(coordinates[_i], buffer);
    }
  }

  return coordinates;
}
/**
 * 
 * @param {geojson.Feature|geojson.FeatureCollection} geojson  
 */


function encodeGeojson(geojson) {
  console.time('encodeGeojsonCoords');
  var bufferList = [];

  if (geojson.type == 'FeatureCollection') {
    geojson.features.forEach(function (feature) {
      if (!feature.geometry) return;
      encodeGeojsonCoords(feature.geometry.coordinates, bufferList);
    });
  } else if (geojson.type == 'Feature') {
    if (geojson.geometry) {
      encodeGeojsonCoords(geojson.geometry.coordinates, bufferList);
    }
  }

  console.timeEnd('encodeGeojsonCoords');
  console.time('encodeObject');
  geojson = encodeObject(geojson);
  console.timeEnd('encodeObject');
  console.time('mergeBuffers');
  geojson.buffer = (0, _mergeBuffers["default"])(bufferList);
  console.timeEnd('mergeBuffers');
  console.time('fromByteArray');
  geojson.buffer = (0, _index.fromByteArray)(new Uint8Array(geojson.buffer));
  console.timeEnd('fromByteArray');
  return geojson;
}

function decodeGeojson(geojson) {
  console.time('decodeObject');

  if (geojson.codeBook) {
    var codeBook = geojson.codeBook;

    for (var code in geojson) {
      if (geojson.hasOwnProperty(code)) {
        var name = codeBook[code];

        if (name) {
          geojson[name] = geojson[code];
          delete geojson[code];
        }
      }
    }

    decodeObject(geojson);
  }

  console.timeEnd('decodeObject');
  var buffer = geojson.buffer;
  delete geojson.buffer;

  if (buffer) {
    console.time('toByteArray');
    buffer = (0, _index.toByteArray)(buffer);
    console.timeEnd('toByteArray');
    console.time('decodeGeojsonCoords');

    if (geojson.type == 'FeatureCollection') {
      var features = geojson.features;
      features.forEach(function (feature, id) {
        var geometry = feature.geometry;

        if (geometry) {
          geometry.coordinates = decodeGeojsonCoords(geometry.coordinates, buffer);
        }
      });
    } else if (geojson.type == 'Feature') {
      var geometry = geojson.geometry;

      if (geometry) {
        geometry.coordinates = decodeGeojsonCoords(geometry.coordinates, buffer);
      }
    }

    console.timeEnd('decodeGeojsonCoords');
    delete geojson.buffer;
  }

  return geojson;
}
/**
 * 
 * @param {geojson.Feature|geojson.FeatureCollection} geojson 
 * @param {(progress)=>void} onProress  
 */


function decodeGeojsonCoordsAsync(geojson, onProress, totalProgress) {
  totalProgress = totalProgress || 0;
  var buffer = geojson.buffer;
  delete geojson.buffer;
  console.time('toByteArray');
  buffer = (0, _index.toByteArray)(buffer);
  console.timeEnd('toByteArray');
  console.time('decodeGeojsonCoords');

  if (geojson.type == 'FeatureCollection') {
    var features = geojson.features;
    var batchList = [],
        batch = [],
        batchSize = features.length > 10000 ? features.length / 80 : features.length / 40;
    batchList.push(batch);
    features.forEach(function (feature, id) {
      var geometry = feature.geometry;
      if (!geometry) return;

      if (batch.length > batchSize) {
        batch = [];
        batchList.push(batch);
      }

      batch.push(feature);
    });
    return new _GenericWorker["default"](batchList, function (batch) {
      batch.forEach(function (feature) {
        var geometry = feature.geometry;
        geometry.coordinates = decodeGeojsonCoords(geometry.coordinates, buffer);
      });
    }).run(function (progress) {
      if (onProress) onProress(totalProgress + progress * 0.5);
    }).then(function () {
      console.timeEnd('decodeGeojsonCoords');
      totalProgress = 100;
      if (onProress) onProress(totalProgress);
      return geojson;
    });
  } else if (geojson.type == 'Feature') {
    var geometry = geojson.geometry;

    if (geometry) {
      geometry.coordinates = decodeGeojsonCoords(geometry.coordinates, buffer);
    }
  }

  console.timeEnd('decodeGeojsonCoords');
  return Promise.resolve(geojson);
}
/**
 * 
 * @param {geojson.Feature|geojson.FeatureCollection} geojson 
 * @param {(progress)=>void} onProress  
 */


function decodeGeojsonAsync(geojson, onProress) {
  if (geojson.codeBook) {
    console.time('decodeObject');
    var codeBook = geojson.codeBook;
    delete geojson.codeBook;

    for (var code in geojson) {
      if (geojson.hasOwnProperty(code)) {
        var name = codeBook[code],
            vCode = geojson[code],
            v = codeBook[vCode];
        if (typeof v != 'undefined') geojson[code] = v;

        if (name) {
          geojson[name] = geojson[code];
          delete geojson[code];
        }
      }
    }

    if (geojson.type == 'Feature') {
      decodeObject(geojson);
    } else {
      var features = geojson.features,
          batchList = [],
          batch = [],
          totalProgress = 0,
          batchSize = features.length > 10000 ? features.length / 80 : features.length / 40;
      batchList.push(batch);
      var geometryCode = codeBook.indexOf('geometry');
      features.forEach(function (feature, id) {
        var geometry = feature[geometryCode];

        if (geometry) {
          if (batch.length > batchSize) {
            batch = [];
            batchList.push(batch);
          }

          batch.push(feature);
        }
      });
      return new _GenericWorker["default"](batchList, function (batch) {
        batch.forEach(function (feature) {
          decodeObject(feature, codeBook);
        });
      }).run(function (progress) {
        totalProgress = progress * 0.5;
        if (onProress) onProress(totalProgress);
      }).then(function () {
        console.timeEnd('decodeObject');
        totalProgress = 50;
        if (onProress) onProress(totalProgress);
        return decodeGeojsonCoordsAsync(geojson, onProress, totalProgress);
      });
    }
  }

  if (geojson.buffer) return decodeGeojsonCoordsAsync(geojson);
  return Promise.resolve(geojson);
}

},{"s_959":218,"._953":189,"-_961":200,"3_962":203,"M_0":241,"M_110":245}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
*@class
*@memberof Cesium
*/
function Path() {}
/**
*
*获取文件扩展名（后缀）
*@param {String}fname 文件名
*/


Path.GetExtension = function (fname) {
  var start = fname.lastIndexOf(".");

  if (start >= 0) {
    return fname.substring(start, fname.length);
  }

  return "";
};
/**
*
*获取文件扩展名（后缀）
*@param {String}fname 文件名
*/


Path.GetFileName = function (fname) {
  var start = fname.lastIndexOf("/");

  if (start < 0) {
    start = fname.lastIndexOf("\\");
    if (start < 0) return fname;
  }

  return fname.substring(start + 1, fname.length);
};
/**
*
*获取文件夹
*@param {String}fname 文件名
*/


Path.GetDirectoryName = function (fname) {
  var start = fname.lastIndexOf("/");

  if (start < 0) {
    return "";
  }

  return fname.substring(0, start);
};
/**
*
*获取文件夹
*@param {String}fname 文件名
*/


Path.Combine = function (dir, fname) {
  return dir + fname;
};

Path.ChangeExtension = function (fname, newExt) {
  return fname.replace(Path.GetExtension(fname), newExt);
};

var _default = Path;
exports["default"] = _default;

},{}],194:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var StringUtil = /*#__PURE__*/function () {
  function StringUtil() {
    (0, _classCallCheck2["default"])(this, StringUtil);
  }

  (0, _createClass2["default"])(StringUtil, null, [{
    key: "trim",
    value:
    /**
     * 
     * @param {string} input
     * @param {string|RegExp}[pattern]
     * @returns  {string} 
     */
    function trim(input, pattern) {
      var output = "";
      var start = 0,
          end = input.length;
      pattern = pattern || '(\\s|\\t)+';
      pattern = new RegExp(pattern);

      while (pattern.test(input[start]) && start < input.length) {
        start++;
      }

      var ch = input[end - 1];

      while (pattern.test(ch) && end > 0) {
        end--;
        ch = input[end - 1];
      }

      output = input.substring(start, end);
      return output;
    }
  }, {
    key: "paddingStart",
    value: function paddingStart(num, length) {
      var sign = num >= 0 ? '+' : '-';
      num = Math.abs(num);
      num = num + "";
      var deltLen = length - num.length;
      var arr = new Array(deltLen).fill('0').join('');
      num = sign + arr + num;
      return num;
    }
  }]);
  return StringUtil;
}();

exports["default"] = StringUtil;

},{"e_1":235,"s_2":236,"M_0":241}],195:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = computeArea;

/**
 * 
 * @param {Cesium.Cartesian3} pa 
 * @param {Cesium.Cartesian3} pb 
 * @param {Cesium.Cartesian3} pc 
 * @returns {number}
 */
function computeArea(pa, pb, pc) {
  if (!pa || !pb || !pc) {
    console.warn(pa, pb, pc);
    return 0;
  }

  var Cartesian3 = Cesium.Cartesian3;
  var a = Cartesian3.distance(pa, pb);
  var b = Cartesian3.distance(pb, pc);
  var c = Cartesian3.distance(pa, pc);
  var p = (a + b + c) / 2,
      S = Math.sqrt(p * (p - a) * (p - b) * (p - c));
  return S;
}

},{}],196:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
*定义属性，并监听属性变化事件,属性值的数据类型可以实现equals接口用于进行更进一步的比较
*@param {Object}owner
*@param {String}name
*@param {Any}defaultVal
*@param {( changed: string, owner: object, newVal: any, oldVal: any )=> void } onChanged
*@private
*/
function _defineProperty(owner, name, defaultVal, onChanged) {
  var privateName = '_' + name;
  owner[privateName] = defaultVal;
  var value = {
    get: function get() {
      return this[privateName];
    },
    set: function set(val) {
      var changed = val != this[privateName];

      if (this[privateName] && this[privateName].equals && val) {
        changed = this[privateName].equals(val);
      }

      var oldVal = this[privateName];
      this[privateName] = val;

      if (typeof onChanged == 'function' && changed) {
        onChanged(changed, owner, val, oldVal);
      }
    }
  };
  var properties = {};
  properties[name] = value;
  Object.defineProperties(owner, properties);
}

var _default = _defineProperty;
exports["default"] = _default;

},{}],197:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = determinant;

//计算矩阵行列式
function determinant(matrix4) {
  var te = matrix4;
  var n11 = te[0],
      n12 = te[4],
      n13 = te[8],
      n14 = te[12];
  var n21 = te[1],
      n22 = te[5],
      n23 = te[9],
      n24 = te[13];
  var n31 = te[2],
      n32 = te[6],
      n33 = te[10],
      n34 = te[14];
  var n41 = te[3],
      n42 = te[7],
      n43 = te[11],
      n44 = te[15]; //TODO: make this more efficient
  //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
}

},{}],198:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = esExtends;

/**
 * 
 * @param {Function} superClass 
 * @param {{constructor:Function,prototype:object,esConstructor:Function}} extendOpts 
 */
function esExtends(superClass, extendOpts) {
  var ExtendedClass;
  var constructor = extendOpts.constructor,
      prototype = extendOpts.prototype,
      esConstructor = extendOpts.esConstructor;

  if (superClass.prototype.constructor.toString().startsWith('class')) {
    ExtendedClass = esConstructor(constructor);

    for (var key in prototype) {
      if (Object.hasOwnProperty.call(prototype, key)) {
        ExtendedClass.prototype[key] = prototype[key];
      }
    }
  } else {
    ExtendedClass = function $ExtendedClass() {
      superClass.apply(this, arguments);
      constructor.apply(this, arguments);
    };

    prototype.constructor = ExtendedClass;
    ExtendedClass.prototype = Object.assign(Object.create(superClass.prototype), prototype);
  }

  return ExtendedClass;
}

},{}],199:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var geojsonHelper = /*#__PURE__*/function () {
  function geojsonHelper() {
    (0, _classCallCheck2["default"])(this, geojsonHelper);
  }

  (0, _createClass2["default"])(geojsonHelper, null, [{
    key: "area",
    value: function area(contour) {
      var n = contour.length;
      var a = 0.0;

      for (var p = n - 1, q = 0; q < n; p = q++) {
        a += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
      }

      return a * 0.5;
    }
  }, {
    key: "isClockWise",
    value: function isClockWise(pts) {
      return geojsonHelper.area(pts) < 0;
    }
    /**
     * 
     * @param {geojson.Feature|geojson.FeatureCollection} geojson 
     * @param {(feature:geojson.Feature,featureId:number)=>vod} callback 
     */

  }, {
    key: "featureEach",
    value: function featureEach(geojson, callback) {
      if (geojson.type == 'Feature') {
        callback(geojson, 0);
      } else {
        geojson.features;

        for (var i = 0; i < geojson.features.length; i++) {
          var feature = geojson.features[i];
          callback(feature, i);
        }
      }
    }
    /**
     * 
     * @param {geojson.Feature|geojson.FeatureCollection|geojson.IPoint|geojson.Shape|geojson.MultiGeometry} geojson 
     * @param {(feature:geojson.Shape|geojson.IPoint,featureId:number,geometryId:number)=>vod} callback 
     */

  }, {
    key: "geometryEach",
    value: function geometryEach(geojson, callback) {
      var type = geojson.type;

      if (type == 'Feature' || type == 'FeatureCollection') {
        this.featureEach(geojson, function (feature, featureId) {
          var geometry = feature.geometry;
          var geomType = geometry.type;

          if (geomType == 'MultiGeometry') {
            geometry.geometry.forEach(function (geometry, geometryId) {
              callback(geometry, featureId, geometryId);
            });
          } else {
            callback(geometry, featureId, 0);
          }
        });
      } else {
        var geometry = geojson;
        var geomType = type;

        if (geomType == 'MultiGeometry') {
          geometry.geometry.forEach(function (geometry, geometryId) {
            callback(geometry, 0, geometryId);
          });
        } else {
          callback(geometry, 0, 0);
        }
      }
    }
    /**
     * 
     * @param {geojson.Feature|geojson.FeatureCollection|geojson.IPoint|geojson.Shape|geojson.MultiGeometry} geojson 
     * @param {(coordinate:number[])=>void} callback 
     */

  }, {
    key: "coordinateEach",
    value: function coordinateEach(geojson, callback) {
      this.geometryEach(geojson, function (geometry, featureId, geometryId) {
        var geomType = geometry.type;
        var coordinates = geometry.coordinates;

        if (geomType == 'LineString' || geomType == 'MultiPoint') {
          coordinates.forEach(callback);
        } else if (geomType == 'MultiLineString' || geomType == 'Polygon') {
          coordinates.forEach(function (line) {
            line.forEach(callback);
          });
        } else if (geomType == 'Point') {
          callback(coordinates);
        } else if (geomType == 'MultiPolygon') {
          coordinates.forEach(function (polygon) {
            polygon.forEach(function (contour) {
              contour.forEach(callback);
            });
          });
        }
      });
    }
    /**
     *  @param {geojson.Feature|geojson.FeatureCollection} geojson  
     */

  }, {
    key: "calcBBox",
    value: function calcBBox(geojson) {
      var _this = this;

      var globalBbox = [Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
      this.featureEach(geojson, function (feature) {
        if (!feature || !feature.geometry) return;
        var bbox = feature.geometry.bbox;

        if (bbox) {
          var nums = bbox.filter(function (n) {
            if (!isNaN(n)) return n;
          });
          if (nums.length == 0) return;
        }

        var min = [],
            max = [];

        _this.coordinateEach(feature, function (coordinate) {
          if (min.length > 0) {
            min[0] = Math.min(coordinate[0], min[0]);
            min[1] = Math.min(coordinate[1], min[1]);
            max[0] = Math.max(coordinate[0], max[0]);
            max[1] = Math.max(coordinate[1], max[1]);
          } else {
            min[0] = coordinate[0];
            min[1] = coordinate[1];
            max[0] = coordinate[0];
            max[1] = coordinate[1];
          }
        });

        feature.geometry.bbox = [min[0], min[1], max[0], max[1]];
        globalBbox[0] = Math.min(globalBbox[0], min[0]);
        globalBbox[1] = Math.min(globalBbox[1], min[1]);
        globalBbox[2] = Math.max(globalBbox[2], max[0]);
        globalBbox[3] = Math.max(globalBbox[3], max[1]);
      });
      return globalBbox;
    }
  }]);
  return geojsonHelper;
}();

exports["default"] = geojsonHelper;

},{"e_1":235,"s_2":236,"M_0":241}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isTypedArray;

function isTypedArray(obj) {
  return obj instanceof Float32Array || obj instanceof Float64Array || obj instanceof Int32Array || obj instanceof Uint32Array || obj instanceof Int16Array || obj instanceof Uint16Array || obj instanceof Int8Array || obj instanceof Uint8Array || obj instanceof Uint8ClampedArray;
}

},{}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function find_crossPoint(p1, p2, p3, p4, crossPoint) {
  //****************************************************************************************
  //  求二条直线的交点的公式
  //  有如下方程 (x-x1)/(y-y1) = (x2-x1)/(y2-y1) ==> a1*x+b1*y=c1
  //            (x-x3)/(y-y3) = (x4-x3)/(y4-y3) ==> a2*x+b2*y=c2
  //  则交点为
  //                x= | c1 b1|  / | a1 b1 |      y= | a1 c1| / | a1 b1 |
  //                   | c2 b2|  / | a2 b2 |         | a2 c2| / | a2 b2 |
  //
  //   a1= y2-y1
  //   b1= x1-x2
  //   c1= x1*y2-x2*y1
  //   a2= y4-y3
  //   b2= x3-x4
  //   c2= x3*y4-x4*y3
  var a1 = p2.y - p1.y;
  var b1 = p1.x - p2.x;
  var c1 = p1.x * p2.y - p2.x * p1.y;
  var a2 = p4.y - p3.y;
  var b2 = p3.x - p4.x;
  var c2 = p3.x * p4.y - p4.x * p3.y;
  var det = a1 * b2 - a2 * b1;
  if (det == 0) return det;
  crossPoint.x = (c1 * b2 - c2 * b1) / det;
  crossPoint.y = (a1 * c2 - a2 * c1) / det; // var abs = Math.abs
  // Now this is cross point of lines
  // Do we need the cross Point of segments(need to judge x,y within 4 endpoints)
  // 是否要判断线段相交
  // if ((abs(crossPoint.x - (p1.x + p2.x) / 2) <= abs(p2.x - p1.x) / 2) &&
  //     (abs(crossPoint.y - (p1.y + p2.y) / 2) <= abs(p2.y - p1.y) / 2) &&
  //     (abs(crossPoint.x - (p3.x + p4.x) / 2) <= abs(p4.x - p3.x) / 2) &&
  //     (abs(crossPoint.y - (p3.y + p4.y) / 2) <= abs(p4.y - p3.y) / 2)) {
  //     return true;
  // }

  return det;
}
/**
 * 
 * @param {THREE.Vector2} p1 
 * @param {THREE.Vector2} p2 
 */


function rotate90(p1, p2) {
  if (!p1 || !p2) debugger;
  var dir = new THREE.Vector2().copy(p1).sub(p2).normalize();
  dir = new THREE.Vector2(-dir.y, dir.x); //旋转90度

  return dir;
}

function find_corner_dir(pt, prevPt, nextPt, lineW) {
  var dir1 = rotate90(prevPt, pt);
  var dir2 = rotate90(pt, nextPt);
  dir1.multiplyScalar(lineW);
  dir2.multiplyScalar(lineW);
  var pt1 = new THREE.Vector2().copy(dir1).add(pt);
  var pt2 = new THREE.Vector2().copy(dir2).add(pt);
  var prevPt1 = new THREE.Vector2().copy(dir1).add(prevPt);
  var nextPt2 = new THREE.Vector2().copy(dir2).add(nextPt);
  var crossPt = new THREE.Vector2();
  var det = find_crossPoint(prevPt1, pt1, pt2, nextPt2, crossPt);

  if (!det) {
    var dir = rotate90(prevPt, pt);
    return dir.multiplyScalar(lineW);
  }

  var dir = crossPt.sub(pt);

  if (checkDir(dir, lineW)) {
    dir = rotate90(prevPt, pt);
    return dir.multiplyScalar(lineW);
  }

  return dir;
}
/**
 * 
 * @param {THREE.Vector2} dir 
 * @param {number} lineWidth 
 */


function checkDir(dir, lineWidth) {
  dir = new THREE.Vector2().copy(dir).divideScalar(lineWidth);
  var m = dir.length();
  return m > lineWidth * 2;
}
/**
 * 
 * @param {Vector2} pt 
 * @param {Vector2} prevPt 
 * @param {Vector2} nextPt 
 */


function lineBufferDir3(pt, prevPt, nextPt, lineWidth) {
  var centerDir;

  if (!nextPt) {
    centerDir = rotate90(prevPt, pt);
    centerDir.multiplyScalar(lineWidth);
    return centerDir;
  } else if (!prevPt) {
    centerDir = rotate90(nextPt, pt);
    centerDir.multiplyScalar(lineWidth);
    return centerDir;
  } else {
    centerDir = find_corner_dir(pt, prevPt, nextPt, lineWidth);
    return centerDir;
  }
}

var _default = lineBufferDir3;
exports["default"] = _default;

},{}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = matrix4LookAt;
exports.matrix4LookDirection = matrix4LookDirection;

var _z, _x, _y, _m1, _m2;

var defaultUp = {
  x: 0,
  y: 0,
  z: 1
};
/**
 * 
 * @param {Cesium.Cartesian3} eye 
 * @param {Cesium.Cartesian3} target 
 * @param {Cesium.Cartesian3} [up] 
 * @param {Cesium.Matrix4} [result] 
 */

function matrix4LookAt(eye, target, up, result) {
  if (!result) result = new Cesium.Matrix4();
  up = up || defaultUp;
  var Cartesian3 = Cesium.Cartesian3;
  if (!_x) _x = new Cartesian3();
  if (!_y) _y = new Cartesian3();
  if (!_z) _z = new Cartesian3();
  Cartesian3.subtract(target, eye, _z); // _z.subVectors(eye, target);

  Cartesian3.normalize(_z, _z); //_z.normalize();

  return matrix4LookDirection(_z, up, result);
}
/**
 *  
 * @param {Cesium.Cartesian3} dir 
 * @param {Cesium.Cartesian3} [up] 
 * @param {Cesium.Matrix4} [result] 
 */


function matrix4LookDirection(dir, up, result) {
  if (!result) result = new Cesium.Matrix4();
  up = up || defaultUp;
  var te = result;
  var Cartesian3 = Cesium.Cartesian3;
  if (!_x) _x = new Cartesian3();
  if (!_y) _y = new Cartesian3(); // if (!_z) _z = new Cartesian3();

  if (dir != _z) _z = Cartesian3.clone(dir); // Cartesian3.subtract(target, eye, _z);// _z.subVectors(eye, target);

  if (Cartesian3.magnitudeSquared(_z) === 0) {
    //_z.lengthSq() === 0) {
    // eye and target are in the same position
    _z.z = 1;
  }

  Cartesian3.cross(up, _z, _x); //_x.crossVectors(up, _z);

  if (Cartesian3.magnitudeSquared(_x) === 0) {
    //_x.lengthSq() === 0) {
    // up and z are parallel
    if (Math.abs(up.z) === 1) {
      _z.x += 0.0001;
    } else {
      _z.z += 0.0001;
    }

    Cartesian3.normalize(_z, _z); // _z.normalize();

    Cartesian3.cross(up, _z, _x); //_x.crossVectors(up, _z);
  }

  Cartesian3.normalize(_x, _x); //_x.normalize();

  Cartesian3.cross(_z, _x, _y); //_y.crossVectors(_z, _x);

  te[0] = _x.x;
  te[4] = _y.x;
  te[8] = _z.x;
  te[1] = _x.y;
  te[5] = _y.y;
  te[9] = _z.y;
  te[2] = _x.z;
  te[6] = _y.z;
  te[10] = _z.z;
  return te;
}

},{}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = mergeBuffers;

/**
 * 
 * @param {Array<Uint8Array|DataView|ArrayBuffer>} buffers 
 * @returns {ArrayBuffer}
 */
function mergeBuffers(buffers) {
  buffers = buffers.map(function (buffer) {
    if (buffer instanceof DataView || buffer instanceof Uint8Array) {
      return buffer.buffer;
    }

    return buffer;
  });
  var totalByteLength = 0;
  buffers.forEach(function (buffer) {
    return totalByteLength += buffer.byteLength;
  });
  var mergedBuffer = new Uint8Array(totalByteLength);
  var byteOffset = 0;
  buffers.forEach(function (buffer) {
    mergedBuffer.set(new Uint8Array(buffer), byteOffset);
    byteOffset += buffer.byteLength;
  });
  return mergedBuffer.buffer;
}

},{}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = parseDefines;

function parseDefines(shader) {
  var defines = [];

  for (var key in shader.defines) {
    if (shader.defines.hasOwnProperty(key)) {
      var val = shader.defines[key];
      defines.push('#define ' + key + ' ' + val);
    }
  }

  defines = defines.join('\n') + "\n";

  if (shader.fragmentShader) {
    shader.fragmentShader = defines + shader.fragmentShader;
  }

  if (shader.vertexShader) {
    shader.vertexShader = defines + shader.vertexShader;
  }

  return shader;
}

},{}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveString = saveString;
exports.saveArrayBuffer = saveArrayBuffer;
var link;

function init$Saver() {
  if (link) return;
  link = document.createElement('a');
  link.style.display = 'none';
  document.body.appendChild(link); // Firefox workaround, see #6594
}

function save(blob, filename) {
  init$Saver();
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click(); // URL.revokeObjectURL( url ); breaks Firefox...
}

function saveString(text, filename) {
  save(new Blob([text], {
    type: 'text/plain'
  }), filename);
}

function saveArrayBuffer(buffer, filename) {
  save(new Blob([buffer], {
    type: 'application/octet-stream'
  }), filename);
}

},{}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = stringToArrayBuffer;

/**
 * Converts a string to an ArrayBuffer.
 * @param  {string} text
 * @return {ArrayBuffer}
 */
function stringToArrayBuffer(text) {
  if (typeof TextEncoder !== 'undefined') {
    return new TextEncoder().encode(text).buffer;
  }

  var array = new Uint8Array(new ArrayBuffer(text.length));

  for (var i = 0, il = text.length; i < il; i++) {
    var value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).

    array[i] = value > 0xFF ? 0x20 : value;
  }

  return array.buffer;
}

},{}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = traverse;

function traverse(node, callback, parent) {
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      traverse(child, callback, node);
    }
  } else {
    callback(node, parent);
    var children = node.children;
    if (!children) return;
    var l = children.length;

    for (var _i = 0; _i < l; _i++) {
      var _child = children[_i];
      traverse(_child, callback, node);
    }
  }
}

},{}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var triangulate = function () {
  //src:http://turfjs.org/docs/#tin
  var Triangle = function () {
    function Triangle(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      var A = b.x - a.x;
      var B = b.y - a.y;
      var C = c.x - a.x;
      var D = c.y - a.y;
      var E = A * (a.x + b.x) + B * (a.y + b.y);
      var F = C * (a.x + c.x) + D * (a.y + c.y);
      var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
      var dx;
      var dy; // If the points of the triangle are collinear, then just find the
      // extremes and use the midpoint as the center of the circumcircle.

      this.x = (D * E - B * F) / G;
      this.y = (A * F - C * E) / G;
      dx = this.x - a.x;
      dy = this.y - a.y;
      this.r = dx * dx + dy * dy;
    }

    return Triangle;
  }();

  function byX(a, b) {
    return b.x - a.x;
  }

  function dedup(edges) {
    var j = edges.length;
    var a;
    var b;
    var i;
    var m;
    var n;

    outer: while (j) {
      b = edges[--j];
      a = edges[--j];
      i = j;

      while (i) {
        n = edges[--i];
        m = edges[--i];

        if (a === m && b === n || a === n && b === m) {
          edges.splice(j, 2);
          edges.splice(i, 2);
          j -= 2;
          continue outer;
        }
      }
    }
  }
  /**
   * 
   * @param {(Cesium.Cartesian2|THREE.Vector2)[]} vertices 
   */


  function triangulate(vertices) {
    // Bail if there aren't enough vertices to form any triangles.
    if (vertices.length < 3) {
      return [];
    } // Ensure the vertex array is in order of descending X coordinate
    // (which is needed to ensure a subquadratic runtime), and then find
    // the bounding box around the points.


    vertices.sort(byX);
    var i = vertices.length - 1;
    var xmin = vertices[i].x;
    var xmax = vertices[0].x;
    var ymin = vertices[i].y;
    var ymax = ymin;
    var epsilon = 1e-12;
    var a;
    var b;
    var c;
    var A;
    var B;
    var G;

    while (i--) {
      if (vertices[i].y < ymin) {
        ymin = vertices[i].y;
      }

      if (vertices[i].y > ymax) {
        ymax = vertices[i].y;
      }
    } // Find a supertriangle, which is a triangle that surrounds all the
    // vertices. This is used like something of a sentinel value to remove
    // cases in the main algorithm, and is removed before we return any
    // results.
    // Once found, put it in the "open" list. (The "open" list is for
    // triangles who may still need to be considered; the "closed" list is
    // for triangles which do not.)


    var dx = xmax - xmin;
    var dy = ymax - ymin;
    var dmax = dx > dy ? dx : dy;
    var xmid = (xmax + xmin) * 0.5;
    var ymid = (ymax + ymin) * 0.5;
    var open = [new Triangle({
      __sentinel: true,
      x: xmid - 20 * dmax,
      y: ymid - dmax
    }, {
      __sentinel: true,
      x: xmid,
      y: ymid + 20 * dmax
    }, {
      __sentinel: true,
      x: xmid + 20 * dmax,
      y: ymid - dmax
    })];
    var closed = [];
    var edges = [];
    var j; // Incrementally add each vertex to the mesh.

    i = vertices.length;

    while (i--) {
      // For each open triangle, check to see if the current point is
      // inside it's circumcircle. If it is, remove the triangle and add
      // it's edges to an edge list.
      edges.length = 0;
      j = open.length;

      while (j--) {
        // If this point is to the right of this triangle's circumcircle,
        // then this triangle should never get checked again. Remove it
        // from the open list, add it to the closed list, and skip.
        dx = vertices[i].x - open[j].x;

        if (dx > 0 && dx * dx > open[j].r) {
          closed.push(open[j]);
          open.splice(j, 1);
          continue;
        } // If not, skip this triangle.


        dy = vertices[i].y - open[j].y;

        if (dx * dx + dy * dy > open[j].r) {
          continue;
        } // Remove the triangle and add it's edges to the edge list.


        edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
        open.splice(j, 1);
      } // Remove any doubled edges.


      dedup(edges); // Add a new triangle for each edge.

      j = edges.length;

      while (j) {
        b = edges[--j];
        a = edges[--j];
        c = vertices[i]; // Avoid adding colinear triangles (which have error-prone
        // circumcircles)

        A = b.x - a.x;
        B = b.y - a.y;
        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));

        if (Math.abs(G) > epsilon) {
          open.push(new Triangle(a, b, c));
        }
      }
    } // Copy any remaining open triangles to the closed list, and then
    // remove any triangles that share a vertex with the supertriangle.


    Array.prototype.push.apply(closed, open);
    i = closed.length;

    while (i--) {
      if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
        closed.splice(i, 1);
      }
    }

    return closed;
  }

  return triangulate;
}();

var _default = triangulate;
exports["default"] = _default;

},{}],209:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "computeArea", {
  enumerable: true,
  get: function get() {
    return _computeArea["default"];
  }
});
Object.defineProperty(exports, "defineProperty", {
  enumerable: true,
  get: function get() {
    return _defineProperty["default"];
  }
});
Object.defineProperty(exports, "determinant", {
  enumerable: true,
  get: function get() {
    return _determinant["default"];
  }
});
Object.defineProperty(exports, "esExtends", {
  enumerable: true,
  get: function get() {
    return _esExtends["default"];
  }
});
Object.defineProperty(exports, "GenericWorker", {
  enumerable: true,
  get: function get() {
    return _GenericWorker["default"];
  }
});
Object.defineProperty(exports, "geojsonHelper", {
  enumerable: true,
  get: function get() {
    return _geojsonHelper["default"];
  }
});
Object.defineProperty(exports, "ImageUtils", {
  enumerable: true,
  get: function get() {
    return _ImageUtils["default"];
  }
});
Object.defineProperty(exports, "isTypedArray", {
  enumerable: true,
  get: function get() {
    return _isTypedArray["default"];
  }
});
Object.defineProperty(exports, "lineBufferDir3", {
  enumerable: true,
  get: function get() {
    return _lineBufferDir["default"];
  }
});
Object.defineProperty(exports, "MathUtils", {
  enumerable: true,
  get: function get() {
    return _MathUtils["default"];
  }
});
Object.defineProperty(exports, "matrix4LookAt", {
  enumerable: true,
  get: function get() {
    return _matrix4LookAt["default"];
  }
});
Object.defineProperty(exports, "mergeBuffers", {
  enumerable: true,
  get: function get() {
    return _mergeBuffers["default"];
  }
});
Object.defineProperty(exports, "decodeGeojson", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.decodeGeojson;
  }
});
Object.defineProperty(exports, "decodeGeojsonAsync", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.decodeGeojsonAsync;
  }
});
Object.defineProperty(exports, "decodeGeojsonCoords", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.decodeGeojsonCoords;
  }
});
Object.defineProperty(exports, "decodeGeojsonCoordsAsync", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.decodeGeojsonCoordsAsync;
  }
});
Object.defineProperty(exports, "decodeObject", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.decodeObject;
  }
});
Object.defineProperty(exports, "encodeGeojson", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.encodeGeojson;
  }
});
Object.defineProperty(exports, "encodeGeojsonCoords", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.encodeGeojsonCoords;
  }
});
Object.defineProperty(exports, "encodeObject", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.encodeObject;
  }
});
Object.defineProperty(exports, "encodeObjectValues", {
  enumerable: true,
  get: function get() {
    return _ObjectUtil.encodeObjectValues;
  }
});
Object.defineProperty(exports, "parseDefines", {
  enumerable: true,
  get: function get() {
    return _parseDefines["default"];
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _Path["default"];
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function get() {
    return _saver.save;
  }
});
Object.defineProperty(exports, "saveArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _saver.saveArrayBuffer;
  }
});
Object.defineProperty(exports, "saveString", {
  enumerable: true,
  get: function get() {
    return _saver.saveString;
  }
});
Object.defineProperty(exports, "stringToArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _stringToArrayBuffer["default"];
  }
});
Object.defineProperty(exports, "StringUtil", {
  enumerable: true,
  get: function get() {
    return _StringUtil["default"];
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function get() {
    return _traverse["default"];
  }
});
Object.defineProperty(exports, "triangulate", {
  enumerable: true,
  get: function get() {
    return _triangulate["default"];
  }
});
Object.defineProperty(exports, "getPaddedBuffer", {
  enumerable: true,
  get: function get() {
    return _BufferUtlils.getPaddedBuffer;
  }
});
Object.defineProperty(exports, "getPaddedBufferSize", {
  enumerable: true,
  get: function get() {
    return _BufferUtlils.getPaddedBufferSize;
  }
});

var _computeArea = _interopRequireDefault(require("s_970"));

var _defineProperty = _interopRequireDefault(require("h_971"));

var _determinant = _interopRequireDefault(require("-_972"));

var _esExtends = _interopRequireDefault(require("3_973"));

var _GenericWorker = _interopRequireDefault(require("D_974"));

var _geojsonHelper = _interopRequireDefault(require("._975"));

var _ImageUtils = _interopRequireDefault(require("C_976"));

var _isTypedArray = _interopRequireDefault(require("o_977"));

var _lineBufferDir = _interopRequireDefault(require("m_978"));

var _MathUtils = _interopRequireDefault(require("M_979"));

var _matrix4LookAt = _interopRequireDefault(require("e_980"));

var _mergeBuffers = _interopRequireDefault(require("s_981"));

var _ObjectUtil = require("h_982");

var _parseDefines = _interopRequireDefault(require("-_983"));

var _Path = _interopRequireDefault(require("3_984"));

var _saver = require("D_985");

var _stringToArrayBuffer = _interopRequireDefault(require("._986"));

var _StringUtil = _interopRequireDefault(require("C_987"));

var _traverse = _interopRequireDefault(require("o_988"));

var _triangulate = _interopRequireDefault(require("m_989"));

var _BufferUtlils = require("M_990");

},{"M_990":188,"D_974":189,"C_976":190,"M_979":191,"h_982":192,"3_984":193,"C_987":194,"s_970":195,"h_971":196,"-_972":197,"3_973":198,"._975":199,"o_977":200,"m_978":201,"e_980":202,"s_981":203,"-_983":204,"D_985":205,"._986":206,"o_988":207,"m_989":208,"M_0":241}],210:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = along;

var _index = _interopRequireDefault(require("s_992"));

var _index2 = _interopRequireDefault(require("h_993"));

var _index3 = _interopRequireDefault(require("-_994"));

var _index4 = require("3_995");

var _index5 = require("D_996");

/**
 * Takes a {@link LineString} and returns a {@link Point} at a specified distance along the line.
 *
 * @name along
 * @param {Feature<LineString>} line input line
 * @param {number} distance distance along the line
 * @param {Object} [options] Optional parameters
 * @param {string} [options.units="kilometers"] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Point>} Point `distance` `units` along the line
 * @example
 * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);
 * var options = {units: 'miles'};
 *
 * var along = turf.along(line, 200, options);
 *
 * //addToMap
 * var addToMap = [along, line]
 */
function along(line, distance, options) {
  if (options === void 0) {
    options = {};
  } // Get Coords


  var geom = (0, _index5.getGeom)(line);
  var coords = geom.coordinates;
  var travelled = 0;

  for (var i = 0; i < coords.length; i++) {
    if (distance >= travelled && i === coords.length - 1) {
      break;
    } else if (travelled >= distance) {
      var overshot = distance - travelled;

      if (!overshot) {
        return (0, _index4.point)(coords[i]);
      } else {
        var direction = (0, _index["default"])(coords[i], coords[i - 1]) - 180;
        var interpolated = (0, _index2["default"])(coords[i], overshot, direction, options);
        return interpolated;
      }
    } else {
      travelled += (0, _index3["default"])(coords[i], coords[i + 1], options);
    }
  }

  return (0, _index4.point)(coords[coords.length - 1]);
}

},{"s_992":211,"h_993":212,"-_994":213,"3_995":214,"D_996":215,"M_0":241}],211:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = bearing;

var _index = require("3_995");

var _index2 = require("D_996");

// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes two {@link Point|points} and finds the geographic bearing between them,
 * i.e. the angle measured in degrees from the north line (0 degrees)
 *
 * @name bearing
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.final=false] calculates the final bearing if true
 * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
 * @example
 * var point1 = turf.point([-75.343, 39.984]);
 * var point2 = turf.point([-75.534, 39.123]);
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2]
 * point1.properties['marker-color'] = '#f00'
 * point2.properties['marker-color'] = '#0f0'
 * point1.properties.bearing = bearing
 */
function bearing(start, end, options) {
  if (options === void 0) {
    options = {};
  } // Reverse calculation


  if (options["final"] === true) {
    return calculateFinalBearing(start, end);
  }

  var coordinates1 = (0, _index2.getCoord)(start);
  var coordinates2 = (0, _index2.getCoord)(end);
  var lon1 = (0, _index.degreesToRadians)(coordinates1[0]);
  var lon2 = (0, _index.degreesToRadians)(coordinates2[0]);
  var lat1 = (0, _index.degreesToRadians)(coordinates1[1]);
  var lat2 = (0, _index.degreesToRadians)(coordinates2[1]);
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return (0, _index.radiansToDegrees)(Math.atan2(a, b));
}
/**
 * Calculates Final Bearing
 *
 * @private
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @returns {number} bearing
 */


function calculateFinalBearing(start, end) {
  // Swap start & end
  var bear = bearing(end, start);
  bear = (bear + 180) % 360;
  return bear;
}

},{"3_995":214,"D_996":215}],212:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = destination;

var _index = require("3_995");

var _index2 = require("D_996");

// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in
 * degrees, radians, miles, or kilometers; and bearing in degrees.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] Translate properties to Point
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.destination(point, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */
function destination(origin, distance, bearing, options) {
  if (options === void 0) {
    options = {};
  } // Handle input


  var coordinates1 = (0, _index2.getCoord)(origin);
  var longitude1 = (0, _index.degreesToRadians)(coordinates1[0]);
  var latitude1 = (0, _index.degreesToRadians)(coordinates1[1]);
  var bearingRad = (0, _index.degreesToRadians)(bearing);
  var radians = (0, _index.lengthToRadians)(distance, options.units); // Main

  var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
  var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
  var lng = (0, _index.radiansToDegrees)(longitude2);
  var lat = (0, _index.radiansToDegrees)(latitude2);
  return (0, _index.point)([lng, lat], options.properties);
}

},{"3_995":214,"D_996":215}],213:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("D_996");

var _index2 = require("3_995");

//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord | Point} from origin point or coordinate
 * @param {Coord | Point} to destination point or coordinate
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
function distance(from, to, options) {
  if (options === void 0) {
    options = {};
  }

  var coordinates1 = (0, _index.getCoord)(from);
  var coordinates2 = (0, _index.getCoord)(to);
  var dLat = (0, _index2.degreesToRadians)(coordinates2[1] - coordinates1[1]);
  var dLon = (0, _index2.degreesToRadians)(coordinates2[0] - coordinates1[0]);
  var lat1 = (0, _index2.degreesToRadians)(coordinates1[1]);
  var lat2 = (0, _index2.degreesToRadians)(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return (0, _index2.radiansToLength)(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}

var _default = distance;
exports["default"] = _default;

},{"3_995":214,"D_996":215}],214:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.feature = feature;
exports.geometry = geometry;
exports.point = point;
exports.points = points;
exports.polygon = polygon;
exports.polygons = polygons;
exports.lineString = lineString;
exports.lineStrings = lineStrings;
exports.featureCollection = featureCollection;
exports.multiLineString = multiLineString;
exports.multiPoint = multiPoint;
exports.multiPolygon = multiPolygon;
exports.geometryCollection = geometryCollection;
exports.round = round;
exports.radiansToLength = radiansToLength;
exports.lengthToRadians = lengthToRadians;
exports.lengthToDegrees = lengthToDegrees;
exports.bearingToAzimuth = bearingToAzimuth;
exports.radiansToDegrees = radiansToDegrees;
exports.degreesToRadians = degreesToRadians;
exports.convertLength = convertLength;
exports.convertArea = convertArea;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.validateBBox = validateBBox;
exports.validateId = validateId;
exports.areaFactors = exports.unitsFactors = exports.factors = exports.earthRadius = void 0;

var _typeof2 = _interopRequireDefault(require("M_110"));

/**
 * @module helpers
 */

/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
var earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */

exports.earthRadius = earthRadius;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1000,
  kilometres: earthRadius / 1000,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1000,
  millimetres: earthRadius * 1000,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */

exports.factors = factors;
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1000,
  kilometres: 1 / 1000,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1000,
  millimetres: 1000,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */

exports.unitsFactors = unitsFactors;
var areaFactors = {
  acres: 0.000247105,
  centimeters: 10000,
  centimetres: 10000,
  feet: 10.763910417,
  hectares: 0.0001,
  inches: 1550.003100006,
  kilometers: 0.000001,
  kilometres: 0.000001,
  meters: 1,
  metres: 1,
  miles: 3.86e-7,
  millimeters: 1000000,
  millimetres: 1000000,
  yards: 1.195990046
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */

exports.areaFactors = areaFactors;

function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var feat = {
    type: "Feature"
  };

  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }

  if (options.bbox) {
    feat.bbox = options.bbox;
  }

  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */


function geometry(type, coordinates, _options) {
  if (_options === void 0) {
    _options = {};
  }

  switch (type) {
    case "Point":
      return point(coordinates).geometry;

    case "LineString":
      return lineString(coordinates).geometry;

    case "Polygon":
      return polygon(coordinates).geometry;

    case "MultiPoint":
      return multiPoint(coordinates).geometry;

    case "MultiLineString":
      return multiLineString(coordinates).geometry;

    case "MultiPolygon":
      return multiPolygon(coordinates).geometry;

    default:
      throw new Error(type + " is invalid");
  }
}
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */


function point(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  if (!coordinates) {
    throw new Error("coordinates is required");
  }

  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }

  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }

  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }

  var geom = {
    type: "Point",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */


function points(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return point(coords, properties);
  }), options);
}
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */


function polygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
    var ring = coordinates_1[_i];

    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }

    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      // Check if first point of Polygon contains two numbers
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }

  var geom = {
    type: "Polygon",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */


function polygons(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return polygon(coords, properties);
  }), options);
}
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */


function lineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }

  var geom = {
    type: "LineString",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */


function lineStrings(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  return featureCollection(coordinates.map(function (coords) {
    return lineString(coords, properties);
  }), options);
}
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */


function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }

  var fc = {
    type: "FeatureCollection"
  };

  if (options.id) {
    fc.id = options.id;
  }

  if (options.bbox) {
    fc.bbox = options.bbox;
  }

  fc.features = features;
  return fc;
}
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */


function multiLineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiLineString",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */


function multiPoint(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiPoint",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */


function multiPolygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "MultiPolygon",
    coordinates: coordinates
  };
  return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */


function geometryCollection(geometries, properties, options) {
  if (options === void 0) {
    options = {};
  }

  var geom = {
    type: "GeometryCollection",
    geometries: geometries
  };
  return feature(geom, properties, options);
}
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */


function round(num, precision) {
  if (precision === void 0) {
    precision = 0;
  }

  if (precision && !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }

  var multiplier = Math.pow(10, precision || 0);
  return Math.round(num * multiplier) / multiplier;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */


function radiansToLength(radians, units) {
  if (units === void 0) {
    units = "kilometers";
  }

  var factor = factors[units];

  if (!factor) {
    throw new Error(units + " units is invalid");
  }

  return radians * factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */


function lengthToRadians(distance, units) {
  if (units === void 0) {
    units = "kilometers";
  }

  var factor = factors[units];

  if (!factor) {
    throw new Error(units + " units is invalid");
  }

  return distance / factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */


function lengthToDegrees(distance, units) {
  return radiansToDegrees(lengthToRadians(distance, units));
}
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */


function bearingToAzimuth(bearing) {
  var angle = bearing % 360;

  if (angle < 0) {
    angle += 360;
  }

  return angle;
}
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */


function radiansToDegrees(radians) {
  var degrees = radians % (2 * Math.PI);
  return degrees * 180 / Math.PI;
}
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */


function degreesToRadians(degrees) {
  var radians = degrees % 360;
  return radians * Math.PI / 180;
}
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */


function convertLength(length, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "kilometers";
  }

  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }

  if (!(length >= 0)) {
    throw new Error("length must be a positive number");
  }

  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted area
 */


function convertArea(area, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "meters";
  }

  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }

  if (!(area >= 0)) {
    throw new Error("area must be a positive number");
  }

  var startFactor = areaFactors[originalUnit];

  if (!startFactor) {
    throw new Error("invalid original units");
  }

  var finalFactor = areaFactors[finalUnit];

  if (!finalFactor) {
    throw new Error("invalid final units");
  }

  return area / startFactor * finalFactor;
}
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */


function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */


function isObject(input) {
  return !!input && input.constructor === Object;
}
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */


function validateBBox(bbox) {
  if (!bbox) {
    throw new Error("bbox is required");
  }

  if (!Array.isArray(bbox)) {
    throw new Error("bbox must be an Array");
  }

  if (bbox.length !== 4 && bbox.length !== 6) {
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  }

  bbox.forEach(function (num) {
    if (!isNumber(num)) {
      throw new Error("bbox must only contain numbers");
    }
  });
}
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */


function validateId(id) {
  if (!id) {
    throw new Error("id is required");
  }

  if (["string", "number"].indexOf((0, _typeof2["default"])(id)) === -1) {
    throw new Error("id must be a number or a string");
  }
}

},{"M_0":241,"M_110":245}],215:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCoord = getCoord;
exports.getCoords = getCoords;
exports.containsNumber = containsNumber;
exports.geojsonType = geojsonType;
exports.featureOf = featureOf;
exports.collectionOf = collectionOf;
exports.getGeom = getGeom;
exports.getType = getType;

var _index = require("3_995");

/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }

  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return coord.geometry.coordinates;
    }

    if (coord.type === "Point") {
      return coord.coordinates;
    }
  }

  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return coord;
  }

  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */


function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  } // Feature


  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    // Geometry
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }

  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */


function containsNumber(coordinates) {
  if (coordinates.length > 1 && (0, _index.isNumber)(coordinates[0]) && (0, _index.isNumber)(coordinates[1])) {
    return true;
  }

  if (Array.isArray(coordinates[0]) && coordinates[0].length) {
    return containsNumber(coordinates[0]);
  }

  throw new Error("coordinates must only contain numbers");
}
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */


function geojsonType(value, type, name) {
  if (!type || !name) {
    throw new Error("type and name required");
  }

  if (!value || value.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
  }
}
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */


function featureOf(feature, type, name) {
  if (!feature) {
    throw new Error("No feature passed");
  }

  if (!name) {
    throw new Error(".featureOf() requires a name");
  }

  if (!feature || feature.type !== "Feature" || !feature.geometry) {
    throw new Error("Invalid input to " + name + ", Feature with geometry required");
  }

  if (!feature.geometry || feature.geometry.type !== type) {
    throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
  }
}
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */


function collectionOf(featureCollection, type, name) {
  if (!featureCollection) {
    throw new Error("No featureCollection passed");
  }

  if (!name) {
    throw new Error(".collectionOf() requires a name");
  }

  if (!featureCollection || featureCollection.type !== "FeatureCollection") {
    throw new Error("Invalid input to " + name + ", FeatureCollection required");
  }

  for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
    var feature = _a[_i];

    if (!feature || feature.type !== "Feature" || !feature.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }

    if (!feature.geometry || feature.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
  }
}
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */


function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }

  return geojson;
}
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message (unused)
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */


function getType(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }

  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }

  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }

  return geojson.type;
}

},{"3_995":214}],216:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("3_1006");

var _index2 = require("D_996");

var _index3 = require("3_995");

/**
 * https://github.com/rook2pawn/node-intersection
 *
 * Author @rook2pawn
 */

/**
 * AB
 *
 * @private
 * @param {Array<Array<number>>} segment - 2 vertex line segment
 * @returns {Array<number>} coordinates [x, y]
 */
function ab(segment) {
  var start = segment[0];
  var end = segment[1];
  return [end[0] - start[0], end[1] - start[1]];
}
/**
 * Cross Product
 *
 * @private
 * @param {Array<number>} v1 coordinates [x, y]
 * @param {Array<number>} v2 coordinates [x, y]
 * @returns {Array<number>} Cross Product
 */


function crossProduct(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
/**
 * Add
 *
 * @private
 * @param {Array<number>} v1 coordinates [x, y]
 * @param {Array<number>} v2 coordinates [x, y]
 * @returns {Array<number>} Add
 */


function add(v1, v2) {
  return [v1[0] + v2[0], v1[1] + v2[1]];
}
/**
 * Sub
 *
 * @private
 * @param {Array<number>} v1 coordinates [x, y]
 * @param {Array<number>} v2 coordinates [x, y]
 * @returns {Array<number>} Sub
 */


function sub(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1]];
}
/**
 * scalarMult
 *
 * @private
 * @param {number} s scalar
 * @param {Array<number>} v coordinates [x, y]
 * @returns {Array<number>} scalarMult
 */


function scalarMult(s, v) {
  return [s * v[0], s * v[1]];
}
/**
 * Intersect Segments
 *
 * @private
 * @param {Array<number>} a coordinates [x, y]
 * @param {Array<number>} b coordinates [x, y]
 * @returns {Array<number>} intersection
 */


function intersectSegments(a, b) {
  var p = a[0];
  var r = ab(a);
  var q = b[0];
  var s = ab(b);
  var cross = crossProduct(r, s);
  var qmp = sub(q, p);
  var numerator = crossProduct(qmp, s);
  var t = numerator / cross;
  var intersection = add(p, scalarMult(t, r));
  return intersection;
}
/**
 * Is Parallel
 *
 * @private
 * @param {Array<number>} a coordinates [x, y]
 * @param {Array<number>} b coordinates [x, y]
 * @returns {boolean} true if a and b are parallel (or co-linear)
 */


function isParallel(a, b) {
  var r = ab(a);
  var s = ab(b);
  return crossProduct(r, s) === 0;
}
/**
 * Intersection
 *
 * @private
 * @param {Array<number>} a coordinates [x, y]
 * @param {Array<number>} b coordinates [x, y]
 * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)
 */


function intersection(a, b) {
  if (isParallel(a, b)) return false;
  return intersectSegments(a, b);
}
/**
 * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.
 *
 * @name lineOffset
 * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON
 * @param {number} distance distance to offset the line (can be of negative value)
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters
 * @returns {Feature<LineString|MultiLineString>} Line offset from the input line
 * @example
 * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { "stroke": "#F00" });
 *
 * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [offsetLine, line]
 * offsetLine.properties.stroke = "#00F"
 */


function lineOffset(geojson, distance, options) {
  // Optional parameters
  options = options || {};
  if (!(0, _index3.isObject)(options)) throw new Error("options is invalid");
  var units = options.units; // Valdiation

  if (!geojson) throw new Error("geojson is required");
  if (distance === undefined || distance === null || isNaN(distance)) throw new Error("distance is required");
  var type = (0, _index2.getType)(geojson);
  var properties = geojson.properties;

  switch (type) {
    case "LineString":
      return lineOffsetFeature(geojson, distance, units);

    case "MultiLineString":
      var coords = [];
      (0, _index.flattenEach)(geojson, function (feature) {
        coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);
      });
      return (0, _index3.multiLineString)(coords, properties);

    default:
      throw new Error("geometry " + type + " is not supported");
  }
}
/**
 * Line Offset
 *
 * @private
 * @param {Geometry|Feature<LineString>} line input line
 * @param {number} distance distance to offset the line (can be of negative value)
 * @param {string} [units=kilometers] units
 * @returns {Feature<LineString>} Line offset from the input line
 */


function lineOffsetFeature(line, distance, units) {
  var segments = [];
  var offsetDegrees = (0, _index3.lengthToDegrees)(distance, units);
  var coords = (0, _index2.getCoords)(line);
  var finalCoords = [];
  coords.forEach(function (currentCoords, index) {
    if (index !== coords.length - 1) {
      var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);
      segments.push(segment);

      if (index > 0) {
        var seg2Coords = segments[index - 1];
        var intersects = intersection(segment, seg2Coords); // Handling for line segments that aren't straight

        if (intersects !== false) {
          seg2Coords[1] = intersects;
          segment[0] = intersects;
        }

        finalCoords.push(seg2Coords[0]);

        if (index === coords.length - 2) {
          finalCoords.push(segment[0]);
          finalCoords.push(segment[1]);
        }
      } // Handling for lines that only have 1 segment


      if (coords.length === 2) {
        finalCoords.push(segment[0]);
        finalCoords.push(segment[1]);
      }
    }
  });
  return (0, _index3.lineString)(finalCoords, line.properties);
}
/**
 * Process Segment
 * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line
 *
 * @private
 * @param {Array<number>} point1 Point coordinates
 * @param {Array<number>} point2 Point coordinates
 * @param {number} offset Offset
 * @returns {Array<Array<number>>} offset points
 */


function processSegment(point1, point2, offset) {
  var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));
  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;
  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;
  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;
  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;
  return [[out1x, out1y], [out2x, out2y]];
}

var _default = lineOffset;
exports["default"] = _default;

},{"3_995":214,"D_996":215,"3_1006":217}],217:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coordAll = coordAll;
exports.coordEach = coordEach;
exports.coordReduce = coordReduce;
exports.featureEach = featureEach;
exports.featureReduce = featureReduce;
exports.findPoint = findPoint;
exports.findSegment = findSegment;
exports.flattenEach = flattenEach;
exports.flattenReduce = flattenReduce;
exports.geomEach = geomEach;
exports.geomReduce = geomReduce;
exports.lineEach = lineEach;
exports.lineReduce = lineReduce;
exports.propEach = propEach;
exports.propReduce = propReduce;
exports.segmentEach = segmentEach;
exports.segmentReduce = segmentReduce;

var _index = require("3_995");

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
  // Handles null Geometry -- Skips this GeoJSON
  if (geojson === null) return;
  var j,
      k,
      l,
      geometry,
      stopG,
      coords,
      geometryMaybeCollection,
      wrapShrink = 0,
      coordIndex = 0,
      isGeometryCollection,
      type = geojson.type,
      isFeatureCollection = type === "FeatureCollection",
      isFeature = type === "Feature",
      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.

  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection; // Handles null Geometry -- Skips this geometry

      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;

      switch (geomType) {
        case null:
          break;

        case "Point":
          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
          coordIndex++;
          multiFeatureIndex++;
          break;

        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }

          if (geomType === "LineString") multiFeatureIndex++;
          break;

        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
              coordIndex++;
            }

            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }

          if (geomType === "Polygon") multiFeatureIndex++;
          break;

        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;

            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                coordIndex++;
              }

              geometryIndex++;
            }

            multiFeatureIndex++;
          }

          break;

        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++) {
            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
          }

          break;

        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */


function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
  }, excludeWrapCoord);
  return previousValue;
}
/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */


function propEach(geojson, callback) {
  var i;

  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false) break;
      }

      break;

    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}
/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */


function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function (currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}
/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */


function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}
/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */


function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function (currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}
/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */


function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function (coord) {
    coords.push(coord);
  });
  return coords;
}
/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */


function geomEach(geojson, callback) {
  var i,
      j,
      g,
      geometry,
      stopG,
      geometryMaybeCollection,
      isGeometryCollection,
      featureProperties,
      featureBBox,
      featureId,
      featureIndex = 0,
      isFeatureCollection = geojson.type === "FeatureCollection",
      isFeature = geojson.type === "Feature",
      stop = isFeatureCollection ? geojson.features.length : 1; // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.

  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection; // Handle null Geometry

      if (geometry === null) {
        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
        continue;
      }

      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          {
            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
            break;
          }

        case "GeometryCollection":
          {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
            }

            break;
          }

        default:
          throw new Error("Unknown Geometry Type");
      }
    } // Only increase `featureIndex` per each feature


    featureIndex++;
  }
}
/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */


function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
  });
  return previousValue;
}
/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */


function flattenEach(geojson, callback) {
  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
    // Callback for single geometry
    var type = geometry === null ? null : geometry.type;

    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback((0, _index.feature)(geometry, properties, {
          bbox: bbox,
          id: id
        }), featureIndex, 0) === false) return false;
        return;
    }

    var geomType; // Callback for multi-geometry

    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;

      case "MultiLineString":
        geomType = "LineString";
        break;

      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }

    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback((0, _index.feature)(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
    }
  });
}
/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */


function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
  });
  return previousValue;
}
/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */


function segmentEach(geojson, callback) {
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0; // Exclude null Geometries

    if (!feature.geometry) return; // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.

    var type = feature.geometry.type;
    if (type === "Point" || type === "MultiPoint") return; // Generate 2-vertex line segments

    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
      if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
        previousCoords = currentCoord;
        previousFeatureIndex = featureIndex;
        previousMultiIndex = multiPartIndexCoord;
        prevGeomIndex = geometryIndex;
        segmentIndex = 0;
        return;
      }

      var currentSegment = (0, _index.lineString)([previousCoords, currentCoord], feature.properties);
      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
      segmentIndex++;
      previousCoords = currentCoord;
    }) === false) return false;
  });
}
/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentIndex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */


function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
    started = true;
  });
  return previousValue;
}
/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */


function lineEach(geojson, callback) {
  // validation
  if (!geojson) throw new Error("geojson is required");
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    if (feature.geometry === null) return;
    var type = feature.geometry.type;
    var coords = feature.geometry.coordinates;

    switch (type) {
      case "LineString":
        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
        break;

      case "Polygon":
        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
          if (callback((0, _index.lineString)(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
        }

        break;
    }
  });
}
/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */


function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
  });
  return previousValue;
}
/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */


function findSegment(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0, _index.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0; // Find FeatureIndex

  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;

    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;

    case "Point":
    case "MultiPoint":
      return null;

    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;

    default:
      throw new Error("geojson is invalid");
  } // Find SegmentIndex


  if (geometry === null) return null;
  var coords = geometry.coordinates;

  switch (geometry.type) {
    case "Point":
    case "MultiPoint":
      return null;

    case "LineString":
      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
      return (0, _index.lineString)([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);

    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return (0, _index.lineString)([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);

    case "MultiLineString":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return (0, _index.lineString)([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);

    case "MultiPolygon":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return (0, _index.lineString)([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
  }

  throw new Error("geojson is invalid");
}
/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */


function findPoint(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0, _index.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0; // Find FeatureIndex

  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;

    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;

    case "Point":
    case "MultiPoint":
      return null;

    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;

    default:
      throw new Error("geojson is invalid");
  } // Find Coord Index


  if (geometry === null) return null;
  var coords = geometry.coordinates;

  switch (geometry.type) {
    case "Point":
      return (0, _index.point)(coords, properties, options);

    case "MultiPoint":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      return (0, _index.point)(coords[multiFeatureIndex], properties, options);

    case "LineString":
      if (coordIndex < 0) coordIndex = coords.length + coordIndex;
      return (0, _index.point)(coords[coordIndex], properties, options);

    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
      return (0, _index.point)(coords[geometryIndex][coordIndex], properties, options);

    case "MultiLineString":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return (0, _index.point)(coords[multiFeatureIndex][coordIndex], properties, options);

    case "MultiPolygon":
      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return (0, _index.point)(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
  }

  throw new Error("geojson is invalid");
}

},{"3_995":214}],218:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

},{}],219:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

// import HttpFileSystem from '@mesh-3d/meteolib/Source/Util/HttpFileSystem/HttpFileSystem'
// import FileInfo from '@mesh-3d/meteolib/Source/Util/HttpFileSystem/FileInfo'
// import '@mesh-3d/meteolib/Source/Util/ExtendMethod'
var _MeteoLib = MeteoLib,
    HttpFileSystem = _MeteoLib.HttpFileSystem,
    FileInfo = _MeteoLib.FileInfo;

function extractDatetime(data) {
  var timeRegex = data.timeRegex;

  if (!timeRegex) {
    timeRegex = 'yyyyMMddhhmm';
  }

  var regex = timeRegex;
  regex = regex.replace("yyyy", "\\d{4}");
  regex = regex.replace("MM", "\\d{2}");
  regex = regex.replace("dd", "\\d{2}");
  regex = regex.replace("hh", "\\d{2}");
  regex = regex.replace("mm", "\\d{2}");
  regex = regex.replace("ss", "\\d{2}");
  regex = new RegExp(regex);
  var time = regex.exec(data.fileName);

  if (!time || !time.length) {
    time = regex.exec('20' + data.fileName);
  }

  if (!time || !time.length) {
    time = null;
  } else {
    time = parseDate(time[0], timeRegex);
  }

  if (data.timeZone) {
    time = time.add('h', data.timeZone);
  }

  data.datetime = time;
  return time;
}
/**
 * 
 * @param {HfsFileLoader} loader 
 * @private
 */


function executeRead(loader) {
  if (loader._fileList.length == 0) {
    loader.isLoading = false;
    return;
  }

  var fileInfo = loader._fileList.shift();

  var options = loader._readOptionsList.shift() || {};
  var offset = options.offset,
      length = options.length,
      responseType = options.responseType,
      encoding = options.encoding;

  var deferred = loader._deferredList.shift();

  if (!fileInfo || fileInfo._aborted) {
    if (deferred) {
      delete deferred.resolve;
      delete deferred.reject;
    }

    executeRead(loader);
    return;
  } //指示文件正在加载


  fileInfo.isLoading = true; //指示加载器正在加载文件

  loader.isLoading = true; //设置当前正在加载的文件信息

  loader.currentFileInfo = fileInfo;
  loader.hfs.readFile(fileInfo, offset, length, responseType, encoding).then(function (res) {
    fileInfo.loaded = true;
    fileInfo.isLoading = false;

    if (!fileInfo._aborted) {
      deferred.resolve(res);
    }

    fileInfo = null;
    loader.currentFileInfo = null;
    delete deferred.resolve;
    delete deferred.reject;
    executeRead(loader);
  }).otherwise(function (reason) {
    fileInfo.isLoading = false;
    fileInfo = null;
    loader.currentFileInfo = null;
    deferred.reject(reason);
    executeRead(loader);
  });
}
/**
 * hfs文件加载器，内部会自动排队，逐个文件地执行读取
 * @example
var hfsLoader = new HfsFileLoader({
    baseUrl: 'http://39.107.107.142:18880/hfs',
    auth: {
        uid: 'admin',
        pwd: 'Adnin@123456'
    }
})
hfsLoader.hfs.getFiles('GZData', 'ECMWF_LR/RH/850', '.000').then(files => {
    console.log(files);
    var promises = files.map(file => {
        return hfsLoader.load(file)
    })
    Promise.all(promises).then(fileBuffers => {
        console.log(fileBuffers);
    })
})
 */


var HfsFileLoader = /*#__PURE__*/function () {
  /**
   *hfs文件加载器，内部会自动排队，逐个文件地执行读取 
   * @param {{
   *  baseUrl:string
   *  auth: {
   *      uid: string
   *      pwd: string
   *  }
   * }} config 
   * @example
  var hfsLoader = new HfsFileLoader({
  baseUrl: 'http://39.107.107.142:18880/hfs',
  auth: {
      uid: 'admin',
      pwd: 'Adnin@123456'
  }
  })
  hfsLoader.hfs.getFiles('GZData', 'ECMWF_LR/RH/850', '.000').then(files => {
  console.log(files);
  var promises = files.map(file => {
      return hfsLoader.load(file)
  })
  Promise.all(promises).then(fileBuffers => {
      console.log(fileBuffers);
  })
  })
   */
  function HfsFileLoader(config) {
    (0, _classCallCheck2["default"])(this, HfsFileLoader);
    this.hfs = new HttpFileSystem({
      config: config
    });
    this._fileList = [];
    this._readOptionsList = [];
    this._deferredList = [];
    this.isLoading = false;
    /**
     * @type {FileInfo}
     */

    this.currentFileInfo = null;
  }
  /**
   * 读取文件数据，如果加载器正在读取文件则排队等待
   * @param {FileInfo} fileInfo 
   * @param {object} [options] 
   * @param {Number} [options.offset=0] 可选，开始读取的位置（字节数）
   * @param {Number} [options.length] 可选，读取的字节数 
   * @param {'arrayBuffer'|'blob'|'json'|'text'|'xml'|'image'} [options.responseType="arrayBuffer"]
   * @param {String} [options.encoding]
   * @returns 
   */


  (0, _createClass2["default"])(HfsFileLoader, [{
    key: "readFile",
    value: function readFile(fileInfo, options) {
      if (this._fileList.includes(fileInfo)) {
        return;
      }

      this._fileList.push(fileInfo);

      this._readOptionsList.push(options);

      var deferred = {};

      this._deferredList.push(deferred);

      fileInfo._aborted = false;
      var readPromise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
      });

      if (!this.isLoading) {
        executeRead(this);
      } else {
        //指示文件正在排队等待
        fileInfo.isWaiting = true;
      }

      return readPromise;
    }
    /**
     * 获取文件列表
    * @param {object} options
    * @param {String} options.dir 根目录名称
    * @param {String} options.path 相对路径
    * @param {String} [options.ext] 可选，如"*.png"等
    * @param {String} [options.startTime] 可选，开始时间
    * @param {String} [options.endTime] 可选，结束时间
    * @param {String} [options.timeRegex] 可选，按文件名中的时间筛选，指定时间格式
    * @param {Boolean} [options.timeZone=0] 时区，0表示北京时间（BTC），8表示世界时间（UTC）
    * @param {Boolean} [options.fromDb=true] 可选，从数据库中检索
    *@return {Promise<FileInfo[]>}
    */

  }, {
    key: "getFiles",
    value: function getFiles(options) {
      var _this = this;

      var dir = options.dir,
          path = options.path,
          ext = options.ext,
          startTime = options.startTime,
          endTime = options.endTime,
          timeRegex = options.timeRegex,
          fromDb = options.fromDb,
          timeZone = options.timeZone;
      return new Promise(function (resolve, reject) {
        _this.hfs.getFiles(dir, path, ext, startTime, endTime, timeRegex, fromDb).then(function (files) {
          if (fromDb == false) {
            files = files.map(function (file) {
              file = {
                fileName: file,
                dir: dir,
                path: path,
                size: 0
              };
              file.timeZone = options.timeZone;
              file.timeRegex = options.timeRegex;
              extractDatetime(file);
              return file;
            });
          } else {
            files.forEach(function (file) {
              if (file.datetime) {
                file.datetime = new Date(file.datetime);

                if (data.timeZone) {
                  file.datetime.add('h', data.timeZone);
                }
              }
            });
          }

          resolve(files);
        }).otherwise(reject);
      });
    }
    /**
     * 取消读取，如果还没开始读取，则直接退出排队；如果已经开始读取则在读到文件后不处理
     * @param {FileInfo} fileInfo 
     */

  }, {
    key: "cancelRead",
    value: function cancelRead(fileInfo) {
      if (!fileInfo.isLoading) {
        var idx = this._fileList.indexOf(fileInfo);

        this._fileList.splice(idx, 1);
      } else {
        fileInfo._aborted = true;
      }
    }
  }]);
  return HfsFileLoader;
}();

exports["default"] = HfsFileLoader;

},{"e_1":235,"s_2":236,"M_0":241}],220:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "HfsFileLoader", {
  enumerable: true,
  get: function get() {
    return _HfsFileLoader["default"];
  }
});
Object.defineProperty(exports, "splitLine", {
  enumerable: true,
  get: function get() {
    return _splitLine["default"];
  }
});
Object.defineProperty(exports, "IHfsFileLayer", {
  enumerable: true,
  get: function get() {
    return _IHfsFileLayer["default"];
  }
});
Object.defineProperty(exports, "MicapsECLayer", {
  enumerable: true,
  get: function get() {
    return _MicapsECLayer["default"];
  }
});
Object.defineProperty(exports, "PUPRadarLayer", {
  enumerable: true,
  get: function get() {
    return _PUPRadarLayer["default"];
  }
});
Object.defineProperty(exports, "SateCloudLayer", {
  enumerable: true,
  get: function get() {
    return _SateCloudLayer["default"];
  }
});
Object.defineProperty(exports, "SwanRadarLayer", {
  enumerable: true,
  get: function get() {
    return _SwanRadarLayer["default"];
  }
});
Object.defineProperty(exports, "MicapsUpAirLayer", {
  enumerable: true,
  get: function get() {
    return _MicapsUpAirLayer["default"];
  }
});
Object.defineProperty(exports, "SurfLayer", {
  enumerable: true,
  get: function get() {
    return _SurfLayer["default"];
  }
});
Object.defineProperty(exports, "GeoGridLayer", {
  enumerable: true,
  get: function get() {
    return _GeoGridLayer["default"];
  }
});
Object.defineProperty(exports, "VectorLayerGroup", {
  enumerable: true,
  get: function get() {
    return _VectorLayerGroup["default"];
  }
});
Object.defineProperty(exports, "Earth", {
  enumerable: true,
  get: function get() {
    return _index.Earth;
  }
});
Object.defineProperty(exports, "LocalSkyBox", {
  enumerable: true,
  get: function get() {
    return _index.LocalSkyBox;
  }
});
Object.defineProperty(exports, "LocalSkyBoxAnimation", {
  enumerable: true,
  get: function get() {
    return _index.LocalSkyBoxAnimation;
  }
});
Object.defineProperty(exports, "ILayer", {
  enumerable: true,
  get: function get() {
    return _index.ILayer;
  }
});
Object.defineProperty(exports, "ImageTileLayer", {
  enumerable: true,
  get: function get() {
    return _index.ImageTileLayer;
  }
});
Object.defineProperty(exports, "TiandituLayer", {
  enumerable: true,
  get: function get() {
    return _index.TiandituLayer;
  }
});
Object.defineProperty(exports, "TiandituImgLayer", {
  enumerable: true,
  get: function get() {
    return _index.TiandituImgLayer;
  }
});
Object.defineProperty(exports, "TiandituTerLayer", {
  enumerable: true,
  get: function get() {
    return _index.TiandituTerLayer;
  }
});
Object.defineProperty(exports, "TiandituVecLayer", {
  enumerable: true,
  get: function get() {
    return _index.TiandituVecLayer;
  }
});
Object.defineProperty(exports, "Vector2dLayer", {
  enumerable: true,
  get: function get() {
    return _index.Vector2dLayer;
  }
});
Object.defineProperty(exports, "HighlightPolygonLayer", {
  enumerable: true,
  get: function get() {
    return _index.HighlightPolygonLayer;
  }
});
Object.defineProperty(exports, "SealandVec2dLayer", {
  enumerable: true,
  get: function get() {
    return _index.SealandVec2dLayer;
  }
});
Object.defineProperty(exports, "HighlightMarkerLayer", {
  enumerable: true,
  get: function get() {
    return _index.HighlightMarkerLayer;
  }
});
Object.defineProperty(exports, "LabelVec2dLayer", {
  enumerable: true,
  get: function get() {
    return _index.LabelVec2dLayer;
  }
});
Object.defineProperty(exports, "CountryVec2dLayer", {
  enumerable: true,
  get: function get() {
    return _index.CountryVec2dLayer;
  }
});
Object.defineProperty(exports, "Vector3dLayer", {
  enumerable: true,
  get: function get() {
    return _index.Vector3dLayer;
  }
});
Object.defineProperty(exports, "C3DTilesLayer", {
  enumerable: true,
  get: function get() {
    return _index.C3DTilesLayer;
  }
});
Object.defineProperty(exports, "OsgbLayer", {
  enumerable: true,
  get: function get() {
    return _index.OsgbLayer;
  }
});
Object.defineProperty(exports, "GeoMesh", {
  enumerable: true,
  get: function get() {
    return _index.GeoMesh;
  }
});
Object.defineProperty(exports, "GeoPolygonMesh", {
  enumerable: true,
  get: function get() {
    return _index.GeoPolygonMesh;
  }
});
Object.defineProperty(exports, "GeoPolylineMesh", {
  enumerable: true,
  get: function get() {
    return _index.GeoPolylineMesh;
  }
});
Object.defineProperty(exports, "GeoWaterMesh", {
  enumerable: true,
  get: function get() {
    return _index.GeoWaterMesh;
  }
});
Object.defineProperty(exports, "GeoPolylineGeometry", {
  enumerable: true,
  get: function get() {
    return _index.GeoPolylineGeometry;
  }
});
Object.defineProperty(exports, "GeoPolygonGeometry", {
  enumerable: true,
  get: function get() {
    return _index.GeoPolygonGeometry;
  }
});
Object.defineProperty(exports, "ExtrudedPolygonGeometry", {
  enumerable: true,
  get: function get() {
    return _index.ExtrudedPolygonGeometry;
  }
});
Object.defineProperty(exports, "SolidWireframeGeometry", {
  enumerable: true,
  get: function get() {
    return _index.SolidWireframeGeometry;
  }
});
Object.defineProperty(exports, "VectorPolygonGeometry", {
  enumerable: true,
  get: function get() {
    return _index.VectorPolygonGeometry;
  }
});
Object.defineProperty(exports, "SolidWireframeMaterial", {
  enumerable: true,
  get: function get() {
    return _index.SolidWireframeMaterial;
  }
});
Object.defineProperty(exports, "interactive", {
  enumerable: true,
  get: function get() {
    return _index.interactive;
  }
});
Object.defineProperty(exports, "getPoint", {
  enumerable: true,
  get: function get() {
    return _index.getPoint;
  }
});
Object.defineProperty(exports, "getLine", {
  enumerable: true,
  get: function get() {
    return _index.getLine;
  }
});
Object.defineProperty(exports, "getPolyline", {
  enumerable: true,
  get: function get() {
    return _index.getPolyline;
  }
});
Object.defineProperty(exports, "getRactangle", {
  enumerable: true,
  get: function get() {
    return _index.getRactangle;
  }
});
Object.defineProperty(exports, "pickPosition", {
  enumerable: true,
  get: function get() {
    return _index.pickPosition;
  }
});
Object.defineProperty(exports, "MeshVisualizer", {
  enumerable: true,
  get: function get() {
    return _index2.MeshVisualizer;
  }
});
Object.defineProperty(exports, "CameraUtils", {
  enumerable: true,
  get: function get() {
    return _index2.CameraUtils;
  }
});
Object.defineProperty(exports, "GeometryUtils", {
  enumerable: true,
  get: function get() {
    return _index2.GeometryUtils;
  }
});
Object.defineProperty(exports, "RendererUtils", {
  enumerable: true,
  get: function get() {
    return _index2.RendererUtils;
  }
});
Object.defineProperty(exports, "computeArea", {
  enumerable: true,
  get: function get() {
    return _index3.computeArea;
  }
});
Object.defineProperty(exports, "defineProperty", {
  enumerable: true,
  get: function get() {
    return _index3.defineProperty;
  }
});
Object.defineProperty(exports, "determinant", {
  enumerable: true,
  get: function get() {
    return _index3.determinant;
  }
});
Object.defineProperty(exports, "esExtends", {
  enumerable: true,
  get: function get() {
    return _index3.esExtends;
  }
});
Object.defineProperty(exports, "GenericWorker", {
  enumerable: true,
  get: function get() {
    return _index3.GenericWorker;
  }
});
Object.defineProperty(exports, "geojsonHelper", {
  enumerable: true,
  get: function get() {
    return _index3.geojsonHelper;
  }
});
Object.defineProperty(exports, "ImageUtils", {
  enumerable: true,
  get: function get() {
    return _index3.ImageUtils;
  }
});
Object.defineProperty(exports, "isTypedArray", {
  enumerable: true,
  get: function get() {
    return _index3.isTypedArray;
  }
});
Object.defineProperty(exports, "lineBufferDir3", {
  enumerable: true,
  get: function get() {
    return _index3.lineBufferDir3;
  }
});
Object.defineProperty(exports, "MathUtils", {
  enumerable: true,
  get: function get() {
    return _index3.MathUtils;
  }
});
Object.defineProperty(exports, "matrix4LookAt", {
  enumerable: true,
  get: function get() {
    return _index3.matrix4LookAt;
  }
});
Object.defineProperty(exports, "mergeBuffers", {
  enumerable: true,
  get: function get() {
    return _index3.mergeBuffers;
  }
});
Object.defineProperty(exports, "parseDefines", {
  enumerable: true,
  get: function get() {
    return _index3.parseDefines;
  }
});
Object.defineProperty(exports, "decodeGeojson", {
  enumerable: true,
  get: function get() {
    return _index3.decodeGeojson;
  }
});
Object.defineProperty(exports, "decodeGeojsonAsync", {
  enumerable: true,
  get: function get() {
    return _index3.decodeGeojsonAsync;
  }
});
Object.defineProperty(exports, "decodeGeojsonCoords", {
  enumerable: true,
  get: function get() {
    return _index3.decodeGeojsonCoords;
  }
});
Object.defineProperty(exports, "decodeGeojsonCoordsAsync", {
  enumerable: true,
  get: function get() {
    return _index3.decodeGeojsonCoordsAsync;
  }
});
Object.defineProperty(exports, "decodeObject", {
  enumerable: true,
  get: function get() {
    return _index3.decodeObject;
  }
});
Object.defineProperty(exports, "encodeGeojson", {
  enumerable: true,
  get: function get() {
    return _index3.encodeGeojson;
  }
});
Object.defineProperty(exports, "encodeGeojsonCoords", {
  enumerable: true,
  get: function get() {
    return _index3.encodeGeojsonCoords;
  }
});
Object.defineProperty(exports, "encodeObject", {
  enumerable: true,
  get: function get() {
    return _index3.encodeObject;
  }
});
Object.defineProperty(exports, "encodeObjectValues", {
  enumerable: true,
  get: function get() {
    return _index3.encodeObjectValues;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _index3.Path;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function get() {
    return _index3.save;
  }
});
Object.defineProperty(exports, "saveArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _index3.saveArrayBuffer;
  }
});
Object.defineProperty(exports, "saveString", {
  enumerable: true,
  get: function get() {
    return _index3.saveString;
  }
});
Object.defineProperty(exports, "stringToArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _index3.stringToArrayBuffer;
  }
});
Object.defineProperty(exports, "StringUtil", {
  enumerable: true,
  get: function get() {
    return _index3.StringUtil;
  }
});
Object.defineProperty(exports, "triangulate", {
  enumerable: true,
  get: function get() {
    return _index3.triangulate;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function get() {
    return _index3.traverse;
  }
});
Object.defineProperty(exports, "getPaddedBuffer", {
  enumerable: true,
  get: function get() {
    return _index3.getPaddedBuffer;
  }
});
Object.defineProperty(exports, "getPaddedBufferSize", {
  enumerable: true,
  get: function get() {
    return _index3.getPaddedBufferSize;
  }
});
exports.terrainSampler = exports.rasterSampler = void 0;

var _HfsFileLoader = _interopRequireDefault(require("h_1015"));

var rasterSampler = _interopRequireWildcard(require("-_1016"));

exports.rasterSampler = rasterSampler;

var terrainSampler = _interopRequireWildcard(require("3_1017"));

exports.terrainSampler = terrainSampler;

var _splitLine = _interopRequireDefault(require("D_1018"));

var _IHfsFileLayer = _interopRequireDefault(require("._1019"));

var _MicapsECLayer = _interopRequireDefault(require("C_1020"));

var _PUPRadarLayer = _interopRequireDefault(require("o_1021"));

var _SateCloudLayer = _interopRequireDefault(require("m_1022"));

var _SwanRadarLayer = _interopRequireDefault(require("M_1023"));

var _MicapsUpAirLayer = _interopRequireDefault(require("e_1024"));

var _SurfLayer = _interopRequireDefault(require("s_1025"));

var _GeoGridLayer = _interopRequireDefault(require("h_1026"));

var _VectorLayerGroup = _interopRequireDefault(require("-_1027"));

var _index = require("3_1028");

var _index2 = require("D_1029");

var _index3 = require("._1030");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"D_1029":39,"3_1028":71,"._1030":209,"h_1015":219,"h_1026":221,"._1019":222,"C_1020":223,"e_1024":224,"o_1021":225,"m_1022":226,"s_1025":227,"M_1023":228,"-_1027":229,"-_1016":230,"D_1018":231,"3_1017":232,"M_0":241,"M_110":245}],221:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _ImageTileLayer2 = _interopRequireDefault(require("h_1037"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function createSymbolImage(options) {
  options = options || {};
  var cv = document.createElement('canvas');
  cv.width = 64;
  cv.height = 64;
  var ctx = cv.getContext('2d');
  ctx.fillStyle = options.bgColor || "#00061a"; //"#394252"

  ctx.fillRect(0, 0, cv.width, cv.height);
  ctx.fillStyle = options.lightColor || '#5076b1';
  var size = 1;
  ctx.fillRect(0, 0, size, size);
  ctx.fillRect(63, 0, size, size);
  ctx.fillRect(0, 63, size, size);
  ctx.fillRect(63, 63, size, size);
  var xSize = 16,
      ySize = 16;
  var dx = cv.width / (xSize + 1);
  var dy = cv.height / (ySize + 1);
  var y = dy,
      x = dx;

  for (var i = 0; i < ySize; i++) {
    ctx.fillRect(x, 0, size, size);
    ctx.fillRect(x, cv.height, size, size);
    x += dx;
  }

  for (var _i = 0; _i < xSize; _i++) {
    ctx.fillRect(0, y, size, size);
    ctx.fillRect(cv.width, y, size, size);
    y += dy;
  }

  ctx.fillStyle = options.darkColor || '#435a7c';
  y = 0, x = 0;
  var off = 4,
      size = 1;

  for (var _i2 = 0; _i2 < ySize; _i2++) {
    x = 0;

    for (var j = 0; j < xSize; j++) {
      ctx.fillRect(x + off, y + off, size, size);
      x += dx;
    }

    y += dy;
  }

  return cv;
}

function createGridImage(options) {
  var symbol = createSymbolImage(options);
  var cv = document.createElement('canvas');
  cv.width = 256;
  cv.height = 256;
  var ctx = cv.getContext('2d');
  var y = 0;

  for (var i = 0; i <= 4; i++) {
    var x = 0;

    for (var j = 0; j <= 4; j++) {
      ctx.drawImage(symbol, x, y);
      x += 64;
    }

    y += 64;
  }

  return cv;
}

var GeoGridLayer = /*#__PURE__*/function (_ImageTileLayer) {
  (0, _inherits2["default"])(GeoGridLayer, _ImageTileLayer);

  var _super = _createSuper(GeoGridLayer);

  function GeoGridLayer(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, GeoGridLayer);
    options = options || {};
    _this = _super.call(this, options);
    var gridImg = options.gridImage || createGridImage({
      bgColor: options.bgColor,
      lightColor: options.lightColor,
      darkColor: options.darkColor
    });
    var ready = false;
    var deferred = {};
    _this.readyPromise = new Promise(function (resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    Object.defineProperties((0, _assertThisInitialized2["default"])(_this), {
      ready: {
        get: function get() {
          return ready;
        }
      }
    });

    if (typeof gridImg != 'string') {
      ready = true;
      deferred.resolve((0, _assertThisInitialized2["default"])(_this));
    }

    var provider = new Cesium.GridImageryProvider({
      minimumLevel: options.minimumLevel,
      maximumLevel: options.maximumLevel
    });

    provider.requestImage = function (x, y, level, request) {
      var _this2 = this;

      if (ready) return gridImg;
      return Cesium.Resource.fetchImage(gridImg).then(function (img) {
        gridImg = img;
        ready = true;
        deferred.resolve(_this2);
        return img;
      }).otherwise(deferred.reject);
    };

    _this.provider = provider;
    return _this;
  }

  return GeoGridLayer;
}(_ImageTileLayer2["default"]);

exports["default"] = GeoGridLayer;

},{"h_1037":56,"s_332":233,"e_1":235,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],222:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// import HfsFileLoader from "h_1048";
// import '@mesh-3d/meteolib/Source/Util/ExtendMethod'
// import FileInfo from "@mesh-3d/meteolib/Source/Util/HttpFileSystem/FileInfo";

/**
 * 
 * @param {SateCloudLayer} layer 
 */
function setCurrentFile(layer) {
  if (layer.fileList.length == 1) {
    layer._currentFile = layer.fileList[0];
  } else {
    for (var i = 1; i < layer.fileList.length; i++) {
      var a = layer.fileList[i - 1],
          b = layer.fileList[i];
      var dB = b.datetime - layer.currentTime;
      var dA = a.datetime - layer.currentTime;

      if (dB == 0) {
        //b.datetime == layer.currentTime
        layer._currentFile = b;
        layer._currentIndex = i;
        break;
      } else if (dA == 0) {
        //a.datetime == layer.currentTime
        layer._currentFile = a;
        layer._currentIndex = i - 1;
        break;
      } else if (dB < 0) {
        //a.datetime < layer.currentTime < b.datetime 
        dA = Math.abs(dA);
        dB = Math.abs(dB);
        layer._currentFile = dA <= dB ? a : b;
        layer._currentIndex = dA <= dB ? i - 1 : i;
        break;
      }
    }
  }
} //保存上次查询的时间范围


var _startTime, _endTime;

var IHfsFileLayer = /*#__PURE__*/function () {
  /**
   * 
   * @param {HfsFileLoader} fileLoader 
   * @param {{
   *  dir: string;
   *  path: string;
   *  ext: string;
   *  fromDb: boolean;
   *  timeRegex: string;
   * }} options 
   */
  function IHfsFileLayer(fileLoader, options) {
    (0, _classCallCheck2["default"])(this, IHfsFileLayer);
    options = options || {};
    this._fileLoader = fileLoader;
    this.options = Object.assign({
      dir: 'GZData',
      path: '',
      fromDb: false,
      timeRegex: 'yyyyMMddhhmmss'
    }, options);
    /**
     * @type {FileInfo[]}
     */

    this.fileList = [];
    this.timeList = [];
    this.isLoading = false;
    this.earth = null;
    this.colorMap = null;
    this.rectangle = null;
    this.name = '未命名图层';
    this.zIndex = options.zIndex || 3;
    this._currentTime = null;
    /**
     * @type {FileInfo}
     * @private
     */

    this._currentFile = null;
    this._currentIndex = -1;
    this._show = true;
  } //可读可写属性


  (0, _createClass2["default"])(IHfsFileLayer, [{
    key: "currentTime",
    get: function get() {
      return this._currentTime;
    },
    set: function set(val) {
      if (this._currentTime != val) {
        this._currentTime = val;
        setCurrentFile(this);
        this.updateLayer();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      if (this._show != val) {
        this._show = val;
      }
    } //只读属性

  }, {
    key: "currentFile",
    get: function get() {
      return this._currentFile;
    }
  }, {
    key: "channelPath",
    get: function get() {
      return this.options.path;
    }
  }, {
    key: "latestTime",
    get: function get() {
      if (!this.timeList || !this.timeList.length) return null;
      return this.timeList[this.timeList.length - 1];
    }
  }, {
    key: "updateList",
    value: function updateList(startTime, endTime) {
      var _this = this;

      if (this.isLoading) {
        return this._listPromise;
      }

      this.isLoading = true;
      var timeRegex = this.options.timeRegex;

      if (startTime instanceof Date) {
        startTime = startTime.format(timeRegex);
      }

      if (endTime instanceof Date) {
        endTime = endTime.format(timeRegex);
      }

      if (startTime) {
        _startTime = startTime;
      }

      if (endTime) {
        _endTime = endTime;
      }

      this._listPromise = this._fileLoader.getFiles(Object.assign({}, this.options, {
        path: this.channelPath,
        startTime: _startTime,
        endTime: _endTime
      })).then(function (files) {
        //按时间降序排序
        files.sort(function (a, b) {
          return a.datetime - b.datetime;
        });

        _this.fileList.slice(0);

        _this.timeList.slice(0);

        var _iterator = _createForOfIteratorHelper(files),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var file = _step.value;

            _this.fileList.push(file);

            _this.timeList.push(file.datetime);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        _this.isLoading = false;
        _this._listPromise = null;

        _this.onListUpdate(_this);

        return _this;
      })["catch"](function (err) {
        _this.isLoading = false;
        _this._listPromise = null;

        _this.onError(err);
      });
      return this._listPromise;
    }
  }, {
    key: "load",
    value: function load(earth) {
      this.earth = earth;
      return this.updateList();
    } //子类需要实现的接口

  }, {
    key: "updateLayer",
    value: function updateLayer(layer) {}
  }, {
    key: "unload",
    value: function unload(earth) {
      this.earth = null;
      throw new Error('IHfsFileLayer：卸载方法未实现');
    }
  }, {
    key: "onError",
    value: function onError(err) {}
  }, {
    key: "onListUpdate",
    value: function onListUpdate(layer) {}
  }]);
  return IHfsFileLayer;
}();

exports["default"] = IHfsFileLayer;

},{"e_1":235,"s_2":236,"M_0":241}],223:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _HfsFileLoader = _interopRequireDefault(require("h_1048"));

var _IHfsFileLayer2 = _interopRequireDefault(require("-_1049"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * micaps格点格式的EC数值模式图层
 */
// import GridDataImageryProvider from '@mesh-3d/meteolib/Source/Scene/GridDataImageryProvider'
// import RasterImageGenerator from '@mesh-3d/meteolib/Source/Render/RasterImageGenerator'
// import GridData from '@mesh-3d/meteolib/Source/Data/Micaps/GridData'
var _MeteoLib = MeteoLib,
    GridDataImageryProvider = _MeteoLib.GridDataImageryProvider,
    RasterImageGenerator = _MeteoLib.RasterImageGenerator,
    GridData = _MeteoLib.GridData;

function removeImageryLayer(layer) {
  var imageryLayer = layer.imageryLayer,
      earth = layer.earth;

  if (imageryLayer) {
    earth.imageryLayers.remove(imageryLayer);
    imageryLayer.imageryProvider.destroy();
    layer.imageryLayer = null;
  }
}
/**
 * micaps格点格式的EC数值模式图层
 */


var MicapsECLayer = /*#__PURE__*/function (_IHfsFileLayer) {
  (0, _inherits2["default"])(MicapsECLayer, _IHfsFileLayer);

  var _super = _createSuper(MicapsECLayer);

  /**
   *  micaps格点格式的EC数值模式图层
   * @param {HfsFileLoader}  fileLoader
   */
  function MicapsECLayer(fileLoader) {
    var _this;

    (0, _classCallCheck2["default"])(this, MicapsECLayer);
    _this = _super.call(this, fileLoader, {
      dir: 'GZData',
      path: "ECMWF_LR",
      ext: '*.000',
      timeRegex: 'yyyyMMddhh',
      zIndex: 4
    });
    _this._element = 'TMP';
    _this._level = '850';
    _this._forecastTime = '000';
    _this._lastFile = null;
    _this.rectangle = Cesium.Rectangle.fromDegrees(105, 24, 112, 32);
    _this.imageryOptions = {
      // minimumLevel: 1,
      maximumLevel: 6,
      isoLine: true,
      lineColorType: 'single',
      lineColor: 'rgba(40,40,40,0.8)',
      isoValue: true,
      // isoValueColor: Cesium.Color.fromBytes(0, 0, 0),
      // isoValueBackColor: Cesium.Color.TRANSPARENT,
      // isoValueStroke: true,
      // isoValueStrokeWidth: 4,
      // isoValueStrokeColor: Cesium.Color.fromBytes(228, 228, 228),
      // isoValueFontSize: 12,
      // isoValueFontFamily: 'heiti',
      // isoValuePadding: 0,
      point: false,
      maxSamplePointLevel: 6,
      value: false,
      fill: true,
      interpolate: false,
      rectangle: _this.rectangle
    };
    _this.ready = false;
    var deffered = {};
    _this.readyPromise = new Promise(function (resolve, reject) {
      deffered.resolve = resolve;
      deffered.reject = reject;
    });
    _this._deffered = deffered;
    var imageryLayer = null;
    var gridData = new GridData();
    Object.defineProperties((0, _assertThisInitialized2["default"])(_this), {
      gridData: {
        enumerable: false,
        get: function get() {
          return gridData;
        }
      },
      imageryLayer: {
        enumerable: false,
        get: function get() {
          return imageryLayer;
        },
        set: function set(val) {
          imageryLayer = val;
        }
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(MicapsECLayer, [{
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      if (this.imageryLayer) {
        this._show = val;
        this.imageryLayer.show = val;
      }
    }
  }, {
    key: "channelPath",
    get: function get() {
      return [this.options.path, this.element, this.level].join('/');
    } //要素

  }, {
    key: "element",
    get: function get() {
      return this._element;
    },
    set: function set(val) {
      if (this._element != val) {
        this._element = val;
        this.updateList();
      }
    } //层次

  }, {
    key: "level",
    get: function get() {
      return this._level;
    },
    set: function set(val) {
      if (this._level != val) {
        this._level = val;
        this.updateList();
      }
    } //预报时间

  }, {
    key: "forecastTime",
    get: function get() {
      return this._forecastTime;
    },
    set: function set(val) {
      if (this._forecastTime != val) {
        this._forecastTime = val;
        this.options.ext = '*.' + val;
        this.updateList();
      }
    }
  }, {
    key: "showIsoLine",
    get: function get() {
      return this.imageryOptions.isoLine;
    },
    set: function set(val) {
      if (this.imageryOptions.isoLine != val) {
        this.imageryOptions.isoLine = val;
        this.updateImageryLayer();
      }
    }
  }, {
    key: "fill",
    get: function get() {
      return this.imageryOptions.fill;
    },
    set: function set(val) {
      if (this.imageryOptions.fill != val) {
        this.imageryOptions.fill = val;
        this.updateImageryLayer();
      }
    }
  }, {
    key: "interpolate",
    get: function get() {
      return this.imageryOptions.interpolate;
    },
    set: function set(val) {
      if (this.imageryOptions.interpolate != val) {
        this.imageryOptions.interpolate = val;
        this.updateImageryLayer();
      }
    }
  }, {
    key: "clipperLayer",
    get: function get() {
      return this.imageryOptions.clipperLayer;
    },
    set: function set(val) {
      if (val.provider) {
        val = val.provider;
      }

      if (this.imageryOptions.clipperLayer != val) {
        this.imageryOptions.clipperLayer = val;
      }
    }
    /**
     * 基于当前时次的数据重新绘制
     */

  }, {
    key: "updateImageryLayer",
    value: function updateImageryLayer() {
      var imageryLayer = this.imageryLayer,
          earth = this.earth,
          currentFile = this.currentFile;
      /**
      * @type {GridData}
      * @private
      */

      var gridData = this.gridData;
      removeImageryLayer(this);

      if (gridData.familyName) {
        var element = gridData.element;
        /**
         * @type {RasterImageGenerator}
         */

        var imageGenerator = RasterImageGenerator.find(element);
        var colorMap = imageGenerator.colorMap;
        var breaks = [];
        var isolineStartValue = gridData.isolineStartValue,
            isolineEndValue = gridData.isolineEndValue,
            isolineSpace = gridData.isolineSpace;

        for (var num = isolineStartValue; num <= isolineEndValue; num += isolineSpace) {
          breaks.push(num);
        }

        var provider = new GridDataImageryProvider(Object.assign({}, this.imageryOptions, {
          colorMap: colorMap,
          dataArray: gridData.dataArray,
          width: gridData.width,
          height: gridData.height,
          breaks: breaks,
          dataRectangle: Cesium.Rectangle.fromDegrees(gridData.bbox[0], gridData.bbox[1], gridData.bbox[2], gridData.bbox[3])
        }));
        imageryLayer = earth.imageryLayers.addImageryProvider(provider);
        imageryLayer.show = this._show;
        this.name = currentFile.fileName;
        this.colorMap = colorMap;
        this.imageryLayer = imageryLayer; //调整图层顺序

        provider.zIndex = this.zIndex;
        earth.updateOrder();
        this.ready = true;

        this._deffered.resolve(this);
      } else {
        var err = new Error('数据名称为空');
        this.onError(err);
        this.ready = false;

        this._deffered.resolve(err);
      }
    }
  }, {
    key: "updateLayer",
    value: function updateLayer() {
      var _this2 = this;

      var currentFile = this.currentFile;

      if (!currentFile) {
        return;
      }
      /**
       * @type {GridData}
       * @private
       */


      var gridData = this.gridData;

      if (this._lastFile == this.currentFile) {
        this.updateImageryLayer();
      } else {
        var _fileLoader = this._fileLoader;

        _fileLoader.readFile(currentFile).then(function (buf) {
          if (gridData.loadByteArray(buf)) {
            _this2.updateImageryLayer();
          } else {
            _this2.onError(new Error('格点数据解析失败'));
          }
        })["catch"](function (err) {
          removeImageryLayer(_this2);

          _this2.onError(err);

          _this2.ready = false;

          _this2._deffered.resolve(err);
        });
      }
    }
  }, {
    key: "unload",
    value: function unload() {
      removeImageryLayer(this);
    }
  }]);
  return MicapsECLayer;
}(_IHfsFileLayer2["default"]);

exports["default"] = MicapsECLayer;

},{"h_1048":219,"-_1049":222,"s_332":233,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],224:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var turf = _interopRequireWildcard(require("s_1058"));

var _IHfsFileLayer2 = _interopRequireDefault(require("h_1059"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function removeImageryLayer(layer) {
  var imageryLayer = layer.imageryLayer,
      earth = layer.earth;

  if (imageryLayer) {
    earth.imageryLayers.remove(imageryLayer);
    imageryLayer.imageryProvider.destroy();
    layer.imageryLayer = null;
  }
}
/**
    *获取风场符号
    *@param {Number}speed 风速
    *@param {Number}dir 风向
    *@return {Canvas}
    */


function getWindSymbol(speed, dir, layer) {
  var windSymbolType = layer.windSymbolType;
  var level = computeWindLevel(speed);
  var meteoSign = layer.meteoSign;
  var windSymbols = layer.windSymbols;

  if (!windSymbols) {
    windSymbols = {};
  }

  if (!windSymbols[windSymbolType]) {
    windSymbols[windSymbolType] = {};
  }

  layer.windSymbols = windSymbols;

  if (!windSymbols[windSymbolType][level]) {
    var canvas = document.createElement('canvas');
    canvas.width = Cesium.defaultValue(layer.windSymbolSize, 64);
    canvas.height = Cesium.defaultValue(layer.windSymbolSize, 64);
    var ctx = canvas.getContext("2d");

    if (windSymbolType == 'arrow') {
      var percent = level / 12.0;
      var arrowLength = percent * canvas.width;
      var top = canvas.height - arrowLength;
      var left = arrowLength * 0.125;
      var lines = [[{
        x: left,
        y: canvas.height
      }, {
        x: left,
        y: top
      }], [{
        x: left - arrowLength * 0.125,
        y: top + arrowLength * 0.25
      }, {
        x: left,
        y: top
      }], [{
        x: left + arrowLength * 0.125,
        y: top + arrowLength * 0.25
      }, {
        x: left,
        y: top
      }]];
      ctx.lineWidth = layer.meteoSign.lineWidth;
      ctx.strokeStyle = layer.style.fontColor;
      lines.forEach(function (line) {
        ctx.beginPath();
        ctx.moveTo(line[0].x, line[0].y);
        ctx.lineTo(line[1].x, line[1].y);
        ctx.stroke();
      });
    } else {
      var symbol = meteoSign.GetWindCanvas(speed);
      ctx.drawImage(symbol, 0, 0, canvas.width, canvas.height);
    }

    canvas._symbolLeft = left;
    windSymbols[windSymbolType][level] = canvas;
  }

  if (windSymbols[windSymbolType][level]) {
    var symbol = windSymbols[windSymbolType][level]; //"-":canvas的角度顺时针为正，而风向是逆时针为正;
    //风向符号绘制时箭头向上，而micaps格点格式的风向数据，向西为0，向南为90

    var angle = Cesium.Math.toRadians(dir - 180); // + 90);

    if (windSymbolType !== 'arrow') {
      angle += Math.PI;
    }

    var cv = document.createElement('canvas');
    cv.width = symbol.width * 2;
    cv.height = symbol.height * 2;
    var ctx1 = cv.getContext('2d');
    var xpos = cv.width / 2;
    var ypos = cv.height / 2; //旋转图

    ctx1.translate(xpos, ypos);
    ctx1.rotate(angle);
    ctx1.translate(-xpos, -ypos);
    ctx1.drawImage(symbol, xpos - (symbol._symbolLeft ? symbol._symbolLeft : 0), ypos - symbol.height);
    return cv;
  }
}
/** 
     *数据加载并解析完成后，回调此函数，获取站点符号。在外部或子类中重写此函数，可实现自定义站点填图符号
     *@param {Object}station 站点至少包含以下属性，更多要素，参考{@link MeteoLib.Data.Micaps.StationData}中资料代码的注释
     *@param {String}station.stationId 站号
     *@param {String}station.longitude 经度
     *@param {String}station.latitude  纬度
     * @param {MicapsUpAirLayer} layer
     *@return {Image|Canvas}
     */


function getSymbol(station, layer) {
  var _Cesium = Cesium,
      defined = _Cesium.defined,
      Color = _Cesium.Color,
      writeTextToCanvas = _Cesium.writeTextToCanvas;
  var T = station["601"]; //温度

  var H = station["421"]; //位势高度(探空)

  var Q = station["805"]; //湿度

  var TTd = station["803"]; //温度露点差

  var windDir = station["201"]; //风向

  var windSpeed = station["203"]; //风速

  var id = station["stationId"]; //ID

  var Td;

  if (defined(T) && defined(TTd)) {
    Td = T - TTd;
  }

  try {
    if (typeof T != 'undefined') {
      T = T.toFixed(0);
    }

    if (typeof Q != 'undefined') {
      Q = Q.toFixed(0);
    }

    if (typeof TTd != 'undefined') {
      TTd = TTd.toFixed(0);
    }

    if (typeof H != 'undefined') {
      H = H.toFixed(0);
    }

    if (typeof Td != 'undefined') {
      Td = Td.toFixed(0);
    }

    T = Number.pad(T, 4, ' ');
    H = Number.pad(H, 4, ' ');
    Q = Number.pad(Q, 4, ' ');
    TTd = Number.pad(TTd, 4, ' ');
    Td = Number.pad(Td, 4, ' ');
    var style = layer.style;
    var opts = {
      fill: true,
      font: "bold " + style.fontSize + 'px ' + style.fontFamily,
      stroke: style.labelStroke,
      strokeWidth: style.labelStrokeWidth,
      strokeColor: typeof style.labelStrokeColor == 'string' ? Color.fromCssColorString(style.labelStrokeColor) : style.labelStrokeColor,
      fillColor: typeof style.fontColor == 'string' ? Color.fromCssColorString(style.fontColor) : style.fontColor
    };
    opts.fillColor = Color.RED;
    T = writeTextToCanvas(T, opts);
    opts.fillColor = typeof style.fontColor == 'string' ? Color.fromCssColorString(style.fontColor) : style.fontColor;
    H = writeTextToCanvas(H, opts);
    TTd = writeTextToCanvas(TTd, opts);
    Q = writeTextToCanvas(Q, opts);
    Td = writeTextToCanvas(Td, opts);
    id = writeTextToCanvas(id, opts);
    var cv = document.createElement('canvas');
    var width = id.width * 3;
    var height = id.height * 4;
    cv.width = width, cv.height = height;
    var ctx = cv.getContext('2d'); //第一行

    if (T.height) ctx.drawImage(T, width / 3.0 - T.width, 0);
    if (H.height) ctx.drawImage(H, width * 2 / 3.0, 0); //第二行

    if (TTd.height) ctx.drawImage(TTd, width / 3.0 - TTd.width, height / 3.0);
    if (Q.height) ctx.drawImage(Q, width * 2 / 3.0, height / 3.0); //第三行

    if (Td.height) ctx.drawImage(Td, width / 3.0 - Td.width, height * 2 / 3.0);
    ctx.drawImage(id, width * 2 / 3.0, height * 2 / 3.0);

    if (windDir && windSpeed) {
      var wind = getWindSymbol(windSpeed, windDir, layer);
      var newH = Math.max(wind.height, cv.height);
      var newW = Math.max(wind.width, cv.width);
      var newCv = document.createElement("canvas");
      newCv.height = newH;
      newCv.width = newW;
      ctx = newCv.getContext('2d');
      if (cv.width && cv.height) ctx.drawImage(cv, (newW - cv.width) / 2, (newH - cv.height) / 2);
      if (wind.width && wind.height) ctx.drawImage(wind, (newW - wind.width) / 2, (newH - wind.height) / 2); // ctx.drawImage(cv, (newW - cv.width) / 2, (newH - cv.height) / 2);
      // ctx.drawImage(wind,
      //     (newW - wind.width) / 2,
      //     (newH - wind.height) / 2)
    }

    ctx.fillStyle = style.fontColor.toCssColorString();
    ctx.fillRect(ctx.canvas.width / 2 - 2, ctx.canvas.height / 2 - 2, 4, 4);
    return ctx.canvas;
  } catch (e) {
    console.log(e);
  }
}

function computeWindLevel(speed) {
  var level = 1; //1级风

  if (speed <= 1.5) {
    level = 1;
  } //2级风
  else if (speed <= 3.3) {
    level = 2;
  } //3级风
  else if (speed <= 5.4) {
    level = 3;
  } //4级风
  else if (speed <= 7.9) {
    level = 4;
  } //5级风
  else if (speed <= 10.7) {
    level = 5;
  } //6级风
  else if (speed <= 13.8) {
    level = 6;
  } //7级风
  else if (speed <= 17.1) {
    level = 7;
  } //8级风
  else if (speed <= 20.7) {
    level = 8;
  } //9级风
  else if (speed <= 24.4) {
    level = 9;
  } //10级风
  else if (speed <= 28.4) {
    level = 10;
  } //11级风
  else if (speed <= 32.6) {
    level = 11;
  } //12级风
  else {
    level = 12;
  }

  return level;
}
/**
* 站点数据转成geojson
*@param {MeteoLib.Data.Micaps.StationData}stationData
*@return {Geojson}
*/


function toGeojson(stationData, layer) {
  var stationIds = Object.keys(stationData.stationDataMap);
  var pts = [];
  stationIds.forEach(function (id) {
    var st = stationData.stationDataMap[id];
    st.stationId = id;
    st.longitude = st["1"];
    st.latitude = st["2"];
    delete st["1"], delete st['2'];
    st.symbol = getSymbol(st, layer);
    var pt = turf.point([st.longitude, st.latitude], st);
    pts.push(pt);
  });

  if (pts.length > 0) {
    pts = turf.featureCollection(pts);
    pts.name = stationData.description + "_" + stationData.level + stationData.levelDescription;
    return pts;
  }

  return null;
}
/**
 * 高空填图图层
 */


var MicapsUpAirLayer = /*#__PURE__*/function (_IHfsFileLayer) {
  (0, _inherits2["default"])(MicapsUpAirLayer, _IHfsFileLayer);

  var _super = _createSuper(MicapsUpAirLayer);

  function MicapsUpAirLayer(fileLoader) {
    var _this;

    (0, _classCallCheck2["default"])(this, MicapsUpAirLayer);
    _this = _super.call(this, fileLoader, {
      dir: 'LNData',
      path: "UPPER_AIR/PLOT/",
      ext: '*.000',
      timeRegex: 'yyyyMMddhhmmss',
      zIndex: 7
    });
    _this._level = '100';
    _this.ready = false;
    var deffered = {};
    _this.readyPromise = new Promise(function (resolve, reject) {
      deffered.resolve = resolve;
      deffered.reject = reject;
    });
    _this._deffered = deffered;
    var meteoSign = new MeteoLib.MeteoSign();
    /**
     * @type {MeteoLib.MeteoSign}
     */

    _this.meteoSign = meteoSign;
    meteoSign.lineWidth = 3;
    meteoSign.size = 64;
    meteoSign.color = "black";
    _this.style = {
      showLabel: true,
      fontColor: Cesium.Color.BLACK,
      labelStroke: false,
      labelStrokeWidth: 4,
      labelStrokeColor: Cesium.Color.BLACK,
      showMarker: false,
      labelPropertyName: "text",
      outlineColor: Cesium.Color.BLACK
    };
    _this._windSymbolType = "windShaft"; //windShaft,arrow

    _this._windSymbolSize = 32;
    _this.windSymbols = {};
    var _featureCollection = null;
    var imageryLayer = null;

    var _stationData = new MeteoLib.StationData();

    Object.defineProperties((0, _assertThisInitialized2["default"])(_this), {
      _featureCollection: {
        enumerable: false,
        get: function get() {
          return _featureCollection;
        },
        set: function set(val) {
          _featureCollection = val;
        }
      },
      _stationData: {
        enumerable: false,
        get: function get() {
          return _stationData;
        }
      },
      imageryLayer: {
        enumerable: false,
        get: function get() {
          return imageryLayer;
        },
        set: function set(val) {
          imageryLayer = val;
        }
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(MicapsUpAirLayer, [{
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      if (this.imageryLayer) {
        this._show = val;
        this.imageryLayer.show = val;
      }
    }
  }, {
    key: "channelPath",
    get: function get() {
      return this.options.path + this.level;
    }
  }, {
    key: "level",
    get: function get() {
      return this._level;
    },
    set: function set(val) {
      if (this._level != val) {
        this._level = val;
        this.updateList();
      }
    }
  }, {
    key: "windSymbolType",
    get: function get() {
      return this._windSymbolType;
    },
    set: function set(val) {
      if (this._windSymbolType != val) {
        this._windSymbolType = val;
        this.windSymbols = {};
        this.updateImageryLayer();
      }
    }
  }, {
    key: "windSymbolSize",
    get: function get() {
      return this._windSymbolSize;
    },
    set: function set(val) {
      if (this._windSymbolSize != val) {
        this._windSymbolSize = val;
        this.windSymbols = {};
        this.updateImageryLayer();
      }
    }
  }, {
    key: "symbolSize",
    get: function get() {
      return this.meteoSign.size;
    },
    set: function set(val) {
      if (this.meteoSign.size != val) {
        this.meteoSign.size = val;
        this.windSymbols = {};
        this.updateImageryLayer();
      }
    }
  }, {
    key: "updateImageryLayer",
    value: function updateImageryLayer() {
      var imageryLayer = this.imageryLayer,
          earth = this.earth,
          currentFile = this.currentFile;
      /**
       * @type {MeteoLib.StationData}
       * @private
       */

      var stationData = this._stationData;
      var fcs = toGeojson(stationData, this);
      this._featureCollection = fcs;

      if (fcs && fcs.features.length > 1) {
        var provider = new CesiumVectorTile.VectorTileImageryProvider({
          source: fcs,
          defaultStyle: this.style,
          minimumLevel: 3,
          styleFilter: function styleFilter(feature, style) {
            if (feature.properties.lineWidth) {
              style.lineWidth = feature.properties.lineWidth;
            } else if (Cesium.defined(feature.properties.symbol)) {
              style.markerImage = feature.properties.symbol;

              if (style.markerImage) {
                style.pointSize = 64;
                style.showMarker = true;
              } else {
                style.showMarker = false;
              }
            }

            return style;
          }
        });
        imageryLayer = earth.imageryLayers.addImageryProvider(provider);
        imageryLayer.show = this._show;
        this.name = currentFile.fileName;
        this.imageryLayer = imageryLayer; //调整图层顺序

        provider.zIndex = this.zIndex;
        earth.updateOrder();
        this.ready = true;

        this._deffered.resolve(this);
      } else {
        this.error(new Error("高空填图数据文件为空，不包含任何站点数据"));
        return;
      }
    }
  }, {
    key: "updateLayer",
    value: function updateLayer() {
      var _this2 = this;

      var currentFile = this.currentFile;

      if (!currentFile) {
        return;
      }
      /**
       * @type {MeteoLib.StationData}
       * @private
       */


      var stationData = this._stationData;

      if (this._lastFile == this.currentFile) {
        this.updateImageryLayer();
      } else {
        var _fileLoader = this._fileLoader;

        _fileLoader.readFile(currentFile).then(function (buf) {
          if (stationData.loadByteArray(buf)) {
            _this2.updateImageryLayer();
          } else {
            _this2.onError(new Error('高空填图数据解析失败'));
          }
        })["catch"](function (err) {
          removeImageryLayer(_this2);

          _this2.onError(err);

          _this2.ready = false;

          _this2._deffered.resolve(err);
        });
      }
    }
  }, {
    key: "unload",
    value: function unload() {
      removeImageryLayer(this);
    }
  }]);
  return MicapsUpAirLayer;
}(_IHfsFileLayer2["default"]);

exports["default"] = MicapsUpAirLayer;

},{"s_1058":214,"h_1059":222,"s_332":233,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242,"M_110":245}],225:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _HfsFileLoader = _interopRequireDefault(require("h_1048"));

var _IHfsFileLayer2 = _interopRequireDefault(require("-_1049"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * 单站雷达PUP产品图层
 */
// import PupProductFormat from '@mesh-3d/meteolib/Source/Data/PUP/PupProductFormat'
// import RasterImageGenerator from '@mesh-3d/meteolib/Source/Render/RasterImageGenerator'
// import CoordinateHelper from '@mesh-3d/meteolib/Source/Data/Radar/CoordinateHelper';
// import MyLatLng from '@mesh-3d/meteolib/Source/Data/Radar/MyLatLng'
var _MeteoLib = MeteoLib,
    PupProductFormat = _MeteoLib.PupProductFormat,
    RasterImageGenerator = _MeteoLib.RasterImageGenerator,
    CoordinateHelper = _MeteoLib.CoordinateHelper,
    MyLatLng = _MeteoLib.MyLatLng;

function removeImageryLayer(layer) {
  var imageryLayer = layer.imageryLayer,
      earth = layer.earth;

  if (imageryLayer) {
    earth.imageryLayers.remove(imageryLayer);
    imageryLayer.imageryProvider.destroy();
    layer.imageryLayer = null;
  }
}
/**
 * 获取产品名称
 * @param {*}} code 
 * @returns 
 */


function getDataName(code) {
  //基本反射率  19  /R/19
  //基本反射率  20  /R/20
  //基本速度    26  /V/26
  //基本速度    27  /V/27
  //组合反射率  37  /CR/37
  //组合反射率  38  /CR/38
  //回波顶高    41  /ET/41
  //风廓线      48  /VWP/48
  //风暴相对平均径向速度 56 /SRM/56
  //垂直积分液态含水量  57 /VIL/57
  //风暴追踪信息    58  /STI/58
  //冰雹指数        59  /HI/59 
  //中尺度气旋      60  /M/60
  //龙卷漩涡特征    61  /TVS/61
  //一小时累积降水  78  /OHP/78
  //三小时累积降水  79  /THP/79
  //风暴总累计降水  80  /STP/80
  //CAPPI反射率     110 /CAR/110
  var dataName = "";

  switch (code) {
    case 36:
    case 37:
    case 38:
      dataName = "CR";
      break;

    case 41:
      dataName = "ET";
      break;

    case 57:
      dataName = "VIL";
      break;

    default:
      return undefined;
  }

  return dataName;
}
/**
 * 获取产品分辨率，单位为km
 * @param {*} code 
 * @returns 
 */


function getResolution(code) {
  switch (code) {
    case 37:
      return 0.54;

    case 36:
    case 38:
    case 41:
    case 57:
      return 2.2;

    default:
      return undefined;
  }
}
/**
* 雷达局部坐标转经纬高度（等距离投影时使用）
* @param {any} centerWC
* @param {any} srcLC
* @param {any} resultCartographic
*@private
*/


function radarCoordinatesToCartographicEquidistance(centerWC, srcLC, ellipsoid, resultCartographic) {
  var _Cesium = Cesium,
      Cartographic = _Cesium.Cartographic,
      Ellipsoid = _Cesium.Ellipsoid,
      _Math = Cesium.Math;

  if (ellipsoid instanceof Cartographic) {
    resultCartographic = ellipsoid;
    ellipsoid = null;
  }

  if (!ellipsoid) {
    ellipsoid = Ellipsoid.WGS84;
  }

  if (!resultCartographic) {
    resultCartographic = new Cartographic();
  }

  resultCartographic = Cartographic.fromCartesian(centerWC);
  var cn = new MyLatLng(_Math.toDegrees(resultCartographic.longitude), _Math.toDegrees(resultCartographic.latitude));
  var length = Math.sqrt(Math.pow(srcLC.x, 2) + Math.pow(srcLC.y, 2));

  var angle = _Math.toDegrees(Math.atan2(srcLC.x, srcLC.y));

  var lonlat = CoordinateHelper.getMyLatLng(cn, length / 1000.0, angle);
  resultCartographic.longitude = _Math.toRadians(lonlat.m_Longitude);
  resultCartographic.latitude = _Math.toRadians(lonlat.m_Latitude);
  resultCartographic.height = 0;
  return resultCartographic;
}
/**
 * 计算产品四至范围
 * @param {*} pupProduct 
 * @returns 
 */


function computeViewRectangle(pupProduct) {
  var _Cesium2 = Cesium,
      Cartesian3 = _Cesium2.Cartesian3,
      Rectangle = _Cesium2.Rectangle,
      _Math = Cesium.Math;
  var packet = pupProduct.productSymbology.layers[0].packets[0];
  var width = packet.numberOfRows,
      height = width;
  var cnLon = pupProduct.productDescription.longitude;
  var cnLat = pupProduct.productDescription.latitude;
  var cnH = pupProduct.productDescription.height * 0.3048; //英尺转米

  var res = getResolution(pupProduct.msgHeader.code);
  var xDistance = width * res / 4 + 36,
      yDistance = height * res / 4 + 30;
  var cn = Cartesian3.fromDegrees(cnLon, cnLat, cnH);
  var west = 190,
      south = 190,
      east = -190,
      north = -190;
  var xs = [xDistance, -xDistance];
  var ys = [yDistance, -yDistance];

  for (var i = 0; i < xs.length; i++) {
    for (var j = 0; j < ys.length; j++) {
      var lc = new Cartesian3(xs[i] * 1000, ys[j] * 1000, 0);
      var lonlat = radarCoordinatesToCartographicEquidistance(cn, lc);
      west = Math.min(west, lonlat.longitude);
      east = Math.max(east, lonlat.longitude);
      south = Math.min(south, lonlat.latitude);
      north = Math.max(north, lonlat.latitude);
    }
  }

  return new Rectangle(west, south, east, north);
}
/**
 * 获取产品图生成工具
 * @param {*} code 
 * @returns 
 */


function getImageGenerator(code) {
  var dataName = getDataName(code);
  var imageGenerator = null;

  if (dataName == "CR") {
    imageGenerator = RasterImageGenerator.Radar.R;
  } else if (dataName == "ET") {
    imageGenerator = RasterImageGenerator.Radar.ET;
  } else if (dataName == "VIL") {
    imageGenerator = RasterImageGenerator.Radar.VIL;
  }

  return imageGenerator;
}
/**
 * 单站雷达PUP产品图层
 */


var PUPRadarLayer = /*#__PURE__*/function (_IHfsFileLayer) {
  (0, _inherits2["default"])(PUPRadarLayer, _IHfsFileLayer);

  var _super = _createSuper(PUPRadarLayer);

  /**
   * 单站雷达PUP产品图层
   * @param {HfsFileLoader}  fileLoader
   */
  function PUPRadarLayer(fileLoader) {
    var _this;

    (0, _classCallCheck2["default"])(this, PUPRadarLayer);
    _this = _super.call(this, fileLoader, {
      dir: 'GZData',
      path: "SINGLERADAR/PRODUCTS",
      ext: '*.851',
      zIndex: 6,
      timeRegex: 'yyyyMMdd.hhmmss'
    });
    _this._station = '贵阳';
    _this._prodCode = 'CR/38';

    var _pupProduct = new PupProductFormat();

    _this.ready = false;
    var deffered = {};
    _this.readyPromise = new Promise(function (resolve, reject) {
      deffered.resolve = resolve;
      deffered.reject = reject;
    });
    _this._deffered = deffered;
    var imageryLayer = null;
    Object.defineProperties((0, _assertThisInitialized2["default"])(_this), {
      _pupProduct: {
        enumerable: false,
        get: function get() {
          return _pupProduct;
        }
      },
      imageryLayer: {
        enumerable: false,
        get: function get() {
          return imageryLayer;
        },
        set: function set(val) {
          imageryLayer = val;
        }
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(PUPRadarLayer, [{
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      if (this.imageryLayer) {
        this._show = val;
        this.imageryLayer.show = val;
      }
    }
  }, {
    key: "channelPath",
    get: function get() {
      return [this.options.path, this.station, this.prodCode].join('/');
    } //雷达站点名称

  }, {
    key: "station",
    get: function get() {
      return this._station;
    },
    set: function set(val) {
      if (this._station != val) {
        this._station = val;
        this.updateList();
      }
    }
    /**
     * 产品代码:
     * * 组合反射率： CR/38
     * * 回波顶高：ET/41
     * * 垂直积分液态含水量：VIL/57
     */

  }, {
    key: "prodCode",
    get: function get() {
      return this._prodCode;
    },
    set: function set(val) {
      if (this._prodCode != val) {
        this._prodCode = val;
        this.updateList();
      }
    }
    /**
     * 基于当前时次的数据重新绘制
     */

  }, {
    key: "updateImageryLayer",
    value: function updateImageryLayer() {
      var imageryLayer = this.imageryLayer,
          earth = this.earth,
          currentFile = this.currentFile;
      /**
       * @type {PupProductFormat}
       * @private
       */

      var pupProduct = this._pupProduct;
      removeImageryLayer(this);
      /**
       * @type {RasterImageGenerator}
       */

      var imageGenerator = getImageGenerator(pupProduct.msgHeader.code);
      var colorMap = imageGenerator.colorMap;
      var rectangle = computeViewRectangle(pupProduct);
      var packet = pupProduct.productSymbology.layers[0].packets[0];
      var width = packet.numberOfRows,
          height = width;
      var data = packet.colorCodes;
      var oldSelectColorByIndex = imageGenerator.selectColorByIndex;
      imageGenerator.selectColorByIndex = true;
      var image = imageGenerator.generate(data, width, height);
      imageGenerator.selectColorByIndex = oldSelectColorByIndex;
      var provider = new Cesium.SingleTileImageryProvider({
        url: image,
        rectangle: rectangle
      });
      imageryLayer = earth.imageryLayers.addImageryProvider(provider);
      imageryLayer.show = this._show;
      this.name = currentFile.fileName;
      this.colorMap = colorMap;
      this.imageryLayer = imageryLayer; //调整图层顺序

      provider.zIndex = this.zIndex;
      earth.updateOrder();
      this.ready = true;

      this._deffered.resolve(this);
    }
  }, {
    key: "updateLayer",
    value: function updateLayer() {
      var _this2 = this;

      var currentFile = this.currentFile;

      if (!currentFile) {
        return;
      }
      /**
       * @type {PupProductFormat}
       * @private
       */


      var pupProduct = this._pupProduct;

      if (this._lastFile == this.currentFile) {
        this.updateImageryLayer();
      } else {
        var _fileLoader = this._fileLoader;

        _fileLoader.readFile(currentFile).then(function (buf) {
          if (pupProduct.loadByteArray(buf)) {
            _this2.updateImageryLayer();
          } else {
            _this2.onError(new Error('PUP雷达产品数据解析失败'));
          }
        })["catch"](function (err) {
          removeImageryLayer(_this2);

          _this2.onError(err);

          _this2.ready = false;

          _this2._deffered.resolve(err);
        });
      }
    }
  }, {
    key: "unload",
    value: function unload() {
      removeImageryLayer(this);
    }
  }]);
  return PUPRadarLayer;
}(_IHfsFileLayer2["default"]);

exports["default"] = PUPRadarLayer;

},{"h_1048":219,"-_1049":222,"s_332":233,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],226:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _HfsFileLoader = _interopRequireDefault(require("h_1048"));

var _IHfsFileLayer2 = _interopRequireDefault(require("-_1049"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * 卫星云图图层
 */
// import AwxSateImageryProvider from "@mesh-3d/meteolib/Source/Scene/AwxSateImageryProvider";
var _MeteoLib = MeteoLib,
    AwxSateImageryProvider = _MeteoLib.AwxSateImageryProvider;

var SateCloudLayer = /*#__PURE__*/function (_IHfsFileLayer) {
  (0, _inherits2["default"])(SateCloudLayer, _IHfsFileLayer);

  var _super = _createSuper(SateCloudLayer);

  /**
   *   
   * @param {HfsFileLoader}  fileLoader
   */
  function SateCloudLayer(fileLoader) {
    var _this;

    (0, _classCallCheck2["default"])(this, SateCloudLayer);
    _this = _super.call(this, fileLoader, {
      dir: 'GZData',
      path: "SATELLITE/FY4A/L1/CHINA/",
      ext: '*.awx',
      zIndex: 2
    });
    _this._channel = 'C001';
    _this.ready = false;
    var deffered = {};
    _this.readyPromise = new Promise(function (resolve, reject) {
      deffered.resolve = resolve;
      deffered.reject = reject;
    });
    _this._deffered = deffered;
    var imageryLayer = null;
    Object.defineProperties((0, _assertThisInitialized2["default"])(_this), {
      imageryLayer: {
        enumerable: false,
        get: function get() {
          return imageryLayer;
        },
        set: function set(val) {
          imageryLayer = val;
        }
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(SateCloudLayer, [{
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      if (this.imageryLayer) {
        this._show = val;
        this.imageryLayer.show = val;
      }
    }
  }, {
    key: "channelPath",
    get: function get() {
      return this.options.path + this.channel;
    }
    /**
     * 可见光：C002
     * 红外：C012
     * 水汽：C008
     */

  }, {
    key: "channel",
    get: function get() {
      return this._channel;
    },
    set: function set(val) {
      if (this._channel != val) {
        this._channel = val;
        this.updateList();
      }
    }
  }, {
    key: "updateLayer",
    value: function updateLayer() {
      var _this2 = this;

      var currentFile = this._currentFile;

      if (!currentFile) {
        return;
      }

      var imageryLayer = this.imageryLayer,
          earth = this.earth,
          channelPath = this.channelPath,
          options = this.options;

      if (imageryLayer) {
        earth.imageryLayers.remove(imageryLayer);
        imageryLayer.imageryProvider.destroy();
        this.imageryLayer = imageryLayer = null;
      }

      var fileName = currentFile.fileName;
      var iPrvovider = new AwxSateImageryProvider({
        url: this._fileLoader.hfs.getUrl({
          dir: options.dir,
          path: channelPath
        }),
        fileName: fileName
      });
      imageryLayer = earth.imageryLayers.addImageryProvider(iPrvovider);
      imageryLayer.show = this._show;
      iPrvovider.readyPromise.then(function () {
        var imageGenerator = iPrvovider.imageGenerator;
        _this2.colorMap = imageGenerator.colorMap;
        _this2.rectangle = iPrvovider._dataRectangle;
        _this2.ready = true;

        _this2._deffered.resolve(_this2);
      }).otherwise(function (reason) {
        _this2._deffered.reject(reason);
      });
      this.imageryLayer = imageryLayer;
      this.name = currentFile.fileName; //调整图层顺序

      iPrvovider.zIndex = this.zIndex;
      earth.updateOrder();
    }
  }, {
    key: "unload",
    value: function unload() {
      var imageryLayer = this.imageryLayer,
          earth = this.earth;

      if (imageryLayer) {
        earth.imageryLayers.remove(imageryLayer);
        imageryLayer.imageryProvider.destroy();
        imageryLayer = null;
      }
    }
  }]);
  return SateCloudLayer;
}(_IHfsFileLayer2["default"]);

exports["default"] = SateCloudLayer;

},{"h_1048":219,"-_1049":222,"s_332":233,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],227:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _IHfsFileLayer2 = _interopRequireDefault(require("-_1049"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * 地面监测要素图层
 */
// import { GridDataImageryProvider,RasterImageGenerator, Interpolate } from "@mesh-3d/meteolib-wdv";
var _MeteoLib = MeteoLib,
    GridDataImageryProvider = _MeteoLib.GridDataImageryProvider,
    RasterImageGenerator = _MeteoLib.RasterImageGenerator,
    Interpolate = _MeteoLib.Interpolate,
    GridDataColorMap = _MeteoLib.GridDataColorMap;

/**
 * 
 * @param {object[]} dataset 
 */
function computeBBox(dataset) {
  var bbox = [180, 90, -180, -90];

  var _iterator = _createForOfIteratorHelper(dataset),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var row = _step.value;
      var Lon = row.Lon,
          Lat = row.Lat;
      bbox[0] = Math.min(Lon, bbox[0]);
      bbox[1] = Math.min(Lat, bbox[1]);
      bbox[2] = Math.max(Lon, bbox[2]);
      bbox[3] = Math.max(Lat, bbox[3]);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return bbox;
}

function updateInterpDataset(dataset, fieldName, bbox, numX, numY) {
  var xs = [],
      ys = [],
      vals = [];
  dataset.forEach(function (data) {
    var lon = parseFloat(data.Lon),
        lat = parseFloat(data.Lat);
    var v = parseFloat(data[fieldName]);
    xs.push(lon);
    ys.push(lat);
    vals.push(v);
  });
  var s = [xs, ys, vals];
  var gridXY = Interpolate.CreateGridXY_Num(bbox[0], bbox[1], bbox[2], bbox[3], numX, numY);
  var result = Interpolate.Interpolation_IDW_Neighbor(s, gridXY[0], gridXY[1], 8);
  result.reverse();
  var dataArray = new Float32Array(numX * numY);
  var idx = 0;

  for (var i = 0; i < numY; i++) {
    for (var j = 0; j < numX; j++) {
      var v = result[i][j];
      dataArray[idx++] = v;
    }
  }

  return dataArray;
}

function removePointsLayer(layer) {
  var points = layer.points,
      earth = layer.earth;

  while (points.length) {
    var entity = points.shift();
    earth.entities.remove(entity);
  }
}

function removeImageryLayer(layer) {
  var imageryLayer = layer.imageryLayer,
      earth = layer.earth;

  if (imageryLayer) {
    earth.imageryLayers.remove(imageryLayer);
    imageryLayer.imageryProvider.destroy();
    layer.imageryLayer = null;
  }
}
/**
 * 地面监测要素图层
 */


var SurfLayer = /*#__PURE__*/function (_IHfsFileLayer) {
  (0, _inherits2["default"])(SurfLayer, _IHfsFileLayer);

  var _super = _createSuper(SurfLayer);

  function SurfLayer(fileLoader) {
    var _this;

    (0, _classCallCheck2["default"])(this, SurfLayer);
    _this = _super.call(this, fileLoader, {
      dir: 'GZData',
      path: 'surf',
      ext: '*.json',
      timeRegex: 'yyyyMMddhhmmss',
      zIndex: 8
    });
    _this._element = "MAX_PRE_1h";
    _this._textField = "Station_Name";
    _this._interpWidth = 256;
    _this._interpHeight = 256; //色斑图和等值线显示配置

    _this.imageryOptions = {
      // clipperLayer: clipperLayer,
      zIndex: 9,
      //原始数据点显示设置
      point: false,
      pointSize: 2,
      pointColor: Cesium.Color.fromBytes(128, 128, 128),
      pointDensity: 5,
      //指示点的密度，值越大越稀疏
      maximumPointDensity: 8,
      //指示当自动分级（pointDensity为0或者不设置）时点的密度，值越大越稀疏
      //原始数据点数值显示设置
      value: false,
      valueColor: Cesium.Color.fromBytes(128, 128, 128),
      valueBackColor: Cesium.Color.TRANSPARENT,
      valueStroke: true,
      valueStrokeWidth: 1,
      valueStrokeColor: Cesium.Color.WHITE,
      valueFontSize: 9,
      //valueFontFamily: 'kaiti',
      valuePadding: 0,
      //等值线数值显示设置
      isoValue: true,
      isoValueColor: Cesium.Color.fromBytes(0, 0, 0),
      isoValueBackColor: Cesium.Color.TRANSPARENT,
      isoValueStroke: true,
      isoValueStrokeWidth: 4,
      isoValueStrokeColor: Cesium.Color.fromBytes(228, 228, 228),
      isoValueFontSize: 12,
      isoValueFontFamily: 'heiti',
      isoValuePadding: 0,
      //等值线显示设置
      isoLine: true,
      // lineColor: Cesium.Color.WHITE,
      lineWidth: 1,
      lineDash: [5, 0, 5, 0],
      //虚线样式，不设置则为实线
      lineColorType: "single",
      //栅格色斑图数据显示设置
      fill: true,
      // colorMap: this._colorMap,
      interpolate: true,
      // dataArray: dataArray,
      // width: width,
      // height: height,
      // breaks: breaks,
      maximumLevel: 8 // rectangle: rectangle

    }; //点显示配置

    _this._showPoint = true;
    _this._showText = false;
    _this._showValue = true;
    _this._pointGraphics = {
      pixelSize: 10,
      outlineWidth: 1.5
    };
    _this._labelGraphics = {
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      font: '20px sans-serif',
      fillColor: Cesium.Color.BLACK,
      pixelOffset: new Cesium.Cartesian2(0, -8)
    };
    _this._disableDepthTestDistance = null;
    _this.ready = false;
    var deffered = {};
    _this.readyPromise = new Promise(function (resolve, reject) {
      deffered.resolve = resolve;
      deffered.reject = reject;
    });
    _this._deffered = deffered;
    var imageGeneratorPRE = new RasterImageGenerator({
      name: 'PRE',
      colorMap: [[-0.99999, 1, [212, 255, 192, 255], '0~1'], [1, 2, [166, 240, 145, 255], '1~2'], [2, 4, [59, 166, 10, 255], '2~4'], [4, 6, [94, 182, 254, 255], '4~6'], [6, 8, [0, 2, 245, 255], '6~8'], [8, 10, [2, 112, 75, 255], '8~10'], [10, 20, [254, 1, 242, 255], '10~20'], [20, 50, [218, 79, 12, 255], '20~50'], [50, 65535, [120, 1, 0, 255], '>50']]
    });
    var imageGeneratorRHU = new RasterImageGenerator({
      name: 'RHU',
      colorMap: [[-20, 0, [213, 6, 55, 255], '-20~0'], [0, 10, [231, 0, 0, 255], '0~10'], [10, 20, [252, 38, 3, 255], '10~20'], [20, 30, [247, 79, 20, 255], '20~30'], [30, 40, [249, 250, 212, 255], '30~40'], [40, 50, [238, 252, 202, 255], '40~50'], [50, 60, [64, 73, 202, 255], '50~60'], [60, 70, [84, 64, 182, 255], '60~70'], [70, 80, [70, 33, 164, 255], '70~80'], [80, 90, [51, 13, 128, 255], '80~90'], [90, 100, [8, 0, 0, 255], '90~100']]
    });
    var imageGeneratorTEM = new RasterImageGenerator({
      name: 'TEM',
      colorMap: [[-66666666, -30, [0, 0, 255, 255], '<-30'], [-30, -28, [0, 20, 255, 255], '-30~-28'], [-28, -24, [0, 70, 255, 255], '-28~-24'], [-24, -22, [0, 100, 255, 255], '-24~-22'], [-22, -20, [0, 170, 255, 255], '-22~-20'], [-20, -18, [0, 200, 255, 255], '-20~-18'], [-18, -16, [0, 230, 255, 255], '-18~-16'], [-16, -14, [0, 255, 245, 255], '-16~-14'], [-14, -12, [0, 255, 215, 255], '-14~-12'], [-12, -10, [0, 255, 175, 255], '-12~-10'], [-10, -8, [0, 255, 145, 255], '-10~-8'], [-8, -6, [0, 255, 110, 255], '-8~-6'], [-6, -4, [0, 255, 80, 255], '-6~-4'], [-4, -2, [0, 255, 45, 255], '-4~-2'], [-2, 0, [0, 255, 15, 255], '-2~0'], [0, 2, [20, 255, 0, 255], '0~2'], [2, 4, [50, 255, 0, 255], '2~4'], [4, 6, [90, 255, 0, 255], '4~6'], [6, 8, [120, 255, 0, 255], '6~8'], [8, 10, [155, 255, 0, 255], '8~10'], [10, 12, [185, 255, 0, 255], '10~ 12'], [12, 14, [220, 255, 0, 255], '12~14'], [14, 16, [255, 255, 0, 255], '14~16'], [16, 18, [255, 225, 0, 255], '16~ 18'], [18, 20, [255, 195, 0, 255], '18~20'], [20, 22, [255, 160, 0, 255], '20~ 22'], [22, 24, [255, 130, 0, 255], '20~ 22'], [24, 26, [255, 100, 0, 255], '24~ 26'], [26, 28, [255, 65, 0, 255], '26~ 28'], [28, 30, [255, 45, 0, 255], '28~ 30'], [30, 33, [255, 37, 0, 255], '30~ 33'], [33, 35, [255, 20, 0, 255], '33~35'], [35, 666666666, [255, 0, 0, 255], '35>']]
    });

    var imageryLayer = null,
        _dataset,
        _dataArray,
        points = [];

    Object.defineProperties((0, _assertThisInitialized2["default"])(_this), {
      _dataArray: {
        enumerable: false,
        get: function get() {
          return _dataArray;
        },
        set: function set(val) {
          _dataArray = val;
        }
      },
      _dataset: {
        enumerable: false,
        get: function get() {
          return _dataset;
        },
        set: function set(val) {
          _dataset = val;
        }
      },
      imageGenerator: {
        get: function get() {
          var imageGenerator = imageGeneratorPRE;

          switch (this._element) {
            case 'TEM':
              imageGenerator = imageGeneratorTEM;
              break;

            case 'RHU':
              imageGenerator = imageGeneratorRHU;
              break;

            default:
              break;
          }

          imageGenerator.ready = true;
          return imageGenerator;
        }
      },
      imageryLayer: {
        enumerable: false,
        get: function get() {
          return imageryLayer;
        },
        set: function set(val) {
          imageryLayer = val;
        }
      },
      points: {
        enumerable: false,
        get: function get() {
          return points;
        }
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(SurfLayer, [{
    key: "element",
    get: function get() {
      return this._element;
    },
    set: function set(val) {
      if (this._element != val) {
        this._element = val;
        this.updateImageryLayer();
      }
    }
  }, {
    key: "showIsoLine",
    get: function get() {
      return this.imageryOptions.isoLine;
    },
    set: function set(val) {
      if (this.imageryOptions.isoLine != val) {
        this.imageryOptions.isoLine = val;
        this.updateImageryLayer();
      }
    }
  }, {
    key: "fill",
    get: function get() {
      return this.imageryOptions.fill;
    },
    set: function set(val) {
      if (this.imageryOptions.fill != val) {
        this.imageryOptions.fill = val;
        this.updateImageryLayer();
      }
    }
  }, {
    key: "showPoint",
    get: function get() {
      return this._showPoint;
    },
    set: function set(val) {
      if (this._showPoint != val) {
        this._showPoint = val;
        this.points.forEach(function (pt) {
          pt.point.show = val;
        });
      }
    }
  }, {
    key: "showText",
    get: function get() {
      return this._showText;
    },
    set: function set(val) {
      if (this._showText != val) {
        this._showText = val;
        this.updatePointLayer();
      }
    }
  }, {
    key: "showValue",
    get: function get() {
      return this._showValue;
    },
    set: function set(val) {
      if (this._showValue != val) {
        this._showValue = val;
        this.updatePointLayer();
      }
    }
  }, {
    key: "textField",
    get: function get() {
      return this._textField;
    },
    set: function set(val) {
      if (this._textField != val) {
        this._textField = val;
        this.updatePointLayer();
      }
    }
  }, {
    key: "updatePointLayer",
    value: function updatePointLayer() {
      var _Cesium = Cesium,
          defined = _Cesium.defined,
          Cartesian3 = _Cesium.Cartesian3,
          Color = _Cesium.Color;
      var earth = this.earth;
      /**
       * @type {RasterImageGenerator}
       */

      var imageGenerator = this.imageGenerator;
      var colorMap = imageGenerator.colorMap;
      var pointGraphics = this._pointGraphics,
          labelGraphics = this._labelGraphics,
          pointVisible = this._showPoint,
          textVisible = this._showText,
          valueVisible = this._showValue,
          valueField = this.element,
          textField = this.textField,
          disableDepthTestDistance = this._disableDepthTestDistance;
      var points = this.points;

      while (points.length) {
        var entity = points.shift();
        earth.entities.remove(entity);
      }

      this._dataset.DS.forEach(function (data) {
        var lon = parseFloat(data.Lon),
            lat = parseFloat(data.Lat);
        var v = parseFloat(data[valueField]);
        var color = GridDataColorMap.getColor(v, colorMap);
        color = Color.fromBytes.apply(null, color);
        var point = Object.assign(pointGraphics, {
          color: color,
          show: pointVisible,
          disableDepthTestDistance: disableDepthTestDistance
        });
        var label = Object.assign(labelGraphics, {
          text: "",
          disableDepthTestDistance: disableDepthTestDistance
        });

        if (textVisible && textField && defined(data[textField])) {
          label.text += data[textField] + "\r\n";
        }

        if (valueVisible && valueField && defined(data[valueField])) {
          label.text += data[valueField];
        }

        label.show = textVisible || valueVisible;
        var pt = earth.entities.add({
          position: Cartesian3.fromDegrees(lon, lat),
          point: point,
          label: label
        });
        pt.stationData = data;
        points.push(pt);
      });
    }
    /**
     * 基于当前时次的数据重新绘制
     */

  }, {
    key: "updateImageryLayer",
    value: function updateImageryLayer() {
      var imageryLayer = this.imageryLayer,
          earth = this.earth,
          currentFile = this.currentFile;
      removeImageryLayer(this);
      /**
       * @type {RasterImageGenerator}
       */

      var imageGenerator = this.imageGenerator;
      var colorMap = imageGenerator.colorMap;
      var bbox = this.bbox;
      var rectangle = Cesium.Rectangle.fromDegrees(bbox[0], bbox[1], bbox[2], bbox[3]);
      var breaks = []; //生成等值线数值

      for (var index = 1; index < colorMap.length; index++) {
        var item = colorMap[index];
        breaks.push(item[0]);
      }

      var provider = new GridDataImageryProvider(Object.assign({}, this.imageryOptions, {
        colorMap: colorMap,
        dataArray: this._dataArray,
        width: this._interpWidth,
        height: this._interpHeight,
        breaks: breaks,
        dataRectangle: rectangle
      }));
      imageryLayer = earth.imageryLayers.addImageryProvider(provider);
      imageryLayer.show = this._show;
      this.name = currentFile.fileName;
      this.colorMap = colorMap;
      this.imageryLayer = imageryLayer; //调整图层顺序

      provider.zIndex = this.zIndex;
      earth.updateOrder();
      this.ready = true;

      this._deffered.resolve(this);
    }
  }, {
    key: "updateLayer",
    value: function updateLayer() {
      var _this2 = this;

      var currentFile = this.currentFile;

      if (!currentFile) {
        return;
      }

      this.ready = false;

      if (this._lastFile == this.currentFile) {
        this.updateImageryLayer();
        this.updatePointLayer();
      } else {
        var _fileLoader = this._fileLoader;

        _fileLoader.readFile(currentFile, {
          responseType: 'json'
        }).then(function (dataset) {
          _this2._dataset = dataset;
          var bbox = computeBBox(dataset.DS);
          _this2._dataArray = updateInterpDataset(dataset.DS, _this2.element, bbox, _this2._interpWidth, _this2._interpWidth);
          _this2.bbox = bbox;

          if (_this2.imageGenerator.ready) {
            _this2.updateImageryLayer();

            _this2.updatePointLayer();
          } else {
            return new Promise(function (resolve, rejcect) {
              _this2.imageGenerator.readyPromise.then(function () {
                _this2.updateImageryLayer();

                _this2.updatePointLayer();

                resolve();
              }).otherwise(rejcect);
            });
          }
        })["catch"](function (err) {
          console.error(err);
          removeImageryLayer(_this2);
          removePointsLayer(_this2);

          _this2.onError(err);

          _this2.ready = false;

          _this2._deffered.resolve(err);
        });
      }
    }
  }, {
    key: "unload",
    value: function unload() {
      removeImageryLayer(this);
      removePointsLayer(this);
    }
  }]);
  return SurfLayer;
}(_IHfsFileLayer2["default"]);

exports["default"] = SurfLayer;

},{"-_1049":222,"s_332":233,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],228:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _assertThisInitialized2 = _interopRequireDefault(require("s_332"));

var _inherits2 = _interopRequireDefault(require("C_129"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("o_130"));

var _getPrototypeOf2 = _interopRequireDefault(require("m_131"));

var _HfsFileLoader = _interopRequireDefault(require("h_1048"));

var _IHfsFileLayer2 = _interopRequireDefault(require("-_1049"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * micaps格点格式的EC数值模式图层
 */
// import RasterImageGenerator from '@mesh-3d/meteolib/Source/Render/RasterImageGenerator'
// import SwanRadar from '@mesh-3d/meteolib/Source/Data/SWAN/SwanRadar'
var _MeteoLib = MeteoLib,
    RasterImageGenerator = _MeteoLib.RasterImageGenerator,
    SwanRadar = _MeteoLib.SwanRadar;

function removeImageryLayer(layer) {
  var imageryLayer = layer.imageryLayer,
      earth = layer.earth;

  if (imageryLayer) {
    earth.imageryLayers.remove(imageryLayer);
    imageryLayer.imageryProvider.destroy();
    layer.imageryLayer = null;
  }
}
/**
 * swan格点格式的雷达拼图图层
 */


var SwanRadarLayer = /*#__PURE__*/function (_IHfsFileLayer) {
  (0, _inherits2["default"])(SwanRadarLayer, _IHfsFileLayer);

  var _super = _createSuper(SwanRadarLayer);

  /**
   *  swan格点格式的雷达拼图图层
   * @param {HfsFileLoader}  fileLoader
   */
  function SwanRadarLayer(fileLoader) {
    var _this;

    (0, _classCallCheck2["default"])(this, SwanRadarLayer);
    _this = _super.call(this, fileLoader, {
      dir: 'GZData',
      path: "SWAN_PRODUCT/LOCAL/NCRAD/TDMOSAIC",
      ext: '*.BZ2',
      timeRegex: 'yyyyMMddhhmmss',
      zIndex: 6
    });
    _this._level = 0;
    _this._lastFile = null;
    _this._levelCount = 1;
    _this.ready = false;
    var deffered = {};
    _this.readyPromise = new Promise(function (resolve, reject) {
      deffered.resolve = resolve;
      deffered.reject = reject;
    });
    _this._deffered = deffered;
    var imageryLayer = null;
    var swanRadar = null;
    Object.defineProperties((0, _assertThisInitialized2["default"])(_this), {
      swanRadar: {
        enumerable: false,
        get: function get() {
          return swanRadar;
        },
        set: function set(val) {
          swanRadar = val;
        }
      },
      imageryLayer: {
        enumerable: false,
        get: function get() {
          return imageryLayer;
        },
        set: function set(val) {
          imageryLayer = val;
        }
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(SwanRadarLayer, [{
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      if (this.imageryLayer) {
        this._show = val;
        this.imageryLayer.show = val;
      }
    }
  }, {
    key: "channelPath",
    get: function get() {
      return this.options.path;
    } //层次

  }, {
    key: "levelCount",
    get: function get() {
      return this._levelCount;
    },
    set: function set(val) {
      this._levelCount = val;
    }
  }, {
    key: "level",
    get: function get() {
      return this._level;
    },
    set: function set(val) {
      if (this._level != val) {
        this._level = val;

        if (this._lastFile && this.swanRadar) {
          this.updateImageryLayer();
        }
      }
    }
    /**
     * 基于当前时次的数据重新绘制
     */

  }, {
    key: "updateImageryLayer",
    value: function updateImageryLayer() {
      var imageryLayer = this.imageryLayer,
          earth = this.earth,
          currentFile = this.currentFile;
      /**
      * @type {SwanRadar}
      * @private
      */

      var swanRadar = this.swanRadar,
          header = swanRadar.header;
      removeImageryLayer(this);
      /**
       * @type {RasterImageGenerator}
       */

      var imageGenerator = RasterImageGenerator.Radar.R;
      var colorMap = imageGenerator.colorMap;
      var width = header.LonNumGrids,
          height = header.LatNumGrids;
      var length = header.LatNumGrids * header.LonNumGrids;
      var offset = this.level * length;
      var data = new Float32Array(swanRadar.data.buffer, offset, length);
      var rectangle = swanRadar.rectangle;
      var image = imageGenerator.generate(data, width, height);
      var provider = new Cesium.SingleTileImageryProvider({
        url: image,
        rectangle: rectangle
      });
      imageryLayer = earth.imageryLayers.addImageryProvider(provider);
      imageryLayer.show = this._show;
      this.name = currentFile.fileName;
      this.colorMap = colorMap;
      this.imageryLayer = imageryLayer;
      this.rectangle = rectangle;
      this.levelCount = header.ZNumGrids; //调整图层顺序

      provider.zIndex = this.zIndex;
      earth.updateOrder();
      this.ready = true;

      this._deffered.resolve(this);
    }
  }, {
    key: "updateLayer",
    value: function updateLayer() {
      var _this2 = this;

      var currentFile = this.currentFile;

      if (!currentFile) {
        return;
      }

      if (this.swanRadar && this._lastFile == currentFile) {
        this.updateImageryLayer();
      } else {
        var _fileLoader = this._fileLoader;

        _fileLoader.readFile(currentFile).then(function (buf) {
          return new Promise(function (resolve, reject) {
            SwanRadar.load(buf, currentFile.fileName).then(resolve).otherwise(reject);
          });
        }).then(function (swanRadar) {
          _this2.swanRadar = swanRadar;

          _this2.updateImageryLayer();
        })["catch"](function (err) {
          console.error(err);
          removeImageryLayer(_this2);

          _this2.onError(err);

          _this2.ready = false;

          _this2._deffered.resolve(err);
        });
      }
    }
  }, {
    key: "unload",
    value: function unload() {
      removeImageryLayer(this);
    }
  }]);
  return SwanRadarLayer;
}(_IHfsFileLayer2["default"]);

exports["default"] = SwanRadarLayer;

},{"h_1048":219,"-_1049":222,"s_332":233,"e_1":235,"s_2":236,"m_131":239,"C_129":240,"M_0":241,"o_130":242}],229:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("e_1"));

var _createClass2 = _interopRequireDefault(require("s_2"));

var _Vector2dLayer = require("o_1098");

/**
 * 矢量图层组：国界、省界、市界、项目所在市的县界、行政区地名、自然地名、居民地地名
 */
var VectorLayerGroup = /*#__PURE__*/function () {
  function VectorLayerGroup(options) {
    (0, _classCallCheck2["default"])(this, VectorLayerGroup);
    this._theme = options.theme || 'dark';
    this._geoDataServerUrl = options.url || './Assets'; //`${location.protocol}//${location.hostname}:8668`

    this._show = true;
  }

  (0, _createClass2["default"])(VectorLayerGroup, [{
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      if (this._show != val) {
        var sealandLayer = this.sealandLayer,
            provinceLayer = this.provinceLayer,
            countyLayer = this.countyLayer,
            placeNameLayer = this.placeNameLayer,
            placeName2Layer = this.placeName2Layer,
            placeName3Layer = this.placeName3Layer,
            countryLayer = this.countryLayer;
        sealandLayer && (sealandLayer.show = val);
        provinceLayer && (provinceLayer.show = val);
        countyLayer && (countyLayer.show = val);
        placeNameLayer && (placeNameLayer.show = val);
        placeName2Layer && (placeName2Layer.show = val);
        placeName3Layer && (placeName3Layer.show = val);
        countryLayer && (countryLayer.show = val);
      }
    }
  }, {
    key: "load",
    value: function load(earth) {
      var _this = this;

      var sealandLayer;
      var provinceLayer;
      var countyLayer;
      var placeNameLayer;
      var placeName2Layer;
      var placeName3Layer;
      var countryLayer;
      sealandLayer = new _Vector2dLayer.SealandVec2dLayer({
        source: geoDataServerUrl + '/vectorData/geojson/sealand.geojson',
        theme: theme
      });
      var readyPromise = sealandLayer.provider.readyPromise.then(function () {
        provinceLayer = new _Vector2dLayer.HighlightPolygonLayer({
          source: geoDataServerUrl + '/vectorData/shp/边界数据2017版/BOUA省级行政区域.shp',
          focusAdminNames: ['52'],
          focusPropertyName: '省域代码',
          theme: theme
        });
        return provinceLayer.provider.readyPromise;
      }).then(function () {
        countyLayer = new _Vector2dLayer.HighlightPolygonLayer({
          source: geoDataServerUrl + '/vectorData/shp/铜仁市/县界（铜仁）/县界（铜仁）.shp',
          focusAdminNames: ['520621'],
          focusPropertyName: 'PAC',
          theme: theme,
          minimumLevel: 6
        });
        return countyLayer.provider.readyPromise;
      }).then(function () {
        placeNameLayer = new _Vector2dLayer.HighlightMarkerLayer({
          source: geoDataServerUrl + '/vectorData/geojson/placeName.geojson',
          focusAdminNames: ['贵州'],
          focusPropertyName: 'NAME',
          theme: theme
        });
        return placeNameLayer.provider.readyPromise;
      }).then(function () {
        placeName2Layer = new _Vector2dLayer.LabelVec2dLayer({
          source: geoDataServerUrl + '/vectorData/shp/边界数据2017版/AGNP居民地地名.shp',
          minimumLevel: 12
        });
        return placeName2Layer.provider.readyPromise;
      }).then(function () {
        placeName3Layer = new _Vector2dLayer.LabelVec2dLayer({
          source: geoDataServerUrl + '/vectorData/shp/边界数据2017版/AANP自然地名.shp',
          minimumLevel: 12
        });
        return placeName3Layer.provider.readyPromise;
      }).then(function () {
        countryLayer = new _Vector2dLayer.CountryVec2dLayer({
          source: geoDataServerUrl + '/vectorData/shp/边界数据2017版/BOUL国界线.shp',
          theme: theme
        });
        return countryLayer.provider.readyPromise;
      }).then(function () {
        earth.addLayer(sealandLayer);
        earth.addLayer(provinceLayer);
        earth.addLayer(countyLayer);
        earth.addLayer(placeNameLayer);
        earth.addLayer(placeName2Layer);
        earth.addLayer(placeName3Layer);
        earth.addLayer(countryLayer);
        sealandLayer.show = _this.show;
        provinceLayer.show = _this.show;
        countyLayer.show = _this.show;
        placeNameLayer.show = _this.show;
        placeName2Layer.show = _this.show;
        placeName3Layer.show = _this.show;
        countryLayer.show = _this.show;
      });
      Object.defineProperties(this, {
        sealandLayer: {
          get: function get() {
            return sealandLayer;
          }
        },
        provinceLayer: {
          get: function get() {
            return provinceLayer;
          }
        },
        countyLayer: {
          get: function get() {
            return countyLayer;
          }
        },
        placeNameLayer: {
          get: function get() {
            return placeNameLayer;
          }
        },
        placeName2Layer: {
          get: function get() {
            return placeName2Layer;
          }
        },
        placeName3Layer: {
          get: function get() {
            return placeName3Layer;
          }
        },
        countryLayer: {
          get: function get() {
            return countryLayer;
          }
        }
      });
      return readyPromise;
    }
  }]);
  return VectorLayerGroup;
}();

exports["default"] = VectorLayerGroup;

},{"o_1098":66,"e_1":235,"s_2":236,"M_0":241}],230:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineSample = lineSample;

var _splitLine = _interopRequireDefault(require("D_1018"));

var _GenericWorker = _interopRequireDefault(require("e_1101"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _MeteoLib = MeteoLib,
    RasterDataset = _MeteoLib.RasterDataset;
/**
 * 
 * @param {Cesium.Cartographic[]} line 
 * @param {RasterDataset}dataset 
 * @param {object}[options]
 * @param {(progress:number)=>void} [options.onProgress]
 * @param {number}[options.interval]
 * @param {'degrees'|'radians'|'miles'|'kilometers'|'meters'} [options.units='meters'] 
 */

function lineSample(line, dataset, options) {
  options = options || {};
  var onProgress = options.onProgress;
  var sampleLine = (0, _splitLine["default"])(line, options.units, options.interval); //分批进行采样，避免页面卡顿

  var batch = [],
      batches = [batch],
      batchSize = 100;
  sampleLine.positions.forEach(function (p) {
    if (batch.length == batchSize) {
      batch = [];
      batches.push(batch);
    }

    batch.push(p);
  });
  var worker = new _GenericWorker["default"](batches, function (batch) {
    var _iterator = _createForOfIteratorHelper(batch),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var p = _step.value;
        p.value = dataset.selectPoint(0, p.longitude, p.latitude);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  });
  return worker.run(onProgress).then(function () {
    sampleLine.values = sampleLine.positions.map(function (p) {
      var val = p.value;
      delete p.value;
      return val;
    });
    return sampleLine;
  });
}

},{"e_1101":189,"D_1018":231,"M_0":241}],231:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

var _typeof = require("M_110");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = splitLine;

var turf = _interopRequireWildcard(require("-_1104"));

var _index2 = _interopRequireDefault(require("3_1105"));

var _index3 = _interopRequireDefault(require("D_1106"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 细分线段，如果未给定间距（interval），则默认拆分64段
 * @param {Cesium.Cartographic[]} line 
 * @param {'degrees'|'radians'|'miles'|'kilometers'|'meters'} [units='meters'] 
 * @param {number} [interval] 
 * @returns 
 */
function splitLine(line, units, interval) {
  var _Cesium = Cesium,
      Cartographic = _Cesium.Cartographic,
      _Math = Cesium.Math;
  interval = interval;
  units = units || 'meters';
  var computeUnits = units == 'meters' ? 'kilometers' : units;
  var distScale = units == 'meters' ? 1000 : 1; //计算线段总距离

  var coordinates = line.map(function (p) {
    return [_Math.toDegrees(p.longitude), _Math.toDegrees(p.latitude)];
  });
  var lineString = turf.lineString(coordinates);
  var lineDist = (0, _index3["default"])(coordinates[0], coordinates[1], {
    units: computeUnits
  }); //拆分成多个线段

  var positions = [line[0]],
      distances = [0];
  var num = 64;

  if (interval && interval > 0) {
    interval = interval / distScale;
    num = lineDist / interval;
  } else {
    interval = lineDist / num;
  }

  if (num % 1 == 0) num -= 1;

  for (var i = 1; i < num; i++) {
    var d = i * interval;
    var p = (0, _index2["default"])(lineString, d, {
      units: computeUnits
    });
    distances.push(d * distScale);
    var pointCoord = p.geometry.coordinates;
    positions.push(Cartographic.fromDegrees(pointCoord[0], pointCoord[1]));
  }

  positions.push(line[1]), distances.push(lineDist * distScale);
  interval *= distScale;
  return {
    positions: positions,
    distances: distances,
    units: units,
    interval: interval,
    start: {
      /**
       * 经度，单位为角度
       * @type {number} 
       */
      longitude: coordinates[0][0],

      /**
       * 纬度，单位为角度
       * @type {number} 
       */
      latitude: coordinates[0][1]
    },
    stop: {
      /**
       * 经度，单位为角度
       * @type {number} 
       */
      longitude: coordinates[1][0],

      /**
       * 纬度，单位为角度
       * @type {number} 
       */
      latitude: coordinates[1][1]
    },

    /**
     * @type {number[]}
     */
    values: []
  };
}

},{"3_1105":210,"D_1106":213,"-_1104":214,"M_0":241,"M_110":245}],232:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("M_0");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectangleSample = rectangleSample;
exports.lineSample = lineSample;

var _regenerator = _interopRequireDefault(require("C_1108"));

var _asyncToGenerator2 = _interopRequireDefault(require("o_1109"));

var _GenericWorker = _interopRequireDefault(require("e_1101"));

var _splitLine = _interopRequireDefault(require("D_1018"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * 从给定地形数据源中导出指定矩形范围内的地形高度数据
 * @param {Cesium.Rectangle} rectangle 
 * @param {Cesium.TerrainProvider} terrainProvider 
 * @param {object} options 
 * @param {(progress:number)=>void} [options.onProgress]
 * @param {number} [options.tileSize=128]
 * @param {number} [options.level=13]
 * @param {number} [options.maxWidth=14000]
 * @param {number} [options.maxHeight=14000]
 * @returns {Promise<{
 *  width: number;
 *  height: number;
 *  data: Float32Array;
 *  bbox:number[]
 * }>}
 */
function rectangleSample(_x, _x2, _x3) {
  return _rectangleSample.apply(this, arguments);
}
/**
 * 生成地形剖面数据
 * @param {Cesium.Cartographic[]} line 
 * @param {Cesium.CesiumTerrainProvider} terrainProvider 
 * @param {object}[options]
 * @param {(progress:number)=>void} [options.onProgress]
 * @param {number}[options.interval]
 * @param {number}[options.level=13]
 * @param {'degrees'|'radians'|'miles'|'kilometers'|'meters'} [options.units='meters'] 
 */


function _rectangleSample() {
  _rectangleSample = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(rectangle, terrainProvider, options) {
    var _Cesium, Rectangle, Cartesian2, Cartographic, _Math, tileSize, level, maxWidth, maxHeight, onProgress, nw, se, startTile, endTile, tileNum, width, height, buffer, tiles, y, x, worker;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _Cesium = Cesium, Rectangle = _Cesium.Rectangle, Cartesian2 = _Cesium.Cartesian2, Cartographic = _Cesium.Cartographic, _Math = Cesium.Math;
            options = options || {};
            tileSize = options.tileSize || 128;
            level = options.level || 13;
            maxWidth = options.maxWidth || 14000;
            maxHeight = options.maxHeight || 14000;
            onProgress = options.onProgress;
            nw = Rectangle.northwest(rectangle);
            se = Rectangle.southeast(rectangle);
            startTile = terrainProvider.tilingScheme.positionToTileXY(nw, level, {});
            endTile = terrainProvider.tilingScheme.positionToTileXY(se, level, {});
            tileNum = Cartesian2.subtract(endTile, startTile, {});
            width = tileNum.x * tileSize;
            height = tileNum.y * tileSize;

            if (!(width > maxWidth || height > maxHeight)) {
              _context.next = 16;
              break;
            }

            throw new Error('范围太大，请调整范围');

          case 16:
            buffer = new Float32Array(width * height);
            tiles = [];

            for (y = startTile.y; y < endTile.y; y++) {
              for (x = startTile.x; x <= endTile.x; x++) {
                tiles.push({
                  x: x,
                  y: y
                });
              }
            }

            worker = new _GenericWorker["default"](tiles, function (tile) {
              return new Promise(function (resolve, reject) {
                terrainProvider.requestTileGeometry(tile.x, tile.y, level).then(function (terrainData) {
                  var tileRect = terrainProvider.tilingScheme.tileXYToRectangle(tile.x, tile.y, level);
                  var deltX = tileRect.width / (tileSize - 1);
                  var deltY = tileRect.height / (tileSize - 1);
                  var y0 = (tile.y - startTile.y) * tileSize;
                  var x0 = (tile.x - startTile.x) * tileSize;

                  for (var i = 0; i < tileSize; i++) {
                    var y = y0 + i;

                    for (var j = 0; j < tileSize; j++) {
                      var x = x0 + j;
                      var index = y * width + x;
                      var position = new Cartographic(tileRect.west + j * deltX, tileRect.north - i * deltY);
                      var height = terrainData.interpolateHeight(tileRect, position.longitude, position.latitude);
                      buffer[index] = height;
                    }
                  }

                  resolve();
                }).otherwise(function (err) {
                  resolve();
                });
              });
            });
            _context.next = 22;
            return worker.run(onProgress);

          case 22:
            return _context.abrupt("return", {
              width: width,
              height: height,
              data: buffer,
              bbox: [_Math.toDegrees(rectangle.west), _Math.toDegrees(rectangle.south), _Math.toDegrees(rectangle.east), _Math.toDegrees(rectangle.north)]
            });

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _rectangleSample.apply(this, arguments);
}

function lineSample(_x4, _x5, _x6) {
  return _lineSample.apply(this, arguments);
}

function _lineSample() {
  _lineSample = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(line, terrainProvider, options) {
    var _Cesium2, sampleTerrain, level, onProgress, sampleLine, positions, byTiles, tiles, _iterator, _step, position, tile, idx, worker;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _Cesium2 = Cesium, sampleTerrain = _Cesium2.sampleTerrain;
            options = options || {};
            level = options.level || 13;
            onProgress = options.onProgress;
            sampleLine = (0, _splitLine["default"])(line, options.units, options.interval);
            positions = sampleLine.positions; //按点所在瓦片分批次

            byTiles = [], tiles = {};
            _iterator = _createForOfIteratorHelper(positions);

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                position = _step.value;
                tile = terrainProvider.tilingScheme.positionToTileXY(position, level);
                tile = [tile.x, tile.y].join(',');
                idx = tiles[tile];

                if (idx == undefined) {
                  idx = byTiles.length;
                  tiles[tile] = idx;
                  byTiles[idx] = [];
                }

                byTiles[idx].push(position);
              } //开始逐个批次采样

            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            worker = new _GenericWorker["default"](byTiles, function (samplePositions) {
              return new Promise(function (resolve) {
                sampleTerrain(terrainProvider, level, samplePositions).then(resolve).otherwise(resolve);
              });
            });
            _context2.next = 12;
            return worker.run(onProgress);

          case 12:
            sampleLine.values = positions.map(function (p) {
              return p.height;
            });
            return _context2.abrupt("return", sampleLine);

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _lineSample.apply(this, arguments);
}

},{"e_1101":189,"D_1018":231,"o_1109":234,"M_0":241,"C_1108":246}],233:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],234:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],235:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],236:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],237:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],238:[function(require,module,exports){
var superPropBase = require("e_1112");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"e_1112":244}],239:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],240:[function(require,module,exports){
var setPrototypeOf = require("s_1113");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"s_1113":243}],241:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],242:[function(require,module,exports){
var _typeof = require("M_110")["default"];

var assertThisInitialized = require("-_1115");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"-_1115":233,"M_110":245}],243:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],244:[function(require,module,exports){
var getPrototypeOf = require("3_1116");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"3_1116":239}],245:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],246:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":250}],247:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],248:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":247,"buffer":248,"ieee754":249}],249:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],250:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}]},{},[220])(220)
});
//# sourceMappingURL=WeatherDV.js.map
